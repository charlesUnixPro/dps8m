"
" Access an unmapped segment page; fault; map the page; return from fault, 
" restarting the faulted instruction.
"
" Virtual Memory layout
"
"     segment
"       (0)      absolute mode code
"        1       executable code and data
"        2       its/itp data
"
	equ	seg1,1
	equ	seg2,2

"     segment 1 pages
"
"       0-n    code
"       1000   data
"       1001   data
"       1002   data
"       1003   data

	equ	pgsz,1024	" pages are 1024 words long
	equ	program_start,100*pgsz
	equ	seg1_start,200*pgsz
	equ	seg2_start,300*pgsz

	macro	msg
	eaa	#1
	emcall	16
	endm

"""
""" Entry point
"""

	org	0
	tra	start


	equ	fault_base,64
	equ	fault_mme,fault_base+2*2
	equ	fault_dpf3,fault_base+2*19
"""
""" MME handler
"""

	org	fault_mme
	scu	mme_scu
	tra	mme_handler

"""
""" directed page fault handler
"""

	org	fault_dpf3
	scu	dpf3_scu
	tra	dpf3_handler


	org	program_start

ldbr_data:

"""
""" DSBR format for the LDBR instruction:
"""

"        pos len
"  ADDR    0  24  If U = 1, the memory address of the origin of the descriptor
"                 segment; if U = 0, the memory address of the descriptor
"                 segment page table
" 
"  BOUND  37  14  The 14 most significant bits of the highest Y-block16 
"                 address of the descriptor segment that can be addressed 
"                 without causing an fault.

"  U      55   1  U = 0: descriptor segment is paged; 1: unpaged.
"  STACK  60  12  Used by CALL6; the upper 12 bits of the 15 bit stack base
"                 segment number.
"
" U bit
	equ	paged,0
	equ	unpaged,1

" F bit
	equ	nonresident,0
	equ	resident,1

        equ	dsbr_bound,0	" All of our segments will fit in a single
				" Y16 (2 words/segment; this allows 8)

	vfd	24/descr_seg_page_table,12/0
	vfd	1/0,14/dsbr_bound,4/0,1/paged,4/0,12/0

"""
""" Descriptor Segment Page Table.
"""


descr_seg_page_table:

" A table of PTWs; each PTW points to a table of 1024 SDWs; the first PTW is
" used for segment numbers 0-1023, the second for 1024-2047, and so on
"
" In this table, each PTW takes up 2 words; the second word is unused.
" (If the DSPT is unpaged, it is an array of SDWs, which are two words.)

" PTW format:
"    ADDR  x x x x x x 0 0 U 0 0 M x x x F FC
"    x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x 
"
"        pos len
"  ADDR:   0  18  modulo 64 absolute main memory address of page
"     U   26   1  page has been used
"     M   29   1  page has been modfied
"     F   33   1  0: page not in memory; 1: page in memory
"     FC  34   2  direct fault number
   
	bool	fbit,4
	bool	fmask,777777777773

" The following vfd allocate 24 bits for the addr to hand-wave away the 
" divide by 64.

" segments 0-1023

	vfd	24/seg_0_descr_seg_page_table,2/0,1/0,2/0,1/0,3/0,1/resident,2/0
	vfd	36/0

"""
""" SDW format
"""

" even word
"        pos len
" ADDR     0  24   U=1: address of the unpaged segment; 0 address of the 
"                  segment page table
" R1      24   3
" R2      27   3
" R3      30   3
" F       33   1    0: page is non-resident, 1: resident
" FC      34   2

" odd word
"        pos len
" BOUND    1  14
" R       15   1
" E       16   1
" W       17   1
" P       18   1
" U       19   1   0: segment is paged; 1: unpaged
" G       20   1
" C       21   1
" ER      22  14

	sixtyfour

"""
""" Descriptor segment page for segments 0-1023
"""

seg_0_descr_seg_page_table:

" segment 0 (non-existant)
	vfd	24/-1, 3/0, 3/0, 3/0, 1/nonresident, 2/0
	vfd	1/0,14/0,1/0,1/0,1/0,1/0,1/paged,1/0,1/1,14/0

" segment 1; code and data R/E/W
	vfd	24/seg_1_page_table,3/0,3/0,3/0,1/resident,2/0
	vfd	1/0,14/-1,1/1,1/1,1/1,1/0,1/paged,1/0,1/1,14/0

" segment 2; data R/W
	vfd	24/seg_2_page_table,3/0,3/0,3/0,1/resident,2/0
	vfd	1/0,14/-1,1/1,1/0,1/1,1/0,1/paged,1/0,1/1,14/0


" 1024 segment, 3 segs used, 2 words/seg
"   (1024 - 3) * 2
        bss	2042

seg_1_page_table:

s1p0:	vfd	24/seg1_start,2/0,1/0,2/0,1/0,3/0,1/resident,2/3
s1p1:	vfd	24/seg1_start+1024,2/0,1/0,2/0,1/0,3/0,1/resident,2/3

seg_2_page_table:

s2p0:	vfd	24/seg2_start,2/0,1/unpaged,2/0,1/0,3/0,1/resident,2/3


"""
""" Abs mode code
"""

	sixtyfour
start:	
	msg	msg_start_entry

	ldbr	ldbr_data

	lprp0	entry_ptr
	tra	0|0

"""
""" MME handler
"""

mme_handler:
	sta	mme_arg

	msg	msg_mme_entry

" A == 0: Mark pages resident
" A != 0: Mark pages non-resident

	szn	mme_arg
	tnz	mark_non

" Set the F bit in the page table entrys

	lda	f_bit
	orsa	s1p0
	orsa	s1p1
	orsa	s2p0
	tra	mark_done

mark_non:

" Clear the F bit in the page table entrys

	lda	f_mask
	ansa	s1p0
	ansa	s1p1
	ansa	s2p0

mark_done:

" Reset the caches

	cams
	camp

" And return

	rcu	mme_scu

mme_arg:
	dec	0

"""
""" page fault handler
"""

dpf3_handler:
	sreg	dpf3_sreg

	msg	msg_dpf3_entry

" Test the FIF bit

	lda	fif_mask
	ana	dpf3_scu_5
	tze	operand_fetch

" Fault during instruction fetch

	msg	msg_fetch

" Print fault address for debugging

	" Get the segno
	msg	msg_segno
	lda	dpf3_scu_2
	arl	18
	ana	mask15
	emcall	5	" putdec
	" Get the IC
	msg	msg_ic
	lda	dpf3_scu_4
	arl	18
	ana	mask18
	emcall	3	" putoct
	emcall	8	" nl

	" Lookup the segment in the descr_seg_page_table (assume segno < 1024)

	eax0	seg_0_descr_seg_page_table

	" Compute table[2*segno]

	adx0	dpf3_scu_2
	adx0	dpf3_scu_2

	" Get the first word of the SDW

	lda	0,x0

	" Get the address of segment page table

	arl	12
	sta	spt_addr

	" Get the IC

	lda	dpf3_scu_4
	arl	18
	ana	mask18

	" Divide by 1024

	arl	10

	" Compute page_table[offset/1024]

	ada	spt_addr
	als	18	" move to high half
	sta	spte_addr

	" Set the resident bit for the page
	lda	f_bit
	orsa	spte_addr,*

	" Reset the caches

	cams
	camp

	" And done...
	tra	dpf3_done


" Fault during operand fetch

operand_fetch:
	msg	msg_operand_fetch

" Print fault address for debugging

	" Get the segno
	msg	msg_segno
	lda	dpf3_scu_2
	arl	18
	ana	mask15
	emcall	5	" putdec
	" Get the CA
	msg	msg_ca
	lda	dpf3_scu_5
	arl	18
	ana	mask18
	emcall	3	" putoct
	emcall	8	" nl

	" Lookup the segment in the descr_seg_page_table (assume segno < 1024)

	eax0	seg_0_descr_seg_page_table

	" Compute table[2*segno]

	adx0	dpf3_scu_2
	adx0	dpf3_scu_2

	" Get the first word of the SDW

	lda	0,x0

	" Get the address of segment page table

	arl	12
	sta	spt_addr

	" Get the CA

	lda	dpf3_scu_5
	arl	18
	ana	mask18

	" Divide by 1024

	arl	10

	" Compute page_table[offset/1024]

	ada	spt_addr
	als	18	" move to high half
	sta	spte_addr

	" Set the resident bit for the page
	lda	f_bit
	orsa	spte_addr,*

	" Reset the caches

	cams
	camp

	" And done...
	tra	dpf3_done

	dis	*

dpf3_done:
	lreg	dpf3_sreg
	rcu	dpf3_scu

spt_addr:
	bss	1

spte_addr:
	bss	1

f_mask:	oct	fmask
f_bit:	oct	fbit
fif_mask:
	oct	100
mask15:
	oct	77777
mask18:
	oct	777777

	eight
mme_scu:
	bss	8

	eight
dpf3_sreg:
	bss	8

	eight
dpf3_scu:
	oct	0
	oct	0
dpf3_scu_2:
	oct	0
	oct	0
dpf3_scu_4:
	oct	0
dpf3_scu_5:
	oct	0
	oct	0
	oct	0

entry_ptr:
	vfd	6/0,12/seg1,18/0

msg_start_entry:
	aci	'Fault test entry\n\0\0'
	oct	0

msg_mme_entry:
	aci	'MME entry\n\0\0'
	oct	0

msg_dpf3_entry:
	aci	'DPF3 entry\n\0\0'
	oct	0

msg_fetch:
	aci	'DPF3 instruction fetch\n'
	oct	0

msg_operand_fetch:
	aci	'DPF3 operand fetch\n'
	oct	0

msg_segno:
	aci	'segno: '
	oct	0

msg_ca:
	aci	' CA: '
	oct	0

msg_ic:
	aci	' IC: '
	oct	0

