	COMPILATION LISTING OF SEGMENT rdisk_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0955.5 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
       16*     audit(86-02-21,Coppola), install(86-03-21,MR12.0-1033):
       17*     Support the IBM3380
       18*     remove support of MSU0509.
       19*  2) change(86-01-16,Fawcett), approve(86-04-11,MCR7383),
       20*     audit(86-06-06,GWMay), install(86-07-17,MR12.0-1097):
       21*     Add support for subvolumes, and 512_WORD_IO, 3380 and 3390.
       22*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
       23*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
       24*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
       25*  4) change(87-03-31,Blair), approve(87-03-31,MCR7666),
       26*     audit(87-06-25,Fawcett), install(87-07-15,MR12.1-1041):
       27*     Change the setup for Stream_output to equate to put_chars instead of
       28*     get_chars.
       29*                                                   END HISTORY COMMENTS */
       30 
       31 
       32 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indend,dclind5,idind32 */
       33 rdisk_:
       34      proc;
       35 	return;					/*  should never enter here  */
       36 
       37 
       38 /*  MODIFICATION HISTORY:
       39*
       40*   Initially coded by J. A. Weeldreyer -- March, 1975.
       41*   Modified to conform to new ioi_ interface by J. A. Weeldreyer -- April, 1975.
       42*   Modified to conform to the  rcp_ interface by J. A. Weeldreyer -- July, 1975.
       43*   modified -- December, 1975 by J. A. Bush to add the raw mode and  the
       44*   format_trk, rd_trk_header, and device_info control orders.
       45*   Modified to support the new io_call control mechanism By L. E. Johnson -- May, 1976
       46*   Modified to provide sequential_(input output update) opening modes,
       47*   position operation, write_record operation, and more device types
       48*   by Jim Gildersleeve and Jim Falksen -- 1976 June.
       49*   Modified by D. R. Vinograd to provide limited stream
       50*   support for the volume reloader. - July 1976
       51*   Modified by Michael R. Jordan on 01/31/79 for MSU0500s
       52*   Modified 9/79 by R.J.C. Kissel for MSU0501's.
       53*   Modified 11/79 by Michael R. Jordan for MSU0500 formatting.
       54*   Modified 1/80 by Michael R. Jordan to add -device and -model control arguments.
       55*   Modified 2/80 by Michael R. Jordan for MSU0501 and bug fixes.
       56*   Modified May 1982 by J. Bongiovanni for larger buffers
       57*   Modified 3/83 by GA Texada for changes made by W. Olin Sibert to make
       58*		large buffers work and assorted other bugfixes.
       59**/
       60 
       61 
       62 /*  DESCRIPTION:
       63*
       64*   *	     This  I/O  module supports I/O from/to removable disk packs.
       65*   *	Sequential and indexed file types are supported.
       66*   *
       67*   *	     Entries in this module are not  called  directly  by  users;
       68*   *	rather,  the  module is accessed through the I/O system.  See the
       69*   *	MPM section, the Multics I/O System, for a general description of
       70*   *	the I/O system,  and  see  the  MPM  section,  File  I/O,  for  a
       71*   *	discussion of files.
       72*   *
       73*   *	     This  I/O module provides a very elementary, physical device
       74*   *	oriented I/O facility, and is the basic user-level interface to a
       75*   *	disk device.  All  operations  are  performed  through  calls  to
       76*   *	various I/O Interfacer (ioi_) and Resource Control Package (rcp_)
       77*   *	entries.   This  I/O module provides the capability to read/write
       78*   *	a caller-specified number  of  characters  to/from  a  disk_pack.
       79*   *	Supported device types are  DSU181, DSU190, DSU191, MSU0400,
       80*   *	MSU0451, MSU0500, MSU0501, MSU3380 and MSU3381.
       81**/
       82 
       83 /*  NOTES:
       84*
       85**/
       86 
  1     1 /* BEGIN INCLUDE FILE iocbx.incl.pl1 */
  1     2 /* written 27 Dec 1973, M. G. Smith */
  1     3 /* returns attributes removed, hashing support BIM Spring 1981 */
  1     4 /* version made character string June 1981 BIM */
  1     5 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     6*      version number to IOX2. */
  1     7 /* format: style2 */
  1     8 
  1     9      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1    10 	     2 version	      character (4) aligned,	/* IOX2 */
  1    11 	     2 name	      char (32),		/* I/O name of this block. */
  1    12 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    13 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    14 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    15 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    16 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    17 	     2 event_channel      bit (72),		/* Event channel for asynchronous I/O. */
  1    18 	     2 detach_iocb	      entry (ptr, fixed bin (35)),
  1    19 						/* detach_iocb(p) */
  1    20 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed bin (35)),
  1    21 						/* open(p,mode,not_used) */
  1    22 	     2 close	      entry (ptr, fixed bin (35)),
  1    23 						/* close(p) */
  1    24 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
  1    25 						/* get_line(p,bufptr,buflen,actlen) */
  1    26 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
  1    27 						/* get_chars(p,bufptr,buflen,actlen) */
  1    28 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed bin (35)),
  1    29 						/* put_chars(p,bufptr,buflen) */
  1    30 	     2 modes	      entry (ptr, char (*), char (*), fixed bin (35)),
  1    31 						/* modes(p,newmode,oldmode) */
  1    32 	     2 position	      entry (ptr, fixed, fixed (21), fixed bin (35)),
  1    33 						/* position(p,u1,u2) */
  1    34 	     2 control	      entry (ptr, char (*), ptr, fixed bin (35)),
  1    35 						/* control(p,order,infptr) */
  1    36 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
  1    37 						/* read_record(p,bufptr,buflen,actlen) */
  1    38 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed bin (35)),
  1    39 						/* write_record(p,bufptr,buflen) */
  1    40 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed bin (35)),
  1    41 						/* rewrite_record(p,bufptr,buflen) */
  1    42 	     2 delete_record      entry (ptr, fixed bin (35)),
  1    43 						/* delete_record(p) */
  1    44 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed bin (35)),
  1    45 						/* seek_key(p,key,len) */
  1    46 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed bin (35)),
  1    47 						/* read_key(p,key,len) */
  1    48 	     2 read_length	      entry (ptr, fixed (21), fixed bin (35)),
  1    49 						/* read_length(p,len) */
  1    50 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    51 						/* open_file(p,mode,desc,not_used,s) */
  1    52 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    53 						/* close_file(p,desc,s) */
  1    54 	     2 detach	      entry (ptr, char (*), fixed bin (35)),
  1    55 						/* detach(p,desc,s) */
  1    56 						/* Hidden information, to support SYN attachments. */
  1    57 	     2 ios_compatibility  ptr,		/* Ptr to old DIM's IOS transfer vector. */
  1    58 	     2 syn_inhibits	      bit (36),		/* Operations inhibited by SYN. */
  1    59 	     2 syn_father	      ptr,		/* IOCB immediately SYNed to. */
  1    60 	     2 syn_brother	      ptr,		/* Next IOCB SYNed as this one is. */
  1    61 	     2 syn_son	      ptr,		/* First IOCB SYNed to this one. */
  1    62 	     2 hash_chain_ptr     ptr;		/* Next IOCB in hash bucket */
  1    63 
  1    64      declare iox_$iocb_version_sentinel
  1    65 			      character (4) aligned external static;
  1    66 
  1    67 /* END INCLUDE FILE iocbx.incl.pl1 */
       87 
       88 
  2     1 
  2     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  2     3 
  2     4 dcl  pcwp ptr;					/* pointer to PCW */
  2     5 
  2     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  2     7      (2 command bit (6),				/* device command */
  2     8       2 device bit (6),				/* device code */
  2     9       2 ext bit (6),				/* address extension */
  2    10       2 code bit (3),				/* should be "111"b for PCW */
  2    11       2 mask bit (1),				/* channel mask bit */
  2    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  2    13       2 chan_cmd bit (6),				/* type of I/O operation */
  2    14       2 count bit (6),				/* record count or control character */
  2    15       2 mbz1 bit (3),
  2    16       2 channel bit (6),				/* channel number */
  2    17       2 mbz2 bit (27)) unal;
  2    18 
  2    19 dcl  idcwp ptr;					/* pointer to IDCW */
  2    20 
  2    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  2    22      (2 command bit (6),				/* device command */
  2    23       2 device bit (6),				/* device code */
  2    24       2 ext bit (6),				/* address extension */
  2    25       2 code bit (3),				/* should be "111"b for PCW */
  2    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  2    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  2    28       2 chan_cmd bit (6),				/* type of I/O operation */
  2    29       2 count bit (6)) unal;				/* record count or control character */
  2    30 
  2    31 /* End include file ...... iom_pcw.incl.pl1 */
  2    32 
       89 
       90 
  3     1 
  3     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  3     3 
  3     4 dcl  dcwp ptr,					/* pointer to DCW */
  3     5      tdcwp ptr;					/* pointer to TDCW */
  3     6 
  3     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  3     8      (2 address bit (18),				/* address for data transfer */
  3     9       2 char_pos bit (3),				/* character position */
  3    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  3    11       2 type bit (2),				/* DCW type */
  3    12       2 tally bit (12)) unal;				/* tally for data transfer */
  3    13 
  3    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  3    15      (2 address bit (18),				/* address to transfer to */
  3    16       2 mbz1 bit (4),
  3    17       2 type bit (2),				/* should be "10"b for TDCW */
  3    18       2 mbz2 bit (9),
  3    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  3    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  3    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  3    22 
  3    23 /* End of include file ...... iom_dcw.incl.pl1 */
  3    24 
       91 
       92 
  4     1 /* Begin include file ... track_header_info.incl.pl1 */
  4     2 /* Created 11/79 by Michael R. Jordan to describe format data for new style format command */
  4     3 
  4     4 dcl  thi_ptr ptr;
  4     5 dcl  thi_version_1 fixed bin static options (constant) init (1);
  4     6 
  4     7 dcl 1 thi aligned based (thi_ptr),
  4     8     2 version fixed bin,
  4     9     2 msu4xx_info aligned,
  4    10       3 cyl fixed bin (16) unsigned unal,
  4    11       3 head fixed bin (16) unsigned unal,
  4    12       3 pad1 bit (2) unal,
  4    13       3 ti fixed bin (2) unsigned unal,
  4    14       3 pad2 bit (4) unal,
  4    15       3 flag_byte bit (8) unal,
  4    16       3 alt_cyl fixed bin (16) unsigned unal,
  4    17       3 alt_head fixed bin (16) unsigned unal,
  4    18       3 alt_rec fixed bin (8) unsigned unal,
  4    19       3 pad3 bit (128) unal,
  4    20     2 msu5xx_info aligned,
  4    21       3 c0 unal,
  4    22         4 flags unal,
  4    23 	5 large_records bit (1) unal,
  4    24 	5 honeywell_formatted bit (1) unal,
  4    25 	5 format_complete bit (1) unal,
  4    26 	5 pad bit (2) unal,
  4    27 	5 log_track bit (1) unal,
  4    28 	5 ti fixed bin (2) unsigned unal,
  4    29         4 cyl_lower fixed bin (8) unsigned unal,
  4    30         4 cyl_upper fixed bin (2) unsigned unal,
  4    31         4 head fixed bin (6) unsigned unal,
  4    32         4 rec fixed bin (8) unsigned unal,
  4    33         4 skip (1:2) unal,
  4    34 	5 used bit (1) unal,
  4    35 	5 gap_following_count bit (1) unal,
  4    36 	5 gap_following_data bit (1) unal,
  4    37 	5 gap_between_index_and_c0 bit (1) unal,
  4    38 	5 displacement fixed bin (12) unsigned unal,
  4    39         4 alt_cyl_lower fixed bin (8) unsigned unal,
  4    40         4 alt_cyl_upper fixed bin (2) unsigned unal,
  4    41         4 alt_head fixed bin (6) unsigned unal,
  4    42         4 t_skip (1:3) unal,
  4    43 	5 hex_80 bit (8) unal,
  4    44 	5 distance fixed bin (8) unsigned unal,
  4    45         4 pad4 bit (8) unal,
  4    46         4 cf bit (8) unal,
  4    47       3 c (1:39) unal,
  4    48         4 flags unal,
  4    49 	5 large_records bit (1) unal,
  4    50 	5 honeywell_formatted bit (1) unal,
  4    51 	5 format_complete bit (1) unal,
  4    52 	5 pad bit (2) unal,
  4    53 	5 log_track bit (1) unal,
  4    54 	5 ti fixed bin (2) unsigned unal,
  4    55         4 cyl_lower fixed bin (8) unsigned unal,
  4    56         4 cyl_upper fixed bin (2) unsigned unal,
  4    57         4 head fixed bin (6) unsigned unal,
  4    58         4 rec fixed bin (8) unsigned unal,
  4    59         4 skip (1:2) unal,
  4    60 	5 used bit (1) unal,
  4    61 	5 gap_following_count bit (1) unal,
  4    62 	5 gap_following_data bit (1) unal,
  4    63 	5 pad bit (1) unal,
  4    64 	5 displacement fixed bin (12) unsigned unal,
  4    65         4 cf bit (8) unal;
  4    66 
  4    67 /* End include file ... track_header_info.incl.pl1 */
       93 
       94 
  5     1 /*	Begin  include file rcp_disk_info.incl.pl1
  5     2**
  5     3**	Created on 03/31/74 by Bill Silver.
  5     4**	This include file defines the RCP device info structure for disks.
  5     5**/
  5     6 
  5     7 
  5     8 
  5     9 
  5    10 /****^  HISTORY COMMENTS:
  5    11*  1) change(86-06-03,Hartogs), approve(86-06-03,MCR7383),
  5    12*     audit(86-06-06,GWMay), install(86-07-18,MR12.0-1098):
  5    13*     Added DISK_INFO_VERSION_1 constant.
  5    14*                                                   END HISTORY COMMENTS */
  5    15 
  5    16 
  5    17 dcl	disk_info_ptr	ptr;		/* Pointer to disk device info structure. */
  5    18 
  5    19 dcl    1	disk_info based(disk_info_ptr) aligned,	/* RCP device info structure for disks. */
  5    20 	2  version_num	fixed bin,	/* Version number of this structure. */
  5    21 	2  usage_time	fixed bin,	/* Number of minutes drive will/may be used. */
  5    22 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
  5    23 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
  5    24 	2  device_name	char(8),		/* Disk drive name. */
  5    25 	2  model		fixed bin,	/* Disk drive model number. */
  5    26 	2  volume_name	char(32),		/* Disk pack name. */
  5    27 	2  write_flag	bit(1);		/* ON => writing on disk pack. */
  5    28 
  5    29 dcl       DISK_INFO_VERSION_1 fixed bin int static options (constant) init (1);
  5    30 
  5    31 /*	End of include file ... rcp_disk_info.incl.pl1	*/
       95 
       96 
  6     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  6     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  6     6*     Add support for FIPS
  6     7*     3380.
  6     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  6     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  6    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  6    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  6    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  6    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  6    14*                                                   END HISTORY COMMENTS */
  6    15 
  6    16 /* Modified 5/19/76 by N. I. Morris */
  6    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  6    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  6    19 /* Modified '82 by BIM for needs_alt_part */
  6    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  6    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  6    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  6    23*   volmap and record stock can be expanded. */
  6    24 
  6    25 /*
  6    26********************************************************************************
  6    27**							        *
  6    28**                           WARNING:                                          *
  6    29**							        *
  6    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  6    31**   type is added.						        *
  6    32**							        *
  6    33**   There are other include files that contain arrays indexed by the device   *
  6    34**   index obtained by references to MODELX or MODELN in this include file.    *
  6    35**   These must be modified when a new device type is added:		        *
  6    36**   disk_pack.incl.pl1					        *
  6    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  6    38**							        *
  6    39********************************************************************************
  6    40**/
  6    41 
  6    42 
  6    43 dcl (maxdevt init (9),				/* maximum legal devt */
  6    44      bulkdevt init (1),				/* bulk store devt */
  6    45      msu0500devt init (2),				/* MSU0500 device type */
  6    46      msu0451devt init (3),				/* MSU0451 device type */
  6    47      msu0450devt init (3),				/* MSU0450 device type */
  6    48      msu0400devt init (4),				/* MSU0400 device type */
  6    49      dsu191devt init (4),				/* DSU191 device type */
  6    50      dsu190devt init (5),				/* DSU190 device type */
  6    51      dsu181devt init (6),				/* DSU181 device type */
  6    52      msu0501devt init (7),				/* MSU0501 device type */
  6    53      fips3380devt init (8),				/* 3380D FIPS device type */
  6    54      fips3381devt init (9)				/* 3380E FIPS device type */
  6    55      ) fixed bin (4) static options (constant);
  6    56 
  6    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  6    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  6    59 
  6    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  6    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  6    62 
  6    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  6    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  6    65 
  6    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  6    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  6    68 
  6    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  6    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  6    71 
  6    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  6    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  6    74 
  6    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  6    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  6    77 
  6    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  6    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  6    80 
  6    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  6    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  6    83 
  6    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  6    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  6    86 
  6    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  6    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  6    89 
  6    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  6    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  6    92 
  6    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  6    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  6    95 
  6    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  6    97      ("abc");
  6    98 
  6    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  6   100      init ("a","b","c");
  6   101 
  6   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  6   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  6   104 
  6   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  6   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  6   107 
  6   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  6   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  6   110 
  6   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  6   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  6   113 
  6   114 
  6   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  6   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  6   117 
  6   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  6   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  6   120 
  6   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  6   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  6   123 
  6   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  6   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  6   126 
  6   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  6   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  6   129 
  6   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  6   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  6   132 
  6   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  6   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  6   135 
  6   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  6   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  6   138 
  6   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  6   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  6   141 
  7     1 /* Begin fs_dev_types_sector.incl.pl1 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  7     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  7     7*     Add the sector differance for devices that do 64 word IO and devices that
  7     8*     do 512 word IO.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  7    12*	 need all the data in fs_dev_types. This is also included in
  7    13*	 fs_dev_types.incl.pl1  */
  7    14 
  7    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  7    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  7    17 
  7    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  7    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  7    20 
  7    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  7    22  /* table of # of sectors per record on each device */
  7    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  7    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  7    25 
  7    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  7    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  7    28 	
  7    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  7    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  7    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  7    32 
  7    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  7    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  7    35 
  7    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  7    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  7    38 
  7    39 /* End fs_dev_types_sector.incl.pl1 */
  7    40 
  6   142 
  6   143 
  6   144 /* End of include file ...... fs_dev_types.incl.pl1 */
       97 
       98 
  8     1 /* Begin include file ..... iox_modes.incl.pl1 */
  8     2 
  8     3 /* Written by C. D. Tavares, 03/17/75 */
  8     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  8     5 
  8     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  8     7     ("stream_input", "stream_output", "stream_input_output",
  8     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  8     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  8    10      "direct_input", "direct_output", "direct_update");
  8    11 
  8    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  8    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  8    14 
  8    15 dcl (Stream_input initial (1),
  8    16      Stream_output initial (2),
  8    17      Stream_input_output initial (3),
  8    18      Sequential_input initial (4),
  8    19      Sequential_output initial (5),
  8    20      Sequential_input_output initial (6),
  8    21      Sequential_update initial (7),
  8    22      Keyed_sequential_input initial (8),
  8    23      Keyed_sequential_output initial (9),
  8    24      Keyed_sequential_update initial (10),
  8    25      Direct_input initial (11),
  8    26      Direct_output initial (12),
  8    27      Direct_update initial (13)) fixed bin int static options (constant);
  8    28 
  8    29 /* End include file ..... iox_modes.incl.pl1 */
       99 
      100 
      101 dcl  1 disk_data		       based (disk_ptr),	/*  rdisk_ data structure  */
      102        2 attach_descrip	       aligned,		/*  Current attach description  */
      103          3 length		       fixed bin (17),	/*  Length of description in chars.  */
      104          3 descrip		       char (168),		/* the actual description  */
      105        2 attach_data	       aligned,		/*  attachment data for use by  rdisk_  */
      106          3 sze		       fixed bin (35),	/* if ^= 0 => size specified in attach or control  */
      107          (
      108          3 err_sw,					/* on if error messages are to be printed  */
      109          3 write_sw,				/*  on if  device is to be mounted in write mode  */
      110          3 compare_sw,				/*   on if Write_and_Compare idcw is to be used for writes  */
      111          3 raw_sw,					/* ON => raw mode */
      112          3 alt_sw,					/* ON => alt mode */
      113          3 label_sw,				/* ON => label mode */
      114          3 sys_sw
      115          )		       bit (1) unal,	/*  on if this is a privileged system process  */
      116          3 pack_id		       char (32),		/*  Current disk pack id.  */
      117          3 rcp_id		       bit (36),		/* rcp unique id. */
      118          3 max_buff_size	       fixed bin (19),	/* ioi_ buffer size limit set by rcp_ */
      119          3 wait_list,				/*  event channel information  */
      120 	 4 nchan		       fixed bin,		/* number of channels (currently using 1)  */
      121 	 4 ev_chan	       fixed bin (71),	/* event channel id.  */
      122          3 dev_type		       fixed bin,		/*  device type indicator   */
      123          3 devx		       fixed bin,		/* device index returned by ioi_ */
      124          3 drive		       fixed bin (6),	/* drive number returned by ioi_ */
      125          3 errors		       fixed bin,		/* error count */
      126          3 sect_per_dev	       fixed bin (35),	/* sectors per device */
      127          3 sect_size	       fixed bin (12),	/* quantity of words in one sector */
      128          3 num_alt_sect	       fixed bin,		/* quantity of sectors reserved for alternate sector usage */
      129          3 device_group	       fixed bin,		/* 1 = MSU04XX */
      130 						/* 2 = MSU0500/1 */
      131 						/* 3 = MSU3380/90 */
      132          3 is_sv		       bit (1),		/* attach subvolume */
      133          3 sv_num		       fixed bin,		/* attached subvolume number */
      134          3 att_dev_idx	       fixed bin,		/* index into attachments array for this device */
      135          3 att_sv_idx	       fixed bin,		/* index into attachments array of this device subvolume */
      136        2 open_descrip	       aligned,		/* open description */
      137          3 length		       fixed bin (17),	/* number of characters in open descrip. */
      138          3 descrip		       char (32),		/* the actual open descrip. */
      139        2 open_data		       aligned,		/* more rdisk_ data */
      140          3 mode		       fixed bin,		/* mode number:  4 = sq_i, 5 = sq_o, 7 = sq_u,
      141*						   11 = d_i, 13 = d_u    */
      142          3 buf_ptr		       ptr,		/* pointer to buffer created by ioi_$workspace */
      143          3 fill		       bit (9),		/* Fill left-over part of last sector of the current record with this value when writing. */
      144          3 buf_len		       fixed bin (19),	/*  length (words) of buffer */
      145          3 data_len		       fixed bin (19),	/* length of data area in buffer */
      146          3 time_int		       fixed bin (71),	/* current time out interval */
      147          3 next_key		       fixed bin (35),	/* next key as per iox_ */
      148          3 current_key	       fixed bin (35),	/* current key as per iox_ */
      149          3 key_for_insertion	       fixed bin (35),	/* key for insertion as per iox_  */
      150 						/* key_for_insertion is always null for the
      151*						   present implementation, since write_record
      152*						   is not supported for direct_update.  */
      153          3 bounds,					/* current key  boundaries */
      154 	 4 low		       fixed bin (35),	/* the lower bound */
      155 	 4 high		       fixed bin (35),	/* higher bound */
      156          3 mode_string	       char (32) varying,	/* current modes */
      157          3 rcp_data		       (size (disk_info)) fixed bin (35);
      158 						/* area for rcp_disk_info structure */
      159 
      160 
      161 dcl  1 attachments		       based (attachments_ptr),
      162        2 number_attached	       fixed bin,
      163        2 number_used	       fixed bin,
      164        2 array		       (100),
      165          3 device_att	       char (8),
      166          3 sv		       (3),
      167 	 4 this_sv	       fixed bin,
      168 	 4 this_iocbp	       ptr;
      169 
      170 dcl  attachments_ptr	       ptr static init (null ());
      171 dcl  system_area_ptr	       ptr;
      172 dcl  system_area		       area based (system_area_ptr);
      173 dcl  1 status		       based (addr (iom_stat)),
      174 						/* breakout of iom_stat */
      175        2 pad		       bit (2) unal,	/* not used */
      176        2 maj		       bit (4) unal,	/* major status */
      177        2 sub		       bit (6) unal,	/* sub status */
      178        2 pad2		       bit (48) unal,	/* not used */
      179        2 residue		       bit (12) unal;	/* tally residue */
      180 
      181 dcl  1 seek		       aligned,
      182        2 block_count_limit	       fixed bin (12) unsigned unal,
      183        2 ti		       bit (2) unal,
      184        2 mbz		       bit (1) unal,
      185        2 sector		       fixed bin (21) unsigned unal;
      186 
      187 dcl  1 super_seek		       aligned,
      188        2 sector_number	       fixed bin (8) unsigned unal,
      189        2 mbz1		       bit (4) unal,
      190        2 ti		       bit (2) unal,
      191        2 is_super_seek	       bit (1) unal,
      192        2 flag		       bit (1) unal,
      193        2 mbz2		       bit (4) unal,
      194        2 cyl_lower		       fixed bin (8) unsigned unal,
      195        2 cyl_upper		       fixed bin (2) unsigned unal,
      196        2 head		       fixed bin (6) unsigned unal;
      197 
      198 dcl  1 buffer		       based (buf_ptr),	/* ioi_ buffer */
      199        2 control_info,				/* device control data */
      200          3 (
      201          rst_idcw,
      202          sk_idcw,
      203          sk_dcw,
      204          rw_idcw,
      205          rw_dcw		       (70),
      206          rsr_idcw,
      207          rsr_dcw
      208          )		       bit (36) aligned,	/* DCW's */
      209          3 seek_data	       like seek,		/* Information for seek DCW */
      210          3 rsr_data		       bit (72) unal,	/* detailed device status read by RSR */
      211          3 reserved		       (6) fixed bin (35),	/* pad for future expansion */
      212          3 istat		       aligned,		/* I/O Interfacer status structure */
      213 	 4 completion,				/* completion flags */
      214 	 ( 5 st		       bit (1),		/* "1"b if status returned */
      215 	   5 er		       bit (1),		/* "1"b if status indicates error condition */
      216 	   5 run		       bit (1),		/* "1"b if channel still running */
      217 	   5 time_out	       bit (1)
      218 	   )		       unal,		/* "1"b if time-out occurred */
      219 	 4 level		       fixed bin (3),	/* IOM interrupt level */
      220 	 4 offset		       fixed bin (18),	/* DCW list offset */
      221 	 4 absaddr	       fixed bin (24),	/* absolute address of workspace */
      222 	 4 iom_stat	       bit (72),		/* IOM status */
      223 	 4 lpw		       bit (72),		/* LPW residue */
      224        2 data		       char (4 * data_len);	/* data area  */
      225 
      226 dcl  1 event_info		       aligned,		/*  event message info  */
      227        2 chan_id		       fixed bin (71),
      228        2 message,
      229          3 pad1		       bit (15) unal,
      230          3 int_level	       bit (3) unal,
      231          3 pad2		       bit (36) unal,
      232          3 special_type	       fixed bin (17) unal,
      233        2 sender		       bit (36),
      234        2 origin,
      235          3 dev_signal	       bit (18) unal,
      236          3 ring		       bit (18) unal,
      237        2 chan_x		       fixed bin;
      238 
      239 dcl  1 tp_info,					/*  terminate_process_ information */
      240        2 version		       fixed bin,		/* version no. (currently 0) */
      241        2 code		       fixed bin (35);	/* error code to be printed before process is termed */
      242 
      243 dcl  1 query_info		       aligned,		/* command_query_ information */
      244        2 version		       fixed bin init (2),
      245        2 yes_or_no_sw	       bit (1) unal init ("1"b),
      246 						/* want only "yes" or "no" */
      247        2 suppress_name_sw	       bit (1) unal init ("0"b),
      248 						/* let them  know who we are */
      249        2 (status_code, query_code)   fixed bin (35) init (0);
      250 
      251 dcl  pri_iocb_ptr		       ptr;
      252 dcl  (disk_ptr, iocb_ptr, real_iocb_ptr, ubuf_ptr, block_ptr, rs_ptr, info_ptr, fmdp)
      253 			       ptr init (null);	/* pointers */
      254 dcl  dcw_offset		       fixed bin (18);	/* offset in ioi_ buffer to first IDCW */
      255 dcl  (code, rec_len, tot_rec_len, data_left, mode_len, mode_start)
      256 			       fixed bin (35);
      257 dcl  key			       fixed bin (21);	/* working seek key */
      258 dcl  control_command	       bit (6);		/* data xfer command in execution */
      259 dcl  track_indicators	       bit (2) init ("00"b);	/* track indicator bits for seek cmd */
      260 dcl  (count_limit_fixed, block_len)  fixed bin (12);
      261 dcl  (i, j, num_opts, err_ct, old_length, new_length, rcp_state)
      262 			       fixed bin;
      263 dcl  (cyl, head)		       fixed bin (16);
      264 dcl  (again, not_sw, mode_err_sw, cont_sw)
      265 			       bit (1) unal;
      266 dcl  answer		       char (3) varying;
      267 dcl  block		       char (4 * block_len) based (block_ptr);
      268 						/*  current user data block */
      269 dcl  dev_id		       char (4);		/* alpha device id, e.g. D191 */
      270 dcl  rs_mode		       fixed bin (5);	/* rcp_sys_ access mode for this process */
      271 dcl  old_descrip		       char (168);		/* hold area for changing attach descrip. */
      272 dcl  new_pack_id		       char (32) varying based (info_ptr);
      273 						/* new pack id for changepack order */
      274 dcl  1 user_bounds		       based (info_ptr),	/* current bounds returned via this structure */
      275        2 low		       fixed bin (35),
      276        2 high		       fixed bin (35);
      277 dcl  new_size		       fixed bin (35) based (info_ptr);
      278 						/* new size for setsize control order */
      279 dcl  new_modes		       char (24);		/* new modes for  modes oper. */
      280 dcl  next_mode		       char (8) varying init ("dummy");
      281 dcl  mask_str		       bit (36) aligned;	/* ips_ mask */
      282 dcl  1 mask		       based (addr (mask_str)),
      283 						/* different def'n of above */
      284        2 pad		       bit (35) unal,	/* we don't use this */
      285        2 masked		       bit (1) unal;	/* flag to indicate if we are masked */
      286 dcl  temp_key		       fixed bin (35);
      287 dcl  1 drive_number,
      288        2 sign		       char (1),
      289        2 number		       char (2);
      290 dcl  drive_dec		       dec (2) based (addr (drive_number));
      291 						/* used for drive number conversion */
      292 dcl  drive_name		       char (8);		/* name of the requested device or spaces */
      293 dcl  model_number		       fixed bin;		/* model number requested by user */
      294 
      295 
      296 dcl  DEVICE_GROUP		       (9) fixed bin int static options (constant) init (0, 2, 1, 1, 1, 1, 2, 3, 3);
      297 						/* "bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381" */
      298 dcl  FORMAT_DATA_LEN	       (9) fixed bin int static options (constant) init (0, 88, 6, 6, 6, 6, 24, 24, 24);
      299 dcl  MSU04XX		       fixed bin int static options (constant) init (1);
      300 
      301 dcl  MSU33XX		       fixed bin init static options (constant) init (3);
      302 dcl  overhead		       fixed bin int static options (constant) init (192);
      303 						/* number of control words reserved in ioi_ buffer */
      304 dcl  max_retries		       int static options (constant) fixed bin init (10);
      305 						/* number of times we will retry certain operations */
      306 dcl  ATTENTION		       int static options (constant) bit (4) init ("0010"b);
      307 dcl  EOF			       int static options (constant) bit (4) init ("0100"b);
      308 dcl  LAST_BLOCK		       int static options (constant) bit (6) init ("000001"b);
      309 dcl  LAST_BLOCK_MASK	       int static options (constant) bit (6) init ("111101"b);
      310 dcl  TI_MASK		       int static options (constant) bit (6) init ("011100"b);
      311 dcl  STANDBY		       int static options (constant) bit (6) init ("010000"b);
      312 dcl  EXEC			       bit (5) int static options (constant) init ("00100"b);
      313 dcl  FORMAT_TRK		       bit (6) int static options (constant) init ("001111"b);
      314 dcl  RD_TRK_HEADER		       bit (6) int static options (constant) init ("010111"b);
      315 dcl  SPECIAL_SEEK		       bit (6) int static options (constant) init ("011110"b);
      316 dcl  SPECIAL_SEEK_512	       bit (6) int static options (constant) init ("35"b3);
      317 dcl  LONG_WAIT		       fixed bin int static options (constant) init (2);
      318 dcl  COMPLETE		       fixed bin int static options (constant) init (0);
      319 dcl  RETAIN		       bit (1) int static options (constant) init ("1"b);
      320 dcl  DEFAULT		       bit (1) int static options (constant) init ("0"b);
      321 dcl  NOT_SET		       fixed bin (6) int static options (constant) init (-1);
      322 dcl  num_label_sect		       fixed bin int static options (constant) init (8);
      323 dcl  rcp_dev_type		       char (32) int static options (constant) init ("disk_drive");
      324 dcl  IOTD			       bit (2) aligned int static options (constant) init ("00"b);
      325 dcl  MAX_DCW_TALLY		       fixed bin int static options (constant) init (4096);
      326 
      327 
      328 dcl  restore_idcw_string	       int static bit (36) init ("420000720201"b3);
      329 dcl  seek_idcw_string	       int static bit (36) init ("340000720000"b3);
      330 dcl  seek_dcw_string	       int static bit (36) init ("000000000001"b3);
      331 dcl  read_idcw_string	       int static bit (36) init ("250000700000"b3);
      332 dcl  write_idcw_string	       int static bit (36) init ("310000700000"b3);
      333 dcl  write_and_compare_idcw_string   int static bit (36) init ("330000700000"b3);
      334 dcl  control_idcw_string	       int static bit (36) init ("000000700000"b3);
      335 dcl  read_write_dcw_string	       int static bit (36) init ("000000010000"b3);
      336 						/* IOTP */
      337 dcl  1 restore_idcw_template	       defined (restore_idcw_string) like idcw;
      338 dcl  1 seek_idcw_template	       defined (seek_idcw_string) like idcw;
      339 dcl  1 seek_dcw_template	       defined (seek_dcw_string) like dcw;
      340 dcl  1 read_idcw_template	       defined (read_idcw_string) like idcw;
      341 dcl  1 write_idcw_template	       defined (write_idcw_string) like idcw;
      342 dcl  1 write_and_compare_idcw_template
      343 			       defined (write_and_compare_idcw_string) like idcw;
      344 dcl  1 control_idcw_template	       defined (control_idcw_string) like idcw;
      345 dcl  1 read_write_dcw_template       defined (read_write_dcw_string) like dcw;
      346 
      347 dcl  (
      348      error_table_$action_not_performed,			/*  notacted, The requested action was not performed.;  */
      349      error_table_$bad_arg,				/*  bad_arg , Illegal command or subroutine argument.;  */
      350      error_table_$bad_conversion,			/*  bad_conv, Error in conversion.;  */
      351      error_table_$bad_mode,				/*  badmode , Improper mode specification for this device.;  */
      352      error_table_$device_end,				/*  devend  , Physical end of device encountered.;  */
      353      error_table_$device_parity,			/*  xmiterr , Unrecoverable data-transmission error on physical device.;  */
      354      error_table_$end_of_info,			/*  eoi     , End of information reached.;  */
      355      error_table_$incompatible_attach,			/*  att^=opn, Attach and open are incompatible.;  */
      356      error_table_$invalid_device,			/*  invdev  , Attempt to attach to an invalid device.;  */
      357      error_table_$invalid_read,			/*  invread , Attempt to read or move read pointer on device which was not attached as readable.;  */
      358      error_table_$invalid_write,			/*  invwrite, Attempt to write or move write pointer on device which was not attached as writeable.;  */
      359      error_table_$no_current_record,			/*  fm_16   , no_current_record := there is no current record.;  */
      360      error_table_$no_operation,			/*  no_oper , Invalid I/O operation.;  */
      361      error_table_$no_record,				/*  no_rec  , Record not located.;  */
      362      error_table_$noarg,				/*          , Expected argument missing.;  */
      363      error_table_$not_attached,			/*  notattch, I/O switch (or device) is not attached.;  */
      364      error_table_$not_closed,				/*  not_clsd, I/O switch is not closed.;  */
      365      error_table_$not_detached,			/*  not_det , I/O switch is not detached.;  */
      366      error_table_$not_open,				/*  not_open, I/O switch is not open.;  */
      367      error_table_$request_not_recognized,		/*  reqnorec, Request not recognized.;  */
      368      error_table_$resource_assigned,
      369      error_table_$termination_requested,		/*  termrqu , Process terminated because of system defined error condition.;  */
      370      error_table_$user_not_found,			/*  usernfd , User-name not on access control list for branch.;  */
      371      error_table_$unimplemented_version
      372      )			       external static fixed bin (35);
      373 
      374 
      375 dcl  (abs, addr, addrel, bin, bit, bool, ceil, char, divide, fixed, floor, hbound, index, length, max, min, mod, null,
      376      rel, search, size, string, substr, unspec, ltrim, rtrim, verify)
      377 			       builtin;
      378 dcl  get_system_free_area_	       entry () returns (ptr);
      379 dcl  ipc_$delete_ev_chn	       entry (fixed bin (71), fixed bin (35));
      380 dcl  iox_$err_no_operation	       entry options (variable);
      381 dcl  iox_$err_not_closed	       entry options (variable);
      382 dcl  iox_$err_not_open	       entry options (variable);
      383 dcl  ioi_$timeout		       entry (fixed bin, fixed bin (52), fixed bin (35));
      384 dcl  ioi_$workspace		       entry (fixed bin, ptr, fixed bin (19), fixed bin (35));
      385 
      386 
      387 dcl  sub_err_		       entry options (variable);
      388 
      389 /*  The above sub_err_ line used to be for com_err_ but clarification on the rules for writing
      390*   *  I/O modules resulted in two significant decisions:
      391*   *     (1) I/O modules should use the sub_err_ subroutine, not the com_err subroutine.
      392*   *     (2) I/O modules should call sub_err_ _o_n_l_y in their attach routine,
      393*   *         and then only if the value of the third argument equals "1"b.
      394*   *  The next  "dcl"  statement is associated with sub_err_
      395*   */
      396 dcl  retval		       fixed bin (35);	/* value returned from caller specifying rdisk_ action */
      397 						/* No actions in rdisk_ are defined at the moment. */
      398 						/* When actions are defined, which value yields what */
      399 						/* action could be listed here.  */
      400 
      401 
      402 dcl  hcs_$make_seg		       entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      403 dcl  hcs_$delentry_seg	       entry (ptr, fixed bin (35));
      404 dcl  iox_$propagate		       entry (ptr);
      405 dcl  ipc_$create_ev_chn	       entry (fixed bin (71), fixed bin (35));
      406 dcl  cv_dec_check_		       entry (char (*), fixed bin (35)) returns (fixed bin (35));
      407 dcl  ioi_$connect		       entry (fixed bin, fixed bin (18), fixed bin (35));
      408 dcl  ipc_$block		       entry (ptr, ptr, fixed bin (35));
      409 dcl  ioi_$set_status	       entry (fixed bin, fixed bin (18), fixed bin (8), fixed bin (35));
      410 dcl  ioi_$get_detailed_status	       entry (fixed bin, bit (1) aligned, bit (*), fixed bin (35));
      411 dcl  ioa_$ioa_stream	       entry options (variable);
      412 dcl  command_query_		       entry options (variable);
      413 dcl  timer_manager_$sleep	       entry (fixed bin (71), bit (2));
      414 dcl  hcs_$initiate		       entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr,
      415 			       fixed bin (35));
      416 dcl  hcs_$fs_get_mode	       entry (ptr, fixed bin (5), fixed bin (35));
      417 dcl  hcs_$set_ips_mask	       entry (bit (36) aligned, bit (36) aligned);
      418 dcl  hcs_$reset_ips_mask	       entry (bit (36) aligned, bit (36) aligned);
      419 dcl  default_handler_$set	       entry (entry);
      420 dcl  terminate_process_	       entry (char (*), ptr);
      421 dcl  rcp_$attach		       entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
      422 dcl  rcp_$check_attach	       entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (71),
      423 			       fixed bin, fixed bin (35));
      424 dcl  rcp_$detach		       entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
      425 dcl  iox_$control		       entry (ptr, char (*), ptr, fixed bin (35));
      426 
      427 dcl  a_iocb_ptr		       ptr;		/* parameter:  IOCB pointer */
      428 dcl  a_code		       fixed bin (35);	/* parameter:  return code */
      429 dcl  a_rec_len		       fixed bin (21);	/* parameter:  user record length */
      430 dcl  a_ubuf_ptr		       ptr;		/* parameter:  pointer to user buffer */
      431 dcl  a_ubuf_len		       fixed bin (21);	/* parameter: length (chars.) of user buffer */
      432 
      433 dcl  1 fmt_dta		       based (fmdp) aligned,	/* data needed by the format trk command */
      434        2 svcyl		       bit (16) unaligned,	/* seek verification  data cylinder number */
      435        2 svhd		       bit (16) unaligned,	/* seek verification data head number */
      436        2 hz		       bit (2) unaligned,	/* header bypass switch */
      437        2 ti		       bit (2) unaligned,	/* track indicator bits */
      438        2 pad1		       bit (10) unaligned,
      439        2 r0cti		       bit (2) unaligned,	/* record zero track indicators */
      440        2 r0ccyl		       bit (16) unaligned,	/* record zero count field - cyl number */
      441        2 r0chd		       bit (16) unaligned,	/* record zero count field - head number */
      442        2 pad2		       bit (2) unaligned,
      443        2 chk_chr		       bit (6) unaligned,	/* exclusive or check character  */
      444        2 pad3		       bit (12) unaligned,
      445        2 pad4		       bit (72) unaligned;
      446 
      447 dcl  1 fmt_info		       based (info_ptr) aligned,
      448 						/* user supplied structure for format_trk order */
      449        2 hz		       bit (2) unaligned,	/* header bypass information */
      450        2 ti		       bit (2) unaligned,	/* track indicator bits */
      451        2 alt_def_cyl	       fixed bin (16) unaligned,
      452 						/*  user supplied cyl and head address for alt or   */
      453        2 alt_def_hd		       fixed bin (16) unaligned;
      454 						/* defective track address */
      455 
      456 dcl  info_block		       char (20) based (info_ptr);
      457 						/* users info buffer for rd_trk_header order */
      458 
      459 dcl  1 user_dev_char_table	       based (info_ptr) aligned,
      460 						/* Users device Characteristics Table */
      461        2 user_subsystem_name	       char (4),		/* Disk subsystem name */
      462        2 user_device_name	       char (8),		/* Device name */
      463        2 user_sect_per_dev	       fixed bin (35),	/* total no. of non-T&D sectors on pack */
      464        2 user_cyl_per_dev	       fixed bin,		/* no. of non-T&D cylinders on pack */
      465        2 user_sect_per_cyl	       fixed bin,		/* no of sectors per cylinder */
      466        2 user_sect_per_track	       fixed bin,		/* no. of sectors per track */
      467        2 user_num_label_sect	       fixed bin,		/* no. of sectors to reserve for label */
      468        2 user_num_alt_sect	       fixed bin,		/* no. of sectors to reserve for alt. track area */
      469        2 user_sect_size	       fixed bin (12);	/* no. of words in sector */
      470 
      471 dcl  user_hardware_status	       bit (72) based (info_ptr);
      472 
      473 dcl  io_command		       char (8) varying;	/* values are "read", "write", or "rewrite" */
      474 dcl  current_mode_name	       char (24);		/* name of current opening mode */
      475 
      476 dcl  dcwx			       fixed bin;
      477 dcl  dcw_address		       fixed bin (18);
      478 dcl  rw_length		       fixed bin (18);
      479 
      480 dcl  END			       fixed bin int static init (-5);
      481 						/* used to indicate that a key is at the end of the file */
      482 dcl  NULL			       fixed bin int static init (-1);
      483 						/* used to flag keys as currently being invalid */
      484 dcl  unique_chars_		       entry (bit (*)) returns (char (15));
      485 dcl  unique_entry_name	       char (22);
      486 
      487 /*  Start of ATTACH module  */
      488 
      489 rdisk_attach:
      490      entry (a_iocb_ptr, options, a_err_sw, a_code);
      491 
      492 /*
      493*   *	     The attach description has the following form:
      494*   *
      495*   *	     rdisk_ device_id pack_id -opt1_- -opt_n-
      496*   *
      497*   *      1.   device_id      is a character string identifying the type  number
      498*   *                          of  the  required disk device.  The supported disk
      499*   *                          devices are listed in the table below, along  with
      500*   *                          the character string to use for device_id:
      501*
      502*   *                          device_id
      503*   *                          Character
      504*   *                          String              Device Type
      505*   *                          __________          ___________________
      506*
      507*   *                          d181                DSU181
      508*   *                          d190                DSU190
      509*   *                          d191                DSU190 with the
      510*   *                                                high-efficiency format
      511*   *                                                (40 sectors/track)
      512*   *                          d400                MSU0400
      513*   *                          d451                MSU0451
      514*   *			d500		MSU0500
      515*   * 			d501		MSU0501
      516*   *			3380		MSU3380
      517*   *			3381		MSU3381
      518*   *
      519*   *	      2.  pack_id             is a character  string  identifying
      520*   *				the disk pack to be mounted.
      521*   *
      522*   *	      3.  opt_i                may  be  one   of   the   following
      523*   *				options.   An option may occur only
      524*   *				once.
      525*   *
      526*   *                -device device_name    Indicate what device the user is
      527*   *				requesting. The device_name format is:
      528*   *				dskX_NN{S}. Where X is the subsystem
      529*   *				name, NN is the device number, and S
      530*   *				the optional subvolume name. If S is 
      531*   *				given then the seeks will be relative
      532*   *				to the indicated subvolume.
      533*   *
      534*   *		-write              indicates that the disk pack is  to
      535*   *				be   written.    If   omitted,  the
      536*   *				operator  will  be  instructed   to
      537*   *				mount the pack write inhibited.
      538*   *
      539*   *		-size n             indicates that the value of n is to
      540*   *				override the value of buff_len as a
      541*   *				record    size    limit   for   the
      542*   *				read_record    operation.
      543*   *
      544*   *	       -system, -sys         indicates that the attachment  is  being
      545*   *		                    made by a system process and that a disk
      546*   *		                    drive  reserved  for system functions is
      547*   *		                    to be assigned.
      548*   *
      549*   *		                    (NOTE:  This control argument used to be
      550*   *		                    supplied by the user as "-priv"  but  is
      551*   *		                    being  changed  to  "-system"  for  greater
      552*   *		                    consistency with other parts of Multics.
      553*   *		                    The character  string  "-priv"  will  be
      554*   *		                    honored  for  awhile,  i.e., both "-system"
      555*   *		                    and "-priv" will have  the  same  effect
      556*   *		                    for  now.   With  some  future  release,
      557*   *		                    "-priv" will no longer be accepted.)
      558*   *
      559*   *	     The  attachment causes the specified disk pack to be mounted
      560*   *	on a drive of the specified type.  (See the IOI and RCP documentation.)
      561**/
      562 
      563 dcl  options		       (*) char (*) varying;	/* parameter:  attach description elements */
      564 dcl  a_err_sw		       bit (1) aligned;	/* parameter: print errors flag */
      565 dcl  found_dev_att		       bit (1);
      566 dcl  rcp_detachment		       bit (1);
      567 
      568 
      569 	if attachments_ptr = null ()
      570 	     then do;				/* If there is no attachments get the space */
      571 		system_area_ptr = get_system_free_area_ ();
      572 		allocate attachments in (system_area) set (attachments_ptr);
      573 		attachments.device_att (*) = "";
      574 		attachments.array (*).sv (*).this_iocbp = null ();
      575 		attachments.number_used = 0;
      576 		attachments.number_attached = 0;
      577 	     end;
      578 
      579 
      580 	code = 0;					/* clear return code */
      581 
      582 	unique_entry_name = unique_chars_ ("0"b) || ".rdisk_";
      583 	call hcs_$make_seg ("", unique_entry_name, "", 01010b, disk_ptr, code);
      584 						/* make our work segment */
      585 	if disk_ptr = null then call error (code, "");	/* if it didn't work */
      586 
      587 	iocb_ptr = a_iocb_ptr;			/* grab IOCB pointer */
      588 
      589 	if iocb_ptr -> attach_descrip_ptr ^= null then call att_err (error_table_$not_detached);
      590 						/* must be detached */
      591 	call parse_attach_options;
      592 
      593 	if is_sv
      594 	     then if attach_data.dev_type ^= 0
      595 		     then if sv_num >= number_of_sv (attach_data.dev_type)
      596 			     then call att_err (error_table_$invalid_device);
      597 	if attach_data.dev_type = 0
      598 	     then attach_descrip.descrip = "rdisk_ """" " || pack_id;
      599 	     else attach_descrip.descrip =
      600 		     "rdisk_ " || device_names (attach_data.dev_type) || " " || attach_data.pack_id;
      601 						/* init. att. descrip. */
      602 	attach_descrip.length = length (rtrim (attach_descrip.descrip));
      603 	do i = 3 to num_opts;			/* add the options */
      604 	     attach_descrip.descrip = substr (attach_descrip.descrip, 1, attach_descrip.length) || " " || options (i);
      605 						/* concatenate the next option */
      606 	     attach_descrip.length = length (rtrim (attach_descrip.descrip));
      607 	     end;
      608 
      609 	if ^(found_dev_att)
      610 	     then do;
      611 		call ipc_$create_ev_chn (ev_chan, code);/* create an event channel */
      612 		if code ^= 0 then call att_err (code);	/* if we didn't make it */
      613 		nchan = 1;			/* only one channel */
      614 
      615 		disk_info_ptr = addr (rcp_data);	/* init. disk info prior to assignment */
      616 		disk_info.version_num = DISK_INFO_VERSION_1;
      617 		disk_info.usage_time, disk_info.wait_time = 0;
      618 		disk_info.system_flag = sys_sw;
      619 		if dev_type ^= 0
      620 		     then disk_info.model = MODELN (dev_type);
      621 		     else disk_info.model = 0;
      622 	     end;
      623 	disk_info.device_name = substr (drive_name, 1, 7);
      624 	disk_info.write_flag = disk_data.write_sw;
      625 	raw_sw = "0"b;				/* reset raw mode if set */
      626 	alt_sw = "0"b;
      627 	label_sw = "1"b;
      628 	if ^found_dev_att
      629 	     then do;
      630 		call mount ();			/* attach drive, and mount pack */
      631 		if code ^= 0 then call att_err (code);	/* complain if we didn't make it */
      632 
      633 		disk_data.dev_type = 0;
      634 		do i = 1 to hbound (MODELN, 1) while (disk_data.dev_type = 0);
      635 		     if disk_info.model = MODELN (i) then disk_data.dev_type = i;
      636 		     end;
      637 
      638 		if disk_data.dev_type <= 1 then call att_err (error_table_$invalid_device);
      639 
      640 		device_group = DEVICE_GROUP (disk_data.dev_type);
      641 
      642 		if disk_data.is_sv
      643 		     then disk_data.sect_per_dev = sect_per_sv (disk_data.dev_type);
      644 		     else disk_data.sect_per_dev =
      645 			     sect_per_cyl (disk_data.dev_type) * cyl_per_dev (disk_data.dev_type);
      646 						/* Set up device specific constants */
      647 		disk_data.sect_size = words_per_sect (disk_data.dev_type);
      648 		disk_data.num_alt_sect =
      649 		     last_alt_sect_num (disk_data.dev_type) - first_alt_sect_num (disk_data.dev_type) + 1;
      650 
      651 		if sys_sw
      652 		     then disk_data.bounds.low = 0;
      653 		     else disk_data.bounds.low = num_label_sect;
      654 						/* initialize the seek low bound */
      655 		if disk_data.device_group = MSU04XX
      656 		     then disk_data.bounds.high = last_alt_sect_num (disk_data.dev_type);
      657 		else if (disk_data.device_group = MSU33XX) & disk_data.is_sv
      658 		     then disk_data.bounds.high = sect_per_sv (disk_data.dev_type) - 1;
      659 		else disk_data.bounds.high = last_sect_num (disk_data.dev_type);
      660 	     end;
      661 	     else do;
      662 		disk_data.errors = 0;		/* give the pack a fresh start */
      663 		disk_data.buf_len = min (max (divide (disk_data.sze, 4, 17, 0), 1024), disk_data.max_buff_size);
      664 						/* determine ioi_ buffer size */
      665 		disk_data.data_len = disk_data.buf_len - overhead;
      666 						/* set length of data area */
      667 	     end;
      668 
      669 	disk_data.mode_string = "label,^alttrk,^wrtcmp,^raw";
      670 						/* set the modes string */
      671 
      672 	mask_str = "0"b;				/* initialize ips_ mask */
      673 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
      674 	call hcs_$set_ips_mask (mask_str, mask_str);
      675 
      676 	iocb_ptr -> attach_descrip_ptr = addr (attach_descrip);
      677 						/* fill in IOCB; attach descrip. */
      678 	iocb_ptr -> attach_data_ptr = disk_ptr;		/* attach data */
      679 	iocb_ptr -> detach_iocb = rdisk_detach;		/* detach entry */
      680 	iocb_ptr -> open = rdisk_open;		/* open entry */
      681 	iocb_ptr -> iocb.control = rdisk_control;	/* control entry */
      682 	iocb_ptr -> modes = rdisk_modes;		/* modes entry */
      683 
      684 	call iox_$propagate (iocb_ptr);		/*  let iox_ have its turn */
      685 
      686 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
      687 
      688 	next_key, current_key, key_for_insertion = NULL;	/* Change when valid values established */
      689 
      690 /* add this atttachment to the array */
      691 	if found_dev_att
      692 	     then att_dev_idx = pri_iocb_ptr -> attach_data_ptr -> att_dev_idx;
      693 
      694 	     else do att_dev_idx = 1 to hbound (attachments.array, 1)
      695 		     while (attachments.array (att_dev_idx).device_att ^= "");
      696 		     end;
      697 	if att_dev_idx > attachments.number_used then attachments.number_used = att_dev_idx;
      698 	if sv_num = -1
      699 	     then					/* user attaching entire device */
      700 		att_sv_idx = 1;
      701 	     else do att_sv_idx = 1 to 3 while (attachments.array (att_dev_idx).sv (att_sv_idx).this_iocbp ^= null ());
      702 		     end;
      703 	if ^(found_dev_att) then attachments.array (att_dev_idx).device_att = addr (rcp_data) -> disk_info.device_name;
      704 	attachments.array (att_dev_idx).sv (att_sv_idx).this_iocbp = iocb_ptr -> actual_iocb_ptr;
      705 						/* the real iocb ptr */
      706 	attachments.array (att_dev_idx).sv (att_sv_idx).this_sv = sv_num;
      707 	attachments.number_attached = attachments.number_attached + 1;
      708 exit:
      709 	a_code = code;				/* return the code */
      710 	return;					/* bye-bye */
      711 
      712 parse_attach_options:
      713      proc;
      714 
      715 /* This internal proc sets up the attach_data if this is a subvolume attach */
      716 /* then it will copy the "buddy" disk_data and fill in the new values for   */
      717 /* the attach options. */
      718 
      719 dcl  1 at_opt,
      720        2 sze		       fixed bin (35),
      721        (
      722        2 err_sw,
      723        2 write_sw,
      724        2 compare_sw,
      725        2 raw_sw,
      726        2 alt_sw,
      727        2 label_sw,
      728        2 sys_sw
      729        )			       bit (1) unal,
      730        2 pack_id		       char (32),
      731        2 dev_type		       fixed bin,
      732        2 is_sv		       bit (1),
      733        2 sv_num		       fixed bin;
      734 
      735 dcl  (dv, sv)		       fixed bin;
      736 	at_opt.err_sw = a_err_sw;			/* fill in print errors flag */
      737 	at_opt.write_sw, at_opt.sys_sw, at_opt.compare_sw = "0"b;
      738 						/* initialize switches */
      739 	at_opt.pack_id = " ";			/* clear pack id */
      740 	at_opt.sze = 0;				/* reset size field */
      741 	drive = NOT_SET;				/* init drive field */
      742 	drive_name = "";				/* no specific drive specified */
      743 	model_number = 0;
      744 
      745 	at_opt.is_sv = "0"b;			/* default to no subvolume */
      746 	at_opt.sv_num = -1;				/* -1 indcates not sv */
      747 	num_opts = hbound (options, 1);		/* how many descrip. elements? */
      748 
      749 	if num_opts >= 2
      750 	     then do;				/* if enough */
      751 		dev_id = options (1);		/* set device name */
      752 		at_opt.pack_id = options (2);		/* set pack id */
      753 	     end;
      754 	     else call att_err (error_table_$noarg);	/* complain if not enough  */
      755 
      756 	if dev_id = "d191" | dev_id = "D191" then dev_id = "d400";
      757 						/* set up for compatibility */
      758 						/* ******** */
      759 	if dev_id = "d450" then dev_id = "d451";
      760 
      761 	if dev_id = "m400" then dev_id = "d400";	/* For MR7.0 only */
      762 	else if dev_id = "m451" then dev_id = "d451";	/* For MR7.0 only */
      763 
      764 	at_opt.dev_type = 0;			/* clear device type indicator */
      765 	do i = 1 to maxdevt while (at_opt.dev_type = 0);	/*  look up dev. name in dev. char. table */
      766 	     if dev_id = device_names (i) then at_opt.dev_type = i;
      767 						/* if found, set device type indicator */
      768 	     end;					/* ******** */
      769 
      770 	do i = 3 to num_opts;			/* check out attach options */
      771 
      772 	     if options (i) = "-write" then at_opt.write_sw = "1"b;
      773 						/* if -write set write mode switch */
      774 	     else if options (i) = "-size"
      775 		then do;				/* if -size, try to set size */
      776 		     if i >= num_opts then call att_err (error_table_$noarg);
      777 						/* if no size value, complain */
      778 		     i = i + 1;			/* set for next option element */
      779 		     at_opt.sze = cv_dec_check_ ((options (i)), code);
      780 						/* pick up size value */
      781 		     if code ^= 0 then call att_err (error_table_$bad_conversion);
      782 						/* if not number, complain */
      783 		     if at_opt.sze <= 0
      784 			then call error (error_table_$bad_arg, "Value of size option must be positive.");
      785 		end;
      786 
      787 	     else if options (i) = "-system" | options (i) = "-sys" | options (i) = "-priv"
      788 						/* obsolete */
      789 		then do;				/* if a reserved drive is wanted */
      790 
      791 		     call hcs_$initiate (">system_library_1", "rcp_sys_", "", 0, 0, rs_ptr, code);
      792 						/* test rcp_sys_ access */
      793 		     if rs_ptr ^= null
      794 			then do;			/* if can be initiated */
      795 			     call hcs_$fs_get_mode (rs_ptr, rs_mode, code);
      796 						/* check caller's access */
      797 			     if code = 0
      798 				then if bit (rs_mode) & EXEC then at_opt.sys_sw = "1"b;
      799 						/* if execute, then priv. process */
      800 			end;
      801 		     if ^at_opt.sys_sw then call att_err (error_table_$user_not_found);
      802 						/* User does not have correct access to rcp_sys_ gate. */
      803 		end;
      804 
      805 	     else if options (i) = "-device" | options (i) = "-dv"
      806 		then do;				/* -device device-name */
      807 		     if i >= num_opts then call att_err (error_table_$noarg);
      808 		     i = i + 1;
      809 		     drive_name = options (i);
      810 		     if drive_name ^= options (i) then call att_err (error_table_$bad_arg);
      811 		     call check_dev (drive_name);
      812 		     if code ^= 0 then call att_err (code);
      813 
      814 		end;
      815 
      816 	     else if options (i) = "-model"
      817 		then do;				/* -model model-number */
      818 		     if i >= num_opts then call att_err (error_table_$noarg);
      819 		     i = i + 1;
      820 		     model_number = cv_dec_check_ ((options (i)), code);
      821 		     if code ^= 0 then call att_err (error_table_$bad_conversion);
      822 		     at_opt.dev_type = 0;
      823 		     do j = 1 to hbound (MODEL, 1) while (at_opt.dev_type = 0);
      824 			if model_number = MODEL (j) then at_opt.dev_type = MODELX (j);
      825 			end;
      826 		     if at_opt.dev_type = 0 then call att_err (error_table_$bad_arg);
      827 		     model_number = MODELN (at_opt.dev_type);
      828 		end;
      829 
      830 	     else call att_err (error_table_$request_not_recognized);
      831 						/* if not valid option, complain */
      832 
      833 	     end;
      834 
      835 	found_dev_att = "0"b;
      836 
      837 	if drive_name ^= ""
      838 	     then do;
      839 		do dv = 1 to attachments.number_used while (^found_dev_att);
      840 		     if attachments.device_att (dv) = substr (drive_name, 1, 7)
      841 			then do;
      842 			     if ^found_dev_att
      843 				then do;
      844 				     found_dev_att = "1"b;
      845 
      846 				     if at_opt.sv_num = -1 then call att_err (error_table_$resource_assigned);
      847 
      848 				     do sv = 1 to 3;
      849 					if attachments.array (dv).this_iocbp (sv) ^= null
      850 					     then do;
      851 						if attachments.array (dv).this_sv (sv) = -1
      852 						     | at_opt.sv_num = attachments.array (dv).this_sv (sv)
      853 						     then call att_err (error_table_$resource_assigned);
      854 						pri_iocb_ptr = attachments.array (dv).this_iocbp (sv);
      855 					     end;
      856 					end;
      857 				end;
      858 			end;
      859 		     end;
      860 	     end;
      861 
      862 	if found_dev_att then disk_data = pri_iocb_ptr -> attach_data_ptr -> disk_data;
      863 	disk_data.attach_data = at_opt, by name;
      864 	return;
      865 
      866 check_dev:
      867      proc (at_dev);
      868 
      869 /* Internal procedure for checking the device name format on attach */
      870 
      871 dcl  at_dev		       char (8);
      872 dcl  at_dev_len		       fixed bin;
      873 dcl  s_code		       fixed bin (35);
      874 	at_dev_len = length (rtrim (at_dev));
      875 	if at_dev_len < 7 then goto invalid_device;
      876 
      877 	if substr (at_dev, 1, 3) ^= "dsk" | substr (at_dev, 5, 1) ^= "_" then goto invalid_device;
      878 
      879 	s_code = verify (substr (at_dev, 6, 2), "0123456789");
      880 	if s_code ^= 0 then goto invalid_device;
      881 
      882 	if at_dev_len = 8
      883 	     then do;
      884 		s_code = verify (substr (at_dev, 8, 1), valid_sv_string);
      885 		if s_code ^= 0 then goto invalid_device;
      886 		at_opt.is_sv = "1"b;
      887 		at_opt.sv_num = (search (valid_sv_string, substr (at_dev, 8, 1))) - 1;
      888 	     end;
      889 	     else do;
      890 		at_opt.is_sv = "0"b;
      891 		at_opt.sv_num = -1;
      892 	     end;
      893 	code = 0;
      894 	return;
      895 
      896 invalid_device:
      897 	code = error_table_$invalid_device;
      898      end check_dev;
      899 
      900      end parse_attach_options;
      901 
      902 /*  Internal handler for errors occurring during ATTACH  */
      903 
      904 att_err:
      905      proc (b_code);
      906 
      907 dcl  (b_code, c_code)	       fixed bin (35);	/* error code */
      908 
      909 	c_code = b_code;
      910 	if err_sw then call sub_err_ (c_code, "rdisk_", "c", null, retval, "^a", iocb_ptr -> iocb.name);
      911 	call hcs_$delentry_seg (disk_ptr, c_code);	/* get rid of work segment */
      912 	code = b_code;				/* set code */
      913 	go to exit;				/* return */
      914 
      915      end att_err;
      916 
      917 
      918 /*  End of ATTACH module  */
      919 
      920 /*  Start of OPEN module  */
      921 
      922 rdisk_open:
      923      entry (a_iocb_ptr, a_mode, a_ext, a_code);
      924 
      925 /*
      926*   *           The following opening modes are supported:
      927*
      928*
      929*   *		stream_input
      930*   *		stream_output
      931*   *		stream_input_output
      932*   *                sequential_input
      933*   *                sequential_output
      934*   *                sequential_update
      935*   *                direct_input
      936*   *                direct_update
      937*
      938*
      939*   *           Note that if the opening mode is of the output  or  update  type,
      940*   *      the  attach  description  must  include the  -write  control  argument
      941*   *      so  that  the operator  will not  press  the PROTECT button  when  the
      942*   pack is mounted.
      943**/
      944 
      945 dcl  a_mode		       fixed bin;		/* parameter:  open mode  */
      946 dcl  a_ext		       bit (1) aligned;	/* parameter:  extend bit */
      947 
      948 	call setup ("closed");			/* set up working environment */
      949 						/* If setup returns to here, the switch is closed. */
      950 
      951 	mode = a_mode;				/* pick up requested opening mode */
      952 
      953 
      954 /*  Set up various items which are opening-mode dependent.  */
      955 /*  Since current_key remains NULL for all modes, it is not changed and hence does not show below. */
      956 
      957 	if mode = Stream_input
      958 	     then do;
      959 		open_descrip.length = 12;
      960 		open_descrip.descrip = "stream_input";
      961 		real_iocb_ptr -> position = rdisk_position;
      962 		real_iocb_ptr -> get_chars = rdisk_read;
      963 		next_key = bounds.low;
      964 		fill = "101101101"b;		/* Should never be used. */
      965 	     end;
      966 
      967 	else if mode = Stream_output
      968 	     then do;
      969 		if ^write_sw
      970 		     then call error (error_table_$incompatible_attach, "stream_output requires -write control arg.");
      971 						/* complain if not attached for write */
      972 		open_descrip.length = 13;
      973 		open_descrip.descrip = "stream_output";
      974 		real_iocb_ptr -> position = rdisk_position;
      975 		real_iocb_ptr -> put_chars = rdisk_write;
      976 		next_key = bounds.low;
      977 		fill = "101101101"b;		/* Should never be used. */
      978 	     end;
      979 
      980 	else if mode = Stream_input_output
      981 	     then do;
      982 		if ^write_sw
      983 		     then call error (error_table_$incompatible_attach,
      984 			     "stream_input_output requires -write control arg.");
      985 						/* complain if not attached for write */
      986 		open_descrip.length = 19;
      987 		open_descrip.descrip = "stream_input_output";
      988 		real_iocb_ptr -> position = rdisk_position;
      989 		real_iocb_ptr -> get_chars = rdisk_read;
      990 		real_iocb_ptr -> put_chars = rdisk_write;
      991 		next_key = bounds.low;
      992 		fill = "101101101"b;		/* Should never be used. */
      993 	     end;
      994 
      995 	else if mode = Sequential_input
      996 	     then do;
      997 		open_descrip.length = 16;
      998 		open_descrip.descrip = "sequential_input";
      999 		real_iocb_ptr -> position = rdisk_position;
     1000 		real_iocb_ptr -> read_record = rdisk_read;
     1001 		next_key = bounds.low;
     1002 		fill = "101101101"b;		/* Should never be used. */
     1003 	     end;
     1004 
     1005 	else if mode = Sequential_output
     1006 	     then do;
     1007 		if ^write_sw
     1008 		     then call error (error_table_$incompatible_attach,
     1009 			     "sequential_output requires -write control arg.");
     1010 						/* complain if not attached for write */
     1011 		open_descrip.length = 17;
     1012 		open_descrip.descrip = "sequential_output";
     1013 		real_iocb_ptr -> write_record = rdisk_write;
     1014 		next_key = bounds.low;
     1015 		fill = "000100000"b;		/* ASCII space fill last sector when write. */
     1016 	     end;
     1017 
     1018 	else if mode = Sequential_update
     1019 	     then do;
     1020 		if ^write_sw
     1021 		     then call error (error_table_$incompatible_attach,
     1022 			     "sequential_update requires -write control arg.");
     1023 						/* complain if not attached for write */
     1024 		open_descrip.length = 17;
     1025 		open_descrip.descrip = "sequential_update";
     1026 		real_iocb_ptr -> position = rdisk_position;
     1027 		real_iocb_ptr -> read_record = rdisk_read;
     1028 		real_iocb_ptr -> rewrite_record = rdisk_rewrite;
     1029 		next_key = bounds.low;
     1030 		fill = "000100000"b;		/* ASCII space fill last sector when write. */
     1031 	     end;
     1032 
     1033 	else if mode = Direct_input
     1034 	     then do;
     1035 		open_descrip.length = 12;
     1036 		open_descrip.descrip = "direct_input";
     1037 		real_iocb_ptr -> read_record = rdisk_read;
     1038 		real_iocb_ptr -> seek_key = rdisk_seek; /* next_key remains NULL */
     1039 		fill = "110110110"b;		/* Should never be used. */
     1040 	     end;
     1041 
     1042 	else if mode = Direct_update
     1043 	     then do;
     1044 		if ^write_sw
     1045 		     then call error (error_table_$incompatible_attach, "direct_update requires -write control arg.");
     1046 						/* complain if not attached for write */
     1047 		open_descrip.length = 13;
     1048 		open_descrip.descrip = "direct_update";
     1049 		real_iocb_ptr -> read_record = rdisk_read;
     1050 		real_iocb_ptr -> rewrite_record = rdisk_rewrite;
     1051 		real_iocb_ptr -> seek_key = rdisk_seek; /* next_key remains NULL */
     1052 		fill = "000000000"b;		/* Zero fill last sector when write. */
     1053 	     end;
     1054 
     1055 	else do;					/* complain if an invalid opening mode was requested. */
     1056 	     current_mode_name = iox_modes (mode);
     1057 	     call error (error_table_$request_not_recognized, current_mode_name);
     1058 						/* complain if invalid opening mode */
     1059 	end;
     1060 
     1061 
     1062 	if a_ext then call error (error_table_$action_not_performed, "Extension attempt -- not valid for disk.");
     1063 						/* extension is meaningless for rdisk_ */
     1064 
     1065 
     1066 	mask_str = "0"b;				/* initialize ips_ mask */
     1067 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     1068 	call hcs_$set_ips_mask (mask_str, mask_str);
     1069 
     1070 /*  The file is now open.  Set up to allow a close, but not an open or detach. */
     1071 
     1072 	real_iocb_ptr -> close = rdisk_close;
     1073 	real_iocb_ptr -> open, real_iocb_ptr -> detach_iocb = iox_$err_not_closed;
     1074 
     1075 
     1076 	real_iocb_ptr -> open_descrip_ptr = addr (open_descrip);
     1077 						/* fill in IOCB open descrip. pointer */
     1078 
     1079 	call iox_$propagate (iocb_ptr);		/* let iox_ have a turn again */
     1080 
     1081 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     1082 
     1083 	a_code = 0;				/* give successful code */
     1084 	return;					/* auf wiedersehen */
     1085 
     1086 /*  End of OPEN module  */
     1087 /*  */
     1088 /*  Start of SEEK module  */
     1089 
     1090 rdisk_seek:
     1091      entry (a_iocb_ptr, a_key, a_rec_len, a_code);
     1092 
     1093 /*
     1094*   *      S__e_e_k_K__e_y_O__p_e_r_a_t_i_o_n
     1095*
     1096*
     1097*   *           This operation returns a status code of 0 for any key that  is  a
     1098*   *      valid  sector  number.   The  record  length  returned  is  always 256
     1099*   *      (current physical sector size in characters) for any valid  key.   The
     1100*   *      specified key must be a character string that could have been produced
     1101*   *      by  editing  through  a  PL/I picture of "(8)9".
     1102*   *      This operation is supported for only the direct opening modes.
     1103**/
     1104 
     1105 dcl  a_key		       char (256) varying;	/* parameter:   key to seek on  */
     1106 
     1107 	call setup ("open");			/* set up working environment */
     1108 	if mode = Direct_input | mode = Direct_update
     1109 	     then ;
     1110 	     else call error (error_table_$no_record, "seek valid only for direct openings.");
     1111 
     1112 	temp_key = cv_dec_check_ (ltrim (rtrim (a_key)), code);
     1113 	if code ^= 0 then call error (error_table_$no_record, (a_key));
     1114 
     1115 	if (temp_key < bounds.low) | (temp_key > bounds.high)
     1116 	     then call error (error_table_$no_record, "Requested sector outside available area.");
     1117 	     else next_key, current_key = temp_key;	/* key_for_insertion is not changed */
     1118 
     1119 	a_rec_len = 4 * sect_size;			/* return canned rec. len. of sect. size (chars.) */
     1120 	a_code = 0;				/* and good code */
     1121 	return;					/* 'til next time */
     1122 
     1123 /*  End of SEEK module  */
     1124 /*  */
     1125 /* Start of POSITION module */
     1126 
     1127 rdisk_position:
     1128      entry (a_iocb_ptr, a_type, a_quantity, a_code);
     1129 
     1130 /*
     1131*   *	Position Operation
     1132*   *
     1133*   *           This operation is supported for  only  the  sequential and stream modes
     1134*   *	opening modes.  In the stream opening modes only position mtype 2 is
     1135*   supported. The type and quanity values are
     1136*   *      interpreted as follows:
     1137*   *           _t_y_p_e  _q_u_a_n_t_i_t_y  _a_c_t_i_o_n______________________________________
     1138*   *
     1139*   *            -1    --       position to the beginning of the file.
     1140*   *            +1    --       position to the end of the file.
     1141*   *             0    n        skip  n  sectors (forward if n > 0; backward
     1142*   *                               if n < 0).
     1143*   *             2    n        position to sector n.
     1144*   *
     1145*   Abbreviations used in the following table are:
     1146*   b.l     =  bounds.low = sector address of first sector user can write in.
     1147*   b.h     = bounds.high = sector address of last  sector user can write in.
     1148*   R(a,b)  = range from a to b inclusive, i.e.,  ( a <= variable <= b )
     1149*   nk      = next_key
     1150*   qty     = quantity, i.e., the input parameter called quantity in thee above table.
     1151*
     1152*   <--------  If all of these conditions are satisfied  ----->        <-- then do this ---->
     1153*   absolute					set
     1154*   value of					next_key
     1155*   type   next_key  quantity  quantity            nk+qty              equal to  other action
     1156*   ____	________	________	_____________	____________	_________	____________
     1157*
     1158*   -1	--	--	--		--		b.l	--
     1159*
     1160*   +1	--	--	--		--		END	--
     1161*
     1162*   2	--	< b.l	--		--		b.l	error
     1163*
     1164*   2	--	R(b.l,b.h)  --		--		quantity	--
     1165*
     1166*   2	--	> b.h	--		--		END	error
     1167*
     1168*   0	NULL	--	--		--		--	error
     1169*
     1170*   0	R(b.l,b.h)  --	--		R(b.l,b.h)	nk+qty	--
     1171*
     1172*   0	R(b.l,b.h)  --	--		< b.l		b.l	error
     1173*
     1174*   0	R(b.l,b.h)  --	--		> b.h		END	error
     1175*
     1176*   0	END	<= 0	<=(b.h-b.l+1)	--		b.h-qty+1	--
     1177*
     1178*   0	END	> 0	--		--		END	error
     1179*
     1180*   0	END	< 0	>(b.h-b.l+1)	--		b.l	error
     1181*
     1182*   For sequential_update, if no errors occur, current_key = new value of next_key
     1183*   */
     1184 /*  */
     1185 
     1186 dcl  a_type		       fixed bin;		/* type of positioning requested */
     1187 dcl  type			       fixed bin;
     1188 dcl  a_quantity		       fixed bin (21);	/* how far to move the position */
     1189 dcl  quantity		       fixed bin;
     1190 dcl  desired_key		       fixed bin;		/* possible resulting value */
     1191 
     1192 	call setup ("open");			/* set up working environment */
     1193 
     1194 
     1195 	if mode = Direct_update | mode = Direct_input
     1196 	     then call error (error_table_$no_operation,
     1197 		     "Position operation valid only for sequential or stream openings.");
     1198 
     1199 	type = a_type;
     1200 
     1201 	quantity = a_quantity;
     1202 
     1203 	if (type < -1) | (2 < type)
     1204 	     then call error (error_table_$no_operation, "Only legal values for type are -1, 0, +1, and +2");
     1205 
     1206 	if mode = Stream_input | mode = Stream_output | mode = Stream_input_output
     1207 	     then do;
     1208 		if mod (quantity, sect_size * 4) ^= 0
     1209 		     then do;
     1210 			next_key = NULL;
     1211 			call error (error_table_$no_record, "Byte offset specified not at begining of sector");
     1212 		     end;
     1213 
     1214 		quantity = divide (quantity, sect_size * 4, 17, 0);
     1215 	     end;
     1216 
     1217 	if type = -1
     1218 	     then do;				/* position to beginning of the file */
     1219 		next_key = bounds.low;
     1220 	     end;
     1221 
     1222 	else if type = +1
     1223 	     then do;				/* position to end of the file */
     1224 		next_key = END;
     1225 	     end;					/* type = 2 is absolute positioning */
     1226 
     1227 	else if (type = 2) & (quantity < bounds.low)
     1228 	     then do;
     1229 		call error (error_table_$end_of_info, "quantity is before first available sector");
     1230 		next_key = bounds.low;
     1231 	     end;
     1232 
     1233 	else if (type = 2) & (bounds.low <= quantity) & (quantity <= bounds.high)
     1234 	     then do;
     1235 		next_key = quantity;
     1236 	     end;
     1237 
     1238 	else if (type = 2) & (quantity > bounds.high)
     1239 	     then do;
     1240 		call error (error_table_$end_of_info, "quantity is after last available sector");
     1241 		next_key = END;
     1242 	     end;
     1243 
     1244 /* type = 0 is relative positioning */
     1245 	else if (type = 0) & (next_key = NULL)
     1246 	     then call error (error_table_$no_current_record, "Present position is undefined.");
     1247 
     1248 	else if (type = 0) & (next_key ^= NULL) & (next_key ^= END)
     1249 	     then do;
     1250 		desired_key = next_key + quantity;
     1251 		if (bounds.low <= desired_key) & (desired_key <= bounds.high)
     1252 		     then do;
     1253 			next_key = desired_key;
     1254 		     end;
     1255 
     1256 		else if (desired_key < bounds.low)
     1257 		     then do;
     1258 			call error (error_table_$end_of_info,
     1259 			     "Present position plus quantity is before start of the file.");
     1260 			next_key = bounds.low;
     1261 		     end;
     1262 
     1263 		else if (desired_key > bounds.high)
     1264 		     then do;
     1265 			call error (error_table_$end_of_info,
     1266 			     "Present position plus quantity is past end of the file.");
     1267 			next_key = END;
     1268 		     end;
     1269 	     end;
     1270 
     1271 
     1272 /* May be OK to back up from the end of the file */
     1273 
     1274 	else if (type = 0) & (next_key = END) & (quantity <= 0) & (abs (quantity) <= (bounds.high - bounds.low + 1))
     1275 	     then do;
     1276 		next_key = bounds.high + quantity;	/* "+ quantity" (not minus) because quantity is negative, or zero  */
     1277 	     end;
     1278 
     1279 	else if (type = 0) & (next_key = END) & (quantity > 0)
     1280 	     then call error (error_table_$end_of_info, "Were at file end; quantity attempted to move forward.");
     1281 						/* next_key still = END */
     1282 
     1283 
     1284 	else if (type = 0) & (next_key = END) & (quantity < 0) & (abs (quantity) > (bounds.high - bounds.low + 1))
     1285 	     then do;
     1286 		call error (error_table_$end_of_info, "Were at file end; quantity would put you before file.");
     1287 		next_key = bounds.low;
     1288 	     end;
     1289 
     1290 	else call error (error_table_$no_operation, "Should never get to this point.");
     1291 
     1292 
     1293 	if mode = Sequential_update then current_key = next_key;
     1294 	a_code = 0;				/* If we get here, there were no errors. */
     1295 	return;
     1296 
     1297 
     1298 /* End of POSITION module */
     1299 /*  */
     1300 /*  Start of READ and WRITE modules  */
     1301 
     1302 rdisk_read:
     1303      entry (a_iocb_ptr, a_ubuf_ptr, a_ubuf_len, a_rec_len, a_code);
     1304 
     1305 /*
     1306*   *	     If the amount of data to be read does  not  terminate  on  a
     1307*   *	sector  boundary,  the  excess portion of the last sector will be
     1308*   *	discarded.  A zero code will be  returned  in  this  case.
     1309**/
     1310 
     1311 	call setup ("open");			/* set up working environment */
     1312 
     1313 	if mode = Sequential_output | mode = Stream_output
     1314 	     then					/* read OK for all other modes */
     1315 		call error (error_table_$invalid_read, "read not supported for sqo or so.");
     1316 	if next_key = NULL then call error (error_table_$no_record, "next_key must be non-null to read");
     1317 	else if next_key = END
     1318 	     then do;
     1319 		if mode = Sequential_input | mode = Sequential_update
     1320 		     then do;
     1321 			current_key = NULL;
     1322 			call error (error_table_$end_of_info,
     1323 			     "Attempted to read (sqi, squ) past end of available area.");
     1324 		     end;
     1325 		     else do;			/*  mode = either direct_input or direct_update */
     1326 			next_key = NULL;
     1327 			current_key = NULL;
     1328 			call error (error_table_$device_end,
     1329 			     "Attempted to read (di, du) past end of avilable area.");
     1330 		     end;
     1331 	     end;
     1332 	io_command = "read";			/* set switch for read */
     1333 
     1334 
     1335 	if sze ^= 0
     1336 	     then rec_len = min (sze, a_ubuf_len);	/* set appropriate record length */
     1337 	     else rec_len = a_ubuf_len;
     1338 	a_rec_len = 0;
     1339 	key = next_key;				/* set working key value */
     1340 	go to read_write_common;			/* proceed  to common code */
     1341 
     1342 rdisk_rewrite:
     1343      entry (a_iocb_ptr, a_ubuf_ptr, a_rec_len, a_code);
     1344 
     1345 /*
     1346*   *           If the amount of data to be  written  does  not  terminate  on  a
     1347*   *      sector  boundary,  the  remaining portion of the last sector is filled
     1348*   *      with  spaces in  sequential modes and binary zeros in direct modes.  A
     1349*   *      code  of 0  is returned  in  this  case.  This
     1350*   *      operation is supported for only the update opening modes.
     1351**/
     1352 
     1353 	call setup ("open");			/* set up working environment */
     1354 
     1355 	if mode = Sequential_update | mode = Direct_update
     1356 	     then ;
     1357 	     else call error (error_table_$invalid_write, "rewrite valid only for update.");
     1358 
     1359 	if current_key = NULL
     1360 	     then call error (error_table_$no_record, "Attempted to rewrite before the start of the file.");
     1361 	else if current_key = END
     1362 	     then do;
     1363 		next_key = END;
     1364 		call error (error_table_$device_end, "Attempted to rewrite when already at the end of the file.");
     1365 	     end;
     1366 
     1367 	io_command = "rewrite";			/* set switch for rewrite */
     1368 
     1369 
     1370 	rec_len = a_rec_len;			/* set output record length */
     1371 	key = current_key;				/* set working key */
     1372 	go to read_write_common;
     1373 
     1374 rdisk_write:
     1375      entry (a_iocb_ptr, a_ubuf_ptr, a_rec_len, a_code);
     1376 
     1377 
     1378 /*
     1379*   *           If the amount of data to be  written  does  not  terminate  on  a
     1380*   *      sector  boundary,  the  remaining portion of the last sector is filled
     1381*   *      with ASCII spaces.  A code of  0  is  returned  in  this  case.
     1382*   *      This   operation   is   supported  for  only  the
     1383*   *      sequential_output  opening  mode.   A  series  of  writes  will  write
     1384*   *      successive records.
     1385**/
     1386 
     1387 
     1388 	call setup ("open");			/* set up working environment */
     1389 
     1390 	if mode = Sequential_output | mode = Stream_output | mode = Stream_input_output
     1391 	     then ;
     1392 	     else call error (error_table_$invalid_write, "write supported only for sqo, so, and sio.");
     1393 
     1394 	if next_key = END
     1395 	     then do;
     1396 		current_key = NULL;
     1397 		call error (error_table_$device_end, "Already at end of the file.");
     1398 	     end;
     1399 
     1400 	else if next_key = NULL then call error (error_table_$no_record, "Next record designator was NULL.");
     1401 
     1402 	io_command = "write";
     1403 	rec_len = a_rec_len;			/* set output record length */
     1404 	key = next_key;				/* set working key */
     1405 	go to read_write_common;
     1406 
     1407 read_write_common:					/*
     1408*   *           For the sequential_input and sequential_update opening modes,  if
     1409*   *      an attempt is made to read beyond the end of the user-accessible area,
     1410*   *      the   code   error_table_$end_of_info  is  returned  to  the   calling
     1411*   *      program.   For  all other opening modes, if an attempt is made to read
     1412*   *      or write beyond the end of the user-accessible area on disk, the  code
     1413*   *      error_table_$device_end   is   returned.   If  a  defective  track  is
     1414*   *      encountered or if any other unrecoverable data transmission  error  is
     1415*   *      encountered, the code error_table_$device_parity is returned.
     1416*   *
     1417*   *           The  record length is specified through the buff_len parameter in
     1418*   *      the read_record operation, and through the rec_len parameter  for  the
     1419*   *      write  and  rewrite  operations,  unless overridden by a -size control
     1420*   *      argument in the attach description, or by a setsize control order.
     1421**/
     1422 dcl  sectors_for_record	       fixed bin;		/* Qty. of sectors necessary to hold the record to be written */
     1423 dcl  potential_next_sector	       fixed bin (21);	/* Tentative address of sector immediately following the last */
     1424 						/* sector this record will occupy if this is a write. */
     1425 
     1426 	sectors_for_record = ceil (rec_len / (4 * sect_size));
     1427 
     1428 	potential_next_sector = key + sectors_for_record;
     1429 
     1430 	if key = NULL
     1431 	     then do;				/* if he didn't do a seek */
     1432 		code = error_table_$no_record;	/* complain */
     1433 		call io_err ("0"b);
     1434 	     end;
     1435 
     1436 	if (io_command = "write") | (io_command = "rewrite")
     1437 	     then if potential_next_sector > bounds.high + 1
     1438 		     then call error (error_table_$no_operation, "Record will not fit in space left on disk.");
     1439 
     1440 	tot_rec_len = 0;				/* init total records counter */
     1441 	ubuf_ptr = a_ubuf_ptr;			/* grab pointer to user buffer */
     1442 	cont_sw = "0"b;				/* reset control switch if set */
     1443 	track_indicators = "00"b;			/* reset ti bits if set */
     1444 	if rec_len > 4 * (floor ((max_buff_size - overhead) / sect_size) * sect_size)
     1445 	     then do;				/* if record longer than maximum ioi_ buffer size */
     1446 
     1447 		if buf_len < max_buff_size
     1448 		     then do;			/* if current ioi_ buffer len. < max. */
     1449 			call ioi_$workspace (devx, buf_ptr, max_buff_size, code);
     1450 						/* grow it to max size */
     1451 			if code ^= 0 then call io_err ("1"b);
     1452 						/* no luck */
     1453 			buf_len = max_buff_size;	/* set current length */
     1454 			data_len = buf_len - overhead;/* set data area length */
     1455 		     end;
     1456 
     1457 		block_len = ceil (ceil (data_len / 4) / sect_size) * sect_size;
     1458 						/* set I/O block size */
     1459 		block_ptr = ubuf_ptr;		/* initialize block pointer */
     1460 		data_left = rec_len;		/* initialize amount of data left to xmit */
     1461 
     1462 		do while (data_left > 0);		/*  perform the I/O one block at a time */
     1463 		     call do_io;			/* do the  I/O */
     1464 		     block_ptr = addrel (block_ptr, block_len);
     1465 						/* set pointer for next block */
     1466 		     tot_rec_len = tot_rec_len + rec_len;
     1467 						/* remember total records */
     1468 		     data_left = data_left - block_len * 4;
     1469 						/* decrement data left to xmit */
     1470 		     key = key + fixed (block_len / sect_size, 21);
     1471 						/* increment the working key */
     1472 		     end;
     1473 
     1474 	     end;
     1475 
     1476 	     else do;				/*   record will fit within max-sized ioi_ buffer */
     1477 
     1478 		if rec_len > 4 * floor (data_len / sect_size) * sect_size
     1479 		     then do;			/*  if record longer than current ioi_ buffer size */
     1480 
     1481 			data_len = max (1024 - overhead, ceil (ceil (rec_len / 4) / sect_size) * sect_size);
     1482 			buf_len = data_len + overhead;/* tell ioi_ how much space we need */
     1483 			call ioi_$workspace (devx, buf_ptr, buf_len, code);
     1484 						/* grow the buffer */
     1485 			if code ^= 0 then call io_err ("1"b);
     1486 						/* can't win all the time */
     1487 
     1488 		     end;
     1489 
     1490 		block_ptr = ubuf_ptr;		/* initialize block pointer */
     1491 		block_len = ceil (ceil (rec_len / 4) / sect_size) * sect_size;
     1492 						/* and block length */
     1493 		data_left = rec_len;		/* and data left to xmit */
     1494 		call do_io;			/* go do the I/O  (only one block this time) */
     1495 
     1496 	     end;
     1497 
     1498 
     1499 io_succeeded:					/* 			PATH 1 */
     1500 	if io_command = "read"
     1501 	     then do;
     1502 
     1503 		current_key = next_key;
     1504 		if tot_rec_len = 0
     1505 		     then a_rec_len = rec_len;	/* Send back length of data actually read. */
     1506 		     else a_rec_len = tot_rec_len;	/* ditto */
     1507 
     1508 /* 			PATH 1a */
     1509 
     1510 		if potential_next_sector < bounds.high + 1
     1511 		     then do;			/* Record will _n_o_t reach end of available area. */
     1512 
     1513 /* 			PATH 1a1 */
     1514 
     1515 			if mode = Direct_input | mode = Direct_update
     1516 			     then next_key = NULL;
     1517 
     1518 /* 			PATH 1a2 */
     1519 
     1520 			     else next_key = next_key + sectors_for_record;
     1521 		     end;
     1522 
     1523 /* 			PATH 1b */
     1524 
     1525 		     else do;			/* potential_next_sector = bounds.high + 1 */
     1526 						/* Record _w_i_l_l reach end of available area. */
     1527 
     1528 /* 			PATH 1b1 */
     1529 
     1530 			if mode = Direct_input | mode = Direct_update
     1531 			     then next_key = NULL;
     1532 
     1533 /* 			PATH 1b2 */
     1534 
     1535 			     else next_key = END;
     1536 
     1537 		     end;
     1538 
     1539 	     end;
     1540 
     1541 
     1542 /* 			PATH 2 */
     1543 
     1544 	else if io_command = "rewrite"
     1545 	     then do;				/* No change to  current_key  */
     1546 
     1547 /* 			PATH 2a */
     1548 
     1549 		if mode = Sequential_update
     1550 		     then				/* 			PATH 2a1 */
     1551 			if potential_next_sector < bounds.high + 1
     1552 			     then			/* Record will _n_o_t reach end of available area. */
     1553 				next_key = current_key + sectors_for_record;
     1554 
     1555 /* 			PATH 2a2 */
     1556 
     1557 			     else next_key = END;	/* potential_next_sector = bounds.high + 1 */
     1558 						/* Record _w_i_l_l reach end of available area. */
     1559 
     1560 /* 			PATH 2b */
     1561 
     1562 		     else next_key = NULL;		/* mode = direct_update */
     1563 
     1564 	     end;
     1565 
     1566 /* 			PATH 3 */
     1567 
     1568 	else if io_command = "write"
     1569 	     then do;
     1570 
     1571 		current_key = NULL;
     1572 
     1573 /* 			PATH 3a */
     1574 
     1575 		if potential_next_sector < bounds.high + 1
     1576 		     then				/* Record will _n_o_t reach end of available area. */
     1577 			next_key = next_key + sectors_for_record;
     1578 
     1579 /* 			PATH 3b */
     1580 
     1581 		     else next_key = END;		/* potential_next_sector = bounds.high + 1 */
     1582 						/* Record _w_i_l_l reach end of available area. */
     1583 
     1584 	     end;
     1585 
     1586 /* Do this every time, for any case */
     1587 
     1588 	a_code = 0;				/* give good  code */
     1589 	return;					/* come again, sometime */
     1590 
     1591 /*  */
     1592 
     1593 /*  Internal Procedure to  reset certain fields after the occurrence of an I/O error  */
     1594 
     1595 io_err:
     1596      proc (clear_space);
     1597 
     1598 dcl  clear_space		       bit (1);		/*  flag to tell us to zap ioi_ workspace */
     1599 
     1600 	if clear_space
     1601 	     then do;				/* if space  no good */
     1602 		buf_ptr = null;			/* zap it!! */
     1603 		buf_len, data_len = 0;
     1604 	     end;
     1605 
     1606 	call error (code, "");			/* let user know */
     1607 
     1608      end io_err;
     1609 
     1610 /*  */
     1611 
     1612 /*  Internal procedure to actually perform I/O  */
     1613 
     1614 do_io:
     1615      proc;
     1616 
     1617 dcl  (true_len, data_read)	       fixed bin (35);	/* internal data  manipulation variables */
     1618 dcl  sector_offset		       fixed bin;		/* used for subvolumes */
     1619 	true_len = min (4 * block_len, data_left);	/* set true amount to xmit */
     1620 
     1621 
     1622 /* If we are going to write onto the disk, fill in unused area at end of the disk sector
     1623*   with zeros for direct opening modes
     1624*   or with ASCII spaces for sequential opening modes. */
     1625 /*  and fill in unused space with zeros */
     1626 
     1627 	if io_command ^= "read" & ^cont_sw
     1628 	     then do;				/* if an output command and not  format */
     1629 
     1630 		substr (data, 1, true_len) = substr (block, 1, true_len);
     1631 						/* move data to ioi_ buffer */
     1632 		if true_len < 4 * block_len
     1633 		     then unspec (substr (data, true_len + 1, 4 * block_len - true_len)) = fill;
     1634 	     end;
     1635 
     1636 	idcwp = addr (sk_idcw);			/* get pointer to  seek IDCW */
     1637 	idcw = seek_idcw_template;			/* move in template seek IDCW */
     1638 	idcw.device = bit (drive);			/* set drive no. */
     1639 	count_limit_fixed = ceil (block_len / sect_size); /* and sector  count limit  in seek data */
     1640 
     1641 	if key <= last_sect_num (dev_type)		/* in the data region */
     1642 	     then goto BUILD_NORMAL_SEEK;
     1643 	else if key <= last_alt_sect_num (dev_type)	/* in the alternate region */
     1644 	     then goto BUILD_ALT_SEEK (device_group);
     1645 	else goto BUILD_TANDD_SEEK (device_group);	/* must be T&D region */
     1646 
     1647 
     1648 BUILD_TANDD_SEEK (1):				/* T&D region on MSU04XX device */
     1649 	idcw.command = SPECIAL_SEEK;			/* seek cmd = spiecial seek */
     1650 
     1651 BUILD_ALT_SEEK (1):					/* Alternate track region on MSU04XX device */
     1652 BUILD_NORMAL_SEEK:
     1653 	idcw.command = seek_command (dev_type);
     1654 	unspec (seek) = "0"b;
     1655 	seek.block_count_limit = count_limit_fixed;
     1656 	seek.ti = track_indicators;
     1657 	if is_sv
     1658 	     then do;				/* convert the key to real sector */
     1659 		sector_offset = mod (key, sect_per_cyl (dev_type));
     1660 		seek.sector =
     1661 		     ((key - sector_offset) * number_of_sv (dev_type)) + (sv_num * sect_per_cyl (dev_type))
     1662 		     + sector_offset;
     1663 	     end;
     1664 	     else seek.sector = key;
     1665 	unspec (seek_data) = unspec (seek);
     1666 	goto SEEK_BUILT;
     1667 
     1668 
     1669 BUILD_ALT_SEEK (2):					/* Alternate track region on MSU0500/1 device */
     1670 BUILD_TANDD_SEEK (2):				/* T&D region on MSU0500/1 device */
     1671 	idcw.command = SPECIAL_SEEK;
     1672 
     1673 
     1674 BUILD_SUPER_SEEK:
     1675 	unspec (super_seek) = "0"b;
     1676 	super_seek.sector_number = mod (key, sect_per_track (dev_type));
     1677 	super_seek.ti = track_indicators;
     1678 	super_seek.is_super_seek = "1"b;
     1679 	super_seek.flag = "1"b;			/* ON => sector number in 0-12 rather than block count limit */
     1680 	cyl = divide (key, sect_per_cyl (dev_type), 16, 0);
     1681 	head = mod (key, sect_per_cyl (dev_type));
     1682 	head = divide (head, sect_per_track (dev_type), 16, 0) * 2 + mod (cyl, 2);
     1683 	if mod (cyl, 2) = mod (drive, 2)
     1684 	     then					/* see EPS for details of this crock */
     1685 		if mod (cyl, 2) = 0
     1686 		     then cyl = cyl + 1;
     1687 		     else cyl = cyl - 1;
     1688 	super_seek.cyl_lower = mod (cyl, 256);
     1689 	super_seek.cyl_upper = divide (cyl, 256, 2, 0);
     1690 	super_seek.head = head;
     1691 	unspec (seek_data) = unspec (super_seek);
     1692 	goto SEEK_BUILT;
     1693 
     1694 
     1695 
     1696 
     1697 BUILD_ALT_SEEK (3):					/* Alternate track region on MSU0509 device */
     1698 BUILD_TANDD_SEEK (3):				/* T&D region on MSU0509 device */
     1699 	idcw.command = SPECIAL_SEEK_512;
     1700 	goto BUILD_SUPER_SEEK;
     1701 
     1702 
     1703 SEEK_BUILT:					/* Seek command and data are ready */
     1704 	dcwp = addr (sk_dcw);			/* get pointer to seek DCW */
     1705 	dcw = seek_dcw_template;			/* put in canned value */
     1706 	dcw.address = rel (addr (seek_data));		/* fill in data address */
     1707 
     1708 	idcwp = addr (rw_idcw);			/* get pointer to read/write IDCW */
     1709 	if cont_sw
     1710 	     then do;				/* if format trk or rd trk header */
     1711 		idcw = control_idcw_template;
     1712 		idcw.command = control_command;
     1713 	     end;
     1714 	else if (io_command = "read") then idcw = read_idcw_template;
     1715 						/* if read, put in canned read value */
     1716 	else if compare_sw then idcw = write_and_compare_idcw_template;
     1717 						/*  put in compare comd. if in that mode */
     1718 	else idcw = write_idcw_template;		/* put in canned write value */
     1719 	idcw.device = bit (drive);			/*  fill in drive number */
     1720 
     1721 	dcw_address = bin (rel (addr (data)));		/* Beginning of data */
     1722 	rw_length = block_len;			/* Length of data */
     1723 	do dcwx = 1 by 1 while (rw_length > 0);		/* Build each DCW */
     1724 	     dcwp = addr (rw_dcw (dcwx));		/* point to next dcw */
     1725 	     dcw = read_write_dcw_template;		/* IOTP */
     1726 	     dcw.address = bit (bin (dcw_address, 18), 18);
     1727 	     if rw_length >= MAX_DCW_TALLY
     1728 		then dcw.tally = bit (bin (MAX_DCW_TALLY, 12), 12);
     1729 		else dcw.tally = bit (bin (rw_length, 12), 12);
     1730 	     dcw_address = dcw_address + MAX_DCW_TALLY;
     1731 	     rw_length = rw_length - MAX_DCW_TALLY;
     1732 	     end;
     1733 
     1734 	dcw.type = IOTD;
     1735 
     1736 	dcw_offset = fixed (rel (addr (sk_idcw)));	/* set offset for ioi_ */
     1737 
     1738 	again = "1"b;				/* so we do it at least once */
     1739 	err_ct = 0;				/* init. error count */
     1740 
     1741 	do while (again);				/* I/O loop */
     1742 
     1743 	     completion.st = "0"b;			/* initialize status entry */
     1744 	     completion.run = "1"b;
     1745 
     1746 	     call ioi_$connect (devx, dcw_offset, code);	/* Start I/O */
     1747 	     if code ^= 0 then call io_err ("0"b);	/* didn't get away from the starting line */
     1748 
     1749 	     do while (^completion.st & completion.run);	/* while connected and no status */
     1750 
     1751 		call ipc_$block (addr (wait_list), addr (event_info), code);
     1752 						/* wait for completion */
     1753 		if code ^= 0 then call io_err ("0"b);	/* No loiterers?? */
     1754 
     1755 		end;
     1756 
     1757 	     again = "0"b;				/* set for no retry */
     1758 
     1759 	     if completion.time_out | ^(completion.st | completion.er | completion.run | completion.time_out)
     1760 						/* if nothing */
     1761 		then call retry;			/* try again */
     1762 
     1763 	     else if level <= 1 then call perm_err;	/* if fault */
     1764 
     1765 	     else if level > 3 then call retry;		/* if special or marker */
     1766 
     1767 	     else if status.maj = ATTENTION
     1768 		then if status.sub & STANDBY
     1769 			then call delay_retry;	/* other MPC may have control */
     1770 			else call loud_retry;	/* just plain attention, let user know */
     1771 
     1772 	     else if status.maj = EOF
     1773 		then if (status.sub & LAST_BLOCK_MASK = LAST_BLOCK)
     1774 			then do;			/* if we've run off end of the pack */
     1775 			     if (io_command = "read")
     1776 				then do;		/* and we were reading */
     1777 				     data_read = min (true_len, (block_len - fixed (status.residue) - 1) * 4);
     1778 						/* amount read */
     1779 				     substr (block, 1, data_read) = substr (data, 1, data_read);
     1780 						/* give user what we can */
     1781 				     a_rec_len, rec_len = rec_len - data_left + data_read;
     1782 						/* and tell him how much */
     1783 				     unspec (substr (block, rec_len + 1, data_left - data_read)) = fill;
     1784 						/* spaces for sequential; zeros for direct */
     1785 				end;
     1786 
     1787 
     1788 			     if (mode = Sequential_input) | (mode = Sequential_update)
     1789 				then code = error_table_$end_of_info;
     1790 				else code = error_table_$device_end;
     1791 						/* all other modes */
     1792 
     1793 
     1794 			     call io_err ("0"b);	/* tell user */
     1795 			end;
     1796 		     else if ((status.sub & TI_MASK) ^= "00"b3) & cont_sw & (io_command = "read") then ;
     1797 		     else call perm_err;		/* any other EOF is bad news */
     1798 
     1799 	     else if status.maj ^= "0000"b then call retry;
     1800 						/* don't beat a dead horse */
     1801 
     1802 	     end;
     1803 
     1804 	if (io_command = "read") & ^cont_sw
     1805 	     then do;				/* if normal read command */
     1806 		substr (block, 1, true_len) = substr (data, 1, true_len);
     1807 						/* give the user his data */
     1808 		rec_len = true_len;			/* Send back length of data actually read. */
     1809 	     end;
     1810 
     1811 	if (io_command = "read") & cont_sw
     1812 	     then substr (info_block, 1, 4 * (block_len - fixed (status.residue))) =
     1813 		     substr (data, 1, 4 * (block_len - fixed (status.residue)));
     1814 						/* if rd trk header command */
     1815 
     1816      end do_io;
     1817 
     1818 /*  */
     1819 
     1820 /*  Internal procedure to retry I/O  */
     1821 
     1822 retry:
     1823      proc;
     1824 
     1825 	if status.maj ^= ATTENTION then err_ct = err_ct + 1;
     1826 						/* don't keep track of attentions */
     1827 
     1828 	if err_ct <= max_retries
     1829 	     then do;				/* is it worth while? */
     1830 		idcwp = addr (rst_idcw);		/* yes, get pointer to restore IDCW */
     1831 		idcw = restore_idcw_template;		/* put in canned restore value */
     1832 		idcw.device = bit (drive);		/* fill in drive no. */
     1833 		dcw_offset = fixed (rel (addr (rst_idcw)));
     1834 						/* set up offset for ioi_ */
     1835 		again = "1"b;			/* and set flag to try again */
     1836 	     end;
     1837 	     else call perm_err;			/* our patience has worn thin */
     1838 
     1839      end retry;
     1840 
     1841 /*  */
     1842 
     1843 /*  Internal procedure to handle ATTENTION status with STANDBY sub-status.  */
     1844 
     1845 delay_retry:
     1846      proc;
     1847 
     1848 /*  Have been told that this status occurs in dual-MPC configurations
     1849*   if the other MPC has the device.  This procedure merely delays for a
     1850*   short time, and then retries.  */
     1851 
     1852 	err_ct = err_ct + 1;			/* keep track of how often we do this */
     1853 
     1854 	if err_ct >= max_retries
     1855 	     then do;				/* if too often */
     1856 		err_ct = 0;			/* reset error count */
     1857 		call loud_retry;			/* let user decide what to do */
     1858 	     end;
     1859 	     else do;
     1860 		call timer_manager_$sleep (500000, "10"b);
     1861 						/* delay for 1/2 sec.  */
     1862 		call retry;			/* and try again */
     1863 	     end;
     1864 
     1865      end delay_retry;
     1866 
     1867 /*  */
     1868 
     1869 /*  Internal procedure to handle ATTENTION status (non-STANDBY)  */
     1870 
     1871 loud_retry:
     1872      proc;
     1873 
     1874 /*  This really should go to the operator's console.  */
     1875 
     1876 	call command_query_ (addr (query_info), answer, "rdisk_",
     1877 	     "Your disk drive (No. ^d) needs attention.  Please have the operator
     1878 check it out and reply appropriately _a_f_t_e_r the device has been checked.
     1879 
     1880 Do you wish to retry?", drive);
     1881 
     1882 	if answer = "yes"
     1883 	     then call retry;
     1884 	     else call perm_err;			/* your wish is my command */
     1885 
     1886      end loud_retry;
     1887 
     1888 /*  */
     1889 
     1890 
     1891 /*  Internal procedure to handle permanent I/O errors  */
     1892 
     1893 perm_err:
     1894      proc;
     1895 
     1896 /*  This procedure obtains the detailed device status, and dumps all available
     1897*   status information to the user terminal.  It would be nice if this info could
     1898*   be  put out on the operator's console, but there is currently no way for
     1899*   a normal user's process to put it there.  */
     1900 
     1901 dcl  based_rsr_data		       (9) bit (8) unal based (addr (buffer.control_info.rsr_data));
     1902 dcl  found		       bit (1) aligned;
     1903 
     1904 	call ioi_$get_detailed_status (devx, found, buffer.control_info.rsr_data, code);
     1905 
     1906 	idcwp = addrel (buf_ptr, offset);		/* look at the offending DCW chain */
     1907 	do while (idcw.code ^= "111"b & fixed (rel (idcwp)) > 0);
     1908 						/* look for IDCW or beginning of seg */
     1909 	     idcwp = addrel (idcwp, -1);		/* back track */
     1910 	     end;
     1911 	dcwp = addrel (idcwp, 1);			/* set to corresponding DCW */
     1912 
     1913 	disk_info_ptr = addr (rcp_data);		/* initialize pointer first */
     1914 	call sub_err_ (0, "rdisk_", "c", null, retval,
     1915 	     "Unrecoverable error on ^a device ^a, sector ^o (^d.).^/IOM Status:^-^w ^w^/IDCW/DCW Pair:^-^w ^w",
     1916 	     device_names (dev_type), disk_info.device_name, key, key, substr (string (status), 1, 36),
     1917 	     substr (string (status), 37, 36), idcw, dcw);
     1918 
     1919 	if found then call ioa_$ioa_stream ("error_output", "Detailed Device Status: ^( ^2.4b^) (hex)", based_rsr_data);
     1920 
     1921 	errors = errors + 1;			/* increment pack  error count */
     1922 
     1923 	code = error_table_$device_parity;		/* tell user about his misfortune */
     1924 	goto exit;
     1925 
     1926      end perm_err;
     1927 
     1928 /*  */
     1929 
     1930 /*  Start of CONTROL module  */
     1931 
     1932 rdisk_control:
     1933      entry (a_iocb_ptr, order, a_info_ptr, a_code);
     1934 
     1935 /*
     1936*   *	     The  following  orders  are supported when the I/O switch is
     1937*   *	open, except for getbounds, which is supported while  the  switch
     1938*   *	is attached.
     1939*   *
     1940*   *		changepack          causes  the  current  pack  to   be
     1941*   *				dismounted  and  another pack to be
     1942*   *				mounted in its place.  The info_ptr
     1943*   *				should point to a varying character
     1944*   *				string (maximum of  32  characters)
     1945*   *				containing  the  identifier  of the
     1946*   *				pack  to be mounted.
     1947*   *
     1948*   *		getbounds           causes  the  lowest   and   highest
     1949*   *				sector  numbers  accessible  by the
     1950*   *				caller under the current  modes  to
     1951*   *				be  returned.   The info_ptr should
     1952*   *				point  to  a  structure  like   the
     1953*   *				following:
     1954*   *
     1955*   *				dcl 1 bounds,
     1956*   *				      2  low fixed bin (35),
     1957*   *				      2  high fixed bin (35);
     1958*   *
     1959*   *		setsize             causes the value of the record size
     1960*   *				override setting to be reset.   The
     1961*   *				info_ptr  should  point  to a fixed
     1962*   *				bin(35) quantity containing the new
     1963*   *				override value.
     1964*   *
     1965*   *		device_info         causes  information  pertaining  to
     1966*   *				the  attached  disk  device  to  be
     1967*   *				returned to the user.  The info_ptr
     1968*   *				should point to a structure of  the
     1969*   *				following form:
     1970*   *
     1971*   *				dcl 1 device_info_table aligned,
     1972*   *				    2 dev_type char (4),
     1973*   *				    2 device_name char (8),
     1974*   *				    2 sect_per_dev fixed bin (35),
     1975*   *				    2 cyl_per_dev fixed bin,
     1976*   *				    2 sect_per_cyl fixed bin,
     1977*   *				    2 sect_per_track fixed bin,
     1978*   *				    2 num_label_sect fixed bin,
     1979*   *				    2 num_alt_sect fixed bin,
     1980*   *				    2 sect_size fixed bin (12);
     1981*   *
     1982*   *				where:
     1983*   *
     1984*   *				1. subsystem_name  is the  name  of
     1985*   *				   the  Disk subsystem in use (i.e.
     1986*   *				   "D191").
     1987*   *
     1988*   *				2. device_name  is the  name of the
     1989*   *				   disk   device   in   use   (i.e.
     1990*   *				   "disk_04").
     1991*   *
     1992*   *				3. sect_per_dev    is   the   total
     1993*   *				   number of non-T&D sectors on the
     1994*   *				   disk pack.
     1995*   *
     1996*   *				4. cyl_per_dev  is the total number
     1997*   *				   of non-T&D cylinders on the disk
     1998*   *				   pack.
     1999*   *
     2000*   *				5. sect_per_cyl  is the  number  of
     2001*   *				   data  sectors   on each cylinder
     2002*   *				   of a disk pack.
     2003*   *
     2004*   *				6. sect_per_track  is the number of
     2005*   *				   data sectors on each track.
     2006*   *
     2007*   *				7. num_label_sect  is the number of
     2008*   *				   data  sectors  to  reserve   for
     2009*   *				   label information.
     2010*   *
     2011*   *				8. num_alt_sect  is the  number  of
     2012*   *				   data   sectors  to  reserve  for
     2013*   *				   alternate  track area.
     2014*   *
     2015*   *				9. sect_size  is the number  of  36
     2016*   *				   bit  words  in each data sector.
     2017*   *
     2018*   *		format_trk          causes a format track command to be
     2019*   *				issued  to  the  track   that   was
     2020*   *				indicated  by a preceeding seek_key
     2021*   *				operation.   The  info_ptr   should
     2022*   *				point  to a user supplied structure
     2023*   *				of the following form:
     2024*   *
     2025*   *				dcl 1 format_trk_info aligned,
     2026*   *				   (2 hz bit (2),
     2027*   *				    2 ti bit (2),
     2028*   *				    2 adcyl fixed bin (16),
     2029*   *				    2 adhd fixed bin (16)) unal;
     2030*   *
     2031*   *				where:
     2032*   *
     2033*   *				1. hz is a bit  pattern  indicating
     2034*   *				   the  state  of the header bypass
     2035*   *				   switch. The hz bits are  defined
     2036*   *				   as follows:
     2037*   *
     2038*   *				      h z   bit pattern meaning
     2039*   *				      0 0   format  home   address
     2040*   *				            and all data records
     2041*   *				      0 1   verify  home   address
     2042*   *				            and record one, format
     2043*   *				            home  address  and all
     2044*   *				            data records
     2045*   *				      1 0   skip   home   address,
     2046*   *				            format     all    data
     2047*   *				            records
     2048*   *				      1 1   verify  home   address
     2049*   *				            and  data  record one,
     2050*   *				            skip home address  and
     2051*   *				            format    all     data
     2052*   *				            records
     2053*   *
     2054*   *				2. ti is a bit  pattern  indicating
     2055*   *				   the state of the track indicator
     2056*   *				   bits. The ti bits are defined as
     2057*   *				   follows:
     2058*   *
     2059*   *				      t i   bit pattern meaning
     2060*   *				      0 0   format trk good
     2061*   *				      0 1   format trk alternate
     2062*   *				      1 0   format  trk  defective
     2063*   *				            with   alternate   trk
     2064*   *				            assigned
     2065*   *				      1 1   format  trk  defective
     2066*   *				            with  no alternate trk
     2067*   *				            assigned
     2068*   *
     2069*   *				3. adcyl and adhd are the alternate
     2070*   *				   or defective cylinder  and  head
     2071*   *
     2072*   *				   numbers  used  when   the  track
     2073*   *				   indicator bits  equal  "01"b  or
     2074*   *				   "10"b.   These  two  fields  are
     2075*   *				   defined as follows:
     2076*   *
     2077*   *				   If the track indicator bits  are
     2078*   *				   set  to  "01"b  (alternate trk),
     2079*   *				   then adcyl and adhd   should  be
     2080*   *				   equal  to the defective cylinder
     2081*   *				   and head number  for  which  the
     2082*   *				   alternate    track    is   being
     2083*   *				   formatted.
     2084*   *
     2085*   *				   If the track indicator bits  are
     2086*   *				   set  to  "10"b  (defective  with
     2087*   *				   alternate assigned), then  adcyl
     2088*   *				   and  adhd should be equal to the
     2089*   *				   cylinder and head number of  the
     2090*   *				   alternate track.
     2091*   *
     2092*   *		rd_trk_header       causes a read track header  command
     2093*   *				to  be issued to the track that was
     2094*   *				indicated by a preceeding  seek_key
     2095*   *				operation.  The  raw  track  header
     2096*   *				information is passed  to the  user
     2097*   *				in   a  structure  (pointed  to  by
     2098*   *				info_ptr) of the following form:
     2099*   *
     2100*   *				dcl 1 trk_header_info aligned,
     2101*   *				   (2 ha_cyl bit (16),
     2102*   *				    2 ha_head bit (16),
     2103*   *				    2 pad1 bit (2),
     2104*   *				    2 ha_ti bit (2),
     2105*   *				    2 pad2 bit (10),
     2106*   *				    2 rcd_0_ti bit (2),
     2107*   *				    2 rcd_0_cyl bit (16),
     2108*   *				    2 rcd_0_head bit (16),
     2109*   *				    2 rcd_0_rn bit (8),
     2110*   *				    2 pad3 bit (24),
     2111*   *				    2 rcd_0_data (8), bit (8),
     2112*   *				    2 pad4 bit (4)) unaligned;
     2113*   *
     2114*   *				where:
     2115*   *
     2116*   *				1. ha_cyl is  the  cylinder  number
     2117*   *				   read   from   the   track   home
     2118*   *				   address.
     2119*   *
     2120*   *				2. ha_head is the head number  read
     2121*   *				   from the track home address.
     2122*   *
     2123*   *				3. ha_ti  is  the  track  indicator
     2124*   *				   bits    (defined  above  in  the
     2125*   *				   format_trk order)  read from the
     2126*   *				   track home address.
     2127*   *
     2128*   *				4. rcd_0_ti is the track  indicator
     2129*   *				   bits  read  from record zero. If
     2130*   *				   the ha_ti bits  indicate  "10"b,
     2131*   *				   then rcd_0_ti should equal "01"b
     2132*   *				   for  alternate track.  If  ha_ti
     2133*   *				   indicates "01"b,  then  rcd_0_ti
     2134*   *				   should equal "10"b for defective
     2135*   *				   track.   Otherwise rcd_0_ti will
     2136*   *				   equal ha_ti.
     2137*   *
     2138*   *				5. rcd_0_cyl and rcd_0_head are the
     2139*   *				   cylinder and  head  number  read
     2140*   *				   from   record  zero.   If  ha_ti
     2141*   *				   indicates "10"b, then  rcd_0_cyl
     2142*   *				   and  rcd_0_head  will  equal the
     2143*   *				   cylinder and head number of  the
     2144*   *				   alternate    track.   If   ha_ti
     2145*   *				   indicates "01"b, then  rcd_0_cyl
     2146*   *				   and  rcd_0_head will contain the
     2147*   *				   cylinder and head number of  the
     2148*   *				   defective    track.    Otherwise
     2149*   *				   rcd_0_cyl  and  rcd_0_head  will
     2150*   *				   equal ha_cyl and ha_head.
     2151*   *
     2152*   *				6. rcd_0_rn is  the  record  number
     2153*   *				   for record zero (normally  equal
     2154*   *				   to zero).
     2155*   *
     2156*   *				7. rcd_0_data  is  the  eight  data
     2157*   *				   bytes  in  record  zero  (not  a
     2158*   *				   normal  data  record)  and  will
     2159*   *				   normally be equal to zero.
     2160*   *
     2161*   *				8. padn are unused bits which  will
     2162*   *				   be returned as "0"b.
     2163**/
     2164 
     2165 dcl  order		       char (*);		/* parameter: the control order */
     2166 dcl  a_info_ptr		       ptr;		/* parameter:  pointer to supplemental information */
     2167 
     2168 	call setup ("don't_care");			/* set up working environment */
     2169 	if order = "io_call"
     2170 	     then do;				/* special order for io_call command */
     2171 		call io_call_order;
     2172 		a_code = code;
     2173 		return;
     2174 	     end;
     2175 	if order ^= "getbounds"
     2176 	     then if real_iocb_ptr -> open_descrip_ptr = null
     2177 		     then call error (error_table_$not_open, "Only getbounds is allowed when file is not open.");
     2178 	info_ptr = a_info_ptr;			/* grab pointer to additional info */
     2179 
     2180 	if (order = "changepack") & media_removable (dev_type)
     2181 	     then do;				/* process the "changepack" order */
     2182 		call rcp_$detach (rcp_id, (RETAIN), errors, "", code);
     2183 						/* dismount current pack */
     2184 		if code ^= 0 then call error (code, "");/* didn't work too well */
     2185 		pack_id = new_pack_id;		/* pick up new pack id. */
     2186 		call mount ();			/* mount it */
     2187 		if code ^= 0 then call error (code, "");/* it's hard for a little pack to get on a big drive */
     2188 
     2189 		new_length = index (pack_id, " ") - 1;	/* get length of  the new pack id string */
     2190 		old_length = index (substr (attach_descrip.descrip, 13), " ") - 1;
     2191 						/* and see how long the old one was */
     2192 		if new_length = old_length
     2193 		     then				/* if the same, just overlay the old one in the att. desc. */
     2194 			substr (attach_descrip.descrip, 13, old_length) = substr (pack_id, 1, new_length);
     2195 		     else do;			/* otherwise, we have to do some juggling  */
     2196 			old_descrip = attach_descrip.descrip;
     2197 						/* put the old one in a temp area */
     2198 			attach_descrip.descrip = substr (old_descrip, 1, 12) || substr (pack_id, 1, new_length)
     2199 						/* and build */
     2200 			     || substr (old_descrip, 13 + old_length, attach_descrip.length - old_length - 12);
     2201 						/* the new one */
     2202 			attach_descrip.length = attach_descrip.length + new_length - old_length;
     2203 						/* adjust the length */
     2204 		     end;
     2205 	     end;					/*  changepack  */
     2206 
     2207 	else if order = "getbounds"
     2208 	     then do;				/* process the "getbounds" order */
     2209 		user_bounds.low = bounds.low;		/* pass back the low bound */
     2210 		user_bounds.high = bounds.high;	/* and the high bound */
     2211 	     end;					/*  getbounds  */
     2212 
     2213 	else if order = "setsize" then sze = new_size;	/*  The "setsize" order is easy * */
     2214 
     2215 	else if order = "disk_info"
     2216 	     then do;				/* process the disk_info order */
     2217 		disk_info_ptr = addr (rcp_data);
     2218 		if info_ptr -> disk_info.version_num ^= disk_info.version_num
     2219 		     then do;
     2220 			a_code = error_table_$unimplemented_version;
     2221 			return;
     2222 		     end;
     2223 		info_ptr -> disk_info = disk_info;
     2224 	     end;
     2225 
     2226 	else if order = "device_info"
     2227 	     then do;				/* process the device_info order */
     2228 		disk_info_ptr = addr (rcp_data);	/* initialize pointer first */
     2229 		user_dev_char_table.user_subsystem_name = device_names (dev_type);
     2230 		user_dev_char_table.user_device_name = disk_info.device_name;
     2231 		user_dev_char_table.user_sect_per_dev = sect_per_dev;
     2232 		user_dev_char_table.user_cyl_per_dev = cyl_per_dev (dev_type);
     2233 		user_dev_char_table.user_sect_per_cyl = sect_per_cyl (dev_type);
     2234 		user_dev_char_table.user_sect_per_track = sect_per_track (dev_type);
     2235 		user_dev_char_table.user_num_label_sect = num_label_sect;
     2236 		user_dev_char_table.user_num_alt_sect = num_alt_sect;
     2237 		user_dev_char_table.user_sect_size = sect_size;
     2238 	     end;
     2239 
     2240 	else if (order = "format_trk") & device_group = MSU04XX
     2241 	     then do;				/* process the "format_trk" order */
     2242 		fmdp = addr (buffer.data);		/* set up data pointer */
     2243 		key = current_key;			/* convert key to binary */
     2244 		if key < sect_per_cyl (dev_type)
     2245 		     then cyl = 0;			/* :: */
     2246 		     else cyl = divide (key, sect_per_cyl (dev_type), 16, 0);
     2247 						/* figure cylinder number */
     2248 		i = mod (key, sect_per_cyl (dev_type)); /* save remainder */
     2249 		if i <= 0
     2250 		     then head = 0;			/* figure out head */
     2251 		     else head = divide (i, sect_per_track (dev_type), 16, 0);
     2252 		fmt_dta = "0"b;			/* clear out the buffer first */
     2253 		fmt_dta.svcyl = bit (cyl);		/* set up seek verif. cyl number */
     2254 		fmt_dta.svhd = bit (head);		/* set up seek verif. head number */
     2255 		if fmt_info.ti = "01"b | fmt_info.ti = "10"b
     2256 		     then do;
     2257 			fmt_dta.r0ccyl = bit (fmt_info.alt_def_cyl);
     2258 						/* if alt or def trk to be formated */
     2259 			fmt_dta.r0chd = bit (fmt_info.alt_def_hd);
     2260 						/* use user supplied cyl and head */
     2261 			if fmt_info.ti = "10"b
     2262 			     then			/* for r0 count field */
     2263 				fmt_dta.r0cti = "01"b;
     2264 			     else fmt_dta.r0cti = "10"b;
     2265 		     end;
     2266 		     else do;
     2267 			fmt_dta.r0ccyl = bit (cyl);	/* otherwise use the present position */
     2268 			fmt_dta.r0chd = bit (head);
     2269 			fmt_dta.r0cti = fmt_info.ti;
     2270 		     end;
     2271 		fmt_dta.hz = fmt_info.hz;		/* copy the header bypass info */
     2272 		fmt_dta.ti = fmt_info.ti;		/* copy the ti bits */
     2273 		fmt_dta.chk_chr = cksum ();		/* compute cksum char. */
     2274 		track_indicators = fmt_info.ti;	/* copy ti bits for seek command */
     2275 		control_command = FORMAT_TRK;		/* set up the active command to format trk */
     2276 		io_command = "format";		/* make sure not read */
     2277 		cont_sw = "1"b;			/* set the control sw */
     2278 		block_len = 5;			/* set the data xfer length to 5 words */
     2279 		call do_io ();			/* execute the format command sequence */
     2280 	     end;
     2281 
     2282 	else if order = "rd_trk_header" & device_group = MSU04XX
     2283 	     then do;				/* process the "rd_trk_header" order */
     2284 		key = next_key;			/* convert key to binary */
     2285 		cont_sw = "1"b;			/* set control switch */
     2286 		io_command = "read";		/* set up for read command */
     2287 		block_len = 5;			/* set  the data xfer length to 5 words */
     2288 		track_indicators = "00"b;		/* reset track_indicators */
     2289 		control_command = RD_TRK_HEADER;	/* set the command to 27 (8) */
     2290 		call do_io ();			/* execute the read trk header command sequence */
     2291 	     end;
     2292 
     2293 	else if order = "read_track_header"		/* New style read track header order for 451s or 500s. */
     2294 	     then do;				/* process the "rd_trk_header" order */
     2295 		thi_ptr = info_ptr;
     2296 		if thi.version ^= thi_version_1	/* wrong version number in structure */
     2297 		     then call error (error_table_$unimplemented_version, "");
     2298 		info_ptr = addr (thi.msu4xx_info);	/* data is in word after version */
     2299 		key = next_key;			/* convert key to binary */
     2300 		cont_sw = "1"b;			/* set control switch */
     2301 		io_command = "read";		/* set up for read command */
     2302 		block_len = FORMAT_DATA_LEN (dev_type); /* set the data xfer length to proper value */
     2303 		unspec (info_ptr -> block) = "0"b;
     2304 		track_indicators = "00"b;		/* reset track_indicators */
     2305 		control_command = RD_TRK_HEADER;	/* set the command to 27 (8) */
     2306 		call do_io ();			/* execute the read trk header command sequence */
     2307 	     end;
     2308 
     2309 	else if order = "format_track"
     2310 	     then do;				/* Format either a 4xx or a 5xx device */
     2311 		thi_ptr = info_ptr;
     2312 		if thi.version ^= thi_version_1	/* wrong version number */
     2313 		     then call error (error_table_$unimplemented_version, "Bad header version.");
     2314 		if dev_type > 7 then call error (error_table_$unimplemented_version, "Bad header version.");
     2315 		key = current_key;
     2316 		track_indicators = bit (thi.msu4xx_info.ti);
     2317 		control_command = FORMAT_TRK;
     2318 		io_command = "format";
     2319 		cont_sw = "1"b;
     2320 		block_len = FORMAT_DATA_LEN (dev_type); /* set proper block length */
     2321 		addr (data) -> block = addrel (addr (thi), 1) -> block;
     2322 		call do_io ();
     2323 	     end;
     2324 
     2325 	else if order = "hardware_status" then user_hardware_status = iom_stat;
     2326 
     2327 	else call error (error_table_$no_operation, order);
     2328 						/* if bad order,  tell the user */
     2329 
     2330 	a_code = 0;				/* made it */
     2331 	return;					/* au revoir */
     2332 
     2333 /*  End of CONTROL module  */
     2334 
     2335 /*  */
     2336 
     2337 /*  Start of MODES module  */
     2338 
     2339 rdisk_modes:
     2340      entry (a_iocb_ptr, a_new_modes, a_old_modes, a_code);
     2341 
     2342 /*
     2343*   *	     The modes operation is supported  when  the  I/O  switch  is
     2344*   *	attached.   The recognized modes are listed below.  Each mode has
     2345*   *	a complement indicated by the character "^" (e.g. "^label")  that
     2346*   *	turns the mode off.
     2347*   *
     2348*   *		label,^label        specifies  that  a   system-defined
     2349*   *				number  of sectors at the beginning
     2350*   *				of the pack are reserved for a pack
     2351*   *				label,   and   that   a    seek_key or position
     2352*   *				operation   is  to  treat  any  key
     2353*   *				within this area as an invalid key.
     2354*   *				(Default is on.)
     2355*   *
     2356*   *		alttrk,^alttrk      specifies that the  pack  has  been
     2357*   *				formatted  with  the  assignment of
     2358*   *				alternate   tracks,   so   that   a
     2359*   *				system-defined number of sectors at
     2360*   *				the  end  of  the pack are reserved
     2361*   *				for  an   alternate   track   area.
     2362*   *				Therefore,  a seek_key or position operation is
     2363*   *				to treat any key within  that  area
     2364*   *				as  an  invalid  key.   (Default is
     2365*   *				off.)
     2366*   *
     2367*   *		wrtcmp,^wrtcmp      specifies         that          the
     2368*   *				Write-and-Compare
     2369*   *				instruction,rather than  the  Write
     2370*   *				instruction  will  be  used for the
     2371*   *				rewrite_record   operation.    This
     2372*   *				causes  all  data written out to be
     2373*   *				read back in and  compared  to  the
     2374*   *				data  as  it  was  prior  to  being
     2375*   *				written.  This mode should be  used
     2376*   *				with  discretion,  since it doubles
     2377*   *				the data  transfer  time  of  every
     2378*   *				write.  (Default is off.)
     2379*   *
     2380*   *		raw, ^raw           specifies that the entire disk pack
     2381*   *		                    is available to the user, including
     2382*   *		                    the  T  &  D  cylinder  (the   last
     2383*   *		                    cylinder  on  the  disk pack). (The
     2384*   *		                    default is off.)
     2385**/
     2386 
     2387 dcl  a_new_modes		       char (*);		/* parameter: new modes string */
     2388 dcl  a_old_modes		       char (*);		/* parameter:  put the old modes string here */
     2389 dcl  temp_next_mode		       char (16);		/* for type conversion for call error */
     2390 
     2391 	call setup ("don't_care");			/* set up working environment */
     2392 
     2393 	if length (a_old_modes) > 0 then a_old_modes = mode_string;
     2394 						/* if wanted, pass back old modes */
     2395 
     2396 	mode_len = length (a_new_modes);		/* see how much we've got */
     2397 	if mode_len > 0
     2398 	     then do;				/* if something */
     2399 
     2400 		new_modes = a_new_modes;		/* grab the new modes */
     2401 		mode_start = 1;			/* keep track of where we are in the string */
     2402 
     2403 		do while (next_mode ^= "");		/* mode processing loop */
     2404 
     2405 		     call get_next_mode;		/* extract a  mode */
     2406 		     if next_mode ^= ""
     2407 			then do;			/* if we got one, do something with it */
     2408 
     2409 			     mode_err_sw = "0"b;	/* give user  the benefit of the doubt */
     2410 
     2411 			     if next_mode = "label"
     2412 				then do;
     2413 				     bounds.low = num_label_sect;
     2414 						/* reserve label area */
     2415 				     label_sw = "1"b;
     2416 				end;
     2417 			     else if next_mode = "^label"
     2418 				then do;
     2419 				     bounds.low = 0;/* let him  play,starting at sect. 0 */
     2420 				     label_sw = "0"b;
     2421 				end;
     2422 
     2423 			     else if (next_mode = "alttrk")
     2424 				then do;
     2425 				     bounds.high = last_sect_num (dev_type);
     2426 						/* reserve alternate track area */
     2427 				     alt_sw = "1"b;
     2428 				end;
     2429 			     else if next_mode = "^alttrk"
     2430 				then do;
     2431 				     if device_group = MSU04XX
     2432 					then bounds.high = last_alt_sect_num (dev_type);
     2433 					else bounds.high = last_sect_num (dev_type);
     2434 				     alt_sw = "0"b;
     2435 				end;
     2436 
     2437 			     else if next_mode = "wrtcmp" then compare_sw = "1"b;
     2438 						/* set compare mode switch */
     2439 			     else if next_mode = "^wrtcmp" then compare_sw = "0"b;
     2440 						/* set for ordinary write */
     2441 
     2442 			     else if next_mode = "raw"
     2443 				then do;
     2444 				     bounds.low = 0;/* let user have entire pack in this mode */
     2445 				     bounds.high = last_physical_sect_num (dev_type);
     2446 				     raw_sw = "1"b; /* set indicator */
     2447 				end;
     2448 			     else if next_mode = "^raw"
     2449 				then do;
     2450 				     if label_sw	/* in label mode */
     2451 					then bounds.low = num_label_sect;
     2452 						/* reset origial defaults */
     2453 					else bounds.low = 0;
     2454 				     if ^alt_sw	/* in alt mode */
     2455 					& device_group = MSU04XX
     2456 						/* and on a 400 series device */
     2457 					then bounds.high = last_alt_sect_num (dev_type);
     2458 					else bounds.high = last_sect_num (dev_type);
     2459 				     raw_sw = "0"b; /* reset raw indicator */
     2460 				end;
     2461 			     else do;		/* oh oh */
     2462 				code = error_table_$bad_mode;
     2463 						/* tried to fool mother rdisk_, eh?  */
     2464 				mode_err_sw = "1"b; /* can't let that happen */
     2465 			     end;
     2466 
     2467 			     if ^mode_err_sw then call set_mode;
     2468 						/* update the mode string */
     2469 
     2470 			end;
     2471 		     end;
     2472 	     end;
     2473 
     2474 	temp_next_mode = next_mode || "                "; /* obtain proper type for */
     2475 	temp_next_mode = substr (temp_next_mode, 1, 16);	/* the call to error */
     2476 	if code ^= 0
     2477 	     then call error (code, temp_next_mode);	/* let him know how he did */
     2478 	     else a_code = 0;
     2479 
     2480 	return;					/* don't rush off */
     2481 
     2482 /*  Internal procedure to extract single modes from the mode string  */
     2483 
     2484 get_next_mode:
     2485      proc;
     2486 
     2487 	if mode_len > 0
     2488 	     then do;				/* if we still have something left */
     2489 
     2490 		new_modes = substr (new_modes, mode_start, mode_len);
     2491 						/* update work string */
     2492 
     2493 		i = index (new_modes, ",");		/* set i to length of next mode + 1 */
     2494 		if i = 0
     2495 		     then do;
     2496 			i = index (new_modes, " ");
     2497 			if i = 0 then i = mode_len + 1;
     2498 		     end;
     2499 
     2500 		mode_len = mode_len - i;		/* keep track of how much we have left */
     2501 		mode_start = i + 1;			/* and where to start */
     2502 		next_mode = substr (new_modes, 1, i - 1);
     2503 						/* pass back the mode */
     2504 
     2505 	     end;
     2506 
     2507 	     else next_mode = "";			/* nothing to return */
     2508 
     2509      end get_next_mode;
     2510 
     2511 /*  Internal procedure to update the mode string  */
     2512 
     2513 set_mode:
     2514      proc;
     2515 
     2516 	not_sw = (substr (next_mode, 1, 1) = "^");	/* set switch if a  "^" mode */
     2517 
     2518 	i = index (mode_string, substr (next_mode, 1 + fixed (not_sw)));
     2519 						/* point to basic mode */
     2520 
     2521 	if i <= 1
     2522 	     then if not_sw
     2523 		     then mode_string = "^" || mode_string;
     2524 		     else ;			/* if at beg. just prefix "^" */
     2525 
     2526 	else if not_sw & (substr (mode_string, i - 1, 1) ^= "^")
     2527 						/* insert a  "^" */
     2528 	     then substr (mode_string, i) = "^" || substr (mode_string, i);
     2529 
     2530 	else if ^not_sw & (substr (mode_string, i - 1, 1) = "^")
     2531 	     then					/* delete a "^" */
     2532 		substr (mode_string, i - 1) = substr (mode_string, i);
     2533 
     2534      end set_mode;
     2535 
     2536 /*  End of MODES module  */
     2537 
     2538 /*  */
     2539 
     2540 /*  Start of CLOSE module  */
     2541 
     2542 rdisk_close:
     2543      entry (a_iocb_ptr, a_code);
     2544 
     2545 /*
     2546*   This operation has no effect on the device, but merely  resets some
     2547*   fields in the IOCB.
     2548**/
     2549 
     2550 	call setup ("open");			/* set up working environment */
     2551 
     2552 	mask_str = "0"b;				/* initialize ips_ mask */
     2553 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     2554 	call hcs_$set_ips_mask (mask_str, mask_str);
     2555 
     2556 	real_iocb_ptr -> open_descrip_ptr = null;	/* put IOCB in closed state;  open descrip. pointer */
     2557 
     2558 	real_iocb_ptr -> open = rdisk_open;		/* set open entry */
     2559 	real_iocb_ptr -> detach_iocb = rdisk_detach;	/* and detach entry */
     2560 
     2561 	real_iocb_ptr -> close,			/* shut the close entry */
     2562 	     real_iocb_ptr -> read_record,		/* and the read record entry */
     2563 	     real_iocb_ptr -> rewrite_record,		/* and the rewrite record entry */
     2564 	     real_iocb_ptr -> position,		/* and the position entry */
     2565 	     real_iocb_ptr -> write_record,		/* and the write record entry */
     2566 	     real_iocb_ptr -> seek_key = iox_$err_not_open;
     2567 						/* and the seek key entry */
     2568 
     2569 	call iox_$propagate (iocb_ptr);		/* give iox_ a turn */
     2570 
     2571 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     2572 
     2573 	next_key, current_key, key_for_insertion = NULL;	/* reset all keys to invalid state */
     2574 
     2575 	a_code = 0;				/* be nice to him */
     2576 	return;					/* and he may call us again, sometime */
     2577 
     2578 /*  End of CLOSE module  */
     2579 /*  */
     2580 /*  Start of DETACH  module  */
     2581 
     2582 rdisk_detach:
     2583      entry (a_iocb_ptr, a_code);
     2584 
     2585 /*
     2586*   This operation dismounts and detaches the device, and cleans up the IOCB.
     2587**/
     2588 
     2589 	call setup ("closed");			/* set up working environment */
     2590 	rcp_detachment = "0"b;
     2591 	call delete_attach (rcp_detachment);
     2592 
     2593 	if rcp_detachment
     2594 	     then do;
     2595 		call rcp_$detach (rcp_id, (DEFAULT), errors, "", code);
     2596 						/* detach the device */
     2597 		call ipc_$delete_ev_chn (ev_chan, code);/* get rid of event channel */
     2598 	     end;
     2599 
     2600 	call hcs_$delentry_seg (disk_ptr, code);	/* get rid of work segment */
     2601 	disk_ptr = null;				/* null the pointer */
     2602 
     2603 	mask_str = "0"b;				/* initialize ips_ mask */
     2604 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     2605 	call hcs_$set_ips_mask (mask_str, mask_str);
     2606 
     2607 	iocb_ptr -> attach_data_ptr = null;		/* clean up the IOCB;  null the data pointer */
     2608 	iocb_ptr -> attach_descrip_ptr = null;		/* and the attach descrip. pointer */
     2609 
     2610 	iocb_ptr -> iocb.control,			/* reset control */
     2611 	     iocb_ptr -> iocb.modes = iox_$err_no_operation;
     2612 						/* and modes operations */
     2613 
     2614 	call iox_$propagate (iocb_ptr);		/* tell iox_ */
     2615 
     2616 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     2617 
     2618 	if code ^= 0 then call error (code, "Problem in detaching.");
     2619 						/* tell user if something went wrong */
     2620 
     2621 	a_code = 0;				/* otherwise, give him a good send-off */
     2622 	return;
     2623 
     2624 delete_attach:
     2625      proc (detach_rcp);
     2626 
     2627 
     2628 /* Internal proc to delete this attachment from the array */
     2629 dcl  detach_rcp		       bit (1);
     2630 dcl  sv_att_idx		       fixed bin;
     2631 dcl  count_att		       fixed bin;
     2632 	count_att = 0;
     2633 	if attachments_ptr = null () then detach_rcp = "1"b;
     2634 						/* some this is wrong let rcp complain it may know */
     2635 	if attachments.array (att_dev_idx).sv (1).this_sv = -1
     2636 						/* attached as one device can only be one attachment */
     2637 	     then count_att = 1;
     2638 	     else do sv_att_idx = 1 to 3;		/* count the number of attachments for this device */
     2639 		     if attachments.array (att_dev_idx).sv (sv_att_idx).this_iocbp ^= null ()
     2640 			then count_att = count_att + 1;
     2641 		     end;
     2642 	attachments.array (att_dev_idx).sv (att_sv_idx).this_iocbp = null ();
     2643 	if count_att = 1
     2644 	     then do;
     2645 		detach_rcp = "1"b;
     2646 		attachments.array (att_dev_idx).device_att = "";
     2647 	     end;
     2648 	attachments.number_attached = attachments.number_attached - 1;
     2649 	if attachments.number_attached = 0
     2650 	     then do;				/* free attachment array */
     2651 		free attachments in (system_area);
     2652 		attachments_ptr = null ();
     2653 	     end;
     2654 	return;
     2655      end delete_attach;
     2656 
     2657 
     2658 /*  End of DETACH module  */
     2659 /*  */
     2660 /*  Internal SETUP Procedure  */
     2661 
     2662 setup:
     2663      proc (setup_input_arg);
     2664 
     2665 dcl  setup_input_arg	       char (*);
     2666 dcl  desired_switch_state	       char (12) varying;
     2667 
     2668 /*  call setup ("open")       means the switch should be open   -- complain if it is closed.  */
     2669 /*  call setup ("closed")       "    "     "     "    "  closed --    "     "  "  "    open.  */
     2670 /*  call setup ("don't_care") means that the switch can be either open or closed.  */
     2671 
     2672 dcl  who_did_the_attach	       char (32) varying;	/*  Which I/O module attached this file?  */
     2673 dcl  setup_error_msg	       char (36);		/*  temporary error message  */
     2674 
     2675 	code = 0;					/* give him a chance to make it */
     2676 
     2677 	desired_switch_state = setup_input_arg;
     2678 	iocb_ptr = a_iocb_ptr;			/* pick up pointer to IOCB */
     2679 	real_iocb_ptr = iocb_ptr -> actual_iocb_ptr;	/* the real one, this time */
     2680 	disk_ptr = real_iocb_ptr -> attach_data_ptr;	/* and a pointer to our work seg */
     2681 
     2682 	if real_iocb_ptr -> attach_descrip_ptr = null then call error (error_table_$not_attached, "");
     2683 						/*  must be attached */
     2684 
     2685 	who_did_the_attach = substr (attach_descrip.descrip, 1, index (attach_descrip.descrip, " ") - 1);
     2686 	if who_did_the_attach ^= "rdisk_"
     2687 	     then do;
     2688 		setup_error_msg = "Not attached by rdisk_ but by " || who_did_the_attach;
     2689 		call error (error_table_$not_attached, setup_error_msg);
     2690 	     end;
     2691 
     2692 
     2693 	if desired_switch_state = "open"
     2694 	     then if real_iocb_ptr -> open_descrip_ptr = null then call error (error_table_$not_open, "");
     2695 
     2696 		else if desired_switch_state = "closed"
     2697 		     then if real_iocb_ptr -> open_descrip_ptr ^= null then call error (error_table_$not_closed, "");
     2698 
     2699 			else if desired_switch_state = "don't_care" then return;
     2700 
     2701      end setup;					/*  */
     2702 
     2703 /*  Internal ERROR Procedure  */
     2704 
     2705 error:
     2706      proc (cd, err_msg);
     2707 
     2708 dcl  cd			       fixed bin (35);	/* code */
     2709 dcl  err_msg		       char (*);		/* Additional text. */
     2710 
     2711 	if disk_ptr ^= null
     2712 	     then					/* if we have a work seg, we can check print-error switch */
     2713 		if err_sw
     2714 		     then call sub_err_ (cd, "rdisk_", "c", null, retval, "^a  ^a", iocb_ptr -> iocb.name, err_msg);
     2715 						/* print if desired */
     2716 		     else ;
     2717 	     else call sub_err_ (cd, "rdisk_", "c", null, retval, "^a  ^a", iocb_ptr -> iocb.name, err_msg);
     2718 						/* can't check, just give it to him */
     2719 
     2720 	code = cd;				/* set code */
     2721 
     2722 	go to exit;				/* and exit, stage right */
     2723 
     2724      end error;
     2725 
     2726 /*  */
     2727 
     2728 /*  Internal PACK MOUNT procedure  */
     2729 
     2730 mount:
     2731      proc;
     2732 dcl  cleanup		       condition;
     2733 
     2734 	errors = 0;				/* give the pack a fresh start */
     2735 
     2736 	disk_info_ptr = addr (rcp_data);		/* init. disk info prior to attaching device */
     2737 	disk_info.volume_name = pack_id;		/* fill in new pack id */
     2738 
     2739 	call rcp_$attach ((rcp_dev_type), disk_info_ptr, ev_chan, "", rcp_id, code);
     2740 						/* attach device */
     2741 	if code ^= 0 then return;			/* let caller handle problems */
     2742 
     2743 	call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, time_int, rcp_state, code);
     2744 	if code ^= 0 then return;			/* check attachment completion */
     2745 
     2746 	do while (rcp_state ^= COMPLETE);		/* loop until attachment is complete or fails */
     2747 	     on cleanup call detach;			/* detach disk if user aborting */
     2748 	     call ipc_$block (addr (wait_list), addr (event_info), code);
     2749 						/* wait to hear from rcp_ */
     2750 	     revert cleanup;
     2751 	     if code ^= 0 then return;
     2752 	     call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, time_int, rcp_state, code);
     2753 	     if code ^= 0 then return;		/* let caller worry about it */
     2754 	     if rcp_state < COMPLETE | rcp_state >= LONG_WAIT
     2755 		then do;
     2756 		     code = error_table_$action_not_performed;
     2757 						/* let user know he has a problem */
     2758 		     return;			/* let caller pass bad news to user */
     2759 		end;
     2760 	     end;
     2761 
     2762 	if drive = NOT_SET
     2763 	     then do;
     2764 		drive_number.sign = "+";		/* successful assignment, convert and save drive number */
     2765 		drive_number.number = substr (disk_info.device_name, 6, 2);
     2766 		drive = drive_dec;
     2767 	     end;
     2768 
     2769 	buf_len = min (max (divide (sze, 4, 17, 0), 1024), max_buff_size);
     2770 						/* determine ioi_ buffer size */
     2771 	call ioi_$workspace (devx, buf_ptr, buf_len, code);
     2772 						/* and try to get it */
     2773 	if code ^= 0 then return;			/* win some -- lose some */
     2774 	data_len = buf_len - overhead;		/* set length of data area */
     2775 
     2776 	call ioi_$set_status (devx, fixed (rel (addr (istat))), 1, code);
     2777 						/* tell ioi_ how to reach us */
     2778 	if code ^= 0 then return;
     2779 
     2780 	call ioi_$timeout (devx, (time_int), code);	/* have ioi_ do it */
     2781 	if code ^= 0 then return;			/* how do you like that! */
     2782 
     2783 detach:
     2784      proc;
     2785 	call rcp_$detach (rcp_id, "0"b, (0), "", (0));
     2786 	return;
     2787      end detach;
     2788 
     2789      end mount;
     2790 
     2791 /*  */
     2792 
     2793 /*  Internal CONDITION HANDLER */
     2794 
     2795 cond_hdlr:
     2796      proc (mc_ptr, cond_name, wc_mc_ptr, info_ptr, cont_sw);
     2797 
     2798 /*
     2799*   This procedure handles any unusual conditions signaled while we are
     2800*   masked by terminating the process.  This avoids problems we
     2801*   would have if we attempted to use an IOCB  which was left in an
     2802*   inconsistent state.
     2803**/
     2804 dcl  (mc_ptr, wc_mc_ptr, info_ptr)   ptr;
     2805 dcl  cond_name		       char (*);		/* condition name */
     2806 dcl  cont_sw		       bit (1) aligned;	/* continuation switch */
     2807 
     2808 	if masked
     2809 	     then do;				/* if we were masked, kill the process */
     2810 		tp_info.version = 0;		/* currently version 0 */
     2811 		tp_info.code = error_table_$termination_requested;
     2812 						/* as good a reason as any */
     2813 		call terminate_process_ ("fatal_error", addr (tp_info));
     2814 						/* do the dirty deed */
     2815 	     end;
     2816 
     2817 	if cond_name ^= "cleanup" then cont_sw = "1"b;	/* don't pass on cleanup */
     2818 
     2819      end cond_hdlr;					/*  */
     2820 
     2821 /*  Internal CHECKSUM procedure  */
     2822 
     2823 
     2824 cksum:
     2825      proc returns (bit (6));
     2826 
     2827 /* routine to compute exclusive or check char */
     2828 
     2829 dcl  ckchar		       bit (6);		/* working storage */
     2830 dcl  fmtsum		       (30) bit (6) based (fmdp);
     2831 						/* format data as 6 bit char */
     2832 	ckchar = "0"b;				/* initialize working storage */
     2833 	do i = 1 to 30;				/* compute check char */
     2834 	     ckchar = bool (ckchar, fmtsum (i), "0110"b);
     2835 	     end;
     2836 	return (ckchar);				/* return computed check character */
     2837      end cksum;
     2838 
     2839 /*  */
     2840 /* Internal procedure to handle the io_call order */
     2841 
     2842 io_call_order:
     2843      proc;
     2844 
     2845 dcl  changepack		       char (32) var;
     2846 dcl  1 getbounds		       aligned,
     2847        2 low		       fixed bin (35),
     2848        2 high		       fixed bin (35);
     2849 dcl  setsize		       fixed bin (35);
     2850 dcl  1 device_info_table	       aligned,
     2851        2 dev_type		       char (4),
     2852        2 device_name	       char (8),
     2853        2 sect_per_dev	       fixed bin (35),
     2854        2 cyl_per_dev	       fixed bin,
     2855        2 sect_per_cyl	       fixed bin,
     2856        2 sect_per_track	       fixed bin,
     2857        2 num_label_sect	       fixed bin,
     2858        2 num_alt_sect	       fixed bin,
     2859        2 sect_size		       fixed bin (12);
     2860 
     2861 dcl  1 track_header_data	       like thi;
     2862 
  9     1 /* Begin include file ..... io_call_info.incl.pl1 */
  9     2 
  9     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  9     4*   on behalf of the io_call command. */
  9     5 /* Coded April 1976 by Larry Johnson */
  9     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  9     7 
  9     8      dcl	   io_call_infop	      ptr;
  9     9 
  9    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  9    11 	     2 version	      fixed bin,
  9    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  9    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  9    14 	     2 report	      entry variable options (variable),
  9    15 						/* Entry to ioa_ like procedure to report results */
  9    16 	     2 error	      entry variable options (variable),
  9    17 						/* Entry to com_err_ like procedure to report results */
  9    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  9    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  9    20 	     2 fill	      (5) bit (36) aligned,
  9    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  9    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  9    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  9    24 
  9    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  9    26 						/* Return string for active function */
  9    27 
  9    28 /* End include file ..... io_call_info.incl.pl1 */
     2863 
     2864 
     2865 	io_call_infop = a_info_ptr;
     2866 	if io_call_info.order_name = "setsize"
     2867 	     then do;
     2868 		if io_call_info.nargs ^> 0
     2869 		     then do;
     2870 			call io_call_info.error (error_table_$noarg, io_call_info.caller_name, "New size.");
     2871 			return;
     2872 		     end;
     2873 		setsize = cv_dec_check_ ((io_call_info.args (1)), code);
     2874 		if code ^= 0
     2875 		     then do;
     2876 			call io_call_info
     2877 			     .error (0, io_call_info.caller_name, "Invalid size: ^a.", io_call_info.args (1));
     2878 			code = 0;
     2879 			return;
     2880 		     end;
     2881 		call iox_$control (iocb_ptr, "setsize", addr (setsize), code);
     2882 		return;
     2883 	     end;
     2884 	else if io_call_info.order_name = "changepack"
     2885 	     then do;
     2886 		if io_call_info.nargs ^> 0
     2887 		     then do;
     2888 			call io_call_info.error (error_table_$noarg, io_call_info.caller_name, "New pack name.");
     2889 			return;
     2890 		     end;
     2891 		changepack = io_call_info.args (1);
     2892 		call iox_$control (iocb_ptr, "changepack", addr (changepack), code);
     2893 		return;
     2894 	     end;
     2895 	else if io_call_info.order_name = "getbounds"
     2896 	     then do;
     2897 		call iox_$control (iocb_ptr, "getbounds", addr (getbounds), code);
     2898 		if code = 0
     2899 		     then do;
     2900 			call io_call_info
     2901 			     .
     2902 			     report ("^a: Sectors available are ^d:^d", io_call_info.caller_name, getbounds.low,
     2903 			     getbounds.high);
     2904 		     end;
     2905 		return;
     2906 	     end;
     2907 	else if io_call_info.order_name = "device_info"
     2908 	     then do;
     2909 		call iox_$control (iocb_ptr, "device_info", addr (device_info_table), code);
     2910 		if code = 0
     2911 		     then do;
     2912 			call io_call_info
     2913 			     .
     2914 			     report ("Device Characteristics:^/^/device type:^-^-^a^/device name:^-^-^a",
     2915 			     device_info_table.dev_type, device_info_table.device_name);
     2916 			call io_call_info
     2917 			     .
     2918 			     report ("sectors per device:^-^-^d^/cylinders per device:^-^d",
     2919 			     device_info_table.sect_per_dev, device_info_table.cyl_per_dev);
     2920 			call io_call_info
     2921 			     .
     2922 			     report ("sectors per cylinder:^-^d^/sectors per track:^-^-^d",
     2923 			     device_info_table.sect_per_cyl, device_info_table.sect_per_track);
     2924 			call io_call_info
     2925 			     .
     2926 			     report ("number of label sectors:^-^d^/number of alternate sectors:^-^d",
     2927 			     device_info_table.num_label_sect, device_info_table.num_alt_sect);
     2928 			call io_call_info.report ("sector size (words):^-^d", device_info_table.sect_size);
     2929 		     end;
     2930 		return;
     2931 	     end;
     2932 
     2933 	else if io_call_info.order_name = "read_track_header"
     2934 	     then do;
     2935 		track_header_data.version = thi_version_1;
     2936 		call iox_$control (iocb_ptr, "read_track_header", addr (track_header_data), code);
     2937 		if code = 0
     2938 		     then if io_call_info.nargs > 0
     2939 			     then if io_call_info.args (1) = "-hex"
     2940 				     then call print_track_header_info (addr (track_header_data),
     2941 					     io_call_info.report, "1"b);
     2942 				     else call print_track_header_info (addr (track_header_data),
     2943 					     io_call_info.report, "0"b);
     2944 			     else call print_track_header_info (addr (track_header_data), io_call_info.report, "0"b)
     2945 				     ;
     2946 		return;
     2947 	     end;
     2948 	else if io_call_info.order_name = "format_trk" | io_call_info.order_name = "rd_trk_header"
     2949 	     | io_call_info.order_name = "read_track_header"
     2950 	     then do;
     2951 		call io_call_info
     2952 		     .
     2953 		     error (0, io_call_info.caller_name, "The ^a control order is not supported by io_call",
     2954 		     io_call_info.order_name);
     2955 		return;
     2956 	     end;
     2957 
     2958 	else code = error_table_$no_operation;
     2959 	return;
     2960 
     2961      end io_call_order;
     2962 
     2963 print_track_header_info:
     2964      proc (thip, report, all_sw);
     2965 
     2966 
     2967 dcl  all_sw		       bit (1);
     2968 dcl  report		       entry variable options (variable);
     2969 dcl  thip			       ptr;
     2970 
     2971 dcl  header_dumped		       bit (1) init ("0"b);
     2972 dcl  i			       fixed bin;
     2973 dcl  last_sector		       fixed bin;
     2974 
     2975 dcl  header_array		       (FORMAT_DATA_LEN (dev_type)) bit (36) based (addrel (thip, 1));
     2976 
     2977 
     2978 	call report ("^/position=(^d/^d)  ti=^2b^[  alternate=(^d/^d)^;^2s^]  tskip=^d,^d,^d  cf=^a",
     2979 	     thip -> thi.c0.cyl_lower + thip -> thi.c0.cyl_upper * 256, thip -> thi.c0.head, bit (thip -> thi.c0.ti),
     2980 	     (thip -> thi.c0.alt_cyl_lower + thip -> thi.c0.alt_cyl_upper + thip -> thi.c0.alt_head ^= 0),
     2981 	     thip -> thi.c0.alt_cyl_lower + thip -> thi.c0.alt_cyl_upper * 256, thip -> thi.c0.alt_head,
     2982 	     thip -> thi.c0.t_skip.distance, cond_flag (thip -> thi.c0.cf));
     2983 	call report (
     2984 	     "physical sector size = ^[512^;64^] words.^[Format of this disk by Honeywell has ^[not ^]completed.^;^s^]",
     2985 	     thip -> thi.c0.large_records, thip -> thi.c0.honeywell_formatted, ^(thip -> thi.c0.format_complete));
     2986 	if thip -> thi.c0.log_track then call report ("*** This is a log track. ***");
     2987 	call report ("^/skip1^5xskip2^5xcf^/");
     2988 	call report ("^8a^2x^8a^2x^a", skip_mess (thip -> thi.c0.skip (1)), skip_mess (thip -> thi.c0.skip (2)),
     2989 	     cond_flag (thip -> thi.c0.cf));
     2990 	if dev_type = msu0500devt then last_sector = 40;
     2991 	else if dev_type = msu0501devt then last_sector = 8;
     2992 	else last_sector = 0;
     2993 	do i = 1 to last_sector - 1;
     2994 	     call report ("^8a^2x^8a^2x^a", skip_mess (thip -> thi.c (i).skip (1)),
     2995 		skip_mess (thip -> thi.c (i).skip (2)), cond_flag (thip -> thi.c (i).cf));
     2996 	     end;
     2997 
     2998 	if all_sw					/* dump it in hex also */
     2999 	     then call dump_header ();
     3000 
     3001 	return;
     3002 
     3003 
     3004 cond_flag:
     3005      proc (cf) returns (char (*));
     3006 
     3007 
     3008 dcl  cf			       bit (8) unal;
     3009 
     3010 
     3011 	if cf = "0011100"b then return ("No Error");
     3012 	else if cf = "00111001"b then return ("EDAC Error - Corrected");
     3013 	else if cf = "00111010"b then return ("EDAC Error - Uncorrectable");
     3014 	else return (char (cf));
     3015 
     3016 
     3017      end cond_flag;
     3018 
     3019 
     3020 dump_header:
     3021      proc ();
     3022 
     3023 
     3024 	if header_dumped then return;
     3025 
     3026 	call report ("^(^/^4(^9.4b^2x^)^)", header_array);
     3027 
     3028 	header_dumped = "1"b;
     3029 
     3030 	return;
     3031 
     3032 
     3033      end dump_header;
     3034 
     3035 
     3036 skip_mess:
     3037      proc (skip) returns (char (8));
     3038 
     3039 
     3040 dcl  1 skip		       like thi.msu5xx_info.c0.skip unal;
     3041 
     3042 dcl  1 retval		       unal,
     3043        2 disp		       pic "zzzz9",
     3044        2 space		       char (1) init (" "),
     3045        2 type		       char (2);
     3046 
     3047 
     3048 	if ^skip.used then return ("none  ");
     3049 
     3050 	if skip.gap_following_count then type = "FC";
     3051 	else if skip.gap_following_data then type = "FD";
     3052 	else type = "ID";
     3053 	disp = skip.displacement;
     3054 
     3055 	return (string (retval));
     3056 
     3057 
     3058      end skip_mess;
     3059 
     3060 
     3061      end print_track_header_info;
     3062 
     3063 
     3064 
     3065      end rdisk_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0851.4  rdisk_.pl1                        >spec>install>1115>rdisk_.pl1
87           1    06/03/83  1008.5  iocbx.incl.pl1                    >ldd>include>iocbx.incl.pl1
89           2    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
91           3    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
93           4    02/23/81  1142.4  track_header_info.incl.pl1        >ldd>include>track_header_info.incl.pl1
95           5    07/24/86  2051.8  rcp_disk_info.incl.pl1            >ldd>include>rcp_disk_info.incl.pl1
97           6    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
6-142        7    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
99           8    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
2863         9    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTENTION                              constant        bit(4)                   initial packed unaligned dcl 306 ref 1767 1825
COMPLETE                               constant        fixed bin(17,0)          initial dcl 318 ref 2746 2754
DEFAULT                                constant        bit(1)                   initial packed unaligned dcl 320 ref 2595
DEVICE_GROUP                    000027 constant        fixed bin(17,0)          initial array dcl 296 ref 640
DISK_INFO_VERSION_1                    constant        fixed bin(17,0)          initial dcl 5-29 ref 616
Direct_input                           constant        fixed bin(17,0)          initial dcl 8-15 ref 1033 1108 1195 1515 1530
Direct_update                          constant        fixed bin(17,0)          initial dcl 8-15 ref 1042 1108 1195 1355 1515 1530
END                             017772 constant        fixed bin(17,0)          initial dcl 480 ref 1224 1241 1248 1267 1274 1279
                                                                                  1284 1317 1361 1363 1394 1535 1557 1581
EOF                                    constant        bit(4)                   initial packed unaligned dcl 307 ref 1772
EXEC                                   constant        bit(5)                   initial packed unaligned dcl 312 ref 797
FORMAT_DATA_LEN                 000016 constant        fixed bin(17,0)          initial array dcl 298 ref 2302 2320 3026
FORMAT_TRK                             constant        bit(6)                   initial packed unaligned dcl 313 ref 2275 2317
IOTD                                   constant        bit(2)                   initial dcl 324 ref 1734
LAST_BLOCK                             constant        bit(6)                   initial packed unaligned dcl 308 ref 1772
LAST_BLOCK_MASK                        constant        bit(6)                   initial packed unaligned dcl 309 ref 1772
LONG_WAIT                              constant        fixed bin(17,0)          initial dcl 317 ref 2754
MAX_DCW_TALLY                          constant        fixed bin(17,0)          initial dcl 325 ref 1727 1727 1730 1731
MODEL                           000350 constant        fixed bin(17,0)          initial array dcl 6-57 ref 823 824
MODELN                          000323 constant        fixed bin(17,0)          initial array dcl 6-63 ref 619 634 635 827
MODELX                          000334 constant        fixed bin(17,0)          initial array dcl 6-60 ref 824
MSU04XX                                constant        fixed bin(17,0)          initial dcl 299 ref 655 2240 2282 2431 2454
MSU33XX                                constant        fixed bin(17,0)          initial dcl 301 ref 657
NOT_SET                         017771 constant        fixed bin(6,0)           initial dcl 321 ref 741 2762
NULL                            017771 constant        fixed bin(17,0)          initial dcl 482 ref 688 1210 1245 1248 1316 1321
                                                                                  1326 1327 1359 1396 1400 1430 1515 1530 1562 1571
                                                                                  2573
RD_TRK_HEADER                          constant        bit(6)                   initial packed unaligned dcl 314 ref 2289 2305
RETAIN                                 constant        bit(1)                   initial packed unaligned dcl 319 ref 2182
SPECIAL_SEEK                           constant        bit(6)                   initial packed unaligned dcl 315 ref 1648 1669
SPECIAL_SEEK_512                       constant        bit(6)                   initial packed unaligned dcl 316 ref 1697
STANDBY                                constant        bit(6)                   initial packed unaligned dcl 311 ref 1767
Sequential_input                       constant        fixed bin(17,0)          initial dcl 8-15 ref 995 1319 1788
Sequential_output                      constant        fixed bin(17,0)          initial dcl 8-15 ref 1005 1313 1390
Sequential_update                      constant        fixed bin(17,0)          initial dcl 8-15 ref 1018 1293 1319 1355 1549 1788
Stream_input                           constant        fixed bin(17,0)          initial dcl 8-15 ref 957 1206
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 8-15 ref 980 1206 1390
Stream_output                          constant        fixed bin(17,0)          initial dcl 8-15 ref 967 1206 1313 1390
TI_MASK                                constant        bit(6)                   initial packed unaligned dcl 310 ref 1796
a_code                                 parameter       fixed bin(35,0)          dcl 428 set ref 489 708* 922 1083* 1090 1120* 1127
                                                                                  1294* 1302 1342 1374 1588* 1932 2172* 2220* 2330*
                                                                                  2339 2478* 2542 2575* 2582 2621*
a_err_sw                               parameter       bit(1)                   dcl 564 ref 489 736
a_ext                                  parameter       bit(1)                   dcl 946 ref 922 1062
a_info_ptr                             parameter       pointer                  dcl 2166 ref 1932 2178 2865
a_iocb_ptr                             parameter       pointer                  dcl 427 ref 489 587 922 1090 1127 1302 1342 1374
                                                                                  1932 2339 2542 2582 2678
a_key                                  parameter       varying char(256)        dcl 1105 ref 1090 1112 1112 1113
a_mode                                 parameter       fixed bin(17,0)          dcl 945 ref 922 951
a_new_modes                            parameter       char                     packed unaligned dcl 2387 ref 2339 2396 2400
a_old_modes                            parameter       char                     packed unaligned dcl 2388 set ref 2339 2393 2393*
a_quantity                             parameter       fixed bin(21,0)          dcl 1188 ref 1127 1201
a_rec_len                              parameter       fixed bin(21,0)          dcl 429 set ref 1090 1119* 1302 1338* 1342 1370 1374
                                                                                  1403 1504* 1506* 1781*
a_type                                 parameter       fixed bin(17,0)          dcl 1186 ref 1127 1199
a_ubuf_len                             parameter       fixed bin(21,0)          dcl 431 ref 1302 1335 1337
a_ubuf_ptr                             parameter       pointer                  dcl 430 ref 1302 1342 1374 1441
abs                                                    builtin function         dcl 375 ref 1274 1284
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-9 ref 704 2679
addr                                                   builtin function         dcl 375 ref 615 676 703 1076 1636 1703 1706 1708
                                                                                  1721 1724 1736 1751 1751 1751 1751 1767 1767 1772
                                                                                  1772 1777 1796 1799 1811 1811 1825 1830 1833 1876
                                                                                  1876 1913 1914 1914 1914 1914 1919 2217 2228 2242
                                                                                  2298 2321 2321 2736 2748 2748 2748 2748 2766 2776
                                                                                  2776 2808 2813 2813 2881 2881 2892 2892 2897 2897
                                                                                  2909 2909 2936 2936 2937 2937 2942 2942 2944 2944
addrel                                                 builtin function         dcl 375 ref 1464 1906 1909 1911 2321 3026
address                                based           bit(18)                  level 2 packed packed unaligned dcl 3-7 set ref
                                                                                  1706* 1726*
again                           000203 automatic       bit(1)                   packed unaligned dcl 264 set ref 1738* 1741 1757*
                                                                                  1835*
all_sw                                 parameter       bit(1)                   packed unaligned dcl 2967 ref 2963 2998
alt_cyl_lower            10(28)        based           fixed bin(8,0)           level 4 packed packed unsigned unaligned dcl 4-7 set
                                                                                  ref 2978 2978
alt_cyl_upper            11            based           fixed bin(2,0)           level 4 packed packed unsigned unaligned dcl 4-7 set
                                                                                  ref 2978 2978
alt_def_cyl               0(04)        based           fixed bin(16,0)          level 2 packed packed unaligned dcl 447 ref 2257
alt_def_hd                0(21)        based           fixed bin(16,0)          level 2 packed packed unaligned dcl 447 ref 2259
alt_head                 11(02)        based           fixed bin(6,0)           level 4 packed packed unsigned unaligned dcl 4-7 set
                                                                                  ref 2978 2978*
alt_sw                   55(04)        based           bit(1)                   level 3 packed packed unaligned dcl 101 set ref 626*
                                                                                  2427* 2434* 2454
answer                          000210 automatic       varying char(3)          dcl 266 set ref 1876* 1882
args                     44            based           varying char             array level 2 dcl 9-10 set ref 2873 2876* 2891 2937
array                     2            based           structure                array level 2 unaligned dcl 161 set ref 694
at_dev                                 parameter       char(8)                  packed unaligned dcl 871 ref 866 874 877 877 879 884
                                                                                  887
at_dev_len                      000416 automatic       fixed bin(17,0)          dcl 872 set ref 874* 875 882
at_opt                          000366 automatic       structure                level 1 unaligned dcl 719 set ref 863
att_dev_idx             106            based           fixed bin(17,0)          level 3 dcl 101 set ref 691* 691 694* 694* 697 697
                                                                                  701 703 704 706 2635 2639 2642 2646
att_sv_idx              107            based           fixed bin(17,0)          level 3 dcl 101 set ref 698* 701* 701* 704 706 2642
attach_data              54            based           structure                level 2 dcl 101 set ref 863*
attach_data_ptr          16            based           pointer                  level 2 dcl 1-9 set ref 678* 691 862 2607* 2680
attach_descrip                         based           structure                level 2 dcl 101 set ref 676
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-9 set ref 589 676* 2608* 2682
attachments                            based           structure                level 1 unaligned dcl 161 set ref 572 2651
attachments_ptr                 000010 internal static pointer                  initial dcl 170 set ref 569 572* 573 574 575 576 694
                                                                                  694 697 697 701 703 704 706 707 707 839 840 849
                                                                                  851 851 854 2633 2635 2639 2642 2646 2648 2648
                                                                                  2649 2651 2652*
b_code                                 parameter       fixed bin(35,0)          dcl 907 ref 904 909 912
based_rsr_data                         based           bit(8)                   array packed unaligned dcl 1901 set ref 1919*
bin                                                    builtin function         dcl 375 ref 1721 1726 1727 1729
bit                                                    builtin function         dcl 375 ref 797 1638 1719 1726 1727 1729 1832 2253
                                                                                  2254 2257 2259 2267 2268 2316 2978 2978
block                                  based           char                     packed unaligned dcl 267 set ref 1630 1779* 1783*
                                                                                  1806* 2303* 2321* 2321
block_count_limit               000114 automatic       fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 181 set
                                                                                  ref 1655*
block_len                       000171 automatic       fixed bin(12,0)          dcl 260 set ref 1457* 1464 1468 1470 1491* 1619 1630
                                                                                  1632 1632 1639 1722 1777 1779 1783 1806 1811 1811
                                                                                  2278* 2287* 2302* 2303 2320* 2321 2321
block_ptr                       000146 automatic       pointer                  initial dcl 252 set ref 252* 1459* 1464* 1464 1490*
                                                                                  1630 1779 1783 1806
bool                                                   builtin function         dcl 375 ref 2834
bounds                  137            based           structure                level 3 dcl 101
buf_len                 127            based           fixed bin(19,0)          level 3 dcl 101 set ref 663* 665 1447 1453* 1454
                                                                                  1482* 1483* 1603* 2769* 2771* 2774
buf_ptr                 124            based           pointer                  level 3 dcl 101 set ref 1449* 1483* 1602* 1630 1632
                                                                                  1636 1665 1691 1703 1706 1708 1721 1724 1736 1743
                                                                                  1744 1749 1749 1759 1759 1759 1759 1759 1763 1765
                                                                                  1767 1767 1772 1772 1777 1779 1796 1799 1806 1811
                                                                                  1811 1811 1825 1830 1833 1904 1906 1906 1914 1914
                                                                                  1914 1914 1919 2242 2321 2325 2771* 2776 2776
buffer                                 based           structure                level 1 unaligned dcl 198
c                        13            based           structure                array level 3 packed packed unaligned dcl 4-7
c0                        7            based           structure                level 3 in structure "thi" packed packed unaligned
                                                                                  dcl 4-7 in procedure "rdisk_"
c0                        7     000627 automatic       structure                level 3 in structure "track_header_data" packed
                                                                                  packed unaligned dcl 2861 in procedure
                                                                                  "io_call_order"
c_code                          000426 automatic       fixed bin(35,0)          dcl 907 set ref 909* 910* 911*
caller_name               1            based           char(32)                 level 2 dcl 9-10 set ref 2870* 2876* 2888* 2900*
                                                                                  2951*
cd                                     parameter       fixed bin(35,0)          dcl 2708 set ref 2705 2711* 2717* 2720
ceil                                                   builtin function         dcl 375 ref 1426 1457 1457 1481 1481 1491 1491 1639
cf                       12(28)        based           bit(8)                   level 4 in structure "thi" packed packed unaligned
                                                                                  dcl 4-7 in procedure "rdisk_" set ref 2978* 2988*
cf                       14(28)        based           bit(8)                   array level 4 in structure "thi" packed packed
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2994*
cf                                     parameter       bit(8)                   packed unaligned dcl 3008 in procedure "cond_flag"
                                                                                  ref 3004 3011 3012 3013 3014
changepack                      000600 automatic       varying char(32)         dcl 2845 set ref 2891* 2892 2892
char                                                   builtin function         dcl 375 ref 3014
chk_chr                   2(10)        based           bit(6)                   level 2 packed packed unaligned dcl 433 set ref
                                                                                  2273*
ckchar                          000570 automatic       bit(6)                   packed unaligned dcl 2829 set ref 2832* 2834* 2834
                                                                                  2836
cleanup                         000100 stack reference condition                dcl 2732 ref 2747 2750
clear_space                            parameter       bit(1)                   packed unaligned dcl 1598 ref 1595 1600
close                    36            based           entry variable           level 2 dcl 1-9 set ref 1072* 2561*
code                      0(18)        based           bit(3)                   level 2 in structure "idcw" packed packed unaligned
                                                                                  dcl 2-21 in procedure "rdisk_" set ref 1907
code                      1     000126 automatic       fixed bin(35,0)          level 2 in structure "tp_info" dcl 239 in procedure
                                                                                  "rdisk_" set ref 2811*
code                            000157 automatic       fixed bin(35,0)          dcl 255 in procedure "rdisk_" set ref 580* 583* 585*
                                                                                  611* 612 612* 631 631* 708 779* 781 791* 795* 797
                                                                                  812 812* 820* 821 893* 896* 912* 1112* 1113 1432*
                                                                                  1449* 1451 1483* 1485 1606* 1746* 1747 1751* 1753
                                                                                  1788* 1790* 1904* 1923* 2172 2182* 2184 2184* 2187
                                                                                  2187* 2462* 2476 2476* 2595* 2597* 2600* 2618
                                                                                  2618* 2675* 2720* 2739* 2741 2743* 2744 2748* 2751
                                                                                  2752* 2753 2756* 2771* 2773 2776* 2778 2780* 2781
                                                                                  2873* 2874 2878* 2881* 2892* 2897* 2898 2909* 2910
                                                                                  2936* 2937 2958*
command                                based           bit(6)                   level 2 packed packed unaligned dcl 2-21 set ref
                                                                                  1648* 1651* 1669* 1697* 1712*
command_query_                  000146 constant        entry                    external dcl 412 ref 1876
compare_sw                1(02) 000366 automatic       bit(1)                   level 2 in structure "at_opt" packed packed
                                                                                  unaligned dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 737*
compare_sw               55(02)        based           bit(1)                   level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 101 in procedure "rdisk_" set ref
                                                                                  1716 2437* 2439*
completion              125            based           structure                level 4 dcl 198
cond_name                              parameter       char                     packed unaligned dcl 2805 ref 2795 2817
cont_sw                                parameter       bit(1)                   dcl 2806 in procedure "cond_hdlr" set ref 2795 2817*
cont_sw                         000206 automatic       bit(1)                   packed unaligned dcl 264 in procedure "rdisk_" set
                                                                                  ref 1442* 1627 1709 1796 1804 1811 2277* 2285*
                                                                                  2300* 2319*
control                  66            based           entry variable           level 2 dcl 1-9 set ref 681* 2610*
control_command                 000166 automatic       bit(6)                   packed unaligned dcl 258 set ref 1712 2275* 2289*
                                                                                  2305* 2317*
control_idcw_string             000020 internal static bit(36)                  initial packed unaligned dcl 334 ref 1711 1711 1711
                                                                                  1711 1711 1711 1711 1711 1711 1711 1711 1711 1711
                                                                                  1711 1711 1711
control_idcw_template                  defined         structure                level 1 packed packed unaligned dcl 344 ref 1711
control_info                           based           structure                level 2 unaligned dcl 198
count_att                       000525 automatic       fixed bin(17,0)          dcl 2631 set ref 2632* 2635* 2639* 2639 2643
count_limit_fixed               000170 automatic       fixed bin(12,0)          dcl 260 set ref 1639* 1655
current_key             135            based           fixed bin(35,0)          level 3 dcl 101 set ref 688* 1117* 1293* 1321* 1327*
                                                                                  1359 1361 1371 1396* 1503* 1549 1571* 2243 2315
                                                                                  2573*
current_mode_name               000311 automatic       char(24)                 packed unaligned dcl 474 set ref 1056* 1057*
cv_dec_check_                   000132 constant        entry                    external dcl 406 ref 779 820 1112 2873
cyl                             000201 automatic       fixed bin(16,0)          dcl 263 set ref 1680* 1682 1683 1683 1683* 1683
                                                                                  1687* 1687 1688 1689 2244* 2246* 2253 2267
cyl_lower                 7(08)        based           fixed bin(8,0)           level 4 in structure "thi" packed packed unsigned
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2978
cyl_lower                 0(20) 000115 automatic       fixed bin(8,0)           level 2 in structure "super_seek" packed packed
                                                                                  unsigned unaligned dcl 187 in procedure "rdisk_"
                                                                                  set ref 1688*
cyl_per_dev                     000266 constant        fixed bin(17,0)          initial array dcl 6-102 in procedure "rdisk_" ref
                                                                                  644 2232
cyl_per_dev               4     000615 automatic       fixed bin(17,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2916*
cyl_upper                 0(28) 000115 automatic       fixed bin(2,0)           level 2 in structure "super_seek" packed packed
                                                                                  unsigned unaligned dcl 187 in procedure "rdisk_"
                                                                                  set ref 1689*
cyl_upper                 7(16)        based           fixed bin(2,0)           level 4 in structure "thi" packed packed unsigned
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2978
data                    135            based           char                     level 2 packed packed unaligned dcl 198 set ref
                                                                                  1630* 1632* 1721 1779 1806 1811 2242 2321
data_left                       000162 automatic       fixed bin(35,0)          dcl 255 set ref 1460* 1462 1468* 1468 1493* 1619
                                                                                  1781 1783
data_len                130            based           fixed bin(19,0)          level 3 dcl 101 set ref 665* 1454* 1457 1478 1481*
                                                                                  1482 1603* 1630 1632 1721 1779 1806 1811 2242 2321
                                                                                  2774*
data_read                       000445 automatic       fixed bin(35,0)          dcl 1617 set ref 1777* 1779 1779 1781 1783
dcw                                    based           structure                level 1 dcl 3-7 set ref 1705* 1725* 1914*
dcw_address                     000320 automatic       fixed bin(18,0)          dcl 477 set ref 1721* 1726 1730* 1730
dcw_offset                      000156 automatic       fixed bin(18,0)          dcl 254 set ref 1736* 1746* 1833*
dcwp                            000102 automatic       pointer                  dcl 3-4 set ref 1703* 1705 1706 1724* 1725 1726 1727
                                                                                  1729 1734 1911* 1914
dcwx                            000317 automatic       fixed bin(17,0)          dcl 476 set ref 1723* 1724*
default_handler_$set            000162 constant        entry                    external dcl 419 ref 673 1067 2553 2604
descrip                 111            based           char(32)                 level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 960* 973* 987* 998*
                                                                                  1012* 1025* 1036* 1048*
descrip                   1            based           char(168)                level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 597* 599* 602 604*
                                                                                  604 606 2190 2192* 2196 2198* 2685 2685
desired_key                     000334 automatic       fixed bin(17,0)          dcl 1190 set ref 1250* 1251 1251 1253 1256 1263
desired_switch_state            000534 automatic       varying char(12)         dcl 2666 set ref 2677* 2693 2696 2699
detach_iocb              26            based           entry variable           level 2 dcl 1-9 set ref 679* 1073* 2559*
detach_rcp                             parameter       bit(1)                   packed unaligned dcl 2629 set ref 2624 2633* 2645*
dev_id                          000212 automatic       char(4)                  packed unaligned dcl 269 set ref 751* 756 756 756*
                                                                                  759 759* 761 761* 762 762* 766
dev_type                        000615 automatic       char(4)                  level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2912*
dev_type                 12     000366 automatic       fixed bin(17,0)          level 2 in structure "at_opt" dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 764* 765 766* 822*
                                                                                  823 824* 826 827
dev_type                 74            based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 593 593 597 599 619
                                                                                  619 633* 634 635* 638 640 642 644 644 647 648 648
                                                                                  655 657 659 1641 1643 1651 1659 1660 1660 1676
                                                                                  1680 1681 1682 1914 2180 2229 2232 2233 2234 2244
                                                                                  2246 2248 2251 2302 2314 2320 2425 2431 2433 2445
                                                                                  2454 2458 2990 2991 3026
device                    0(06)        based           bit(6)                   level 2 packed packed unaligned dcl 2-21 set ref
                                                                                  1638* 1719* 1832*
device_att                2            based           char(8)                  array level 3 packed packed unaligned dcl 161 set
                                                                                  ref 573* 694 703* 840 2646*
device_group            103            based           fixed bin(17,0)          level 3 dcl 101 set ref 640* 655 657 1643 1645 2240
                                                                                  2282 2431 2454
device_info_table               000615 automatic       structure                level 1 dcl 2850 set ref 2909 2909
device_name               1     000615 automatic       char(8)                  level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2912*
device_name               4            based           char(8)                  level 2 in structure "disk_info" dcl 5-19
                                                                                  in procedure "rdisk_" set ref 623* 703 1914* 2230
                                                                                  2765
device_names                    000312 constant        char(4)                  initial array dcl 6-66 set ref 599 766 1914* 2229
devx                     75            based           fixed bin(17,0)          level 3 dcl 101 set ref 1449* 1483* 1746* 1904*
                                                                                  2743* 2752* 2771* 2776* 2780*
disk_data                              based           structure                level 1 unaligned dcl 101 set ref 862* 862
disk_info                              based           structure                level 1 dcl 5-19 set ref 862 2223* 2223
disk_info_ptr                   000106 automatic       pointer                  dcl 5-17 set ref 615* 616 617 617 618 619 621 623
                                                                                  624 635 862 1913* 1914 2217* 2218 2223 2228* 2230
                                                                                  2736* 2737 2739* 2743* 2752* 2765
disk_ptr                        000136 automatic       pointer                  initial dcl 252 set ref 252* 583* 585 593 593 593
                                                                                  593 597 597 597 599 599 599 602 602 604 604 604
                                                                                  606 606 611 613 615 618 619 619 624 625 626 627
                                                                                  633 634 635 638 640 640 642 642 642 644 644 644
                                                                                  647 647 648 648 648 651 651 653 655 655 655 657
                                                                                  657 657 657 659 659 662 663 663 663 665 665 669
                                                                                  676 678 688 688 688 691 694 694 697 697 698 698
                                                                                  701 701 701 703 703 704 704 706 706 706 741 862
                                                                                  863 910 911* 951 957 959 960 963 963 964 967 969
                                                                                  972 973 976 976 977 980 982 986 987 991 991 992
                                                                                  995 997 998 1001 1001 1002 1005 1007 1011 1012
                                                                                  1014 1014 1015 1018 1020 1024 1025 1029 1029 1030
                                                                                  1033 1035 1036 1039 1042 1044 1047 1048 1052 1056
                                                                                  1076 1108 1108 1115 1115 1117 1117 1119 1195 1195
                                                                                  1206 1206 1206 1208 1210 1214 1219 1219 1224 1227
                                                                                  1230 1230 1233 1233 1235 1238 1241 1245 1248 1248
                                                                                  1250 1251 1251 1253 1256 1260 1260 1263 1267 1274
                                                                                  1274 1274 1276 1276 1279 1284 1284 1284 1287 1287
                                                                                  1293 1293 1293 1313 1313 1316 1317 1319 1319 1321
                                                                                  1326 1327 1335 1335 1339 1355 1355 1359 1361 1363
                                                                                  1371 1390 1390 1390 1394 1396 1400 1404 1426 1436
                                                                                  1444 1444 1444 1447 1447 1449 1449 1449 1453 1453
                                                                                  1454 1454 1457 1457 1457 1470 1478 1478 1478 1481
                                                                                  1481 1481 1482 1482 1483 1483 1483 1491 1491 1503
                                                                                  1503 1510 1515 1515 1515 1520 1520 1530 1530 1530
                                                                                  1535 1549 1549 1549 1549 1557 1562 1571 1575 1575
                                                                                  1575 1581 1602 1603 1603 1630 1630 1632 1632 1632
                                                                                  1636 1638 1639 1641 1643 1643 1645 1651 1657 1659
                                                                                  1660 1660 1660 1665 1676 1680 1681 1682 1683 1691
                                                                                  1703 1706 1708 1716 1719 1721 1721 1724 1736 1743
                                                                                  1744 1746 1749 1749 1751 1751 1759 1759 1759 1759
                                                                                  1759 1763 1765 1767 1767 1772 1772 1777 1779 1779
                                                                                  1783 1788 1788 1796 1799 1806 1806 1811 1811 1811
                                                                                  1811 1825 1830 1832 1833 1876 1904 1904 1906 1906
                                                                                  1913 1914 1914 1914 1914 1914 1919 1921 1921 2180
                                                                                  2182 2182 2185 2189 2190 2192 2192 2196 2198 2198
                                                                                  2198 2202 2202 2209 2210 2213 2217 2228 2229 2231
                                                                                  2232 2233 2234 2236 2237 2240 2242 2242 2243 2244
                                                                                  2246 2248 2251 2282 2284 2299 2302 2314 2315 2320
                                                                                  2321 2321 2325 2393 2413 2415 2419 2420 2425 2425
                                                                                  2427 2431 2431 2431 2433 2433 2434 2437 2439 2444
                                                                                  2445 2445 2446 2450 2450 2453 2454 2454 2454 2454
                                                                                  2458 2458 2459 2518 2521 2521 2526 2526 2526 2530
                                                                                  2530 2530 2573 2573 2573 2595 2595 2597 2600*
                                                                                  2601* 2635 2639 2642 2642 2646 2680* 2685 2685
                                                                                  2711 2711 2734 2736 2737 2739 2739 2743 2743 2743
                                                                                  2743 2748 2748 2752 2752 2752 2752 2762 2766 2769
                                                                                  2769 2769 2771 2771 2771 2774 2774 2776 2776 2776
                                                                                  2780 2780 2785 2990 2991 3026
disp                            001010 automatic       picture(5)               level 2 packed packed unaligned dcl 3042 set ref
                                                                                  3053*
displacement              0(04)        parameter       fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 3040
                                                                                  ref 3053
distance                 11(16)        based           fixed bin(8,0)           array level 5 packed packed unsigned unaligned
                                                                                  dcl 4-7 set ref 2978*
divide                                                 builtin function         dcl 375 ref 663 1214 1680 1682 1689 2246 2251 2769
drive                    76            based           fixed bin(6,0)           level 3 dcl 101 set ref 741* 1638 1683 1719 1832
                                                                                  1876* 2762 2766*
drive_dec                              based           fixed dec(2,0)           dcl 290 ref 2766
drive_name                      000302 automatic       char(8)                  packed unaligned dcl 292 set ref 623 742* 809* 810
                                                                                  811* 837 840
drive_number                    000301 automatic       structure                level 1 packed packed unaligned dcl 287 set ref 2766
dv                              000403 automatic       fixed bin(17,0)          dcl 735 set ref 839* 840 849 851 851 854*
er                      125(01)        based           bit(1)                   level 5 packed packed unaligned dcl 198 set ref 1759
err_ct                          000175 automatic       fixed bin(17,0)          dcl 261 set ref 1739* 1825* 1825 1828 1852* 1852
                                                                                  1854 1856*
err_msg                                parameter       char                     packed unaligned dcl 2709 set ref 2705 2711* 2717*
err_sw                    1     000366 automatic       bit(1)                   level 2 in structure "at_opt" packed packed
                                                                                  unaligned dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 736*
err_sw                   55            based           bit(1)                   level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 101 in procedure "rdisk_" set ref
                                                                                  910 2711
error                    26            based           entry variable           level 2 dcl 9-10 ref 2870 2876 2888 2951
error_table_$action_not_performed
                                000022 external static fixed bin(35,0)          dcl 347 set ref 1062* 2756
error_table_$bad_arg            000024 external static fixed bin(35,0)          dcl 347 set ref 783* 810* 826*
error_table_$bad_conversion     000026 external static fixed bin(35,0)          dcl 347 set ref 781* 821*
error_table_$bad_mode           000030 external static fixed bin(35,0)          dcl 347 ref 2462
error_table_$device_end         000032 external static fixed bin(35,0)          dcl 347 set ref 1328* 1364* 1397* 1790
error_table_$device_parity      000034 external static fixed bin(35,0)          dcl 347 ref 1923
error_table_$end_of_info        000036 external static fixed bin(35,0)          dcl 347 set ref 1229* 1240* 1258* 1265* 1279* 1286*
                                                                                  1322* 1788
error_table_$incompatible_attach
                                000040 external static fixed bin(35,0)          dcl 347 set ref 969* 982* 1007* 1020* 1044*
error_table_$invalid_device     000042 external static fixed bin(35,0)          dcl 347 set ref 593* 638* 896
error_table_$invalid_read       000044 external static fixed bin(35,0)          dcl 347 set ref 1313*
error_table_$invalid_write      000046 external static fixed bin(35,0)          dcl 347 set ref 1357* 1392*
error_table_$no_current_record  000050 external static fixed bin(35,0)          dcl 347 set ref 1245*
error_table_$no_operation       000052 external static fixed bin(35,0)          dcl 347 set ref 1195* 1203* 1290* 1436* 2327* 2958
error_table_$no_record          000054 external static fixed bin(35,0)          dcl 347 set ref 1110* 1113* 1115* 1211* 1316* 1359*
                                                                                  1400* 1432
error_table_$noarg              000056 external static fixed bin(35,0)          dcl 347 set ref 754* 776* 807* 818* 2870* 2888*
error_table_$not_attached       000060 external static fixed bin(35,0)          dcl 347 set ref 2682* 2689*
error_table_$not_closed         000062 external static fixed bin(35,0)          dcl 347 set ref 2696*
error_table_$not_detached       000064 external static fixed bin(35,0)          dcl 347 set ref 589*
error_table_$not_open           000066 external static fixed bin(35,0)          dcl 347 set ref 2175* 2693*
error_table_$request_not_recognized
                                000070 external static fixed bin(35,0)          dcl 347 set ref 830* 1057*
error_table_$resource_assigned  000072 external static fixed bin(35,0)          dcl 347 set ref 846* 851*
error_table_$termination_requested
                                000074 external static fixed bin(35,0)          dcl 347 ref 2811
error_table_$unimplemented_version
                                000100 external static fixed bin(35,0)          dcl 347 set ref 2220 2296* 2312* 2314*
error_table_$user_not_found     000076 external static fixed bin(35,0)          dcl 347 set ref 801*
errors                   77            based           fixed bin(17,0)          level 3 dcl 101 set ref 662* 1921* 1921 2182* 2595*
                                                                                  2734*
ev_chan                  72            based           fixed bin(71,0)          level 4 dcl 101 set ref 611* 2597* 2739*
event_info                      000116 automatic       structure                level 1 dcl 226 set ref 1751 1751 2748 2748
fill                    126            based           bit(9)                   level 3 dcl 101 set ref 964* 977* 992* 1002* 1015*
                                                                                  1030* 1039* 1052* 1632 1783
first_alt_sect_num              000244 constant        fixed bin(24,0)          initial array dcl 6-130 ref 648
fixed                                                  builtin function         dcl 375 ref 1470 1736 1777 1811 1811 1833 1907 2518
                                                                                  2776 2776
flag                      0(15) 000115 automatic       bit(1)                   level 2 packed packed unaligned dcl 187 set ref
                                                                                  1679*
flags                     7            based           structure                level 4 packed packed unaligned dcl 4-7
floor                                                  builtin function         dcl 375 ref 1444 1478
fmdp                            000154 automatic       pointer                  initial dcl 252 set ref 252* 2242* 2252 2253 2254
                                                                                  2257 2259 2261 2264 2267 2268 2269 2271 2272 2273
                                                                                  2834
fmt_dta                                based           structure                level 1 dcl 433 set ref 2252*
fmt_info                               based           structure                level 1 dcl 447
fmtsum                                 based           bit(6)                   array packed unaligned dcl 2830 ref 2834
format_complete           7(02)        based           bit(1)                   level 5 packed packed unaligned dcl 4-7 set ref 2983
found                           000500 automatic       bit(1)                   dcl 1902 set ref 1904* 1919
found_dev_att                   000330 automatic       bit(1)                   packed unaligned dcl 565 set ref 609 628 691 703
                                                                                  835* 839 842 844* 862
gap_following_count       0(01)        parameter       bit(1)                   level 2 packed packed unaligned dcl 3040 ref 3050
gap_following_data        0(02)        parameter       bit(1)                   level 2 packed packed unaligned dcl 3040 ref 3051
get_chars                46            based           entry variable           level 2 dcl 1-9 set ref 962* 989*
get_system_free_area_           000102 constant        entry                    external dcl 378 ref 571
getbounds                       000612 automatic       structure                level 1 dcl 2846 set ref 2897 2897
hbound                                                 builtin function         dcl 375 ref 634 694 747 823
hcs_$delentry_seg               000124 constant        entry                    external dcl 403 ref 911 2600
hcs_$fs_get_mode                000154 constant        entry                    external dcl 416 ref 795
hcs_$initiate                   000152 constant        entry                    external dcl 414 ref 791
hcs_$make_seg                   000122 constant        entry                    external dcl 402 ref 583
hcs_$reset_ips_mask             000160 constant        entry                    external dcl 418 ref 686 1081 2571 2616
hcs_$set_ips_mask               000156 constant        entry                    external dcl 417 ref 674 1068 2554 2605
head                      7(18)        based           fixed bin(6,0)           level 4 in structure "thi" packed packed unsigned
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2978*
head                      0(30) 000115 automatic       fixed bin(6,0)           level 2 in structure "super_seek" packed packed
                                                                                  unsigned unaligned dcl 187 in procedure "rdisk_"
                                                                                  set ref 1690*
head                            000202 automatic       fixed bin(16,0)          dcl 263 in procedure "rdisk_" set ref 1681* 1682*
                                                                                  1682 1690 2249* 2251* 2254 2268
header_array                           based           bit(36)                  array packed unaligned dcl 2975 set ref 3026*
header_dumped                   000770 automatic       bit(1)                   initial packed unaligned dcl 2971 set ref 2971* 3024
                                                                                  3028*
high                    140            based           fixed bin(35,0)          level 4 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 655* 657* 659* 1115
                                                                                  1233 1238 1251 1263 1274 1276 1284 1436 1510 1549
                                                                                  1575 2210 2425* 2431* 2433* 2445* 2454* 2458*
high                      1     000612 automatic       fixed bin(35,0)          level 2 in structure "getbounds" dcl 2846
                                                                                  in procedure "io_call_order" set ref 2900*
high                      1            based           fixed bin(35,0)          level 2 in structure "user_bounds" dcl 274
                                                                                  in procedure "rdisk_" set ref 2210*
honeywell_formatted       7(01)        based           bit(1)                   level 5 packed packed unaligned dcl 4-7 set ref
                                                                                  2983*
hz                        0(32)        based           bit(2)                   level 2 in structure "fmt_dta" packed packed
                                                                                  unaligned dcl 433 in procedure "rdisk_" set ref
                                                                                  2271*
hz                                     based           bit(2)                   level 2 in structure "fmt_info" packed packed
                                                                                  unaligned dcl 447 in procedure "rdisk_" ref 2271
i                               000771 automatic       fixed bin(17,0)          dcl 2972 in procedure "print_track_header_info" set
                                                                                  ref 2993* 2994 2994 2994 2994 2994*
i                               000172 automatic       fixed bin(17,0)          dcl 261 in procedure "rdisk_" set ref 603* 604* 634*
                                                                                  635 635* 765* 766 766* 770* 772 774 776 778* 778
                                                                                  779 787 787 787 805 805 807 808* 808 809 810 816
                                                                                  818 819* 819 820* 2248* 2249 2251 2493* 2494 2496*
                                                                                  2497 2497* 2500 2501 2502 2518* 2521 2526 2526
                                                                                  2526 2530 2530 2530 2833* 2834*
idcw                                   based           structure                level 1 dcl 2-21 set ref 1637* 1711* 1714* 1716*
                                                                                  1718* 1831* 1914*
idcwp                           000100 automatic       pointer                  dcl 2-19 set ref 1636* 1637 1638 1648 1651 1669 1697
                                                                                  1708* 1711 1712 1714 1716 1718 1719 1830* 1831
                                                                                  1832 1906* 1907 1907 1909* 1909 1911 1914
index                                                  builtin function         dcl 375 ref 2189 2190 2493 2496 2518 2685
info_block                             based           char(20)                 packed unaligned dcl 456 set ref 1811*
info_ptr                               parameter       pointer                  dcl 2804 in procedure "cond_hdlr" ref 2795
info_ptr                        000152 automatic       pointer                  initial dcl 252 in procedure "rdisk_" set ref 252*
                                                                                  1811 2178* 2185 2209 2210 2213 2218 2223 2229 2230
                                                                                  2231 2232 2233 2234 2235 2236 2237 2255 2255 2257
                                                                                  2259 2261 2269 2271 2272 2274 2295 2298* 2303 2311
                                                                                  2325
io_call_info                           based           structure                level 1 dcl 9-10
io_call_infop                   000760 automatic       pointer                  dcl 9-8 set ref 2865* 2866 2868 2870 2870 2873 2876
                                                                                  2876 2876 2884 2886 2888 2888 2891 2895 2900 2900
                                                                                  2907 2912 2916 2920 2924 2928 2933 2937 2937 2937
                                                                                  2942 2944 2948 2948 2948 2951 2951 2951
io_command                      000306 automatic       varying char(8)          dcl 473 set ref 1332* 1367* 1402* 1436 1436 1499
                                                                                  1544 1568 1627 1714 1775 1796 1804 1811 2276*
                                                                                  2286* 2301* 2318*
ioa_$ioa_stream                 000144 constant        entry                    external dcl 411 ref 1919
iocb                                   based           structure                level 1 dcl 1-9
iocb_ptr                        000140 automatic       pointer                  initial dcl 252 set ref 252* 587* 589 676 678 679
                                                                                  680 681 682 684* 704 910 1079* 2569* 2607 2608
                                                                                  2610 2610 2614* 2678* 2679 2711 2717 2881* 2892*
                                                                                  2897* 2909* 2936*
ioi_$connect                    000134 constant        entry                    external dcl 407 ref 1746
ioi_$get_detailed_status        000142 constant        entry                    external dcl 410 ref 1904
ioi_$set_status                 000140 constant        entry                    external dcl 409 ref 2776
ioi_$timeout                    000114 constant        entry                    external dcl 383 ref 2780
ioi_$workspace                  000116 constant        entry                    external dcl 384 ref 1449 1483 2771
iom_stat                131            based           bit(72)                  level 4 dcl 198 set ref 1767 1767 1772 1772 1777
                                                                                  1796 1799 1811 1811 1825 1914 1914 1914 1914 2325
iox_$control                    000174 constant        entry                    external dcl 425 ref 2881 2892 2897 2909 2936
iox_$err_no_operation           000106 constant        entry                    external dcl 380 ref 2610
iox_$err_not_closed             000110 constant        entry                    external dcl 381 ref 1073
iox_$err_not_open               000112 constant        entry                    external dcl 382 ref 2561
iox_$propagate                  000126 constant        entry                    external dcl 404 ref 684 1079 2569 2614
iox_modes                       000040 constant        char(24)                 initial array dcl 8-6 ref 1056
ipc_$block                      000136 constant        entry                    external dcl 408 ref 1751 2748
ipc_$create_ev_chn              000130 constant        entry                    external dcl 405 ref 611
ipc_$delete_ev_chn              000104 constant        entry                    external dcl 379 ref 2597
is_super_seek             0(14) 000115 automatic       bit(1)                   level 2 packed packed unaligned dcl 187 set ref
                                                                                  1678*
is_sv                   104            based           bit(1)                   level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 593 642 657 1657
is_sv                    13     000366 automatic       bit(1)                   level 2 in structure "at_opt" packed packed
                                                                                  unaligned dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 745* 886* 890*
istat                   125            based           structure                level 3 dcl 198 set ref 2776 2776
j                               000173 automatic       fixed bin(17,0)          dcl 261 set ref 823* 824 824*
key                             000165 automatic       fixed bin(21,0)          dcl 257 set ref 1339* 1371* 1404* 1428 1430 1470*
                                                                                  1470 1641 1643 1659 1660 1664 1676 1680 1681 1914*
                                                                                  1914* 2243* 2244 2246 2248 2284* 2299* 2315*
key_for_insertion       136            based           fixed bin(35,0)          level 3 dcl 101 set ref 688* 2573*
label_sw                 55(05)        based           bit(1)                   level 3 packed packed unaligned dcl 101 set ref 627*
                                                                                  2415* 2420* 2450
large_records             7            based           bit(1)                   level 5 packed packed unaligned dcl 4-7 set ref
                                                                                  2983*
last_alt_sect_num               000233 constant        fixed bin(24,0)          initial array dcl 6-133 ref 648 655 1643 2431 2454
last_physical_sect_num          000222 constant        fixed bin(24,0)          initial array dcl 6-136 ref 2445
last_sect_num                   000255 constant        fixed bin(24,0)          initial array dcl 6-127 ref 659 1641 2425 2433 2458
last_sector                     000772 automatic       fixed bin(17,0)          dcl 2973 set ref 2990* 2991* 2992* 2993
length                  110            based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 959* 972* 986* 997*
                                                                                  1011* 1024* 1035* 1047*
length                                 based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 602* 604 606* 2198
                                                                                  2202* 2202
length                                                 builtin function         dcl 375 in procedure "rdisk_" ref 602 606 874 2393
                                                                                  2396
level                   126            based           fixed bin(3,0)           level 4 dcl 198 set ref 1763 1765
log_track                 7(05)        based           bit(1)                   level 5 packed packed unaligned dcl 4-7 set ref 2986
low                     137            based           fixed bin(35,0)          level 4 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 651* 653* 963 976
                                                                                  991 1001 1014 1029 1115 1219 1227 1230 1233 1251
                                                                                  1256 1260 1274 1284 1287 2209 2413* 2419* 2444*
                                                                                  2450* 2453*
low                                    based           fixed bin(35,0)          level 2 in structure "user_bounds" dcl 274
                                                                                  in procedure "rdisk_" set ref 2209*
low                             000612 automatic       fixed bin(35,0)          level 2 in structure "getbounds" dcl 2846
                                                                                  in procedure "io_call_order" set ref 2900*
ltrim                                                  builtin function         dcl 375 ref 1112 1112
maj                       0(02)        based           bit(4)                   level 2 packed packed unaligned dcl 173 ref 1767
                                                                                  1772 1799 1825
mask                                   based           structure                level 1 packed packed unaligned dcl 282
mask_str                        000277 automatic       bit(36)                  dcl 281 set ref 672* 674* 674* 686* 686* 1066* 1068*
                                                                                  1068* 1081* 1081* 2552* 2554* 2554* 2571* 2571*
                                                                                  2603* 2605* 2605* 2616* 2616* 2808
masked                    0(35)        based           bit(1)                   level 2 packed packed unaligned dcl 282 ref 2808
max                                                    builtin function         dcl 375 ref 663 1481 2769
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 9-10 ref 2873 2873 2876 2876 2876 2891
                                                                                  2891 2937 2937
max_buff_size            67            based           fixed bin(19,0)          level 3 dcl 101 set ref 663 1444 1447 1449* 1453
                                                                                  2743* 2752* 2769
max_retries                            constant        fixed bin(17,0)          initial dcl 304 ref 1828 1854
maxdevt                                constant        fixed bin(4,0)           initial dcl 6-43 ref 765
mc_ptr                                 parameter       pointer                  dcl 2804 ref 2795
media_removable                 000311 constant        bit(1)                   initial array packed unaligned dcl 6-75 ref 2180
min                                                    builtin function         dcl 375 ref 663 1335 1619 1777 2769
mod                                                    builtin function         dcl 375 ref 1208 1659 1676 1681 1682 1683 1683 1683
                                                                                  1688 2248
mode                    122            based           fixed bin(17,0)          level 3 dcl 101 set ref 951* 957 967 980 995 1005
                                                                                  1018 1033 1042 1056 1108 1108 1195 1195 1206 1206
                                                                                  1206 1293 1313 1313 1319 1319 1355 1355 1390 1390
                                                                                  1390 1515 1515 1530 1530 1549 1788 1788
mode_err_sw                     000205 automatic       bit(1)                   packed unaligned dcl 264 set ref 2409* 2464* 2467
mode_len                        000163 automatic       fixed bin(35,0)          dcl 255 set ref 2396* 2397 2487 2490 2497 2500* 2500
mode_start                      000164 automatic       fixed bin(35,0)          dcl 255 set ref 2401* 2490 2501*
mode_string             141            based           varying char(32)         level 3 dcl 101 set ref 669* 2393 2518 2521* 2521
                                                                                  2526 2526* 2526 2530 2530* 2530
model                     6            based           fixed bin(17,0)          level 2 dcl 5-19 set ref 619* 621* 635
model_number                    000304 automatic       fixed bin(17,0)          dcl 293 set ref 743* 820* 824 827*
modes                    56            based           entry variable           level 2 dcl 1-9 set ref 682* 2610*
msu0500devt                            constant        fixed bin(4,0)           initial dcl 6-43 ref 2990
msu0501devt                            constant        fixed bin(4,0)           initial dcl 6-43 ref 2991
msu4xx_info               1            based           structure                level 2 dcl 4-7 set ref 2298
msu5xx_info               7     000627 automatic       structure                level 2 in structure "track_header_data" dcl 2861
                                                                                  in procedure "io_call_order"
msu5xx_info               7            based           structure                level 2 in structure "thi" dcl 4-7 in procedure
                                                                                  "rdisk_"
name                      1            based           char(32)                 level 2 dcl 1-9 set ref 910* 2711* 2717*
nargs                    42            based           fixed bin(17,0)          level 2 dcl 9-10 ref 2868 2886 2937
nchan                    70            based           fixed bin(17,0)          level 4 dcl 101 set ref 613*
new_length                      000177 automatic       fixed bin(17,0)          dcl 261 set ref 2189* 2192 2192 2198 2202
new_modes                       000266 automatic       char(24)                 packed unaligned dcl 279 set ref 2400* 2490* 2490
                                                                                  2493 2496 2502
new_pack_id                            based           varying char(32)         dcl 272 ref 2185
new_size                               based           fixed bin(35,0)          dcl 277 ref 2213
next_key                134            based           fixed bin(35,0)          level 3 dcl 101 set ref 688* 963* 976* 991* 1001*
                                                                                  1014* 1029* 1117* 1210* 1219* 1224* 1230* 1235*
                                                                                  1241* 1245 1248 1248 1250 1253* 1260* 1267* 1274
                                                                                  1276* 1279 1284 1287* 1293 1316 1317 1326* 1339
                                                                                  1363* 1394 1400 1404 1503 1515* 1520* 1520 1530*
                                                                                  1535* 1549* 1557* 1562* 1575* 1575 1581* 2284 2299
                                                                                  2573*
next_mode                       000274 automatic       varying char(8)          initial dcl 280 set ref 280* 2403 2406 2411 2417
                                                                                  2423 2429 2437 2439 2442 2448 2474 2502* 2507*
                                                                                  2516 2518
not_sw                          000204 automatic       bit(1)                   packed unaligned dcl 264 set ref 2516* 2518 2521
                                                                                  2526 2530
null                                                   builtin function         dcl 375 ref 252 252 252 252 252 252 252 252 569 574
                                                                                  585 589 701 793 849 910 910 1602 1914 1914 2175
                                                                                  2556 2601 2607 2608 2633 2639 2642 2652 2682 2693
                                                                                  2696 2711 2711 2711 2717 2717
num_alt_sect             10     000615 automatic       fixed bin(17,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2924*
num_alt_sect            102            based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 648* 2236
num_label_sect                         constant        fixed bin(17,0)          initial dcl 322 in procedure "rdisk_" ref 653 2235
                                                                                  2413 2450
num_label_sect            7     000615 automatic       fixed bin(17,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2924*
num_opts                        000174 automatic       fixed bin(17,0)          dcl 261 set ref 603 747* 749 770 776 807 818
number                    0(09) 000301 automatic       char(2)                  level 2 packed packed unaligned dcl 287 set ref
                                                                                  2765*
number_attached                        based           fixed bin(17,0)          level 2 dcl 161 set ref 576* 707* 707 2648* 2648
                                                                                  2649
number_of_sv                    000300 constant        fixed bin(17,0)          initial array dcl 6-93 ref 593 1660
number_used               1            based           fixed bin(17,0)          level 2 dcl 161 set ref 575* 697 697* 839
offset                  127            based           fixed bin(18,0)          level 4 dcl 198 set ref 1906
old_descrip                     000214 automatic       char(168)                packed unaligned dcl 271 set ref 2196* 2198 2198
old_length                      000176 automatic       fixed bin(17,0)          dcl 261 set ref 2190* 2192 2192 2198 2198 2202
open                     32            based           entry variable           level 2 dcl 1-9 set ref 680* 1073* 2558*
open_data               122            based           structure                level 2 dcl 101
open_descrip            110            based           structure                level 2 dcl 101 set ref 1076
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-9 set ref 1076* 2175 2556* 2693 2696
options                                parameter       varying char             array dcl 563 ref 489 604 747 751 752 772 774 779
                                                                                  787 787 787 805 805 809 810 816 820
order                                  parameter       char                     packed unaligned dcl 2165 set ref 1932 2169 2175
                                                                                  2180 2207 2213 2215 2226 2240 2282 2293 2309 2325
                                                                                  2327*
order_name               11            based           char(32)                 level 2 dcl 9-10 set ref 2866 2884 2895 2907 2933
                                                                                  2948 2948 2948 2951*
overhead                               constant        fixed bin(17,0)          initial dcl 302 ref 665 1444 1454 1481 1482 2774
pack_id                  56            based           char(32)                 level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 597 599 2185* 2189
                                                                                  2192 2198 2737
pack_id                   1(09) 000366 automatic       char(32)                 level 2 in structure "at_opt" packed packed
                                                                                  unaligned dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 739* 752*
position                 62            based           entry variable           level 2 dcl 1-9 set ref 961* 974* 988* 999* 1026*
                                                                                  2561*
potential_next_sector           000336 automatic       fixed bin(21,0)          dcl 1423 set ref 1428* 1436 1510 1549 1575
pri_iocb_ptr                    000134 automatic       pointer                  dcl 251 set ref 691 854* 862
put_chars                52            based           entry variable           level 2 dcl 1-9 set ref 975* 990*
quantity                        000333 automatic       fixed bin(17,0)          dcl 1189 set ref 1201* 1208 1214* 1214 1227 1233
                                                                                  1233 1235 1238 1250 1274 1274 1276 1279 1284 1284
query_code                3     000130 automatic       fixed bin(35,0)          initial level 2 dcl 243 set ref 243*
query_info                      000130 automatic       structure                level 1 dcl 243 set ref 1876 1876
r0ccyl                    1(12)        based           bit(16)                  level 2 packed packed unaligned dcl 433 set ref
                                                                                  2257* 2267*
r0chd                     1(28)        based           bit(16)                  level 2 packed packed unaligned dcl 433 set ref
                                                                                  2259* 2268*
r0cti                     1(10)        based           bit(2)                   level 2 packed packed unaligned dcl 433 set ref
                                                                                  2261* 2264* 2269*
raw_sw                   55(03)        based           bit(1)                   level 3 packed packed unaligned dcl 101 set ref 625*
                                                                                  2446* 2459*
rcp_$attach                     000166 constant        entry                    external dcl 421 ref 2739
rcp_$check_attach               000170 constant        entry                    external dcl 422 ref 2743 2752
rcp_$detach                     000172 constant        entry                    external dcl 424 ref 2182 2595 2785
rcp_data                152            based           fixed bin(35,0)          array level 3 dcl 101 set ref 615 703 1913 2217 2228
                                                                                  2736
rcp_detachment                  000331 automatic       bit(1)                   packed unaligned dcl 566 set ref 2590* 2591* 2593
rcp_dev_type                    000006 constant        char(32)                 initial packed unaligned dcl 323 ref 2739
rcp_id                   66            based           bit(36)                  level 3 dcl 101 set ref 2182* 2595* 2739* 2743*
                                                                                  2752* 2785*
rcp_state                       000200 automatic       fixed bin(17,0)          dcl 261 set ref 2743* 2746 2752* 2754 2754
read_idcw_string                000015 internal static bit(36)                  initial packed unaligned dcl 331 ref 1714 1714 1714
                                                                                  1714 1714 1714 1714 1714 1714 1714 1714 1714 1714
                                                                                  1714 1714 1714
read_idcw_template                     defined         structure                level 1 packed packed unaligned dcl 340 ref 1714
read_record              72            based           entry variable           level 2 dcl 1-9 set ref 1000* 1027* 1037* 1049*
                                                                                  2561*
read_write_dcw_string           000021 internal static bit(36)                  initial packed unaligned dcl 335 ref 1725 1725 1725
                                                                                  1725 1725 1725 1725 1725 1725 1725
read_write_dcw_template                defined         structure                level 1 packed packed unaligned dcl 345 ref 1725
real_iocb_ptr                   000142 automatic       pointer                  initial dcl 252 set ref 252* 961 962 974 975 988 989
                                                                                  990 999 1000 1013 1026 1027 1028 1037 1038 1049
                                                                                  1050 1051 1072 1073 1073 1076 2175 2556 2558 2559
                                                                                  2561 2561 2561 2561 2561 2561 2679* 2680 2682 2693
                                                                                  2696
rec_len                         000160 automatic       fixed bin(35,0)          dcl 255 set ref 1335* 1337* 1370* 1403* 1426 1444
                                                                                  1460 1466 1478 1481 1491 1493 1504 1781 1781* 1783
                                                                                  1808*
rel                                                    builtin function         dcl 375 ref 1706 1721 1736 1833 1907 2776 2776
report                                 parameter       entry variable           dcl 2968 in procedure "print_track_header_info" ref
                                                                                  2963 2978 2983 2986 2987 2988 2994 3026
report                   22            based           entry variable           level 2 in structure "io_call_info" dcl 9-10
                                                                                  in procedure "io_call_order" set ref 2900 2912
                                                                                  2916 2920 2924 2928 2937* 2942* 2944*
residue                   1(24)        based           bit(12)                  level 2 packed packed unaligned dcl 173 ref 1777
                                                                                  1811 1811
restore_idcw_string             000012 internal static bit(36)                  initial packed unaligned dcl 328 ref 1831 1831 1831
                                                                                  1831 1831 1831 1831 1831 1831 1831 1831 1831 1831
                                                                                  1831 1831 1831
restore_idcw_template                  defined         structure                level 1 packed packed unaligned dcl 337 ref 1831
retval                          001010 automatic       structure                level 1 packed packed unaligned dcl 3042
                                                                                  in procedure "skip_mess" set ref 3055
retval                          000305 automatic       fixed bin(35,0)          dcl 396 in procedure "rdisk_" set ref 910* 1914*
                                                                                  2711* 2717*
rewrite_record          102            based           entry variable           level 2 dcl 1-9 set ref 1028* 1050* 2561*
rs_mode                         000213 automatic       fixed bin(5,0)           dcl 270 set ref 795* 797
rs_ptr                          000150 automatic       pointer                  initial dcl 252 set ref 252* 791* 793 795*
rsr_data                115            based           bit(72)                  level 3 packed packed unaligned dcl 198 set ref
                                                                                  1904* 1919
rst_idcw                               based           bit(36)                  level 3 dcl 198 set ref 1830 1833
rtrim                                                  builtin function         dcl 375 ref 602 606 874 1112 1112
run                     125(02)        based           bit(1)                   level 5 packed packed unaligned dcl 198 set ref
                                                                                  1744* 1749 1759
rw_dcw                    4            based           bit(36)                  array level 3 dcl 198 set ref 1724
rw_idcw                   3            based           bit(36)                  level 3 dcl 198 set ref 1708
rw_length                       000321 automatic       fixed bin(18,0)          dcl 478 set ref 1722* 1723 1727 1729 1731* 1731
s_code                          000417 automatic       fixed bin(35,0)          dcl 873 set ref 879* 880 884* 885
search                                                 builtin function         dcl 375 ref 887
sect_per_cyl              5     000615 automatic       fixed bin(17,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2920*
sect_per_cyl                    000211 constant        fixed bin(17,0)          initial array dcl 7-15 in procedure "rdisk_" ref 644
                                                                                  1659 1660 1680 1681 2233 2244 2246 2248
sect_per_dev              3     000615 automatic       fixed bin(35,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2916*
sect_per_dev            100            based           fixed bin(35,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 642* 644* 2231
sect_per_sv                     000200 constant        fixed bin(24,0)          initial array dcl 7-18 ref 642 657
sect_per_track                  000167 constant        fixed bin(17,0)          initial array dcl 7-33 in procedure "rdisk_" ref
                                                                                  1676 1682 2234 2251
sect_per_track            6     000615 automatic       fixed bin(17,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2920*
sect_size                11     000615 automatic       fixed bin(12,0)          level 2 in structure "device_info_table" dcl 2850
                                                                                  in procedure "io_call_order" set ref 2928*
sect_size               101            based           fixed bin(12,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 647* 1119 1208 1214
                                                                                  1426 1444 1444 1457 1457 1470 1478 1478 1481 1481
                                                                                  1491 1491 1639 2237
sector                    0(15) 000114 automatic       fixed bin(21,0)          level 2 packed packed unsigned unaligned dcl 181 set
                                                                                  ref 1660* 1664*
sector_number                   000115 automatic       fixed bin(8,0)           level 2 packed packed unsigned unaligned dcl 187 set
                                                                                  ref 1676*
sector_offset                   000446 automatic       fixed bin(17,0)          dcl 1618 set ref 1659* 1660 1660
sectors_for_record              000335 automatic       fixed bin(17,0)          dcl 1407 set ref 1426* 1428 1520 1549 1575
seek                            000114 automatic       structure                level 1 dcl 181 set ref 1654* 1665
seek_command                    000110 automatic       bit(6)                   initial array packed unaligned dcl 6-84 set ref
                                                                                  6-84* 6-84* 6-84* 6-84* 6-84* 6-84* 6-84* 6-84*
                                                                                  6-84* 1651
seek_data               114            based           structure                level 3 packed packed unaligned dcl 198 set ref
                                                                                  1665* 1691* 1706
seek_dcw_string                 000014 internal static bit(36)                  initial packed unaligned dcl 330 ref 1705 1705 1705
                                                                                  1705 1705 1705 1705 1705 1705 1705
seek_dcw_template                      defined         structure                level 1 packed packed unaligned dcl 339 ref 1705
seek_idcw_string                000013 internal static bit(36)                  initial packed unaligned dcl 329 ref 1637 1637 1637
                                                                                  1637 1637 1637 1637 1637 1637 1637 1637 1637 1637
                                                                                  1637 1637 1637
seek_idcw_template                     defined         structure                level 1 packed packed unaligned dcl 338 ref 1637
seek_key                112            based           entry variable           level 2 dcl 1-9 set ref 1038* 1051* 2561*
setsize                         000614 automatic       fixed bin(35,0)          dcl 2849 set ref 2873* 2881 2881
setup_error_msg                 000551 automatic       char(36)                 packed unaligned dcl 2673 set ref 2688* 2689*
setup_input_arg                        parameter       char                     packed unaligned dcl 2665 ref 2662 2677
sign                            000301 automatic       char(1)                  level 2 packed packed unaligned dcl 287 set ref
                                                                                  2764*
size                                                   builtin function         dcl 375 ref 862
sk_dcw                    2            based           bit(36)                  level 3 dcl 198 set ref 1703
sk_idcw                   1            based           bit(36)                  level 3 dcl 198 set ref 1636 1736
skip                      7(32) 000627 automatic       structure                array level 4 in structure "track_header_data"
                                                                                  packed packed unaligned dcl 2861 in procedure
                                                                                  "io_call_order"
skip                      7(32)        based           structure                array level 4 in structure "thi" packed packed
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2988* 2988* 2988* 2988*
skip                     13(32)        based           structure                array level 4 in structure "thi" packed packed
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2994* 2994* 2994* 2994*
skip                                   parameter       structure                level 1 packed packed unaligned dcl 3040
                                                                                  in procedure "skip_mess" ref 3036
space                     1(09) 001010 automatic       char(1)                  initial level 2 packed packed unaligned dcl 3042 set
                                                                                  ref 3042*
st                      125            based           bit(1)                   level 5 packed packed unaligned dcl 198 set ref
                                                                                  1743* 1749 1759
status                                 based           structure                level 1 packed packed unaligned dcl 173 ref 1914
                                                                                  1914 1914 1914
status_code               2     000130 automatic       fixed bin(35,0)          initial level 2 dcl 243 set ref 243*
string                                                 builtin function         dcl 375 ref 1914 1914 1914 1914 3055
sub                       0(06)        based           bit(6)                   level 2 packed packed unaligned dcl 173 ref 1767
                                                                                  1772 1796
sub_err_                        000120 constant        entry                    external dcl 387 ref 910 1914 2711 2717
substr                                                 builtin function         dcl 375 set ref 604 623 840 877 877 879 884 887
                                                                                  1630* 1630 1632 1779* 1779 1783 1806* 1806 1811*
                                                                                  1811 1914 1914 1914 1914 2190 2192* 2192 2198 2198
                                                                                  2198 2475 2490 2502 2516 2518 2526 2526* 2526 2530
                                                                                  2530* 2530 2685 2765
super_seek                      000115 automatic       structure                level 1 dcl 187 set ref 1674* 1691
suppress_name_sw          1(01) 000130 automatic       bit(1)                   initial level 2 packed packed unaligned dcl 243 set
                                                                                  ref 243*
sv                              000404 automatic       fixed bin(17,0)          dcl 735 in procedure "parse_attach_options" set ref
                                                                                  848* 849 851 851 854*
sv                        4            based           structure                array level 3 in structure "attachments" unaligned
                                                                                  dcl 161 in procedure "rdisk_"
sv_att_idx                      000524 automatic       fixed bin(17,0)          dcl 2630 set ref 2638* 2639*
sv_num                   14     000366 automatic       fixed bin(17,0)          level 2 in structure "at_opt" dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 746* 846 851 887*
                                                                                  891*
sv_num                  105            based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 593 698 706 1660
svcyl                                  based           bit(16)                  level 2 packed packed unaligned dcl 433 set ref
                                                                                  2253*
svhd                      0(16)        based           bit(16)                  level 2 packed packed unaligned dcl 433 set ref
                                                                                  2254*
sys_sw                    1(06) 000366 automatic       bit(1)                   level 2 in structure "at_opt" packed packed
                                                                                  unaligned dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 737* 797* 801
sys_sw                   55(06)        based           bit(1)                   level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 101 in procedure "rdisk_" set ref
                                                                                  618 651
system_area                            based           area(1024)               dcl 172 ref 572 2651
system_area_ptr                 000112 automatic       pointer                  dcl 171 set ref 571* 572 2651
system_flag               3            based           bit(1)                   level 2 dcl 5-19 set ref 618*
sze                      54            based           fixed bin(35,0)          level 3 in structure "disk_data" dcl 101
                                                                                  in procedure "rdisk_" set ref 663 1335 1335 2213*
                                                                                  2769
sze                             000366 automatic       fixed bin(35,0)          level 2 in structure "at_opt" dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 740* 779* 783
t_skip                   11(08)        based           structure                array level 4 packed packed unaligned dcl 4-7
tally                     0(24)        based           bit(12)                  level 2 packed packed unaligned dcl 3-7 set ref
                                                                                  1727* 1729*
temp_key                        000300 automatic       fixed bin(35,0)          dcl 286 set ref 1112* 1115 1115 1117
temp_next_mode                  000337 automatic       char(16)                 packed unaligned dcl 2389 set ref 2474* 2475* 2475
                                                                                  2476*
terminate_process_              000164 constant        entry                    external dcl 420 ref 2813
thi                                    based           structure                level 1 dcl 4-7 set ref 2321
thi_ptr                         000104 automatic       pointer                  dcl 4-4 set ref 2295* 2296 2298 2311* 2312 2316 2321
thi_version_1                          constant        fixed bin(17,0)          initial dcl 4-5 ref 2296 2312 2935
thip                                   parameter       pointer                  dcl 2969 ref 2963 2978 2978 2978 2978 2978 2978 2978
                                                                                  2978 2978 2978 2978 2978 2978 2983 2983 2983 2986
                                                                                  2988 2988 2988 2988 2988 2994 2994 2994 2994 2994
                                                                                  3026
this_iocbp                6            based           pointer                  array level 4 dcl 161 set ref 574* 701 704* 849 854
                                                                                  2639 2642*
this_sv                   4            based           fixed bin(17,0)          array level 4 dcl 161 set ref 706* 851 851 2635
ti                        0(12) 000114 automatic       bit(2)                   level 2 in structure "seek" packed packed unaligned
                                                                                  dcl 181 in procedure "rdisk_" set ref 1656*
ti                        7(06)        based           fixed bin(2,0)           level 5 in structure "thi" packed packed unsigned
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2978 2978
ti                        0(34)        based           bit(2)                   level 2 in structure "fmt_dta" packed packed
                                                                                  unaligned dcl 433 in procedure "rdisk_" set ref
                                                                                  2272*
ti                        0(02)        based           bit(2)                   level 2 in structure "fmt_info" packed packed
                                                                                  unaligned dcl 447 in procedure "rdisk_" ref 2255
                                                                                  2255 2261 2269 2272 2274
ti                        0(12) 000115 automatic       bit(2)                   level 2 in structure "super_seek" packed packed
                                                                                  unaligned dcl 187 in procedure "rdisk_" set ref
                                                                                  1677*
ti                        1(34)        based           fixed bin(2,0)           level 3 in structure "thi" packed packed unsigned
                                                                                  unaligned dcl 4-7 in procedure "rdisk_" set ref
                                                                                  2316
time_int                132            based           fixed bin(71,0)          level 3 dcl 101 set ref 2743* 2752* 2780
time_out                125(03)        based           bit(1)                   level 5 packed packed unaligned dcl 198 set ref 1759
                                                                                  1759
timer_manager_$sleep            000150 constant        entry                    external dcl 413 ref 1860
tot_rec_len                     000161 automatic       fixed bin(35,0)          dcl 255 set ref 1440* 1466* 1466 1504 1506
tp_info                         000126 automatic       structure                level 1 unaligned dcl 239 set ref 2813 2813
track_header_data               000627 automatic       structure                level 1 unaligned dcl 2861 set ref 2936 2936 2937
                                                                                  2937 2942 2942 2944 2944
track_indicators                000167 automatic       bit(2)                   initial packed unaligned dcl 259 set ref 259* 1443*
                                                                                  1656 1677 2274* 2288* 2304* 2316*
true_len                        000444 automatic       fixed bin(35,0)          dcl 1617 set ref 1619* 1630 1630 1632 1632 1632 1777
                                                                                  1806 1806 1808
type                            000332 automatic       fixed bin(17,0)          dcl 1187 in procedure "rdisk_" set ref 1199* 1203
                                                                                  1203 1217 1222 1227 1233 1238 1245 1248 1274 1279
                                                                                  1284
type                      1(18) 001010 automatic       char(2)                  level 2 in structure "retval" packed packed
                                                                                  unaligned dcl 3042 in procedure "skip_mess" set
                                                                                  ref 3050* 3051* 3052*
type                      0(22)        based           bit(2)                   level 2 in structure "dcw" packed packed unaligned
                                                                                  dcl 3-7 in procedure "rdisk_" set ref 1734*
ubuf_ptr                        000144 automatic       pointer                  initial dcl 252 set ref 252* 1441* 1459 1490
unique_chars_                   000176 constant        entry                    external dcl 484 ref 582
unique_entry_name               000322 automatic       char(22)                 packed unaligned dcl 485 set ref 582* 583*
unspec                                                 builtin function         dcl 375 set ref 1632* 1654* 1665* 1665 1674* 1691*
                                                                                  1691 1783* 2303*
usage_time                1            based           fixed bin(17,0)          level 2 dcl 5-19 set ref 617*
used                                   parameter       bit(1)                   level 2 packed packed unaligned dcl 3040 ref 3048
user_bounds                            based           structure                level 1 unaligned dcl 274
user_cyl_per_dev          4            based           fixed bin(17,0)          level 2 dcl 459 set ref 2232*
user_dev_char_table                    based           structure                level 1 dcl 459
user_device_name          1            based           char(8)                  level 2 dcl 459 set ref 2230*
user_hardware_status                   based           bit(72)                  packed unaligned dcl 471 set ref 2325*
user_num_alt_sect        10            based           fixed bin(17,0)          level 2 dcl 459 set ref 2236*
user_num_label_sect       7            based           fixed bin(17,0)          level 2 dcl 459 set ref 2235*
user_sect_per_cyl         5            based           fixed bin(17,0)          level 2 dcl 459 set ref 2233*
user_sect_per_dev         3            based           fixed bin(35,0)          level 2 dcl 459 set ref 2231*
user_sect_per_track       6            based           fixed bin(17,0)          level 2 dcl 459 set ref 2234*
user_sect_size           11            based           fixed bin(12,0)          level 2 dcl 459 set ref 2237*
user_subsystem_name                    based           char(4)                  level 2 dcl 459 set ref 2229*
valid_sv_string                 000277 constant        char(3)                  initial packed unaligned dcl 6-96 ref 884 887
verify                                                 builtin function         dcl 375 ref 879 884
version                         000126 automatic       fixed bin(17,0)          level 2 in structure "tp_info" dcl 239 in procedure
                                                                                  "rdisk_" set ref 2810*
version                         000627 automatic       fixed bin(17,0)          level 2 in structure "track_header_data" dcl 2861
                                                                                  in procedure "io_call_order" set ref 2935*
version                                based           fixed bin(17,0)          level 2 in structure "thi" dcl 4-7 in procedure
                                                                                  "rdisk_" set ref 2296 2312
version                         000130 automatic       fixed bin(17,0)          initial level 2 in structure "query_info" dcl 243
                                                                                  in procedure "rdisk_" set ref 243*
version_num                            based           fixed bin(17,0)          level 2 dcl 5-19 set ref 616* 2218 2218
volume_name               7            based           char(32)                 level 2 dcl 5-19 set ref 2737*
wait_list                70            based           structure                level 3 dcl 101 set ref 1751 1751 2748 2748
wait_time                 2            based           fixed bin(17,0)          level 2 dcl 5-19 set ref 617*
wc_mc_ptr                              parameter       pointer                  dcl 2804 ref 2795
who_did_the_attach              000540 automatic       varying char(32)         dcl 2672 set ref 2685* 2686 2688
words_per_sect                  000156 constant        fixed bin(17,0)          initial array dcl 7-36 ref 647
write_and_compare_idcw_string   000017 internal static bit(36)                  initial packed unaligned dcl 333 ref 1716 1716 1716
                                                                                  1716 1716 1716 1716 1716 1716 1716 1716 1716 1716
                                                                                  1716 1716 1716
write_and_compare_idcw_template        defined         structure                level 1 packed packed unaligned dcl 342 ref 1716
write_flag               17            based           bit(1)                   level 2 dcl 5-19 set ref 624*
write_idcw_string               000016 internal static bit(36)                  initial packed unaligned dcl 332 ref 1718 1718 1718
                                                                                  1718 1718 1718 1718 1718 1718 1718 1718 1718 1718
                                                                                  1718 1718 1718
write_idcw_template                    defined         structure                level 1 packed packed unaligned dcl 341 ref 1718
write_record             76            based           entry variable           level 2 dcl 1-9 set ref 1013* 2561*
write_sw                 55(01)        based           bit(1)                   level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 101 in procedure "rdisk_" set ref
                                                                                  624 969 982 1007 1020 1044
write_sw                  1(01) 000366 automatic       bit(1)                   level 2 in structure "at_opt" packed packed
                                                                                  unaligned dcl 719 in procedure
                                                                                  "parse_attach_options" set ref 737* 772*
yes_or_no_sw              1     000130 automatic       bit(1)                   initial level 2 packed packed unaligned dcl 243 set
                                                                                  ref 243*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_output                          internal static fixed bin(17,0)          initial dcl 8-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 8-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 8-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 8-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 8-15
bulkdevt                               internal static fixed bin(4,0)           initial dcl 6-43
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 6-105
dev_time                               internal static float bin(27)            initial array dcl 6-139
dsu181devt                             internal static fixed bin(4,0)           initial dcl 6-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 6-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 6-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 6-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 6-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 6-72
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 6-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 6-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 6-124
io_call_af_ret                         based           varying char             dcl 9-25
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-64
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 6-118
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 6-121
msu0400devt                            internal static fixed bin(4,0)           initial dcl 6-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 6-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 6-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 6-81
pcw                                    based           structure                level 1 dcl 2-6
pcwp                                   automatic       pointer                  dcl 2-4
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 6-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 6-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 6-90
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 7-21
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 7-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 6-78
short_iox_modes                        internal static char(4)                  initial array dcl 8-12
tdcw                                   based           structure                level 1 dcl 3-14
tdcwp                                  automatic       pointer                  dcl 3-4
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 6-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 6-99
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 7-29

NAMES DECLARED BY EXPLICIT CONTEXT.
BUILD_ALT_SEEK                  000003 constant        label                    array(3) dcl 1651 ref 1643
BUILD_NORMAL_SEEK               012300 constant        label                    dcl 1651 ref 1641
BUILD_SUPER_SEEK                012351 constant        label                    dcl 1674 ref 1700
BUILD_TANDD_SEEK                000000 constant        label                    array(3) dcl 1648 ref 1645
SEEK_BUILT                      012454 constant        label                    dcl 1703 ref 1666 1692
att_err                         012022 constant        entry                    internal dcl 904 ref 589 593 612 631 638 754 776 781
                                                                                  801 807 810 812 818 821 826 830 846 851
check_dev                       011717 constant        entry                    internal dcl 866 ref 811
cksum                           015466 constant        entry                    internal dcl 2824 ref 2273
cond_flag                       017221 constant        entry                    internal dcl 3004 ref 2978 2988 2994
cond_hdlr                       015407 constant        entry                    internal dcl 2795 ref 673 673 1067 1067 2553 2553
                                                                                  2604 2604
delay_retry                     013422 constant        entry                    internal dcl 1845 ref 1767
delete_attach                   014204 constant        entry                    internal dcl 2624 ref 2591
detach                          015344 constant        entry                    internal dcl 2783 ref 2747
do_io                           012152 constant        entry                    internal dcl 1614 ref 1463 1494 2279 2290 2306 2322
dump_header                     017312 constant        entry                    internal dcl 3020 ref 2998
error                           014551 constant        entry                    internal dcl 2705 ref 585 783 969 982 1007 1020 1044
                                                                                  1057 1062 1110 1113 1115 1195 1203 1211 1229 1240
                                                                                  1245 1258 1265 1279 1286 1290 1313 1316 1322 1328
                                                                                  1357 1359 1364 1392 1397 1400 1436 1606 2175 2184
                                                                                  2187 2296 2312 2314 2327 2476 2618 2682 2689 2693
                                                                                  2696
exit                            003457 constant        label                    dcl 708 ref 913 1924 2722
get_next_mode                   013762 constant        entry                    internal dcl 2484 ref 2405
invalid_device                  012016 constant        label                    dcl 896 ref 875 877 880 885
io_call_order                   015516 constant        entry                    internal dcl 2842 ref 2171
io_err                          012120 constant        entry                    internal dcl 1595 ref 1433 1451 1485 1747 1753 1794
io_succeeded                    006340 constant        label                    dcl 1499
loud_retry                      013451 constant        entry                    internal dcl 1871 ref 1770 1857
mount                           014740 constant        entry                    internal dcl 2730 ref 630 2186
parse_attach_options            010602 constant        entry                    internal dcl 712 ref 591
perm_err                        013524 constant        entry                    internal dcl 1893 ref 1763 1797 1837 1884
print_track_header_info         016474 constant        entry                    internal dcl 2963 ref 2937 2942 2944
rdisk_                          002332 constant        entry                    external dcl 33
rdisk_attach                    002346 constant        entry                    external dcl 489
rdisk_close                     010227 constant        entry                    external dcl 2542 ref 1072
rdisk_control                   006510 constant        entry                    external dcl 1932 ref 681
rdisk_detach                    010365 constant        entry                    external dcl 2582 ref 679 2559
rdisk_modes                     007672 constant        entry                    external dcl 2339 ref 682
rdisk_open                      003467 constant        entry                    external dcl 922 ref 680 2558
rdisk_position                  004505 constant        entry                    external dcl 1127 ref 961 974 988 999 1026
rdisk_read                      005264 constant        entry                    external dcl 1302 ref 962 989 1000 1027 1037 1049
rdisk_rewrite                   005465 constant        entry                    external dcl 1342 ref 1028 1050
rdisk_seek                      004261 constant        entry                    external dcl 1090 ref 1038 1051
rdisk_write                     005622 constant        entry                    external dcl 1374 ref 975 990 1013
read_write_common               005757 constant        label                    dcl 1407 ref 1340 1372 1405
retry                           013336 constant        entry                    internal dcl 1822 ref 1759 1765 1799 1862 1882
set_mode                        014046 constant        entry                    internal dcl 2513 ref 2467
setup                           014327 constant        entry                    internal dcl 2662 ref 948 1107 1192 1311 1353 1388
                                                                                  2168 2391 2550 2589
skip_mess                       017362 constant        entry                    internal dcl 3036 ref 2988 2988 2988 2988 2994 2994
                                                                                  2994 2994

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     21004       21204   20007       21014
Length     22052   20007       200         631     775          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rdisk_                             1093 external procedure  is an external procedure.  
parse_attach_options                    internal procedure  shares stack frame of external procedure rdisk_.  
check_dev                               internal procedure  shares stack frame of external procedure rdisk_.  
att_err                                 internal procedure  shares stack frame of external procedure rdisk_.  
io_err                                  internal procedure  shares stack frame of external procedure rdisk_.  
do_io                                   internal procedure  shares stack frame of external procedure rdisk_.  
retry                                   internal procedure  shares stack frame of external procedure rdisk_.  
delay_retry                             internal procedure  shares stack frame of external procedure rdisk_.  
loud_retry                              internal procedure  shares stack frame of external procedure rdisk_.  
perm_err                                internal procedure  shares stack frame of external procedure rdisk_.  
get_next_mode                           internal procedure  shares stack frame of external procedure rdisk_.  
set_mode                                internal procedure  shares stack frame of external procedure rdisk_.  
delete_attach                           internal procedure  shares stack frame of external procedure rdisk_.  
setup                                   internal procedure  shares stack frame of external procedure rdisk_.  
error                               106 internal procedure  is called during a stack extension.  
mount                               144 internal procedure  enables or reverts conditions.  
on unit on line 2747                 96 on unit               
detach                                  internal procedure  shares stack frame of on unit on line 2747.  
cond_hdlr                            82 internal procedure  is assigned to an entry variable.  
cksum                                   internal procedure  shares stack frame of external procedure rdisk_.  
io_call_order                           internal procedure  shares stack frame of external procedure rdisk_.  
print_track_header_info                 internal procedure  shares stack frame of external procedure rdisk_.  
cond_flag                           226 internal procedure  uses returns(char(*)) or returns(bit(*)).  
dump_header                             internal procedure  shares stack frame of external procedure rdisk_.  
skip_mess                               internal procedure  shares stack frame of external procedure rdisk_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 attachments_ptr             rdisk_
000012 restore_idcw_string         rdisk_
000013 seek_idcw_string            rdisk_
000014 seek_dcw_string             rdisk_
000015 read_idcw_string            rdisk_
000016 write_idcw_string           rdisk_
000017 write_and_compare_idcw_string
                                   rdisk_
000020 control_idcw_string         rdisk_
000021 read_write_dcw_string       rdisk_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rdisk_                   000100 idcwp                       rdisk_
                         000102 dcwp                        rdisk_
                         000104 thi_ptr                     rdisk_
                         000106 disk_info_ptr               rdisk_
                         000110 seek_command                rdisk_
                         000112 system_area_ptr             rdisk_
                         000114 seek                        rdisk_
                         000115 super_seek                  rdisk_
                         000116 event_info                  rdisk_
                         000126 tp_info                     rdisk_
                         000130 query_info                  rdisk_
                         000134 pri_iocb_ptr                rdisk_
                         000136 disk_ptr                    rdisk_
                         000140 iocb_ptr                    rdisk_
                         000142 real_iocb_ptr               rdisk_
                         000144 ubuf_ptr                    rdisk_
                         000146 block_ptr                   rdisk_
                         000150 rs_ptr                      rdisk_
                         000152 info_ptr                    rdisk_
                         000154 fmdp                        rdisk_
                         000156 dcw_offset                  rdisk_
                         000157 code                        rdisk_
                         000160 rec_len                     rdisk_
                         000161 tot_rec_len                 rdisk_
                         000162 data_left                   rdisk_
                         000163 mode_len                    rdisk_
                         000164 mode_start                  rdisk_
                         000165 key                         rdisk_
                         000166 control_command             rdisk_
                         000167 track_indicators            rdisk_
                         000170 count_limit_fixed           rdisk_
                         000171 block_len                   rdisk_
                         000172 i                           rdisk_
                         000173 j                           rdisk_
                         000174 num_opts                    rdisk_
                         000175 err_ct                      rdisk_
                         000176 old_length                  rdisk_
                         000177 new_length                  rdisk_
                         000200 rcp_state                   rdisk_
                         000201 cyl                         rdisk_
                         000202 head                        rdisk_
                         000203 again                       rdisk_
                         000204 not_sw                      rdisk_
                         000205 mode_err_sw                 rdisk_
                         000206 cont_sw                     rdisk_
                         000210 answer                      rdisk_
                         000212 dev_id                      rdisk_
                         000213 rs_mode                     rdisk_
                         000214 old_descrip                 rdisk_
                         000266 new_modes                   rdisk_
                         000274 next_mode                   rdisk_
                         000277 mask_str                    rdisk_
                         000300 temp_key                    rdisk_
                         000301 drive_number                rdisk_
                         000302 drive_name                  rdisk_
                         000304 model_number                rdisk_
                         000305 retval                      rdisk_
                         000306 io_command                  rdisk_
                         000311 current_mode_name           rdisk_
                         000317 dcwx                        rdisk_
                         000320 dcw_address                 rdisk_
                         000321 rw_length                   rdisk_
                         000322 unique_entry_name           rdisk_
                         000330 found_dev_att               rdisk_
                         000331 rcp_detachment              rdisk_
                         000332 type                        rdisk_
                         000333 quantity                    rdisk_
                         000334 desired_key                 rdisk_
                         000335 sectors_for_record          rdisk_
                         000336 potential_next_sector       rdisk_
                         000337 temp_next_mode              rdisk_
                         000366 at_opt                      parse_attach_options
                         000403 dv                          parse_attach_options
                         000404 sv                          parse_attach_options
                         000416 at_dev_len                  check_dev
                         000417 s_code                      check_dev
                         000426 c_code                      att_err
                         000444 true_len                    do_io
                         000445 data_read                   do_io
                         000446 sector_offset               do_io
                         000500 found                       perm_err
                         000524 sv_att_idx                  delete_attach
                         000525 count_att                   delete_attach
                         000534 desired_switch_state        setup
                         000540 who_did_the_attach          setup
                         000551 setup_error_msg             setup
                         000570 ckchar                      cksum
                         000600 changepack                  io_call_order
                         000612 getbounds                   io_call_order
                         000614 setsize                     io_call_order
                         000615 device_info_table           io_call_order
                         000627 track_header_data           io_call_order
                         000760 io_call_infop               io_call_order
                         000770 header_dumped               print_track_header_info
                         000771 i                           print_track_header_info
                         000772 last_sector                 print_track_header_info
                         001010 retval                      skip_mess

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       return_mac          tra_ext_1           mpfx2
mdfx1               enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc      trunc_fx2           ceil_fx2            floor_fx2           set_chars_eis       index_chars_eis
return_chars_eis    search_eis          any_to_any_truncate_divide_fx1          divide_fx3          op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                cv_dec_check_                 default_handler_$set          get_system_free_area_
hcs_$delentry_seg             hcs_$fs_get_mode              hcs_$initiate                 hcs_$make_seg
hcs_$reset_ips_mask           hcs_$set_ips_mask             ioa_$ioa_stream               ioi_$connect
ioi_$get_detailed_status      ioi_$set_status               ioi_$timeout                  ioi_$workspace
iox_$control                  iox_$err_no_operation         iox_$err_not_closed           iox_$err_not_open
iox_$propagate                ipc_$block                    ipc_$create_ev_chn            ipc_$delete_ev_chn
rcp_$attach                   rcp_$check_attach             rcp_$detach                   sub_err_
terminate_process_            timer_manager_$sleep          unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$bad_conversion
error_table_$bad_mode         error_table_$device_end       error_table_$device_parity    error_table_$end_of_info
error_table_$incompatible_attach                            error_table_$invalid_device   error_table_$invalid_read
error_table_$invalid_write    error_table_$no_current_record                              error_table_$no_operation
error_table_$no_record        error_table_$noarg            error_table_$not_attached     error_table_$not_closed
error_table_$not_detached     error_table_$not_open         error_table_$request_not_recognized
error_table_$resource_assigned                              error_table_$termination_requested
error_table_$unimplemented_version                          error_table_$user_not_found


CONSTANTS
017442  aa  104 070 321 000	D8

017444  aa     000002000000
017445  aa     000000000000
017446  aa     600000000041
017447  aa     001326000000

017450  aa     000002000000
017451  aa     000000000000
017452  aa     600000000041
017453  aa     001303000000

017454  aa     377777777777

017455  aa     777777747777

017456  aa     000007777777

017457  aa  777 777 777 777	
017460  aa  777 777 777 777	
017461  aa  777 777 777 777	
017462  aa  777 777 777 777	
017463  aa  777 777 777 777	
017464  aa  777 777 777 777	
017465  aa  777 777 777 777	
017466  aa  777 777 777 777	
017467  aa  777 777 777 777	
017470  aa  777 777 777 777	
017471  aa  777 777 777 777	
017472  aa  777 777 777 777	
017473  aa  000 000 000 000	    
017474  aa  000 000 000 000	    
017475  aa  000 000 777 777	  
017476  aa  777 777 777 777	
017477  aa  777 777 777 777	
017500  aa  777 777 777 777	
017501  aa  777 777 777 777	
017502  aa  777 777 777 777	
017503  aa  777 777 777 777	
017504  aa  777 777 777 777	
017505  aa  777 777 777 777	
017506  aa  777 777 777 777	
017507  aa  777 777 777 777	
017510  aa  777 777 777 777	
017511  aa  777 777 777 777	
017512  aa  777 777 777 777	
017513  aa  777 777 777 777	
017514  aa  777 777 777 777	
017515  aa  777 777 777 777	
017516  aa  777 777 777 777	
017517  aa  777 777 777 777	
017520  aa  777 777 777 777	
017521  aa  777 777 777 777	
017522  aa  777 777 777 777	
017523  aa  777 777 777 777	
017524  aa  777 777 777 777	
017525  aa  777 777 777 777	
017526  aa  777 777 777 777	
017527  aa  777 777 777 777	
017530  aa  777 777 777 777	
017531  aa  777 777 777 777	
017532  aa  777 777 777 777	
017533  aa  777 777 777 777	
017534  aa  777 777 777 777	
017535  aa  777 777 777 777	
017536  aa  777 777 777 777	
017537  aa  777 777 777 777	
017540  aa  777 777 777 777	
017541  aa  777 777 777 777	
017542  aa  777 777 777 777	
017543  aa  777 777 777 777	
017544  aa  777 777 777 777	
017545  aa  777 777 777 777	
017546  aa  777 777 777 777	
017547  aa  777 777 777 777	
017550  aa  777 777 777 777	
017551  aa  777 777 777 777	
017552  aa  777 777 777 777	
017553  aa  777 777 777 777	
017554  aa  777 777 777 777	
017555  aa  777 777 777 777	
017556  aa  777 777 777 777	
017557  aa  777 777 777 777	
017560  aa  777 777 777 777	
017561  aa  777 777 777 777	
017562  aa  777 777 777 777	
017563  aa  777 777 777 777	
017564  aa  777 777 777 777	
017565  aa  777 777 777 777	
017566  aa  777 777 777 777	
017567  aa  777 777 777 777	
017570  aa  777 777 777 777	
017571  aa  777 777 777 777	
017572  aa  777 777 777 777	
017573  aa  777 777 777 777	
017574  aa  777 777 777 777	
017575  aa  777 777 777 777	
017576  aa  777 777 777 777	
017577  aa  777 777 777 777	
017600  aa  777 777 777 777	
017601  aa  777 777 777 777	
017602  aa  777 777 777 777	
017603  aa  777 777 777 777	
017604  aa  777 777 777 777	
017605  aa  777 777 777 777	
017606  aa  777 777 777 777	
017607  aa  777 777 777 777	
017610  aa  777 777 777 777	
017611  aa  777 777 777 777	
017612  aa  777 777 777 777	
017613  aa  777 777 777 777	
017614  aa  777 777 777 777	
017615  aa  777 777 777 777	
017616  aa  777 777 777 777	
017617  aa  777 777 777 777	
017620  aa  777 777 777 777	
017621  aa  777 777 777 777	
017622  aa  777 777 777 777	
017623  aa  777 777 777 777	
017624  aa  777 777 777 777	
017625  aa  777 777 777 777	
017626  aa  777 777 777 777	
017627  aa  777 777 777 777	
017630  aa  777 777 777 777	
017631  aa  777 777 777 777	
017632  aa  777 777 777 777	
017633  aa  777 777 777 777	
017634  aa  777 777 777 777	
017635  aa  777 777 777 777	
017636  aa  777 777 777 777	
017637  aa  777 777 777 777	
017640  aa  777 777 777 777	
017641  aa  777 777 777 777	
017642  aa  777 777 777 777	
017643  aa  777 777 777 777	
017644  aa  777 777 777 777	
017645  aa  777 777 777 777	
017646  aa  777 777 777 777	
017647  aa  777 777 777 777	
017650  aa  777 777 777 777	
017651  aa  777 777 777 777	
017652  aa  777 777 777 777	
017653  aa  777 777 777 777	
017654  aa  777 777 777 777	
017655  aa  777 777 777 777	
017656  aa  777 777 777 777	

017660  aa     000002000000
017661  aa     000000000000
017662  aa     600000000041
017663  aa     000302000000

017664  aa     773777777777

017666  aa     000002000000
017667  aa     000000000000
017670  aa     600000000041
017671  aa     000331000000

017672  aa     000002000000
017673  aa     000002000000
017674  aa     600000000041
017675  aa     001110000000
017676  ta     000505000000
017677  aa     000000000000

017700  aa     677777777777

017701  aa     767777777777

017702  aa     000000000377
017703  aa     776000000000

017704  aa     000077777400

017705  aa     000003777760

017706  aa     777774000377

017707  aa     777403777777

017710  aa     776377777777

017712  aa     777777777400
017713  aa     001777777777

017714  aa     777700000377

017715  aa     777477777777

017716  aa     000377777777

017717  aa     777777777774

017720  aa     777777777763

017721  aa     777774000017

017722  aa     000003777777

017724  aa     000002000000
017725  aa     000002000000
017726  aa     600000000041
017727  aa     001014000000
017730  ta     000455000000
017731  aa     000000000000

017732  aa     000002000000
017733  aa     000000000000
017734  aa     600000000041
017735  aa     001034000000

017736  aa     000002000000
017737  aa     000002000000
017740  aa     600000000041
017741  aa     001034000000
017742  ta     000476000000
017743  aa     000000000000

017744  aa     000002000000
017745  aa     000002000000
017746  aa     600000000041
017747  aa     001021000000
017750  ta     000476000000
017751  aa     000000000000

017752  aa     000002000000
017753  aa     000002000000
017754  aa     600000000041
017755  aa     001070000000
017756  ta     000505000000
017757  aa     000000000000

017760  aa     077777000043
017761  aa     000001000000

017762  aa     757777777777

017763  aa     737777777777

017764  aa     000002000000
017765  aa     000000000000
017766  aa     600000000041
017767  aa     000157000000

017770  aa     577777777777

017772  aa     777777777773

000006  aa  144 151 163 153	disk
000007  aa  137 144 162 151	_dri
000010  aa  166 145 040 040	ve  
000011  aa  040 040 040 040	    
000012  aa  040 040 040 040	    
000013  aa  040 040 040 040	    
000014  aa  040 040 040 040	    
000015  aa  040 040 040 040	    

000016  aa     000000000000
000017  aa     000000000130
000020  aa     000000000006
000021  aa     000000000006
000022  aa     000000000006
000023  aa     000000000006
000024  aa     000000000030
000025  aa     000000000030
000026  aa     000000000030

000027  aa     000000000000
000030  aa     000000000002
000031  aa     000000000001
000032  aa     000000000001
000033  aa     000000000001
000034  aa     000000000001
000035  aa     000000000002
000036  aa     000000000003
000037  aa     000000000003

000040  aa  163 164 162 145	stre
000041  aa  141 155 137 151	am_i
000042  aa  156 160 165 164	nput
000043  aa  040 040 040 040	    
000044  aa  040 040 040 040	    
000045  aa  040 040 040 040	    
000046  aa  163 164 162 145	stre
000047  aa  141 155 137 157	am_o
000050  aa  165 164 160 165	utpu
000051  aa  164 040 040 040	t   
000052  aa  040 040 040 040	    
000053  aa  040 040 040 040	    
000054  aa  163 164 162 145	stre
000055  aa  141 155 137 151	am_i
000056  aa  156 160 165 164	nput
000057  aa  137 157 165 164	_out
000060  aa  160 165 164 040	put 
000061  aa  040 040 040 040	    
000062  aa  163 145 161 165	sequ
000063  aa  145 156 164 151	enti
000064  aa  141 154 137 151	al_i
000065  aa  156 160 165 164	nput
000066  aa  040 040 040 040	    
000067  aa  040 040 040 040	    
000070  aa  163 145 161 165	sequ
000071  aa  145 156 164 151	enti
000072  aa  141 154 137 157	al_o
000073  aa  165 164 160 165	utpu
000074  aa  164 040 040 040	t   
000075  aa  040 040 040 040	    
000076  aa  163 145 161 165	sequ
000077  aa  145 156 164 151	enti
000100  aa  141 154 137 151	al_i
000101  aa  156 160 165 164	nput
000102  aa  137 157 165 164	_out
000103  aa  160 165 164 040	put 
000104  aa  163 145 161 165	sequ
000105  aa  145 156 164 151	enti
000106  aa  141 154 137 165	al_u
000107  aa  160 144 141 164	pdat
000110  aa  145 040 040 040	e   
000111  aa  040 040 040 040	    
000112  aa  153 145 171 145	keye
000113  aa  144 137 163 145	d_se
000114  aa  161 165 145 156	quen
000115  aa  164 151 141 154	tial
000116  aa  137 151 156 160	_inp
000117  aa  165 164 040 040	ut  
000120  aa  153 145 171 145	keye
000121  aa  144 137 163 145	d_se
000122  aa  161 165 145 156	quen
000123  aa  164 151 141 154	tial
000124  aa  137 157 165 164	_out
000125  aa  160 165 164 040	put 
000126  aa  153 145 171 145	keye
000127  aa  144 137 163 145	d_se
000130  aa  161 165 145 156	quen
000131  aa  164 151 141 154	tial
000132  aa  137 165 160 144	_upd
000133  aa  141 164 145 040	ate 
000134  aa  144 151 162 145	dire
000135  aa  143 164 137 151	ct_i
000136  aa  156 160 165 164	nput
000137  aa  040 040 040 040	    
000140  aa  040 040 040 040	    
000141  aa  040 040 040 040	    
000142  aa  144 151 162 145	dire
000143  aa  143 164 137 157	ct_o
000144  aa  165 164 160 165	utpu
000145  aa  164 040 040 040	t   
000146  aa  040 040 040 040	    
000147  aa  040 040 040 040	    
000150  aa  144 151 162 145	dire
000151  aa  143 164 137 165	ct_u
000152  aa  160 144 141 164	pdat
000153  aa  145 040 040 040	e   
000154  aa  040 040 040 040	    
000155  aa  040 040 040 040	    

000156  aa     000000000000
000157  aa     000000000100
000160  aa     000000000100
000161  aa     000000000100
000162  aa     000000000100
000163  aa     000000000100
000164  aa     000000000100
000165  aa     000000001000
000166  aa     000000001000

000167  aa     000000000000
000170  aa     000000000050
000171  aa     000000000050
000172  aa     000000000050
000173  aa     000000000037
000174  aa     000000000022
000175  aa     000000000100
000176  aa     000000000021
000177  aa     000000000021

000200  aa     000000000000
000201  aa     000000000000
000202  aa     000000000000
000203  aa     000000000000
000204  aa     000000000000
000205  aa     000000000000
000206  aa     000000000000
000207  aa     000000334106
000210  aa     000000445662

000211  aa     000000000000
000212  aa     000000001370
000213  aa     000000001370
000214  aa     000000001370
000215  aa     000000001115
000216  aa     000000000550
000217  aa     000000002400
000220  aa     000000000377
000221  aa     000000000377

000222  aa     000000000000
000223  aa     000002341657
000224  aa     000002271607
000225  aa     000001142047
000226  aa     000000731111
000227  aa     000000215247
000230  aa     000004070777
000231  aa     000000670612
000232  aa     000001562423

000233  aa     000000000000
000234  aa     000002341657
000235  aa     000002270217
000236  aa     000001140457
000237  aa     000000727521
000240  aa     000000216017
000241  aa     000004070777
000242  aa     000000671212
000243  aa     000001562025

000244  aa     000000000000
000245  aa     000002336700
000246  aa     000002263650
000247  aa     000001134110
000250  aa     000000724153
000251  aa     000000214500
000252  aa     000004064000
000253  aa     000000670613
000254  aa     000001561426

000255  aa     000000000000
000256  aa     000002270217
000257  aa     000002263647
000260  aa     000001134107
000261  aa     000000724152
000262  aa     000000214477
000263  aa     000004063777
000264  aa     000000670612
000265  aa     000001561425

000266  aa     000000000000
000267  aa     000000001456
000270  aa     000000001456
000271  aa     000000000632
000272  aa     000000000632
000273  aa     000000000312
000274  aa     000000001510
000275  aa     000000001565
000276  aa     000000003352

000277  aa  141 142 143 000	abc

000300  aa     000000000000
000301  aa     000000000000
000302  aa     000000000000
000303  aa     000000000000
000304  aa     000000000000
000305  aa     000000000000
000306  aa     000000000000
000307  aa     000000000002
000310  aa     000000000003

000311  aa     170000000000

000312  aa  142 165 154 153	bulk
000313  aa  144 065 060 060	d500
000314  aa  144 064 065 061	d451
000315  aa  144 064 060 060	d400
000316  aa  144 061 071 060	d190
000317  aa  144 061 070 061	d181
000320  aa  144 065 060 061	d501
000321  aa  063 063 070 060	3380
000322  aa  063 063 070 061	3381

000323  aa     000000000000
000324  aa     000000000764
000325  aa     000000000703
000326  aa     000000000620
000327  aa     000000000276
000330  aa     000000000265
000331  aa     000000000765
000332  aa     000000006464
000333  aa     000000006465

000334  aa     000000000001
000335  aa     000000000002
000336  aa     000000000003
000337  aa     000000000003
000340  aa     000000000004
000341  aa     000000000004
000342  aa     000000000004
000343  aa     000000000005
000344  aa     000000000006
000345  aa     000000000007
000346  aa     000000000010
000347  aa     000000000011

000350  aa     000000000000
000351  aa     000000000764
000352  aa     000000000703
000353  aa     000000000702
000354  aa     000000000620
000355  aa     000000000622
000356  aa     000000000277
000357  aa     000000000276
000360  aa     000000000265
000361  aa     000000000765
000362  aa     000000006464
000363  aa     000000006465


000364  aa     516100000044

000365  aa     526000000000

000366  aa     524000000026

000367  aa     524000000034

000370  aa     524000000150

000371  aa     516000000010

000372  aa     514000000002

000373  aa     606000000006

000374  aa     404000000017

000375  aa     524000000115

000376  aa     500000000000

000377  aa  055 150 145 170	-hex

000400  aa     404000000014

000401  aa     524000000030

000402  aa     524000000076

000403  aa     524000000063

000404  aa     524000000064

000405  aa     524000000101

000406  aa     524000000016

000407  aa     524000000007

000410  aa     530000000000

000411  aa     524000000011

000412  aa     524000000013

000413  aa     404000000023

000414  aa     410000000107

000415  aa     526000000044

017773  aa  136 000 000 000	^

000416  aa     524000000014

000417  aa     524000000140

000420  aa     516000000110

000421  aa  171 145 163 000	yes

000422  aa     404000000006

000423  aa     524000000254

000424  aa     530000000003

017774  aa     000000000400

000425  aa     516000000001

000426  aa     524000000002

000427  aa     524000000001

017775  aa  137 000 000 000	_

000430  aa  144 163 153 000	dsk

000431  aa     526000000010

000432  aa  055 144 166 000	-dv

000433  aa     404000000002

000434  aa     404000000001

000435  aa     524000000010

000436  aa     524000000021

000437  aa     524000000046

000440  aa  155 064 065 061	m451

000441  aa  155 064 060 060	m400

000442  aa  144 064 065 061	d451

000443  aa  144 064 065 060	d450

000444  aa  144 064 060 060	d400

000445  aa  104 061 071 061	D191

000446  aa  144 061 071 061	d191

017776  aa     300000000000

017777  aa     340000000000

000447  aa     524000000025

000450  aa     526000000020

000451  aa  136 162 141 167	^raw

000452  aa  162 141 167 000	raw

000453  aa     524000000023

000454  aa     514000000044

000455  aa     524000000012

000456  aa     524000000040

000457  aa     524000000033

000460  aa     524000000071

000461  aa     524000000062

000462  aa     524000000070

000463  aa     524000000041

000464  aa     524000000037

000465  aa     524000000065

000466  aa     524000000067

000467  aa     524000000073

000470  aa     524000000036

000471  aa     524000000047

000472  aa     524000000051

000473  aa     524000000057

000474  aa     524000000100

000475  aa     524000000044

000476  aa     524000000004

000477  aa  157 160 145 156	open

000500  aa     524000000050

000501  aa     526000000030

000502  aa     524000000056

000503  aa     524000000060

000504  aa     524000000052

000505  aa     524000000006

020000  aa  040 000 000 000	 

017771  aa     777777777777

000506  aa     404000000005

000507  aa     526000000026

000510  aa     524000000000

000511  aa     516000000006

000512  aa     526077777777

000513  aa     530000000400

000514  aa     404000000021

000515  aa     514000000001

000516  aa     526000000017

000517  aa     404000000025

000520  aa     404000000043

000521  aa     464000000000

020001  aa     000000000004

020002  aa     000000000002

000522  aa  156 157 156 145	none
000523  aa  040 040 040 040	    

000524  aa  116 157 040 105	No E
000525  aa  162 162 157 162	rror

000526  aa  143 154 145 141	clea
000527  aa  156 165 160 000	nup

000530  aa  136 141 040 040	^a  
000531  aa  136 141 000 000	^a

000532  aa     000000000000
000533  aa     000001720440

000534  aa  162 144 151 163	rdis
000535  aa  153 137 000 000	k_

000536  aa  055 155 157 144	-mod
000537  aa  145 154 000 000	el

000540  aa  055 144 145 166	-dev
000541  aa  151 143 145 000	ice

000542  aa  162 143 160 137	rcp_
000543  aa  163 171 163 137	sys_

000544  aa  055 160 162 151	-pri
000545  aa  166 000 000 000	v

000546  aa  055 163 171 163	-sys
000547  aa  164 145 155 000	tem

000550  aa  055 163 151 172	-siz
000551  aa  145 000 000 000	e

000552  aa  055 167 162 151	-wri
000553  aa  164 145 000 000	te

000554  aa  144 165 155 155	dumm
000555  aa  171 000 000 000	y

000556  aa  136 167 162 164	^wrt
000557  aa  143 155 160 000	cmp

000560  aa  167 162 164 143	wrtc
000561  aa  155 160 000 000	mp

000562  aa  136 141 154 164	^alt
000563  aa  164 162 153 000	trk

000564  aa  141 154 164 164	altt
000565  aa  162 153 000 000	rk

000566  aa  136 154 141 142	^lab
000567  aa  145 154 000 000	el

000570  aa  154 141 142 145	labe
000571  aa  154 000 000 000	l

000572  aa  146 157 162 155	form
000573  aa  141 164 000 000	at

000574  aa     000000000000
000575  aa     000000000000

000576  aa  163 145 164 163	sets
000577  aa  151 172 145 000	ize

000600  aa  151 157 137 143	io_c
000601  aa  141 154 154 000	all

000602  aa  167 162 151 164	writ
000603  aa  145 000 000 000	e

000604  aa  162 145 167 162	rewr
000605  aa  151 164 145 000	ite

000606  aa  143 154 157 163	clos
000607  aa  145 144 000 000	ed

000610  aa  162 144 151 163	rdis
000611  aa  153 137 040 000	k_ 

000612  aa  056 162 144 151	.rdi
000613  aa  163 153 137 000	sk_

000614  aa  040 040 040 040	    
000615  aa  040 040 040 040	    

000616  aa     077777000043
000617  aa     000001000000

000620  aa  116 145 167 040	New 
000621  aa  163 151 172 145	size
000622  aa  056 000 000 000	.

000623  aa  146 141 164 141	fata
000624  aa  154 137 145 162	l_er
000625  aa  162 157 162 000	ror

000626  aa  145 162 162 157	erro
000627  aa  162 137 157 165	r_ou
000630  aa  164 160 165 164	tput

000631  aa  060 061 062 063	0123
000632  aa  064 065 066 067	4567
000633  aa  070 071 000 000	89

000634  aa  146 157 162 155	form
000635  aa  141 164 137 164	at_t
000636  aa  162 141 143 153	rack

000637  aa  146 157 162 155	form
000640  aa  141 164 137 164	at_t
000641  aa  162 153 000 000	rk

000642  aa  144 145 166 151	devi
000643  aa  143 145 137 151	ce_i
000644  aa  156 146 157 000	nfo

000645  aa  144 151 163 153	disk
000646  aa  137 151 156 146	_inf
000647  aa  157 000 000 000	o

000650  aa  143 150 141 156	chan
000651  aa  147 145 160 141	gepa
000652  aa  143 153 000 000	ck

000653  aa  147 145 164 142	getb
000654  aa  157 165 156 144	ound
000655  aa  163 000 000 000	s

000656  aa  144 157 156 047	don'
000657  aa  164 137 143 141	t_ca
000660  aa  162 145 000 000	re

000661  aa  144 151 162 145	dire
000662  aa  143 164 137 151	ct_i
000663  aa  156 160 165 164	nput

000664  aa  163 164 162 145	stre
000665  aa  141 155 137 151	am_i
000666  aa  156 160 165 164	nput

000667  aa  162 144 151 163	rdis
000670  aa  153 137 040 042	k_ "
000671  aa  042 040 000 000	" 

000672  aa  136 070 141 136	^8a^
000673  aa  062 170 136 070	2x^8
000674  aa  141 136 062 170	a^2x
000675  aa  136 141 000 000	^a

000676  aa     606100000010
000677  aa     000000000001
000700  aa     000000000003
000701  aa     000000000020

000702  aa  116 145 167 040	New 
000703  aa  160 141 143 153	pack
000704  aa  040 156 141 155	 nam
000705  aa  145 056 000 000	e.

000706  aa     516100000010
000707  aa     000000000001
000710  aa     000000000011
000711  aa     000000000010

020003  aa  040 040 040 040	    
020004  aa  040 040 040 040	    
020005  aa  040 040 040 040	    
020006  aa  040 040 040 040	    

000712  aa  150 141 162 144	hard
000713  aa  167 141 162 145	ware
000714  aa  137 163 164 141	_sta
000715  aa  164 165 163 000	tus

000716  aa  162 144 137 164	rd_t
000717  aa  162 153 137 150	rk_h
000720  aa  145 141 144 145	eade
000721  aa  162 000 000 000	r

000722  aa  144 151 162 145	dire
000723  aa  143 164 137 165	ct_u
000724  aa  160 144 141 164	pdat
000725  aa  145 000 000 000	e

000726  aa  163 145 161 165	sequ
000727  aa  145 156 164 151	enti
000730  aa  141 154 137 151	al_i
000731  aa  156 160 165 164	nput

000732  aa  163 164 162 145	stre
000733  aa  141 155 137 157	am_o
000734  aa  165 164 160 165	utpu
000735  aa  164 000 000 000	t

000736  aa     530177777777
000737  aa     400000000000
000740  aa     400000000000
000741  aa     400000000000

000742  aa  136 050 136 057	^(^/
000743  aa  136 064 050 136	^4(^
000744  aa  071 056 064 142	9.4b
000745  aa  136 062 170 136	^2x^
000746  aa  051 136 051 000	)^)

000747  aa  111 156 166 141	Inva
000750  aa  154 151 144 040	lid 
000751  aa  163 151 172 145	size
000752  aa  072 040 136 141	: ^a
000753  aa  056 000 000 000	.

000754  aa  076 163 171 163	>sys
000755  aa  164 145 155 137	tem_
000756  aa  154 151 142 162	libr
000757  aa  141 162 171 137	ary_
000760  aa  061 000 000 000	1

000761  aa  102 141 144 040	Bad 
000762  aa  150 145 141 144	head
000763  aa  145 162 040 166	er v
000764  aa  145 162 163 151	ersi
000765  aa  157 156 056 000	on.

000766  aa  162 145 141 144	read
000767  aa  137 164 162 141	_tra
000770  aa  143 153 137 150	ck_h
000771  aa  145 141 144 145	eade
000772  aa  162 000 000 000	r

000773  aa  163 145 161 165	sequ
000774  aa  145 156 164 151	enti
000775  aa  141 154 137 165	al_u
000776  aa  160 144 141 164	pdat
000777  aa  145 000 000 000	e

001000  aa  163 145 161 165	sequ
001001  aa  145 156 164 151	enti
001002  aa  141 154 137 157	al_o
001003  aa  165 164 160 165	utpu
001004  aa  164 000 000 000	t

001005  aa  163 164 162 145	stre
001006  aa  141 155 137 151	am_i
001007  aa  156 160 165 164	nput
001010  aa  137 157 165 164	_out
001011  aa  160 165 164 000	put

001012  aa  105 104 101 103	EDAC
001013  aa  040 105 162 162	 Err
001014  aa  157 162 040 055	or -
001015  aa  040 103 157 162	 Cor
001016  aa  162 145 143 164	rect
001017  aa  145 144 000 000	ed

001020  aa  136 057 163 153	^/sk
001021  aa  151 160 061 136	ip1^
001022  aa  065 170 163 153	5xsk
001023  aa  151 160 062 136	ip2^
001024  aa  065 170 143 146	5xcf
001025  aa  136 057 000 000	^/

001026  aa     506000000005
001027  aa     516000000001
001030  aa     516000000001
001031  aa     516000000001
001032  aa     516000000001
001033  aa     606000000014

001034  aa  163 145 143 164	sect
001035  aa  157 162 040 163	or s
001036  aa  151 172 145 040	ize 
001037  aa  050 167 157 162	(wor
001040  aa  144 163 051 072	ds):
001041  aa  136 055 136 144	^-^d

001042  aa     504000000005
001043  aa     516000000022
001044  aa     516000000003
001045  aa     516000000001
001046  aa     516000000002
001047  aa     516000000014

001050  aa  120 162 157 142	Prob
001051  aa  154 145 155 040	lem 
001052  aa  151 156 040 144	in d
001053  aa  145 164 141 143	etac
001054  aa  150 151 156 147	hing
001055  aa  056 000 000 000	.

001056  aa  105 104 101 103	EDAC
001057  aa  040 105 162 162	 Err
001060  aa  157 162 040 055	or -
001061  aa  040 125 156 143	 Unc
001062  aa  157 162 162 145	orre
001063  aa  143 164 141 142	ctab
001064  aa  154 145 000 000	le

001065  aa  052 052 052 040	*** 
001066  aa  124 150 151 163	This
001067  aa  040 151 163 040	 is 
001070  aa  141 040 154 157	a lo
001071  aa  147 040 164 162	g tr
001072  aa  141 143 153 056	ack.
001073  aa  040 052 052 052	 ***

001074  aa  101 154 162 145	Alre
001075  aa  141 144 171 040	ady 
001076  aa  141 164 040 145	at e
001077  aa  156 144 040 157	nd o
001100  aa  146 040 164 150	f th
001101  aa  145 040 146 151	e fi
001102  aa  154 145 056 000	le.

001103  aa  154 141 142 145	labe
001104  aa  154 054 136 141	l,^a
001105  aa  154 164 164 162	lttr
001106  aa  153 054 136 167	k,^w
001107  aa  162 164 143 155	rtcm
001110  aa  160 054 136 162	p,^r
001111  aa  141 167 000 000	aw

001112  aa  136 141 072 040	^a: 
001113  aa  123 145 143 164	Sect
001114  aa  157 162 163 040	ors 
001115  aa  141 166 141 151	avai
001116  aa  154 141 142 154	labl
001117  aa  145 040 141 162	e ar
001120  aa  145 040 136 144	e ^d
001121  aa  072 136 144 000	:^d

001122  aa  116 157 164 040	Not 
001123  aa  141 164 164 141	atta
001124  aa  143 150 145 144	ched
001125  aa  040 142 171 040	 by 
001126  aa  162 144 151 163	rdis
001127  aa  153 137 040 142	k_ b
001130  aa  165 164 040 142	ut b
001131  aa  171 040 000 000	y 

001132  aa  116 145 170 164	Next
001133  aa  040 162 145 143	 rec
001134  aa  157 162 144 040	ord 
001135  aa  144 145 163 151	desi
001136  aa  147 156 141 164	gnat
001137  aa  157 162 040 167	or w
001140  aa  141 163 040 116	as N
001141  aa  125 114 114 056	ULL.

001142  aa  162 145 167 162	rewr
001143  aa  151 164 145 040	ite 
001144  aa  166 141 154 151	vali
001145  aa  144 040 157 156	d on
001146  aa  154 171 040 146	ly f
001147  aa  157 162 040 165	or u
001150  aa  160 144 141 164	pdat
001151  aa  145 056 000 000	e.

001152  aa  123 150 157 165	Shou
001153  aa  154 144 040 156	ld n
001154  aa  145 166 145 162	ever
001155  aa  040 147 145 164	 get
001156  aa  040 164 157 040	 to 
001157  aa  164 150 151 163	this
001160  aa  040 160 157 151	 poi
001161  aa  156 164 056 000	nt.

001162  aa  120 162 145 163	Pres
001163  aa  145 156 164 040	ent 
001164  aa  160 157 163 151	posi
001165  aa  164 151 157 156	tion
001166  aa  040 151 163 040	 is 
001167  aa  165 156 144 145	unde
001170  aa  146 151 156 145	fine
001171  aa  144 056 000 000	d.

001172  aa     504000000010
001173  aa     516000000006
001174  aa     516000000006
001175  aa     516000000006
001176  aa     516000000003
001177  aa     516000000001
001200  aa     516000000002
001201  aa     516000000006
001202  aa     516000000006

001203  aa  156 145 170 164	next
001204  aa  137 153 145 171	_key
001205  aa  040 155 165 163	 mus
001206  aa  164 040 142 145	t be
001207  aa  040 156 157 156	 non
001210  aa  055 156 165 154	-nul
001211  aa  154 040 164 157	l to
001212  aa  040 162 145 141	 rea
001213  aa  144 000 000 000	d

001214  aa  162 145 141 144	read
001215  aa  040 156 157 164	 not
001216  aa  040 163 165 160	 sup
001217  aa  160 157 162 164	port
001220  aa  145 144 040 146	ed f
001221  aa  157 162 040 163	or s
001222  aa  161 157 040 157	qo o
001223  aa  162 040 163 157	r so
001224  aa  056 000 000 000	.

001225  aa  163 145 145 153	seek
001226  aa  040 166 141 154	 val
001227  aa  151 144 040 157	id o
001230  aa  156 154 171 040	nly 
001231  aa  146 157 162 040	for 
001232  aa  144 151 162 145	dire
001233  aa  143 164 040 157	ct o
001234  aa  160 145 156 151	peni
001235  aa  156 147 163 056	ngs.

001236  aa  104 145 164 141	Deta
001237  aa  151 154 145 144	iled
001240  aa  040 104 145 166	 Dev
001241  aa  151 143 145 040	ice 
001242  aa  123 164 141 164	Stat
001243  aa  165 163 072 040	us: 
001244  aa  136 050 040 136	^( ^
001245  aa  062 056 064 142	2.4b
001246  aa  136 051 040 050	^) (
001247  aa  150 145 170 051	hex)

001250  aa  126 141 154 165	Valu
001251  aa  145 040 157 146	e of
001252  aa  040 163 151 172	 siz
001253  aa  145 040 157 160	e op
001254  aa  164 151 157 156	tion
001255  aa  040 155 165 163	 mus
001256  aa  164 040 142 145	t be
001257  aa  040 160 157 163	 pos
001260  aa  151 164 151 166	itiv
001261  aa  145 056 000 000	e.

001262  aa  161 165 141 156	quan
001263  aa  164 151 164 171	tity
001264  aa  040 151 163 040	 is 
001265  aa  141 146 164 145	afte
001266  aa  162 040 154 141	r la
001267  aa  163 164 040 141	st a
001270  aa  166 141 151 154	vail
001271  aa  141 142 154 145	able
001272  aa  040 163 145 143	 sec
001273  aa  164 157 162 000	tor

001274  aa  122 145 161 165	Requ
001275  aa  145 163 164 145	este
001276  aa  144 040 163 145	d se
001277  aa  143 164 157 162	ctor
001300  aa  040 157 165 164	 out
001301  aa  163 151 144 145	side
001302  aa  040 141 166 141	 ava
001303  aa  151 154 141 142	ilab
001304  aa  154 145 040 141	le a
001305  aa  162 145 141 056	rea.

001306  aa  105 170 164 145	Exte
001307  aa  156 163 151 157	nsio
001310  aa  156 040 141 164	n at
001311  aa  164 145 155 160	temp
001312  aa  164 040 055 055	t --
001313  aa  040 156 157 164	 not
001314  aa  040 166 141 154	 val
001315  aa  151 144 040 146	id f
001316  aa  157 162 040 144	or d
001317  aa  151 163 153 056	isk.

001320  aa  122 145 143 157	Reco
001321  aa  162 144 040 167	rd w
001322  aa  151 154 154 040	ill 
001323  aa  156 157 164 040	not 
001324  aa  146 151 164 040	fit 
001325  aa  151 156 040 163	in s
001326  aa  160 141 143 145	pace
001327  aa  040 154 145 146	 lef
001330  aa  164 040 157 156	t on
001331  aa  040 144 151 163	 dis
001332  aa  153 056 000 000	k.

001333  aa  167 162 151 164	writ
001334  aa  145 040 163 165	e su
001335  aa  160 160 157 162	ppor
001336  aa  164 145 144 040	ted 
001337  aa  157 156 154 171	only
001340  aa  040 146 157 162	 for
001341  aa  040 163 161 157	 sqo
001342  aa  054 040 163 157	, so
001343  aa  054 040 141 156	, an
001344  aa  144 040 163 151	d si
001345  aa  157 056 000 000	o.

001346  aa  161 165 141 156	quan
001347  aa  164 151 164 171	tity
001350  aa  040 151 163 040	 is 
001351  aa  142 145 146 157	befo
001352  aa  162 145 040 146	re f
001353  aa  151 162 163 164	irst
001354  aa  040 141 166 141	 ava
001355  aa  151 154 141 142	ilab
001356  aa  154 145 040 163	le s
001357  aa  145 143 164 157	ecto
001360  aa  162 000 000 000	r

001361  aa  144 151 162 145	dire
001362  aa  143 164 137 165	ct_u
001363  aa  160 144 141 164	pdat
001364  aa  145 040 162 145	e re
001365  aa  161 165 151 162	quir
001366  aa  145 163 040 055	es -
001367  aa  167 162 151 164	writ
001370  aa  145 040 143 157	e co
001371  aa  156 164 162 157	ntro
001372  aa  154 040 141 162	l ar
001373  aa  147 056 000 000	g.

001374  aa  163 164 162 145	stre
001375  aa  141 155 137 157	am_o
001376  aa  165 164 160 165	utpu
001377  aa  164 040 162 145	t re
001400  aa  161 165 151 162	quir
001401  aa  145 163 040 055	es -
001402  aa  167 162 151 164	writ
001403  aa  145 040 143 157	e co
001404  aa  156 164 162 157	ntro
001405  aa  154 040 141 162	l ar
001406  aa  147 056 000 000	g.

001407  aa  124 150 145 040	The 
001410  aa  136 141 040 143	^a c
001411  aa  157 156 164 162	ontr
001412  aa  157 154 040 157	ol o
001413  aa  162 144 145 162	rder
001414  aa  040 151 163 040	 is 
001415  aa  156 157 164 040	not 
001416  aa  163 165 160 160	supp
001417  aa  157 162 164 145	orte
001420  aa  144 040 142 171	d by
001421  aa  040 151 157 137	 io_
001422  aa  143 141 154 154	call

001423  aa  117 156 154 171	Only
001424  aa  040 147 145 164	 get
001425  aa  142 157 165 156	boun
001426  aa  144 163 040 151	ds i
001427  aa  163 040 141 154	s al
001430  aa  154 157 167 145	lowe
001431  aa  144 040 167 150	d wh
001432  aa  145 156 040 146	en f
001433  aa  151 154 145 040	ile 
001434  aa  151 163 040 156	is n
001435  aa  157 164 040 157	ot o
001436  aa  160 145 156 056	pen.

001437  aa  102 171 164 145	Byte
001440  aa  040 157 146 146	 off
001441  aa  163 145 164 040	set 
001442  aa  163 160 145 143	spec
001443  aa  151 146 151 145	ifie
001444  aa  144 040 156 157	d no
001445  aa  164 040 141 164	t at
001446  aa  040 142 145 147	 beg
001447  aa  151 156 151 156	inin
001450  aa  147 040 157 146	g of
001451  aa  040 163 145 143	 sec
001452  aa  164 157 162 000	tor

001453  aa  117 156 154 171	Only
001454  aa  040 154 145 147	 leg
001455  aa  141 154 040 166	al v
001456  aa  141 154 165 145	alue
001457  aa  163 040 146 157	s fo
001460  aa  162 040 164 171	r ty
001461  aa  160 145 040 141	pe a
001462  aa  162 145 040 055	re -
001463  aa  061 054 040 060	1, 0
001464  aa  054 040 053 061	, +1
001465  aa  054 040 141 156	, an
001466  aa  144 040 053 062	d +2

001467  aa  163 145 161 165	sequ
001470  aa  145 156 164 151	enti
001471  aa  141 154 137 165	al_u
001472  aa  160 144 141 164	pdat
001473  aa  145 040 162 145	e re
001474  aa  161 165 151 162	quir
001475  aa  145 163 040 055	es -
001476  aa  167 162 151 164	writ
001477  aa  145 040 143 157	e co
001500  aa  156 164 162 157	ntro
001501  aa  154 040 141 162	l ar
001502  aa  147 056 000 000	g.

001503  aa  163 145 161 165	sequ
001504  aa  145 156 164 151	enti
001505  aa  141 154 137 157	al_o
001506  aa  165 164 160 165	utpu
001507  aa  164 040 162 145	t re
001510  aa  161 165 151 162	quir
001511  aa  145 163 040 055	es -
001512  aa  167 162 151 164	writ
001513  aa  145 040 143 157	e co
001514  aa  156 164 162 157	ntro
001515  aa  154 040 141 162	l ar
001516  aa  147 056 000 000	g.

001517  aa  163 164 162 145	stre
001520  aa  141 155 137 151	am_i
001521  aa  156 160 165 164	nput
001522  aa  137 157 165 164	_out
001523  aa  160 165 164 040	put 
001524  aa  162 145 161 165	requ
001525  aa  151 162 145 163	ires
001526  aa  040 055 167 162	 -wr
001527  aa  151 164 145 040	ite 
001530  aa  143 157 156 164	cont
001531  aa  162 157 154 040	rol 
001532  aa  141 162 147 056	arg.

001533  aa  163 145 143 164	sect
001534  aa  157 162 163 040	ors 
001535  aa  160 145 162 040	per 
001536  aa  143 171 154 151	cyli
001537  aa  156 144 145 162	nder
001540  aa  072 136 055 136	:^-^
001541  aa  144 136 057 163	d^/s
001542  aa  145 143 164 157	ecto
001543  aa  162 163 040 160	rs p
001544  aa  145 162 040 164	er t
001545  aa  162 141 143 153	rack
001546  aa  072 136 055 136	:^-^
001547  aa  055 136 144 000	-^d

001550  aa  163 145 143 164	sect
001551  aa  157 162 163 040	ors 
001552  aa  160 145 162 040	per 
001553  aa  144 145 166 151	devi
001554  aa  143 145 072 136	ce:^
001555  aa  055 136 055 136	-^-^
001556  aa  144 136 057 143	d^/c
001557  aa  171 154 151 156	ylin
001560  aa  144 145 162 163	ders
001561  aa  040 160 145 162	 per
001562  aa  040 144 145 166	 dev
001563  aa  151 143 145 072	ice:
001564  aa  136 055 136 144	^-^d

001565  aa  101 164 164 145	Atte
001566  aa  155 160 164 145	mpte
001567  aa  144 040 164 157	d to
001570  aa  040 162 145 167	 rew
001571  aa  162 151 164 145	rite
001572  aa  040 142 145 146	 bef
001573  aa  157 162 145 040	ore 
001574  aa  164 150 145 040	the 
001575  aa  163 164 141 162	star
001576  aa  164 040 157 146	t of
001577  aa  040 164 150 145	 the
001600  aa  040 146 151 154	 fil
001601  aa  145 056 000 000	e.

001602  aa  101 164 164 145	Atte
001603  aa  155 160 164 145	mpte
001604  aa  144 040 164 157	d to
001605  aa  040 162 145 141	 rea
001606  aa  144 040 050 144	d (d
001607  aa  151 054 040 144	i, d
001610  aa  165 051 040 160	u) p
001611  aa  141 163 164 040	ast 
001612  aa  145 156 144 040	end 
001613  aa  157 146 040 141	of a
001614  aa  166 151 154 141	vila
001615  aa  142 154 145 040	ble 
001616  aa  141 162 145 141	area
001617  aa  056 000 000 000	.

001620  aa  101 164 164 145	Atte
001621  aa  155 160 164 145	mpte
001622  aa  144 040 164 157	d to
001623  aa  040 162 145 141	 rea
001624  aa  144 040 050 163	d (s
001625  aa  161 151 054 040	qi, 
001626  aa  163 161 165 051	squ)
001627  aa  040 160 141 163	 pas
001630  aa  164 040 145 156	t en
001631  aa  144 040 157 146	d of
001632  aa  040 141 166 141	 ava
001633  aa  151 154 141 142	ilab
001634  aa  154 145 040 141	le a
001635  aa  162 145 141 056	rea.

001636  aa  127 145 162 145	Were
001637  aa  040 141 164 040	 at 
001640  aa  146 151 154 145	file
001641  aa  040 145 156 144	 end
001642  aa  073 040 161 165	; qu
001643  aa  141 156 164 151	anti
001644  aa  164 171 040 167	ty w
001645  aa  157 165 154 144	ould
001646  aa  040 160 165 164	 put
001647  aa  040 171 157 165	 you
001650  aa  040 142 145 146	 bef
001651  aa  157 162 145 040	ore 
001652  aa  146 151 154 145	file
001653  aa  056 000 000 000	.

001654  aa  127 145 162 145	Were
001655  aa  040 141 164 040	 at 
001656  aa  146 151 154 145	file
001657  aa  040 145 156 144	 end
001660  aa  073 040 161 165	; qu
001661  aa  141 156 164 151	anti
001662  aa  164 171 040 141	ty a
001663  aa  164 164 145 155	ttem
001664  aa  160 164 145 144	pted
001665  aa  040 164 157 040	 to 
001666  aa  155 157 166 145	move
001667  aa  040 146 157 162	 for
001670  aa  167 141 162 144	ward
001671  aa  056 000 000 000	.

001672  aa  120 162 145 163	Pres
001673  aa  145 156 164 040	ent 
001674  aa  160 157 163 151	posi
001675  aa  164 151 157 156	tion
001676  aa  040 160 154 165	 plu
001677  aa  163 040 161 165	s qu
001700  aa  141 156 164 151	anti
001701  aa  164 171 040 151	ty i
001702  aa  163 040 160 141	s pa
001703  aa  163 164 040 145	st e
001704  aa  156 144 040 157	nd o
001705  aa  146 040 164 150	f th
001706  aa  145 040 146 151	e fi
001707  aa  154 145 056 000	le.

001710  aa  101 164 164 145	Atte
001711  aa  155 160 164 145	mpte
001712  aa  144 040 164 157	d to
001713  aa  040 162 145 167	 rew
001714  aa  162 151 164 145	rite
001715  aa  040 167 150 145	 whe
001716  aa  156 040 141 154	n al
001717  aa  162 145 141 144	read
001720  aa  171 040 141 164	y at
001721  aa  040 164 150 145	 the
001722  aa  040 145 156 144	 end
001723  aa  040 157 146 040	 of 
001724  aa  164 150 145 040	the 
001725  aa  146 151 154 145	file
001726  aa  056 000 000 000	.

001727  aa  120 162 145 163	Pres
001730  aa  145 156 164 040	ent 
001731  aa  160 157 163 151	posi
001732  aa  164 151 157 156	tion
001733  aa  040 160 154 165	 plu
001734  aa  163 040 161 165	s qu
001735  aa  141 156 164 151	anti
001736  aa  164 171 040 151	ty i
001737  aa  163 040 142 145	s be
001740  aa  146 157 162 145	fore
001741  aa  040 163 164 141	 sta
001742  aa  162 164 040 157	rt o
001743  aa  146 040 164 150	f th
001744  aa  145 040 146 151	e fi
001745  aa  154 145 056 000	le.

001746  aa  156 165 155 142	numb
001747  aa  145 162 040 157	er o
001750  aa  146 040 154 141	f la
001751  aa  142 145 154 040	bel 
001752  aa  163 145 143 164	sect
001753  aa  157 162 163 072	ors:
001754  aa  136 055 136 144	^-^d
001755  aa  136 057 156 165	^/nu
001756  aa  155 142 145 162	mber
001757  aa  040 157 146 040	 of 
001760  aa  141 154 164 145	alte
001761  aa  162 156 141 164	rnat
001762  aa  145 040 163 145	e se
001763  aa  143 164 157 162	ctor
001764  aa  163 072 136 055	s:^-
001765  aa  136 144 000 000	^d

001766  aa  120 157 163 151	Posi
001767  aa  164 151 157 156	tion
001770  aa  040 157 160 145	 ope
001771  aa  162 141 164 151	rati
001772  aa  157 156 040 166	on v
001773  aa  141 154 151 144	alid
001774  aa  040 157 156 154	 onl
001775  aa  171 040 146 157	y fo
001776  aa  162 040 163 145	r se
001777  aa  161 165 145 156	quen
002000  aa  164 151 141 154	tial
002001  aa  040 157 162 040	 or 
002002  aa  163 164 162 145	stre
002003  aa  141 155 040 157	am o
002004  aa  160 145 156 151	peni
002005  aa  156 147 163 056	ngs.

002006  aa  104 145 166 151	Devi
002007  aa  143 145 040 103	ce C
002010  aa  150 141 162 141	hara
002011  aa  143 164 145 162	cter
002012  aa  151 163 164 151	isti
002013  aa  143 163 072 136	cs:^
002014  aa  057 136 057 144	/^/d
002015  aa  145 166 151 143	evic
002016  aa  145 040 164 171	e ty
002017  aa  160 145 072 136	pe:^
002020  aa  055 136 055 136	-^-^
002021  aa  141 136 057 144	a^/d
002022  aa  145 166 151 143	evic
002023  aa  145 040 156 141	e na
002024  aa  155 145 072 136	me:^
002025  aa  055 136 055 136	-^-^
002026  aa  141 000 000 000	a

002027  aa  136 057 160 157	^/po
002030  aa  163 151 164 151	siti
002031  aa  157 156 075 050	on=(
002032  aa  136 144 057 136	^d/^
002033  aa  144 051 040 040	d)  
002034  aa  164 151 075 136	ti=^
002035  aa  062 142 136 133	2b^[
002036  aa  040 040 141 154	  al
002037  aa  164 145 162 156	tern
002040  aa  141 164 145 075	ate=
002041  aa  050 136 144 057	(^d/
002042  aa  136 144 051 136	^d)^
002043  aa  073 136 062 163	;^2s
002044  aa  136 135 040 040	^]  
002045  aa  164 163 153 151	tski
002046  aa  160 075 136 144	p=^d
002047  aa  054 136 144 054	,^d,
002050  aa  136 144 040 040	^d  
002051  aa  143 146 075 136	cf=^
002052  aa  141 000 000 000	a

002053  aa  125 156 162 145	Unre
002054  aa  143 157 166 145	cove
002055  aa  162 141 142 154	rabl
002056  aa  145 040 145 162	e er
002057  aa  162 157 162 040	ror 
002060  aa  157 156 040 136	on ^
002061  aa  141 040 144 145	a de
002062  aa  166 151 143 145	vice
002063  aa  040 136 141 054	 ^a,
002064  aa  040 163 145 143	 sec
002065  aa  164 157 162 040	tor 
002066  aa  136 157 040 050	^o (
002067  aa  136 144 056 051	^d.)
002070  aa  056 136 057 111	.^/I
002071  aa  117 115 040 123	OM S
002072  aa  164 141 164 165	tatu
002073  aa  163 072 136 055	s:^-
002074  aa  136 167 040 136	^w ^
002075  aa  167 136 057 111	w^/I
002076  aa  104 103 127 057	DCW/
002077  aa  104 103 127 040	DCW 
002100  aa  120 141 151 162	Pair
002101  aa  072 136 055 136	:^-^
002102  aa  167 040 136 167	w ^w

002103  aa  160 150 171 163	phys
002104  aa  151 143 141 154	ical
002105  aa  040 163 145 143	 sec
002106  aa  164 157 162 040	tor 
002107  aa  163 151 172 145	size
002110  aa  040 075 040 136	 = ^
002111  aa  133 065 061 062	[512
002112  aa  136 073 066 064	^;64
002113  aa  136 135 040 167	^] w
002114  aa  157 162 144 163	ords
002115  aa  056 136 133 106	.^[F
002116  aa  157 162 155 141	orma
002117  aa  164 040 157 146	t of
002120  aa  040 164 150 151	 thi
002121  aa  163 040 144 151	s di
002122  aa  163 153 040 142	sk b
002123  aa  171 040 110 157	y Ho
002124  aa  156 145 171 167	neyw
002125  aa  145 154 154 040	ell 
002126  aa  150 141 163 040	has 
002127  aa  136 133 156 157	^[no
002130  aa  164 040 136 135	t ^]
002131  aa  143 157 155 160	comp
002132  aa  154 145 164 145	lete
002133  aa  144 056 136 073	d.^;
002134  aa  136 163 136 135	^s^]

002135  aa  131 157 165 162	Your
002136  aa  040 144 151 163	 dis
002137  aa  153 040 144 162	k dr
002140  aa  151 166 145 040	ive 
002141  aa  050 116 157 056	(No.
002142  aa  040 136 144 051	 ^d)
002143  aa  040 156 145 145	 nee
002144  aa  144 163 040 141	ds a
002145  aa  164 164 145 156	tten
002146  aa  164 151 157 156	tion
002147  aa  056 040 040 120	.  P
002150  aa  154 145 141 163	leas
002151  aa  145 040 150 141	e ha
002152  aa  166 145 040 164	ve t
002153  aa  150 145 040 157	he o
002154  aa  160 145 162 141	pera
002155  aa  164 157 162 012	tor

002156  aa  143 150 145 143	chec
002157  aa  153 040 151 164	k it
002160  aa  040 157 165 164	 out
002161  aa  040 141 156 144	 and
002162  aa  040 162 145 160	 rep
002163  aa  154 171 040 141	ly a
002164  aa  160 160 162 157	ppro
002165  aa  160 162 151 141	pria
002166  aa  164 145 154 171	tely
002167  aa  040 137 010 141	 _a
002170  aa  137 010 146 137	_f_
002171  aa  010 164 137 010	t_
002172  aa  145 137 010 162	e_r
002173  aa  040 164 150 145	 the
002174  aa  040 144 145 166	 dev
002175  aa  151 143 145 040	ice 
002176  aa  150 141 163 040	has 
002177  aa  142 145 145 156	been
002200  aa  040 143 150 145	 che
002201  aa  143 153 145 144	cked
002202  aa  056 012 012 104	.

D
002203  aa  157 040 171 157	o yo
002204  aa  165 040 167 151	u wi
002205  aa  163 150 040 164	sh t
002206  aa  157 040 162 145	o re
002207  aa  164 162 171 077	try?

LABEL ARRAYS
000000  aa   012276 7100 04	tra  	5310,ic		012276
000001  aa   012346 7100 04	tra  	5350,ic		012347
000002  aa   012447 7100 04	tra  	5415,ic		012451

000003  aa   012275 7100 04	tra  	5309,ic		012300
000004  aa   012343 7100 04	tra  	5347,ic		012347
000005  aa   012444 7100 04	tra  	5412,ic		012451

BEGIN PROCEDURE rdisk_
PROLOGUE SEQUENCE
002210  aa  6 01012 4401 00	sxl0 	pr6|522
						STATEMENT 1 ON LINE 84 OF FILE 6
002211  aa  6 00343 4501 00	stz  	pr6|227
002212  aa  6 00343 0541 00	aos  	pr6|227
002213  aa  6 00343 2361 00	ldq  	pr6|227
002214  aa   000006 4020 07	mpy  	6,dl
002215  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
002216  aa   000000 00 0000	descb	0,0
002217  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002220  aa  6 00343 0541 00	aos  	pr6|227
002221  aa  6 00343 2361 00	ldq  	pr6|227
002222  aa   000006 4020 07	mpy  	6,dl
002223  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002224  aa   015554 00 0006	descb	7020,6		017777 = 340000000000
002225  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002226  aa  6 00343 0541 00	aos  	pr6|227
002227  aa  6 00343 2361 00	ldq  	pr6|227
002230  aa   000006 4020 07	mpy  	6,dl
002231  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002232  aa   015546 00 0006	descb	7014,6		017777 = 340000000000
002233  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002234  aa  6 00343 0541 00	aos  	pr6|227
002235  aa  6 00343 2361 00	ldq  	pr6|227
002236  aa   000006 4020 07	mpy  	6,dl
002237  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002240  aa   015540 00 0006	descb	7008,6		017777 = 340000000000
002241  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002242  aa  6 00343 0541 00	aos  	pr6|227
002243  aa  6 00343 2361 00	ldq  	pr6|227
002244  aa   000006 4020 07	mpy  	6,dl
002245  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002246  aa   015532 00 0006	descb	7002,6		017777 = 340000000000
002247  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002250  aa  6 00343 0541 00	aos  	pr6|227
002251  aa  6 00343 2361 00	ldq  	pr6|227
002252  aa   000006 4020 07	mpy  	6,dl
002253  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002254  aa   015524 00 0006	descb	6996,6		017777 = 340000000000
002255  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002256  aa  6 00343 0541 00	aos  	pr6|227
002257  aa  6 00343 2361 00	ldq  	pr6|227
002260  aa   000006 4020 07	mpy  	6,dl
002261  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002262  aa   015516 00 0006	descb	6990,6		017777 = 340000000000
002263  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002264  aa  6 00343 0541 00	aos  	pr6|227
002265  aa  6 00343 2361 00	ldq  	pr6|227
002266  aa   000006 4020 07	mpy  	6,dl
002267  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002270  aa   015507 00 0006	descb	6983,6		017776 = 300000000000
002271  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
002272  aa  6 00343 0541 00	aos  	pr6|227
002273  aa  6 00343 2361 00	ldq  	pr6|227
002274  aa   000006 4020 07	mpy  	6,dl
002275  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
002276  aa   015501 00 0006	descb	6977,6		017776 = 300000000000
002277  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
						STATEMENT 1 ON LINE 243
002300  aa   000002 2360 07	ldq  	2,dl
002301  aa  6 00130 7561 00	stq  	pr6|88		query_info.version
002302  aa   400000 2350 03	lda  	131072,du
002303  aa  6 00131 2551 00	orsa 	pr6|89		query_info.yes_or_no_sw
002304  aa   015464 2350 04	lda  	6964,ic		017770 = 577777777777
002305  aa  6 00131 3551 00	ansa 	pr6|89		query_info.suppress_name_sw
002306  aa  6 00132 4501 00	stz  	pr6|90		query_info.status_code
002307  aa  6 00133 4501 00	stz  	pr6|91		query_info.query_code
						STATEMENT 1 ON LINE 252
002310  aa   776306 2370 04	ldaq 	-826,ic		000616 = 077777000043 000001000000
002311  aa  6 00136 7571 00	staq 	pr6|94		disk_ptr
002312  aa  6 00140 7571 00	staq 	pr6|96		iocb_ptr
002313  aa  6 00142 7571 00	staq 	pr6|98		real_iocb_ptr
002314  aa  6 00144 7571 00	staq 	pr6|100		ubuf_ptr
002315  aa  6 00146 7571 00	staq 	pr6|102		block_ptr
002316  aa  6 00150 7571 00	staq 	pr6|104		rs_ptr
002317  aa  6 00152 7571 00	staq 	pr6|106		info_ptr
002320  aa  6 00154 7571 00	staq 	pr6|108		fmdp
						STATEMENT 1 ON LINE 259
002321  aa  6 00167 4501 00	stz  	pr6|119		track_indicators
						STATEMENT 1 ON LINE 280
002322  aa   776232 2370 04	ldaq 	-870,ic		000554 = 144165155155 171000000000
002323  aa  6 00275 7551 00	sta  	pr6|189		next_mode
002324  aa  6 00276 7561 00	stq  	pr6|190		next_mode
002325  aa   000005 2360 07	ldq  	5,dl
002326  aa  6 00274 7561 00	stq  	pr6|188		next_mode
002327  aa  6 01012 7201 00	lxl0 	pr6|522
002330  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO rdisk_                                             STATEMENT 1 ON LINE 33
rdisk_:
     proc;

002331  da     000626200000
002332  aa   002120 6270 00	eax7 	1104
002333  aa  7 00034 3521 20	epp2 	pr7|28,*
002334  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002335  aa     000000000000
002336  aa     000000000000
002337  aa   777651 7000 04	tsx0 	-87,ic		002210
						STATEMENT 1 ON LINE 35
	return;

002340  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_attach                                       STATEMENT 1 ON LINE 489
rdisk_attach:
     entry (a_iocb_ptr, options, a_err_sw, a_code);

002341  at     000004000521
002342  tt     000736000515
002343  ta     000520000000
002344  ta     002341000000
002345  da     000635300000
002346  aa   002120 6270 00	eax7 	1104
002347  aa  7 00034 3521 20	epp2 	pr7|28,*
002350  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002351  aa     000010000000
002352  aa     000000000000
002353  aa  6 00042 3735 20	epp7 	pr6|34,*
002354  aa  7 00002 2361 20	ldq  	pr7|2,*
002355  aa   000002 6040 04	tmi  	2,ic		002357
002356  aa   777777 3760 07	anq  	262143,dl
002357  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002360  aa  6 01013 7561 00	stq  	pr6|523
002361  aa  6 00032 3715 20	epp5 	pr6|26,*
002362  aa  5 00010 3535 20	epp3 	pr5|8,*
002363  aa  6 00344 2535 00	spri3	pr6|228
002364  aa   777624 7000 04	tsx0 	-108,ic		002210
						STATEMENT 1 ON LINE 569
	if attachments_ptr = null ()
	     then do;

002365  aa  6 00044 3701 20	epp4 	pr6|36,*
002366  ia  4 00010 2371 00	ldaq 	pr4|8		attachments_ptr
002367  aa   776227 6770 04	eraq 	-873,ic		000616 = 077777000043 000001000000
002370  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002371  aa   000064 6010 04	tnz  	52,ic		002455
						STATEMENT 1 ON LINE 571
		system_area_ptr = get_system_free_area_ ();

002372  aa  6 00112 3521 00	epp2 	pr6|74		system_area_ptr
002373  aa  6 01016 2521 00	spri2	pr6|526
002374  aa  6 01014 6211 00	eax1 	pr6|524
002375  aa   004000 4310 07	fld  	2048,dl
002376  la  4 00102 3521 20	epp2 	pr4|66,*		get_system_free_area_
002377  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 572
		allocate attachments in (system_area) set (attachments_ptr);

002400  aa   002572 2360 07	ldq  	1402,dl
002401  aa  6 00112 3521 20	epp2 	pr6|74,*		system_area
002402  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
002403  aa   777775 7100 04	tra  	-3,ic		002400
002404  aa  6 00044 3701 20	epp4 	pr6|36,*
002405  ia  4 00010 2521 00	spri2	pr4|8		attachments_ptr
						STATEMENT 1 ON LINE 573
		attachments.device_att (*) = "";

002406  aa   000001 2360 07	ldq  	1,dl
002407  aa  6 00350 7561 00	stq  	pr6|232
002410  aa  6 00350 2361 00	ldq  	pr6|232
002411  aa   000016 4020 07	mpy  	14,dl
002412  aa   000000 6270 06	eax7 	0,ql
002413  aa   776201 2370 04	ldaq 	-895,ic		000614 = 040040040040 040040040040
002414  aa  6 00044 3701 20	epp4 	pr6|36,*
002415  ia  4 00010 3735 20	epp7 	pr4|8,*		attachments_ptr
002416  aa  7 77764 7551 17	sta  	pr7|-12,7		attachments.device_att
002417  aa  7 77765 7561 17	stq  	pr7|-11,7		attachments.device_att
002420  aa  6 00350 2361 00	ldq  	pr6|232
002421  aa  6 00350 0541 00	aos  	pr6|232
002422  aa   000144 1160 07	cmpq 	100,dl
002423  aa   777765 6040 04	tmi  	-11,ic		002410
						STATEMENT 1 ON LINE 574
		attachments.array (*).sv (*).this_iocbp = null ();

002424  aa   000001 2360 07	ldq  	1,dl
002425  aa  6 00350 7561 00	stq  	pr6|232
002426  aa   000001 2360 07	ldq  	1,dl
002427  aa  6 00351 7561 00	stq  	pr6|233
002430  aa  6 00350 2361 00	ldq  	pr6|232
002431  aa   000016 4020 07	mpy  	14,dl
002432  aa  6 01020 7561 00	stq  	pr6|528
002433  aa  6 00351 2361 00	ldq  	pr6|233
002434  aa   000002 7360 00	qls  	2
002435  aa  6 01020 0761 00	adq  	pr6|528
002436  aa   000000 6270 06	eax7 	0,ql
002437  aa   776157 2370 04	ldaq 	-913,ic		000616 = 077777000043 000001000000
002440  aa  6 00044 3701 20	epp4 	pr6|36,*
002441  ia  4 00010 3735 20	epp7 	pr4|8,*		attachments_ptr
002442  aa  7 77764 7571 17	staq 	pr7|-12,7		attachments.this_iocbp
002443  aa  6 00351 2361 00	ldq  	pr6|233
002444  aa  6 00351 0541 00	aos  	pr6|233
002445  aa   000003 1160 07	cmpq 	3,dl
002446  aa   777762 6040 04	tmi  	-14,ic		002430
002447  aa  6 00350 2361 00	ldq  	pr6|232
002450  aa  6 00350 0541 00	aos  	pr6|232
002451  aa   000144 1160 07	cmpq 	100,dl
002452  aa   777754 6040 04	tmi  	-20,ic		002426
						STATEMENT 1 ON LINE 575
		attachments.number_used = 0;

002453  aa  7 00001 4501 00	stz  	pr7|1		attachments.number_used
						STATEMENT 1 ON LINE 576
		attachments.number_attached = 0;

002454  aa  7 00000 4501 00	stz  	pr7|0		attachments.number_attached
						STATEMENT 1 ON LINE 577
	     end;

						STATEMENT 1 ON LINE 580
	code = 0;

002455  aa  6 00157 4501 00	stz  	pr6|111		code
						STATEMENT 1 ON LINE 582
	unique_entry_name = unique_chars_ ("0"b) || ".rdisk_";

002456  aa   000000 2350 07	lda  	0,dl
002457  aa  6 01020 7551 00	sta  	pr6|528
002460  aa  6 01020 3521 00	epp2 	pr6|528
002461  aa  6 01024 2521 00	spri2	pr6|532
002462  aa  6 01014 3521 00	epp2 	pr6|524
002463  aa  6 01026 2521 00	spri2	pr6|534
002464  aa   776031 3520 04	epp2 	-999,ic		000515 = 514000000001
002465  aa  6 01030 2521 00	spri2	pr6|536
002466  aa   776030 3520 04	epp2 	-1000,ic		000516 = 526000000017
002467  aa  6 01032 2521 00	spri2	pr6|538
002470  aa  6 01022 6211 00	eax1 	pr6|530
002471  aa   010000 4310 07	fld  	4096,dl
002472  la  4 00176 3521 20	epp2 	pr4|126,*		unique_chars_
002473  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
002474  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002475  aa  6 01014 00 0017	desc9a	pr6|524,15
002476  aa  6 00322 00 0017	desc9a	pr6|210,15	unique_entry_name
002477  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002500  aa   776113 00 0007	desc9a	-949,7		000612 = 056162144151
002501  aa  6 00325 60 0007	desc9a	pr6|213(3),7	unique_entry_name
						STATEMENT 1 ON LINE 583
	call hcs_$make_seg ("", unique_entry_name, "", 01010b, disk_ptr, code);

002502  aa   000012 2360 07	ldq  	10,dl
002503  aa  6 01034 7561 00	stq  	pr6|540
002504  aa  6 01020 3521 00	epp2 	pr6|528
002505  aa  6 01040 2521 00	spri2	pr6|544
002506  aa  6 00322 3521 00	epp2 	pr6|210		unique_entry_name
002507  aa  6 01042 2521 00	spri2	pr6|546
002510  aa  6 01021 3521 00	epp2 	pr6|529
002511  aa  6 01044 2521 00	spri2	pr6|548
002512  aa  6 01034 3521 00	epp2 	pr6|540
002513  aa  6 01046 2521 00	spri2	pr6|550
002514  aa  6 00136 3521 00	epp2 	pr6|94		disk_ptr
002515  aa  6 01050 2521 00	spri2	pr6|552
002516  aa  6 00157 3521 00	epp2 	pr6|111		code
002517  aa  6 01052 2521 00	spri2	pr6|554
002520  aa   775770 3520 04	epp2 	-1032,ic		000510 = 524000000000
002521  aa  6 01054 2521 00	spri2	pr6|556
002522  aa  6 01060 2521 00	spri2	pr6|560
002523  aa   775764 3520 04	epp2 	-1036,ic		000507 = 526000000026
002524  aa  6 01056 2521 00	spri2	pr6|558
002525  aa   775761 3520 04	epp2 	-1039,ic		000506 = 404000000005
002526  aa  6 01062 2521 00	spri2	pr6|562
002527  aa   775772 3520 04	epp2 	-1030,ic		000521 = 464000000000
002530  aa  6 01064 2521 00	spri2	pr6|564
002531  aa   775767 3520 04	epp2 	-1033,ic		000520 = 404000000043
002532  aa  6 01066 2521 00	spri2	pr6|566
002533  aa  6 01036 6211 00	eax1 	pr6|542
002534  aa   030000 4310 07	fld  	12288,dl
002535  aa  6 00044 3701 20	epp4 	pr6|36,*
002536  la  4 00122 3521 20	epp2 	pr4|82,*		hcs_$make_seg
002537  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 585
	if disk_ptr = null then call error (code, "");

002540  aa  6 00136 2371 00	ldaq 	pr6|94		disk_ptr
002541  aa   776055 6770 04	eraq 	-979,ic		000616 = 077777000043 000001000000
002542  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002543  aa   000015 6010 04	tnz  	13,ic		002560
002544  aa  6 00157 3521 00	epp2 	pr6|111		code
002545  aa  6 01040 2521 00	spri2	pr6|544
002546  aa  6 01034 3521 00	epp2 	pr6|540
002547  aa  6 01042 2521 00	spri2	pr6|546
002550  aa   775750 3520 04	epp2 	-1048,ic		000520 = 404000000043
002551  aa  6 01046 2521 00	spri2	pr6|550
002552  aa   775736 3520 04	epp2 	-1058,ic		000510 = 524000000000
002553  aa  6 01050 2521 00	spri2	pr6|552
002554  aa  6 01036 6211 00	eax1 	pr6|542
002555  aa   010000 4310 07	fld  	4096,dl
002556  aa   011773 3520 04	epp2 	5115,ic		014551 = 000160627000
002557  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 587
	iocb_ptr = a_iocb_ptr;

002560  aa  6 00032 3735 20	epp7 	pr6|26,*
002561  aa  7 00002 3715 20	epp5 	pr7|2,*		a_iocb_ptr
002562  aa  5 00000 3715 20	epp5 	pr5|0,*		a_iocb_ptr
002563  aa  6 00140 6515 00	spri5	pr6|96		iocb_ptr
						STATEMENT 1 ON LINE 589
	if iocb_ptr -> attach_descrip_ptr ^= null then call att_err (error_table_$not_detached);

002564  aa  5 00014 2371 00	ldaq 	pr5|12		iocb.attach_descrip_ptr
002565  aa   776031 6770 04	eraq 	-999,ic		000616 = 077777000043 000001000000
002566  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002567  aa   000010 6000 04	tze  	8,ic		002577
002570  aa  6 00044 3701 20	epp4 	pr6|36,*
002571  la  4 00064 3521 20	epp2 	pr4|52,*		error_table_$not_detached
002572  aa  6 01024 2521 00	spri2	pr6|532
002573  aa  6 01022 3521 00	epp2 	pr6|530
002574  aa   004000 4310 07	fld  	2048,dl
002575  aa  2 00000 7571 00	staq 	pr2|0
002576  aa   007224 6700 04	tsp4 	3732,ic		012022
						STATEMENT 1 ON LINE 591
	call parse_attach_options;

002577  aa   006003 6700 04	tsp4 	3075,ic		010602
						STATEMENT 1 ON LINE 593
	if is_sv
	     then if attach_data.dev_type ^= 0
		     then if sv_num >= number_of_sv (attach_data.dev_type)
			     then call att_err (error_table_$invalid_device);

002600  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
002601  aa  7 00104 2351 00	lda  	pr7|68		disk_data.is_sv
002602  aa   000016 6000 04	tze  	14,ic		002620
002603  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
002604  aa   000014 6000 04	tze  	12,ic		002620
002605  aa  7 00105 2361 00	ldq  	pr7|69		disk_data.sv_num
002606  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
002607  ta   000277 1160 17	cmpq 	191,7
002610  aa   000010 6040 04	tmi  	8,ic		002620
002611  aa  6 00044 3701 20	epp4 	pr6|36,*
002612  la  4 00042 3521 20	epp2 	pr4|34,*		error_table_$invalid_device
002613  aa  6 01024 2521 00	spri2	pr6|532
002614  aa  6 01022 3521 00	epp2 	pr6|530
002615  aa   004000 4310 07	fld  	2048,dl
002616  aa  2 00000 7571 00	staq 	pr2|0
002617  aa   007203 6700 04	tsp4 	3715,ic		012022
						STATEMENT 1 ON LINE 597
	if attach_data.dev_type = 0
	     then attach_descrip.descrip = "rdisk_ """" " || pack_id;

002620  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
002621  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
002622  aa   000015 6010 04	tnz  	13,ic		002637
002623  aa   000052 2360 07	ldq  	42,dl
002624  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002625  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002626  aa   776042 00 0012	desc9a	-990,10		000667 = 162144151163
002627  aa  2 00000 00 0012	desc9a	pr2|0,10
002630  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002631  aa  7 00056 00 0040	desc9a	pr7|46,32		disk_data.pack_id
002632  aa  2 00002 40 0040	desc9a	pr2|2(2),32
002633  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002634  aa  2 00000 00 0052	desc9a	pr2|0,42
002635  aa  7 00001 00 0250	desc9a	pr7|1,168		disk_data.descrip
002636  aa   000031 7100 04	tra  	25,ic		002667
						STATEMENT 1 ON LINE 599
	     else attach_descrip.descrip =
		     "rdisk_ " || device_names (attach_data.dev_type) || " " || attach_data.pack_id;

002637  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002640  aa   000013 2360 07	ldq  	11,dl
002641  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002642  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002643  aa   775746 00 0007	desc9a	-1050,7		000610 = 162144151163
002644  aa  2 00000 00 0007	desc9a	pr2|0,7
002645  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
002646  ta   000311 3714 17	epp5 	201,7
002647  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002650  aa  5 00000 00 0004	desc9a	pr5|0,4		device_names
002651  aa  2 00001 60 0004	desc9a	pr2|1(3),4
002652  aa   000014 2360 07	ldq  	12,dl
002653  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
002654  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002655  aa   015124 00 0001	desc9a	6740,1		020000 = 040000000000
002656  aa  2 00002 60 0001	desc9a	pr2|2(3),1
002657  aa   000054 2360 07	ldq  	44,dl
002660  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
002661  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002662  aa  7 00056 00 0040	desc9a	pr7|46,32		disk_data.pack_id
002663  aa  2 00003 00 0040	desc9a	pr2|3,32
002664  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002665  aa  2 00000 00 0054	desc9a	pr2|0,44
002666  aa  7 00001 00 0250	desc9a	pr7|1,168		disk_data.descrip
						STATEMENT 1 ON LINE 602
	attach_descrip.length = length (rtrim (attach_descrip.descrip));

002667  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002670  aa  000 000 165 500	tctr 	(pr)
002671  aa  7 00001 00 0250	desc9a	pr7|1,168		disk_data.descrip
002672  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
002673  aa  6 00056 0001 00	arg  	pr6|46
002674  aa  6 00056 2361 00	ldq  	pr6|46
002675  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002676  aa  6 01034 7561 00	stq  	pr6|540
002677  aa   000250 2360 07	ldq  	168,dl
002700  aa  6 01034 1761 00	sbq  	pr6|540
002701  aa  7 00000 7561 00	stq  	pr7|0		disk_data.length
						STATEMENT 1 ON LINE 603
	do i = 3 to num_opts;

002702  aa  6 00174 2361 00	ldq  	pr6|124		num_opts
002703  aa  6 00352 7561 00	stq  	pr6|234
002704  aa   000003 2360 07	ldq  	3,dl
002705  aa  6 00172 7561 00	stq  	pr6|122		i
002706  aa  6 00172 2361 00	ldq  	pr6|122		i
002707  aa  6 00352 1161 00	cmpq 	pr6|234
002710  aa   000062 6054 04	tpnz 	50,ic		002772
						STATEMENT 1 ON LINE 604
	     attach_descrip.descrip = substr (attach_descrip.descrip, 1, attach_descrip.length) || " " || options (i);

002711  aa  6 00042 3735 20	epp7 	pr6|34,*
002712  aa  7 00002 3715 20	epp5 	pr7|2,*
002713  aa  5 00003 2361 00	ldq  	pr5|3
002714  aa  5 00001 4021 00	mpy  	pr5|1
002715  aa  6 01034 7561 00	stq  	pr6|540
002716  aa  5 00003 2361 00	ldq  	pr5|3
002717  aa  6 00172 4021 00	mpy  	pr6|122		i
002720  aa  6 01034 1761 00	sbq  	pr6|540
002721  aa   000000 6260 06	eax6 	0,ql
002722  aa  6 00136 2361 20	ldq  	pr6|94,*		disk_data.length
002723  aa   000001 0760 07	adq  	1,dl
002724  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002725  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
002726  aa  3 00000 7271 00	lxl7 	pr3|0		disk_data.length
002727  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002730  aa  3 00001 00 0017	desc9a	pr3|1,x7		disk_data.descrip
002731  aa  2 00000 00 0017	desc9a	pr2|0,x7
002732  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
002733  aa   015046 00 0001	desc9a	6694,1		020000 = 040000000000
002734  aa  2 00000 00 0001	desc9a	pr2|0,1
002735  aa  6 00032 3515 20	epp1 	pr6|26,*
002736  aa  1 00004 3715 20	epp5 	pr1|4,*
002737  aa  6 01034 7561 00	stq  	pr6|540
002740  aa  5 77777 0761 16	adq  	pr5|-1,6		options
002741  aa  6 01021 7561 00	stq  	pr6|529
002742  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
002743  aa  6 01034 2351 00	lda  	pr6|540
002744  aa  1 00004 3735 76	epp7 	pr1|4,*6		options
002745  aa  7 77777 2361 00	ldq  	pr7|-1		options
002746  aa  040 145 100 540	mlr  	(pr,rl),(pr,rl,al),fill(040)
002747  aa  7 00000 00 0006	desc9a	pr7|0,ql		options
002750  aa  2 00000 00 0006	desc9a	pr2|0,ql
002751  aa  6 01021 2361 00	ldq  	pr6|529
002752  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002753  aa  2 00000 00 0006	desc9a	pr2|0,ql
002754  aa  3 00001 00 0250	desc9a	pr3|1,168		disk_data.descrip
						STATEMENT 1 ON LINE 606
	     attach_descrip.length = length (rtrim (attach_descrip.descrip));

002755  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002756  aa  000 000 165 500	tctr 	(pr)
002757  aa  3 00001 00 0250	desc9a	pr3|1,168		disk_data.descrip
002760  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
002761  aa  6 00056 0001 00	arg  	pr6|46
002762  aa  6 00056 2361 00	ldq  	pr6|46
002763  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002764  aa  6 01021 7561 00	stq  	pr6|529
002765  aa   000250 2360 07	ldq  	168,dl
002766  aa  6 01021 1761 00	sbq  	pr6|529
002767  aa  3 00000 7561 00	stq  	pr3|0		disk_data.length
						STATEMENT 1 ON LINE 607
	     end;

002770  aa  6 00172 0541 00	aos  	pr6|122		i
002771  aa   777715 7100 04	tra  	-51,ic		002706
						STATEMENT 1 ON LINE 609
	if ^(found_dev_att)
	     then do;

002772  aa  6 00330 2351 00	lda  	pr6|216		found_dev_att
002773  aa   000042 6010 04	tnz  	34,ic		003035
						STATEMENT 1 ON LINE 611
		call ipc_$create_ev_chn (ev_chan, code);

002774  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
002775  aa  7 00072 3521 00	epp2 	pr7|58		disk_data.ev_chan
002776  aa  6 01024 2521 00	spri2	pr6|532
002777  aa  6 00157 3521 00	epp2 	pr6|111		code
003000  aa  6 01026 2521 00	spri2	pr6|534
003001  aa  6 01022 6211 00	eax1 	pr6|530
003002  aa   010000 4310 07	fld  	4096,dl
003003  aa  6 00044 3701 20	epp4 	pr6|36,*
003004  la  4 00130 3521 20	epp2 	pr4|88,*		ipc_$create_ev_chn
003005  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 612
		if code ^= 0 then call att_err (code);

003006  aa  6 00157 2361 00	ldq  	pr6|111		code
003007  aa   000003 6000 04	tze  	3,ic		003012
003010  aa   014754 3520 04	epp2 	6636,ic		017764 = 000002000000
003011  aa   007011 6700 04	tsp4 	3593,ic		012022
						STATEMENT 1 ON LINE 613
		nchan = 1;

003012  aa   000001 2360 07	ldq  	1,dl
003013  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003014  aa  7 00070 7561 00	stq  	pr7|56		disk_data.nchan
						STATEMENT 1 ON LINE 615
		disk_info_ptr = addr (rcp_data);

003015  aa  7 00152 3715 00	epp5 	pr7|106		disk_data.rcp_data
003016  aa  6 00106 6515 00	spri5	pr6|70		disk_info_ptr
						STATEMENT 1 ON LINE 616
		disk_info.version_num = DISK_INFO_VERSION_1;

003017  aa   000001 2360 07	ldq  	1,dl
003020  aa  5 00000 7561 00	stq  	pr5|0		disk_info.version_num
						STATEMENT 1 ON LINE 617
		disk_info.usage_time, disk_info.wait_time = 0;

003021  aa  5 00001 4501 00	stz  	pr5|1		disk_info.usage_time
003022  aa  5 00002 4501 00	stz  	pr5|2		disk_info.wait_time
						STATEMENT 1 ON LINE 618
		disk_info.system_flag = sys_sw;

003023  aa  7 00055 2351 00	lda  	pr7|45		disk_data.sys_sw
003024  aa   000006 7350 00	als  	6
003025  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003026  aa  5 00003 7551 00	sta  	pr5|3		disk_info.system_flag
						STATEMENT 1 ON LINE 619
		if dev_type ^= 0
		     then disk_info.model = MODELN (dev_type);

003027  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
003030  aa   000004 6000 04	tze  	4,ic		003034
003031  ta   000322 2360 06	ldq  	210,ql
003032  aa  5 00006 7561 00	stq  	pr5|6		disk_info.model
003033  aa   000002 7100 04	tra  	2,ic		003035
						STATEMENT 1 ON LINE 621
		     else disk_info.model = 0;

003034  aa  5 00006 4501 00	stz  	pr5|6		disk_info.model
						STATEMENT 1 ON LINE 622
	     end;

						STATEMENT 1 ON LINE 623
	disk_info.device_name = substr (drive_name, 1, 7);

003035  aa  6 00302 2371 00	ldaq 	pr6|194		drive_name
003036  aa  0 00176 3771 00	anaq 	pr0|126		= 777777777777 777777777000
003037  aa  0 00456 2771 00	oraq 	pr0|302		= 000000000000 000000000040
003040  aa  6 00106 3735 20	epp7 	pr6|70,*		disk_info_ptr
003041  aa  7 00004 7551 00	sta  	pr7|4		disk_info.device_name
003042  aa  7 00005 7561 00	stq  	pr7|5		disk_info.device_name
						STATEMENT 1 ON LINE 624
	disk_info.write_flag = disk_data.write_sw;

003043  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
003044  aa  5 00055 2351 00	lda  	pr5|45		disk_data.write_sw
003045  aa   000001 7350 00	als  	1
003046  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003047  aa  7 00017 7551 00	sta  	pr7|15		disk_info.write_flag
						STATEMENT 1 ON LINE 625
	raw_sw = "0"b;

003050  aa   014713 2350 04	lda  	6603,ic		017763 = 737777777777
003051  aa  5 00055 3551 00	ansa 	pr5|45		disk_data.raw_sw
						STATEMENT 1 ON LINE 626
	alt_sw = "0"b;

003052  aa   014710 2350 04	lda  	6600,ic		017762 = 757777777777
003053  aa  5 00055 3551 00	ansa 	pr5|45		disk_data.alt_sw
						STATEMENT 1 ON LINE 627
	label_sw = "1"b;

003054  aa   010000 2350 03	lda  	4096,du
003055  aa  5 00055 2551 00	orsa 	pr5|45		disk_data.label_sw
						STATEMENT 1 ON LINE 628
	if ^found_dev_att
	     then do;

003056  aa  6 00330 2351 00	lda  	pr6|216		found_dev_att
003057  aa   000127 6010 04	tnz  	87,ic		003206
						STATEMENT 1 ON LINE 630
		call mount ();

003060  aa  6 00056 6211 00	eax1 	pr6|46
003061  aa   000000 4310 07	fld  	0,dl
003062  aa   011656 3520 04	epp2 	5038,ic		014740 = 000220627000
003063  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 631
		if code ^= 0 then call att_err (code);

003064  aa  6 00157 2361 00	ldq  	pr6|111		code
003065  aa   000003 6000 04	tze  	3,ic		003070
003066  aa   014676 3520 04	epp2 	6590,ic		017764 = 000002000000
003067  aa   006733 6700 04	tsp4 	3547,ic		012022
						STATEMENT 1 ON LINE 633
		disk_data.dev_type = 0;

003070  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003071  aa  7 00074 4501 00	stz  	pr7|60		disk_data.dev_type
						STATEMENT 1 ON LINE 634
		do i = 1 to hbound (MODELN, 1) while (disk_data.dev_type = 0);

003072  aa   000001 2360 07	ldq  	1,dl
003073  aa  6 00172 7561 00	stq  	pr6|122		i
003074  aa  6 00172 2361 00	ldq  	pr6|122		i
003075  aa   000011 1160 07	cmpq 	9,dl
003076  aa   000015 6054 04	tpnz 	13,ic		003113
003077  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003100  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
003101  aa   000012 6010 04	tnz  	10,ic		003113
						STATEMENT 1 ON LINE 635
		     if disk_info.model = MODELN (i) then disk_data.dev_type = i;

003102  aa  6 00106 3715 20	epp5 	pr6|70,*		disk_info_ptr
003103  aa  5 00006 2361 00	ldq  	pr5|6		disk_info.model
003104  aa  6 00172 7271 00	lxl7 	pr6|122		i
003105  ta   000322 1160 17	cmpq 	210,7
003106  aa   000003 6010 04	tnz  	3,ic		003111
003107  aa  6 00172 2361 00	ldq  	pr6|122		i
003110  aa  7 00074 7561 00	stq  	pr7|60		disk_data.dev_type
						STATEMENT 1 ON LINE 636
		     end;

003111  aa  6 00172 0541 00	aos  	pr6|122		i
003112  aa   777762 7100 04	tra  	-14,ic		003074
						STATEMENT 1 ON LINE 638
		if disk_data.dev_type <= 1 then call att_err (error_table_$invalid_device);

003113  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003114  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
003115  aa   000001 1160 07	cmpq 	1,dl
003116  aa   000010 6054 04	tpnz 	8,ic		003126
003117  aa  6 00044 3701 20	epp4 	pr6|36,*
003120  la  4 00042 3521 20	epp2 	pr4|34,*		error_table_$invalid_device
003121  aa  6 01024 2521 00	spri2	pr6|532
003122  aa  6 01022 3521 00	epp2 	pr6|530
003123  aa   004000 4310 07	fld  	2048,dl
003124  aa  2 00000 7571 00	staq 	pr2|0
003125  aa   006675 6700 04	tsp4 	3517,ic		012022
						STATEMENT 1 ON LINE 640
		device_group = DEVICE_GROUP (disk_data.dev_type);

003126  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003127  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
003130  ta   000026 2360 17	ldq  	22,7
003131  aa  7 00103 7561 00	stq  	pr7|67		disk_data.device_group
						STATEMENT 1 ON LINE 642
		if disk_data.is_sv
		     then disk_data.sect_per_dev = sect_per_sv (disk_data.dev_type);

003132  aa  7 00104 2351 00	lda  	pr7|68		disk_data.is_sv
003133  aa   000005 6000 04	tze  	5,ic		003140
003134  aa  7 00074 7261 00	lxl6 	pr7|60		disk_data.dev_type
003135  ta   000177 2360 16	ldq  	127,6
003136  aa  7 00100 7561 00	stq  	pr7|64		disk_data.sect_per_dev
003137  aa   000005 7100 04	tra  	5,ic		003144
						STATEMENT 1 ON LINE 644
		     else disk_data.sect_per_dev =
			     sect_per_cyl (disk_data.dev_type) * cyl_per_dev (disk_data.dev_type);

003140  aa  7 00074 7261 00	lxl6 	pr7|60		disk_data.dev_type
003141  ta   000210 2360 16	ldq  	136,6
003142  ta   000265 4020 16	mpy  	181,6
003143  aa  7 00100 7561 00	stq  	pr7|64		disk_data.sect_per_dev
						STATEMENT 1 ON LINE 647
		disk_data.sect_size = words_per_sect (disk_data.dev_type);

003144  aa  7 00074 7261 00	lxl6 	pr7|60		disk_data.dev_type
003145  ta   000155 2360 16	ldq  	109,6
003146  aa  7 00101 7561 00	stq  	pr7|65		disk_data.sect_size
						STATEMENT 1 ON LINE 648
		disk_data.num_alt_sect =
		     last_alt_sect_num (disk_data.dev_type) - first_alt_sect_num (disk_data.dev_type) + 1;

003147  ta   000232 2360 16	ldq  	154,6
003150  ta   000243 1760 16	sbq  	163,6
003151  aa   000001 0760 07	adq  	1,dl
003152  aa  7 00102 7561 00	stq  	pr7|66		disk_data.num_alt_sect
						STATEMENT 1 ON LINE 651
		if sys_sw
		     then disk_data.bounds.low = 0;

003153  aa  7 00055 2351 00	lda  	pr7|45		disk_data.sys_sw
003154  aa   004000 3150 03	cana 	2048,du
003155  aa   000003 6000 04	tze  	3,ic		003160
003156  aa  7 00137 4501 00	stz  	pr7|95		disk_data.low
003157  aa   000003 7100 04	tra  	3,ic		003162
						STATEMENT 1 ON LINE 653
		     else disk_data.bounds.low = num_label_sect;

003160  aa   000010 2360 07	ldq  	8,dl
003161  aa  7 00137 7561 00	stq  	pr7|95		disk_data.low
						STATEMENT 1 ON LINE 655
		if disk_data.device_group = MSU04XX
		     then disk_data.bounds.high = last_alt_sect_num (disk_data.dev_type);

003162  aa  7 00103 2361 00	ldq  	pr7|67		disk_data.device_group
003163  aa   000001 1160 07	cmpq 	1,dl
003164  aa   000005 6010 04	tnz  	5,ic		003171
003165  aa  7 00074 7251 00	lxl5 	pr7|60		disk_data.dev_type
003166  ta   000232 2360 15	ldq  	154,5
003167  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
003170  aa   000032 7100 04	tra  	26,ic		003222
						STATEMENT 1 ON LINE 657
		else if (disk_data.device_group = MSU33XX) & disk_data.is_sv
		     then disk_data.bounds.high = sect_per_sv (disk_data.dev_type) - 1;

003171  aa   000003 1160 07	cmpq 	3,dl
003172  aa   000010 6010 04	tnz  	8,ic		003202
003173  aa  7 00104 2351 00	lda  	pr7|68		disk_data.is_sv
003174  aa   000006 6000 04	tze  	6,ic		003202
003175  aa  7 00074 7251 00	lxl5 	pr7|60		disk_data.dev_type
003176  ta   000177 2360 15	ldq  	127,5
003177  aa   000001 1760 07	sbq  	1,dl
003200  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
003201  aa   000021 7100 04	tra  	17,ic		003222
						STATEMENT 1 ON LINE 659
		else disk_data.bounds.high = last_sect_num (disk_data.dev_type);

003202  aa  7 00074 7251 00	lxl5 	pr7|60		disk_data.dev_type
003203  ta   000254 2360 15	ldq  	172,5
003204  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
						STATEMENT 1 ON LINE 660
	     end;

003205  aa   000015 7100 04	tra  	13,ic		003222
						STATEMENT 1 ON LINE 661
	     else do;

						STATEMENT 1 ON LINE 662
		disk_data.errors = 0;

003206  aa  5 00077 4501 00	stz  	pr5|63		disk_data.errors
						STATEMENT 1 ON LINE 663
		disk_data.buf_len = min (max (divide (disk_data.sze, 4, 17, 0), 1024), disk_data.max_buff_size);

003207  aa  5 00054 2361 00	ldq  	pr5|44		disk_data.sze
003210  aa   000004 5060 07	div  	4,dl
003211  aa   002000 1160 07	cmpq 	1024,dl
003212  aa   000002 6050 04	tpl  	2,ic		003214
003213  aa   002000 2360 07	ldq  	1024,dl
003214  aa  5 00067 1161 00	cmpq 	pr5|55		disk_data.max_buff_size
003215  aa   000002 6040 04	tmi  	2,ic		003217
003216  aa  5 00067 2361 00	ldq  	pr5|55		disk_data.max_buff_size
003217  aa  5 00127 7561 00	stq  	pr5|87		disk_data.buf_len
						STATEMENT 1 ON LINE 665
		disk_data.data_len = disk_data.buf_len - overhead;

003220  aa   000300 1760 07	sbq  	192,dl
003221  aa  5 00130 7561 00	stq  	pr5|88		disk_data.data_len
						STATEMENT 1 ON LINE 667
	     end;

						STATEMENT 1 ON LINE 669
	disk_data.mode_string = "label,^alttrk,^wrtcmp,^raw";

003222  aa   000032 2360 07	ldq  	26,dl
003223  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003224  aa  7 00141 7561 00	stq  	pr7|97		disk_data.mode_string
003225  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
003226  aa   775656 00 0006	desc9a	-1106,ql		001103 = 154141142145
003227  aa  7 00142 00 0006	desc9a	pr7|98,ql		disk_data.mode_string
						STATEMENT 1 ON LINE 672
	mask_str = "0"b;

003230  aa  6 00277 4501 00	stz  	pr6|191		mask_str
						STATEMENT 1 ON LINE 673
	call default_handler_$set (cond_hdlr);

003231  aa   012156 3520 04	epp2 	5230,ic		015407 = 000140627000
003232  aa  6 01014 2521 00	spri2	pr6|524		cp.789
003233  aa  6 01016 6521 00	spri6	pr6|526		cp.789
003234  aa  6 01014 3521 00	epp2 	pr6|524		cp.789
003235  aa  6 01024 2521 00	spri2	pr6|532
003236  aa  6 01022 6211 00	eax1 	pr6|530
003237  aa   004000 4310 07	fld  	2048,dl
003240  aa  6 00044 3701 20	epp4 	pr6|36,*
003241  la  4 00162 3521 20	epp2 	pr4|114,*		default_handler_$set
003242  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 674
	call hcs_$set_ips_mask (mask_str, mask_str);

003243  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
003244  aa  6 01024 2521 00	spri2	pr6|532
003245  aa  6 01026 2521 00	spri2	pr6|534
003246  aa  6 01022 6211 00	eax1 	pr6|530
003247  aa   010000 4310 07	fld  	4096,dl
003250  aa  6 00044 3701 20	epp4 	pr6|36,*
003251  la  4 00156 3521 20	epp2 	pr4|110,*		hcs_$set_ips_mask
003252  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 676
	iocb_ptr -> attach_descrip_ptr = addr (attach_descrip);

003253  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_data.attach_descrip
003254  aa  6 00140 3715 20	epp5 	pr6|96,*		iocb_ptr
003255  aa  5 00014 6535 00	spri7	pr5|12		iocb.attach_descrip_ptr
						STATEMENT 1 ON LINE 678
	iocb_ptr -> attach_data_ptr = disk_ptr;

003256  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
003257  aa  5 00016 2535 00	spri3	pr5|14		iocb.attach_data_ptr
						STATEMENT 1 ON LINE 679
	iocb_ptr -> detach_iocb = rdisk_detach;

003260  aa   005105 3520 04	epp2 	2629,ic		010365 = 002120627000
003261  aa  5 00026 2521 00	spri2	pr5|22		iocb.detach_iocb
003262  aa   014476 2370 04	ldaq 	6462,ic		017760 = 077777000043 000001000000
003263  aa  5 00030 7571 00	staq 	pr5|24		iocb.detach_iocb
						STATEMENT 1 ON LINE 680
	iocb_ptr -> open = rdisk_open;

003264  aa   000203 3520 04	epp2 	131,ic		003467 = 002120627000
003265  aa  5 00032 2521 00	spri2	pr5|26		iocb.open
003266  aa  5 00034 7571 00	staq 	pr5|28		iocb.open
						STATEMENT 1 ON LINE 681
	iocb_ptr -> iocb.control = rdisk_control;

003267  aa   003221 3520 04	epp2 	1681,ic		006510 = 002120627000
003270  aa  5 00066 2521 00	spri2	pr5|54		iocb.control
003271  aa  5 00070 7571 00	staq 	pr5|56		iocb.control
						STATEMENT 1 ON LINE 682
	iocb_ptr -> modes = rdisk_modes;

003272  aa   004400 3520 04	epp2 	2304,ic		007672 = 002120627000
003273  aa  5 00056 2521 00	spri2	pr5|46		iocb.modes
003274  aa  5 00060 7571 00	staq 	pr5|48		iocb.modes
						STATEMENT 1 ON LINE 684
	call iox_$propagate (iocb_ptr);

003275  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
003276  aa  6 01016 2521 00	spri2	pr6|526
003277  aa  6 01014 6211 00	eax1 	pr6|524
003300  aa   004000 4310 07	fld  	2048,dl
003301  aa  6 00044 3701 20	epp4 	pr6|36,*
003302  la  4 00126 3521 20	epp2 	pr4|86,*		iox_$propagate
003303  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 686
	call hcs_$reset_ips_mask (mask_str, mask_str);

003304  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
003305  aa  6 01024 2521 00	spri2	pr6|532
003306  aa  6 01026 2521 00	spri2	pr6|534
003307  aa  6 01022 6211 00	eax1 	pr6|530
003310  aa   010000 4310 07	fld  	4096,dl
003311  aa  6 00044 3701 20	epp4 	pr6|36,*
003312  la  4 00160 3521 20	epp2 	pr4|112,*		hcs_$reset_ips_mask
003313  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 688
	next_key, current_key, key_for_insertion = NULL;

003314  aa   000001 3360 07	lcq  	1,dl
003315  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003316  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
003317  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
003320  aa  7 00136 7561 00	stq  	pr7|94		disk_data.key_for_insertion
						STATEMENT 1 ON LINE 691
	if found_dev_att
	     then att_dev_idx = pri_iocb_ptr -> attach_data_ptr -> att_dev_idx;

003321  aa  6 00330 2351 00	lda  	pr6|216		found_dev_att
003322  aa   000006 6000 04	tze  	6,ic		003330
003323  aa  6 00134 3715 20	epp5 	pr6|92,*		pri_iocb_ptr
003324  aa  5 00016 3535 20	epp3 	pr5|14,*		iocb.attach_data_ptr
003325  aa  3 00106 2361 00	ldq  	pr3|70		disk_data.att_dev_idx
003326  aa  7 00106 7561 00	stq  	pr7|70		disk_data.att_dev_idx
003327  aa   000027 7100 04	tra  	23,ic		003356
						STATEMENT 1 ON LINE 694
	     else do att_dev_idx = 1 to hbound (attachments.array, 1)
		     while (attachments.array (att_dev_idx).device_att ^= "");

003330  aa  6 00354 6535 00	spri7	pr6|236
003331  aa   000001 2360 07	ldq  	1,dl
003332  aa  6 00354 3715 20	epp5 	pr6|236,*
003333  aa  5 00106 7561 00	stq  	pr5|70		disk_data.att_dev_idx
003334  aa  6 00354 3735 20	epp7 	pr6|236,*
003335  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
003336  aa   000144 1160 07	cmpq 	100,dl
003337  aa   000017 6054 04	tpnz 	15,ic		003356
003340  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
003341  aa  5 00106 2361 00	ldq  	pr5|70		disk_data.att_dev_idx
003342  aa   000016 4020 07	mpy  	14,dl
003343  aa   000000 6270 06	eax7 	0,ql
003344  aa   000000 4310 07	fld  	0,dl
003345  aa  0 00440 2771 00	oraq 	pr0|288		= 040040040040 040040040040
003346  aa  6 00044 3701 20	epp4 	pr6|36,*
003347  ia  4 00010 3535 20	epp3 	pr4|8,*		attachments_ptr
003350  aa  3 77764 1151 17	cmpa 	pr3|-12,7		attachments.device_att
003351  aa   000002 6010 04	tnz  	2,ic		003353
003352  aa  3 77765 1161 17	cmpq 	pr3|-11,7		attachments.device_att
003353  aa   000003 6000 04	tze  	3,ic		003356
						STATEMENT 1 ON LINE 696
		     end;

003354  aa  7 00106 0541 00	aos  	pr7|70		disk_data.att_dev_idx
003355  aa   777757 7100 04	tra  	-17,ic		003334
						STATEMENT 1 ON LINE 697
	if att_dev_idx > attachments.number_used then attachments.number_used = att_dev_idx;

003356  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003357  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
003360  aa  6 00044 3701 20	epp4 	pr6|36,*
003361  ia  4 00010 3715 20	epp5 	pr4|8,*		attachments_ptr
003362  aa  5 00001 1161 00	cmpq 	pr5|1		attachments.number_used
003363  aa   000002 6044 04	tmoz 	2,ic		003365
003364  aa  5 00001 7561 00	stq  	pr5|1		attachments.number_used
						STATEMENT 1 ON LINE 698
	if sv_num = -1
	     then					/* user attaching entire device */
		att_sv_idx = 1;

003365  aa  7 00105 2361 00	ldq  	pr7|69		disk_data.sv_num
003366  aa   014403 1160 04	cmpq 	6403,ic		017771 = 777777777777
003367  aa   000004 6010 04	tnz  	4,ic		003373
003370  aa   000001 2360 07	ldq  	1,dl
003371  aa  7 00107 7561 00	stq  	pr7|71		disk_data.att_sv_idx
003372  aa   000031 7100 04	tra  	25,ic		003423
						STATEMENT 1 ON LINE 701
	     else do att_sv_idx = 1 to 3 while (attachments.array (att_dev_idx).sv (att_sv_idx).this_iocbp ^= null ());

003373  aa  6 00356 6535 00	spri7	pr6|238
003374  aa   000001 2360 07	ldq  	1,dl
003375  aa  6 00356 3535 20	epp3 	pr6|238,*
003376  aa  3 00107 7561 00	stq  	pr3|71		disk_data.att_sv_idx
003377  aa   000000 0110 03	nop  	0,du
003400  aa  6 00356 3735 20	epp7 	pr6|238,*
003401  aa  7 00107 2361 00	ldq  	pr7|71		disk_data.att_sv_idx
003402  aa   000003 1160 07	cmpq 	3,dl
003403  aa   000020 6054 04	tpnz 	16,ic		003423
003404  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
003405  aa  5 00106 2361 00	ldq  	pr5|70		disk_data.att_dev_idx
003406  aa   000016 4020 07	mpy  	14,dl
003407  aa  6 01021 7561 00	stq  	pr6|529
003410  aa  5 00107 2361 00	ldq  	pr5|71		disk_data.att_sv_idx
003411  aa   000002 7360 00	qls  	2
003412  aa  6 01021 0761 00	adq  	pr6|529
003413  aa  6 00044 3701 20	epp4 	pr6|36,*
003414  ia  4 00010 3535 20	epp3 	pr4|8,*		attachments_ptr
003415  aa  3 77764 2371 06	ldaq 	pr3|-12,ql	attachments.this_iocbp
003416  aa   775200 6770 04	eraq 	-1408,ic		000616 = 077777000043 000001000000
003417  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003420  aa   000003 6000 04	tze  	3,ic		003423
						STATEMENT 1 ON LINE 702
		     end;

003421  aa  7 00107 0541 00	aos  	pr7|71		disk_data.att_sv_idx
003422  aa   777756 7100 04	tra  	-18,ic		003400
						STATEMENT 1 ON LINE 703
	if ^(found_dev_att) then attachments.array (att_dev_idx).device_att = addr (rcp_data) -> disk_info.device_name;

003423  aa  6 00330 2351 00	lda  	pr6|216		found_dev_att
003424  aa   000013 6010 04	tnz  	11,ic		003437
003425  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003426  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
003427  aa   000016 4020 07	mpy  	14,dl
003430  aa   000000 6270 06	eax7 	0,ql
003431  aa  7 00156 2351 00	lda  	pr7|110		disk_info.device_name
003432  aa  7 00157 2361 00	ldq  	pr7|111		disk_info.device_name
003433  aa  6 00044 3701 20	epp4 	pr6|36,*
003434  ia  4 00010 3715 20	epp5 	pr4|8,*		attachments_ptr
003435  aa  5 77764 7551 17	sta  	pr5|-12,7		attachments.device_att
003436  aa  5 77765 7561 17	stq  	pr5|-11,7		attachments.device_att
						STATEMENT 1 ON LINE 704
	attachments.array (att_dev_idx).sv (att_sv_idx).this_iocbp = iocb_ptr -> actual_iocb_ptr;

003437  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003440  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
003441  aa   000016 4020 07	mpy  	14,dl
003442  aa  6 01021 7561 00	stq  	pr6|529
003443  aa  7 00107 2361 00	ldq  	pr7|71		disk_data.att_sv_idx
003444  aa   000002 7360 00	qls  	2
003445  aa  6 01021 0761 00	adq  	pr6|529
003446  aa  6 00140 3715 20	epp5 	pr6|96,*		iocb_ptr
003447  aa  5 00012 3715 20	epp5 	pr5|10,*		iocb.actual_iocb_ptr
003450  aa  6 00044 3701 20	epp4 	pr6|36,*
003451  ia  4 00010 3535 20	epp3 	pr4|8,*		attachments_ptr
003452  aa  3 77764 6515 06	spri5	pr3|-12,ql	attachments.this_iocbp
						STATEMENT 1 ON LINE 706
	attachments.array (att_dev_idx).sv (att_sv_idx).this_sv = sv_num;

003453  aa   000000 6270 06	eax7 	0,ql
003454  aa  7 00105 2361 00	ldq  	pr7|69		disk_data.sv_num
003455  aa  3 77762 7561 17	stq  	pr3|-14,7		attachments.this_sv
						STATEMENT 1 ON LINE 707
	attachments.number_attached = attachments.number_attached + 1;

003456  aa  3 00000 0541 00	aos  	pr3|0		attachments.number_attached
						STATEMENT 1 ON LINE 708
exit:
	a_code = code;

003457  aa  6 00157 2361 00	ldq  	pr6|111		code
003460  aa  6 00344 7561 20	stq  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 710
	return;

003461  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_open                                         STATEMENT 1 ON LINE 922
rdisk_open:
     entry (a_iocb_ptr, a_mode, a_ext, a_code);

003462  at     000004000521
003463  tt     000514000515
003464  ta     000520000000
003465  ta     003462000000
003466  da     000643300000
003467  aa   002120 6270 00	eax7 	1104
003470  aa  7 00034 3521 20	epp2 	pr7|28,*
003471  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003472  aa     000010000000
003473  aa     000000000000
003474  aa  6 00032 3735 20	epp7 	pr6|26,*
003475  aa  7 00010 3715 20	epp5 	pr7|8,*
003476  aa  6 00344 6515 00	spri5	pr6|228
003477  aa   776511 7000 04	tsx0 	-695,ic		002210
						STATEMENT 1 ON LINE 948
	call setup ("closed");

003500  aa   775106 2370 04	ldaq 	-1466,ic		000606 = 143154157163 145144000000
003501  aa  6 01070 7571 00	staq 	pr6|568
003502  aa   014250 3520 04	epp2 	6312,ic		017752 = 000002000000
003503  aa  2 00000 2351 00	lda  	pr2|0
003504  aa   010623 6700 04	tsp4 	4499,ic		014327
						STATEMENT 1 ON LINE 951
	mode = a_mode;

003505  aa  6 00032 3735 20	epp7 	pr6|26,*
003506  aa  7 00004 2361 20	ldq  	pr7|4,*		a_mode
003507  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
003510  aa  5 00122 7561 00	stq  	pr5|82		disk_data.mode
						STATEMENT 1 ON LINE 957
	if mode = Stream_input
	     then do;

003511  aa   000001 1160 07	cmpq 	1,dl
003512  aa   000023 6010 04	tnz  	19,ic		003535
						STATEMENT 1 ON LINE 959
		open_descrip.length = 12;

003513  aa   000014 2360 07	ldq  	12,dl
003514  aa  5 00110 7561 00	stq  	pr5|72		disk_data.length
						STATEMENT 1 ON LINE 960
		open_descrip.descrip = "stream_input";

003515  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003516  aa   775147 00 0014	desc9a	-1433,12		000664 = 163164162145
003517  aa  5 00111 00 0040	desc9a	pr5|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 961
		real_iocb_ptr -> position = rdisk_position;

003520  aa   000765 3520 04	epp2 	501,ic		004505 = 002120627000
003521  aa  6 00142 3535 20	epp3 	pr6|98,*		real_iocb_ptr
003522  aa  3 00062 2521 00	spri2	pr3|50		iocb.position
003523  aa   014235 2370 04	ldaq 	6301,ic		017760 = 077777000043 000001000000
003524  aa  3 00064 7571 00	staq 	pr3|52		iocb.position
						STATEMENT 1 ON LINE 962
		real_iocb_ptr -> get_chars = rdisk_read;

003525  aa   001537 3520 04	epp2 	863,ic		005264 = 002120627000
003526  aa  3 00046 2521 00	spri2	pr3|38		iocb.get_chars
003527  aa  3 00050 7571 00	staq 	pr3|40		iocb.get_chars
						STATEMENT 1 ON LINE 963
		next_key = bounds.low;

003530  aa  5 00137 2361 00	ldq  	pr5|95		disk_data.low
003531  aa  5 00134 7561 00	stq  	pr5|92		disk_data.next_key
						STATEMENT 1 ON LINE 964
		fill = "101101101"b;

003532  aa   555000 2350 03	lda  	186880,du
003533  aa  5 00126 7551 00	sta  	pr5|86		disk_data.fill
						STATEMENT 1 ON LINE 965
	     end;

003534  aa   000405 7100 04	tra  	261,ic		004141
						STATEMENT 1 ON LINE 967
	else if mode = Stream_output
	     then do;

003535  aa   000002 1160 07	cmpq 	2,dl
003536  aa   000047 6010 04	tnz  	39,ic		003605
						STATEMENT 1 ON LINE 969
		if ^write_sw
		     then call error (error_table_$incompatible_attach, "stream_output requires -write control arg.");

003537  aa  5 00055 2351 00	lda  	pr5|45		disk_data.write_sw
003540  aa   200000 3150 03	cana 	65536,du
003541  aa   000021 6010 04	tnz  	17,ic		003562
003542  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003543  aa   775632 00 0054	desc9a	-1126,44		001374 = 163164162145
003544  aa  6 01036 00 0054	desc9a	pr6|542,44
003545  aa  6 00044 3701 20	epp4 	pr6|36,*
003546  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$incompatible_attach
003547  aa  6 01074 2521 00	spri2	pr6|572
003550  aa  6 01036 3521 00	epp2 	pr6|542
003551  aa  6 01076 2521 00	spri2	pr6|574
003552  aa   774746 3520 04	epp2 	-1562,ic		000520 = 404000000043
003553  aa  6 01102 2521 00	spri2	pr6|578
003554  aa   774730 3520 04	epp2 	-1576,ic		000504 = 524000000052
003555  aa  6 01104 2521 00	spri2	pr6|580
003556  aa  6 01072 6211 00	eax1 	pr6|570
003557  aa   010000 4310 07	fld  	4096,dl
003560  aa   010771 3520 04	epp2 	4601,ic		014551 = 000160627000
003561  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 972
		open_descrip.length = 13;

003562  aa   000015 2360 07	ldq  	13,dl
003563  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003564  aa  7 00110 7561 00	stq  	pr7|72		disk_data.length
						STATEMENT 1 ON LINE 973
		open_descrip.descrip = "stream_output";

003565  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003566  aa   775145 00 0015	desc9a	-1435,13		000732 = 163164162145
003567  aa  7 00111 00 0040	desc9a	pr7|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 974
		real_iocb_ptr -> position = rdisk_position;

003570  aa   000715 3520 04	epp2 	461,ic		004505 = 002120627000
003571  aa  6 00142 3715 20	epp5 	pr6|98,*		real_iocb_ptr
003572  aa  5 00062 2521 00	spri2	pr5|50		iocb.position
003573  aa   014165 2370 04	ldaq 	6261,ic		017760 = 077777000043 000001000000
003574  aa  5 00064 7571 00	staq 	pr5|52		iocb.position
						STATEMENT 1 ON LINE 975
		real_iocb_ptr -> put_chars = rdisk_write;

003575  aa   002025 3520 04	epp2 	1045,ic		005622 = 002120627000
003576  aa  5 00052 2521 00	spri2	pr5|42		iocb.put_chars
003577  aa  5 00054 7571 00	staq 	pr5|44		iocb.put_chars
						STATEMENT 1 ON LINE 976
		next_key = bounds.low;

003600  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
003601  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 977
		fill = "101101101"b;

003602  aa   555000 2350 03	lda  	186880,du
003603  aa  7 00126 7551 00	sta  	pr7|86		disk_data.fill
						STATEMENT 1 ON LINE 978
	     end;

003604  aa   000335 7100 04	tra  	221,ic		004141
						STATEMENT 1 ON LINE 980
	else if mode = Stream_input_output
	     then do;

003605  aa   000003 1160 07	cmpq 	3,dl
003606  aa   000052 6010 04	tnz  	42,ic		003660
						STATEMENT 1 ON LINE 982
		if ^write_sw
		     then call error (error_table_$incompatible_attach,
			     "stream_input_output requires -write control arg.");

003607  aa  5 00055 2351 00	lda  	pr5|45		disk_data.write_sw
003610  aa   200000 3150 03	cana 	65536,du
003611  aa   000021 6010 04	tnz  	17,ic		003632
003612  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003613  aa   775705 00 0060	desc9a	-1083,48		001517 = 163164162145
003614  aa  6 01072 00 0060	desc9a	pr6|570,48
003615  aa  6 00044 3701 20	epp4 	pr6|36,*
003616  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$incompatible_attach
003617  aa  6 01040 2521 00	spri2	pr6|544
003620  aa  6 01072 3521 00	epp2 	pr6|570
003621  aa  6 01042 2521 00	spri2	pr6|546
003622  aa   774676 3520 04	epp2 	-1602,ic		000520 = 404000000043
003623  aa  6 01046 2521 00	spri2	pr6|550
003624  aa   774657 3520 04	epp2 	-1617,ic		000503 = 524000000060
003625  aa  6 01050 2521 00	spri2	pr6|552
003626  aa  6 01036 6211 00	eax1 	pr6|542
003627  aa   010000 4310 07	fld  	4096,dl
003630  aa   010721 3520 04	epp2 	4561,ic		014551 = 000160627000
003631  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 986
		open_descrip.length = 19;

003632  aa   000023 2360 07	ldq  	19,dl
003633  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003634  aa  7 00110 7561 00	stq  	pr7|72		disk_data.length
						STATEMENT 1 ON LINE 987
		open_descrip.descrip = "stream_input_output";

003635  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003636  aa   775150 00 0023	desc9a	-1432,19		001005 = 163164162145
003637  aa  7 00111 00 0040	desc9a	pr7|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 988
		real_iocb_ptr -> position = rdisk_position;

003640  aa   000645 3520 04	epp2 	421,ic		004505 = 002120627000
003641  aa  6 00142 3715 20	epp5 	pr6|98,*		real_iocb_ptr
003642  aa  5 00062 2521 00	spri2	pr5|50		iocb.position
003643  aa   014115 2370 04	ldaq 	6221,ic		017760 = 077777000043 000001000000
003644  aa  5 00064 7571 00	staq 	pr5|52		iocb.position
						STATEMENT 1 ON LINE 989
		real_iocb_ptr -> get_chars = rdisk_read;

003645  aa   001417 3520 04	epp2 	783,ic		005264 = 002120627000
003646  aa  5 00046 2521 00	spri2	pr5|38		iocb.get_chars
003647  aa  5 00050 7571 00	staq 	pr5|40		iocb.get_chars
						STATEMENT 1 ON LINE 990
		real_iocb_ptr -> put_chars = rdisk_write;

003650  aa   001752 3520 04	epp2 	1002,ic		005622 = 002120627000
003651  aa  5 00052 2521 00	spri2	pr5|42		iocb.put_chars
003652  aa  5 00054 7571 00	staq 	pr5|44		iocb.put_chars
						STATEMENT 1 ON LINE 991
		next_key = bounds.low;

003653  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
003654  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 992
		fill = "101101101"b;

003655  aa   555000 2350 03	lda  	186880,du
003656  aa  7 00126 7551 00	sta  	pr7|86		disk_data.fill
						STATEMENT 1 ON LINE 993
	     end;

003657  aa   000262 7100 04	tra  	178,ic		004141
						STATEMENT 1 ON LINE 995
	else if mode = Sequential_input
	     then do;

003660  aa   000004 1160 07	cmpq 	4,dl
003661  aa   000023 6010 04	tnz  	19,ic		003704
						STATEMENT 1 ON LINE 997
		open_descrip.length = 16;

003662  aa   000020 2360 07	ldq  	16,dl
003663  aa  5 00110 7561 00	stq  	pr5|72		disk_data.length
						STATEMENT 1 ON LINE 998
		open_descrip.descrip = "sequential_input";

003664  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003665  aa   775042 00 0020	desc9a	-1502,16		000726 = 163145161165
003666  aa  5 00111 00 0040	desc9a	pr5|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 999
		real_iocb_ptr -> position = rdisk_position;

003667  aa   000616 3520 04	epp2 	398,ic		004505 = 002120627000
003670  aa  6 00142 3535 20	epp3 	pr6|98,*		real_iocb_ptr
003671  aa  3 00062 2521 00	spri2	pr3|50		iocb.position
003672  aa   014066 2370 04	ldaq 	6198,ic		017760 = 077777000043 000001000000
003673  aa  3 00064 7571 00	staq 	pr3|52		iocb.position
						STATEMENT 1 ON LINE 1000
		real_iocb_ptr -> read_record = rdisk_read;

003674  aa   001370 3520 04	epp2 	760,ic		005264 = 002120627000
003675  aa  3 00072 2521 00	spri2	pr3|58		iocb.read_record
003676  aa  3 00074 7571 00	staq 	pr3|60		iocb.read_record
						STATEMENT 1 ON LINE 1001
		next_key = bounds.low;

003677  aa  5 00137 2361 00	ldq  	pr5|95		disk_data.low
003700  aa  5 00134 7561 00	stq  	pr5|92		disk_data.next_key
						STATEMENT 1 ON LINE 1002
		fill = "101101101"b;

003701  aa   555000 2350 03	lda  	186880,du
003702  aa  5 00126 7551 00	sta  	pr5|86		disk_data.fill
						STATEMENT 1 ON LINE 1003
	     end;

003703  aa   000236 7100 04	tra  	158,ic		004141
						STATEMENT 1 ON LINE 1005
	else if mode = Sequential_output
	     then do;

003704  aa   000005 1160 07	cmpq 	5,dl
003705  aa   000044 6010 04	tnz  	36,ic		003751
						STATEMENT 1 ON LINE 1007
		if ^write_sw
		     then call error (error_table_$incompatible_attach,
			     "sequential_output requires -write control arg.");

003706  aa  5 00055 2351 00	lda  	pr5|45		disk_data.write_sw
003707  aa   200000 3150 03	cana 	65536,du
003710  aa   000021 6010 04	tnz  	17,ic		003731
003711  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003712  aa   775572 00 0060	desc9a	-1158,48		001503 = 163145161165
003713  aa  6 01072 00 0060	desc9a	pr6|570,48
003714  aa  6 00044 3701 20	epp4 	pr6|36,*
003715  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$incompatible_attach
003716  aa  6 01040 2521 00	spri2	pr6|544
003717  aa  6 01072 3521 00	epp2 	pr6|570
003720  aa  6 01042 2521 00	spri2	pr6|546
003721  aa   774577 3520 04	epp2 	-1665,ic		000520 = 404000000043
003722  aa  6 01046 2521 00	spri2	pr6|550
003723  aa   774557 3520 04	epp2 	-1681,ic		000502 = 524000000056
003724  aa  6 01050 2521 00	spri2	pr6|552
003725  aa  6 01036 6211 00	eax1 	pr6|542
003726  aa   010000 4310 07	fld  	4096,dl
003727  aa   010622 3520 04	epp2 	4498,ic		014551 = 000160627000
003730  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1011
		open_descrip.length = 17;

003731  aa   000021 2360 07	ldq  	17,dl
003732  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
003733  aa  7 00110 7561 00	stq  	pr7|72		disk_data.length
						STATEMENT 1 ON LINE 1012
		open_descrip.descrip = "sequential_output";

003734  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003735  aa   775044 00 0021	desc9a	-1500,17		001000 = 163145161165
003736  aa  7 00111 00 0040	desc9a	pr7|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 1013
		real_iocb_ptr -> write_record = rdisk_write;

003737  aa   001663 3520 04	epp2 	947,ic		005622 = 002120627000
003740  aa  6 00142 3715 20	epp5 	pr6|98,*		real_iocb_ptr
003741  aa  5 00076 2521 00	spri2	pr5|62		iocb.write_record
003742  aa   014016 2370 04	ldaq 	6158,ic		017760 = 077777000043 000001000000
003743  aa  5 00100 7571 00	staq 	pr5|64		iocb.write_record
						STATEMENT 1 ON LINE 1014
		next_key = bounds.low;

003744  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
003745  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1015
		fill = "000100000"b;

003746  aa   040000 2350 03	lda  	16384,du
003747  aa  7 00126 7551 00	sta  	pr7|86		disk_data.fill
						STATEMENT 1 ON LINE 1016
	     end;

003750  aa   000171 7100 04	tra  	121,ic		004141
						STATEMENT 1 ON LINE 1018
	else if mode = Sequential_update
	     then do;

003751  aa   000007 1160 07	cmpq 	7,dl
003752  aa   000052 6010 04	tnz  	42,ic		004024
						STATEMENT 1 ON LINE 1020
		if ^write_sw
		     then call error (error_table_$incompatible_attach,
			     "sequential_update requires -write control arg.");

003753  aa  5 00055 2351 00	lda  	pr5|45		disk_data.write_sw
003754  aa   200000 3150 03	cana 	65536,du
003755  aa   000021 6010 04	tnz  	17,ic		003776
003756  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003757  aa   775511 00 0060	desc9a	-1207,48		001467 = 163145161165
003760  aa  6 01072 00 0060	desc9a	pr6|570,48
003761  aa  6 00044 3701 20	epp4 	pr6|36,*
003762  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$incompatible_attach
003763  aa  6 01040 2521 00	spri2	pr6|544
003764  aa  6 01072 3521 00	epp2 	pr6|570
003765  aa  6 01042 2521 00	spri2	pr6|546
003766  aa   774532 3520 04	epp2 	-1702,ic		000520 = 404000000043
003767  aa  6 01046 2521 00	spri2	pr6|550
003770  aa   774512 3520 04	epp2 	-1718,ic		000502 = 524000000056
003771  aa  6 01050 2521 00	spri2	pr6|552
003772  aa  6 01036 6211 00	eax1 	pr6|542
003773  aa   010000 4310 07	fld  	4096,dl
003774  aa   010555 3520 04	epp2 	4461,ic		014551 = 000160627000
003775  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1024
		open_descrip.length = 17;

003776  aa   000021 2360 07	ldq  	17,dl
003777  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004000  aa  7 00110 7561 00	stq  	pr7|72		disk_data.length
						STATEMENT 1 ON LINE 1025
		open_descrip.descrip = "sequential_update";

004001  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004002  aa   774772 00 0021	desc9a	-1542,17		000773 = 163145161165
004003  aa  7 00111 00 0040	desc9a	pr7|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 1026
		real_iocb_ptr -> position = rdisk_position;

004004  aa   000501 3520 04	epp2 	321,ic		004505 = 002120627000
004005  aa  6 00142 3715 20	epp5 	pr6|98,*		real_iocb_ptr
004006  aa  5 00062 2521 00	spri2	pr5|50		iocb.position
004007  aa   013751 2370 04	ldaq 	6121,ic		017760 = 077777000043 000001000000
004010  aa  5 00064 7571 00	staq 	pr5|52		iocb.position
						STATEMENT 1 ON LINE 1027
		real_iocb_ptr -> read_record = rdisk_read;

004011  aa   001253 3520 04	epp2 	683,ic		005264 = 002120627000
004012  aa  5 00072 2521 00	spri2	pr5|58		iocb.read_record
004013  aa  5 00074 7571 00	staq 	pr5|60		iocb.read_record
						STATEMENT 1 ON LINE 1028
		real_iocb_ptr -> rewrite_record = rdisk_rewrite;

004014  aa   001451 3520 04	epp2 	809,ic		005465 = 002120627000
004015  aa  5 00102 2521 00	spri2	pr5|66		iocb.rewrite_record
004016  aa  5 00104 7571 00	staq 	pr5|68		iocb.rewrite_record
						STATEMENT 1 ON LINE 1029
		next_key = bounds.low;

004017  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
004020  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1030
		fill = "000100000"b;

004021  aa   040000 2350 03	lda  	16384,du
004022  aa  7 00126 7551 00	sta  	pr7|86		disk_data.fill
						STATEMENT 1 ON LINE 1031
	     end;

004023  aa   000116 7100 04	tra  	78,ic		004141
						STATEMENT 1 ON LINE 1033
	else if mode = Direct_input
	     then do;

004024  aa   000013 1160 07	cmpq 	11,dl
004025  aa   000021 6010 04	tnz  	17,ic		004046
						STATEMENT 1 ON LINE 1035
		open_descrip.length = 12;

004026  aa   000014 2360 07	ldq  	12,dl
004027  aa  5 00110 7561 00	stq  	pr5|72		disk_data.length
						STATEMENT 1 ON LINE 1036
		open_descrip.descrip = "direct_input";

004030  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004031  aa   774631 00 0014	desc9a	-1639,12		000661 = 144151162145
004032  aa  5 00111 00 0040	desc9a	pr5|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 1037
		real_iocb_ptr -> read_record = rdisk_read;

004033  aa   001231 3520 04	epp2 	665,ic		005264 = 002120627000
004034  aa  6 00142 3535 20	epp3 	pr6|98,*		real_iocb_ptr
004035  aa  3 00072 2521 00	spri2	pr3|58		iocb.read_record
004036  aa   013722 2370 04	ldaq 	6098,ic		017760 = 077777000043 000001000000
004037  aa  3 00074 7571 00	staq 	pr3|60		iocb.read_record
						STATEMENT 1 ON LINE 1038
		real_iocb_ptr -> seek_key = rdisk_seek;

004040  aa   000221 3520 04	epp2 	145,ic		004261 = 002120627000
004041  aa  3 00112 2521 00	spri2	pr3|74		iocb.seek_key
004042  aa  3 00114 7571 00	staq 	pr3|76		iocb.seek_key
						STATEMENT 1 ON LINE 1039
		fill = "110110110"b;

004043  aa   666000 2350 03	lda  	224256,du
004044  aa  5 00126 7551 00	sta  	pr5|86		disk_data.fill
						STATEMENT 1 ON LINE 1040
	     end;

004045  aa   000074 7100 04	tra  	60,ic		004141
						STATEMENT 1 ON LINE 1042
	else if mode = Direct_update
	     then do;

004046  aa   000015 1160 07	cmpq 	13,dl
004047  aa   000047 6010 04	tnz  	39,ic		004116
						STATEMENT 1 ON LINE 1044
		if ^write_sw
		     then call error (error_table_$incompatible_attach, "direct_update requires -write control arg.");

004050  aa  5 00055 2351 00	lda  	pr5|45		disk_data.write_sw
004051  aa   200000 3150 03	cana 	65536,du
004052  aa   000021 6010 04	tnz  	17,ic		004073
004053  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004054  aa   775306 00 0054	desc9a	-1338,44		001361 = 144151162145
004055  aa  6 01072 00 0054	desc9a	pr6|570,44
004056  aa  6 00044 3701 20	epp4 	pr6|36,*
004057  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$incompatible_attach
004060  aa  6 01040 2521 00	spri2	pr6|544
004061  aa  6 01072 3521 00	epp2 	pr6|570
004062  aa  6 01042 2521 00	spri2	pr6|546
004063  aa   774435 3520 04	epp2 	-1763,ic		000520 = 404000000043
004064  aa  6 01046 2521 00	spri2	pr6|550
004065  aa   774417 3520 04	epp2 	-1777,ic		000504 = 524000000052
004066  aa  6 01050 2521 00	spri2	pr6|552
004067  aa  6 01036 6211 00	eax1 	pr6|542
004070  aa   010000 4310 07	fld  	4096,dl
004071  aa   010460 3520 04	epp2 	4400,ic		014551 = 000160627000
004072  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1047
		open_descrip.length = 13;

004073  aa   000015 2360 07	ldq  	13,dl
004074  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004075  aa  7 00110 7561 00	stq  	pr7|72		disk_data.length
						STATEMENT 1 ON LINE 1048
		open_descrip.descrip = "direct_update";

004076  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004077  aa   774624 00 0015	desc9a	-1644,13		000722 = 144151162145
004100  aa  7 00111 00 0040	desc9a	pr7|73,32		disk_data.descrip
						STATEMENT 1 ON LINE 1049
		real_iocb_ptr -> read_record = rdisk_read;

004101  aa   001163 3520 04	epp2 	627,ic		005264 = 002120627000
004102  aa  6 00142 3715 20	epp5 	pr6|98,*		real_iocb_ptr
004103  aa  5 00072 2521 00	spri2	pr5|58		iocb.read_record
004104  aa   013654 2370 04	ldaq 	6060,ic		017760 = 077777000043 000001000000
004105  aa  5 00074 7571 00	staq 	pr5|60		iocb.read_record
						STATEMENT 1 ON LINE 1050
		real_iocb_ptr -> rewrite_record = rdisk_rewrite;

004106  aa   001357 3520 04	epp2 	751,ic		005465 = 002120627000
004107  aa  5 00102 2521 00	spri2	pr5|66		iocb.rewrite_record
004110  aa  5 00104 7571 00	staq 	pr5|68		iocb.rewrite_record
						STATEMENT 1 ON LINE 1051
		real_iocb_ptr -> seek_key = rdisk_seek;

004111  aa   000150 3520 04	epp2 	104,ic		004261 = 002120627000
004112  aa  5 00112 2521 00	spri2	pr5|74		iocb.seek_key
004113  aa  5 00114 7571 00	staq 	pr5|76		iocb.seek_key
						STATEMENT 1 ON LINE 1052
		fill = "000000000"b;

004114  aa  7 00126 4501 00	stz  	pr7|86		disk_data.fill
						STATEMENT 1 ON LINE 1053
	     end;

004115  aa   000024 7100 04	tra  	20,ic		004141
						STATEMENT 1 ON LINE 1055
	else do;

						STATEMENT 1 ON LINE 1056
	     current_mode_name = iox_modes (mode);

004116  aa   000006 4020 07	mpy  	6,dl
004117  aa   000000 6270 06	eax7 	0,ql
004120  ta   000032 3534 17	epp3 	26,7
004121  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004122  aa  3 00000 00 0030	desc9a	pr3|0,24		iox_modes
004123  aa  6 00311 00 0030	desc9a	pr6|201,24	current_mode_name
						STATEMENT 1 ON LINE 1057
	     call error (error_table_$request_not_recognized, current_mode_name);

004124  aa  6 00044 3701 20	epp4 	pr6|36,*
004125  la  4 00070 3521 20	epp2 	pr4|56,*		error_table_$request_not_recognized
004126  aa  6 01074 2521 00	spri2	pr6|572
004127  aa  6 00311 3521 00	epp2 	pr6|201		current_mode_name
004130  aa  6 01076 2521 00	spri2	pr6|574
004131  aa   774367 3520 04	epp2 	-1801,ic		000520 = 404000000043
004132  aa  6 01102 2521 00	spri2	pr6|578
004133  aa   774346 3520 04	epp2 	-1818,ic		000501 = 526000000030
004134  aa  6 01104 2521 00	spri2	pr6|580
004135  aa  6 01072 6211 00	eax1 	pr6|570
004136  aa   010000 4310 07	fld  	4096,dl
004137  aa   010412 3520 04	epp2 	4362,ic		014551 = 000160627000
004140  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1059
	end;

						STATEMENT 1 ON LINE 1062
	if a_ext then call error (error_table_$action_not_performed, "Extension attempt -- not valid for disk.");

004141  aa  6 00032 3735 20	epp7 	pr6|26,*
004142  aa  7 00006 2351 20	lda  	pr7|6,*		a_ext
004143  aa   400000 3150 03	cana 	131072,du
004144  aa   000021 6000 04	tze  	17,ic		004165
004145  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004146  aa   775141 00 0050	desc9a	-1439,40		001306 = 105170164145
004147  aa  6 01022 00 0050	desc9a	pr6|530,40
004150  aa  6 00044 3701 20	epp4 	pr6|36,*
004151  la  4 00022 3521 20	epp2 	pr4|18,*		error_table_$action_not_performed
004152  aa  6 01074 2521 00	spri2	pr6|572
004153  aa  6 01022 3521 00	epp2 	pr6|530
004154  aa  6 01076 2521 00	spri2	pr6|574
004155  aa   774343 3520 04	epp2 	-1821,ic		000520 = 404000000043
004156  aa  6 01102 2521 00	spri2	pr6|578
004157  aa   774321 3520 04	epp2 	-1839,ic		000500 = 524000000050
004160  aa  6 01104 2521 00	spri2	pr6|580
004161  aa  6 01072 6211 00	eax1 	pr6|570
004162  aa   010000 4310 07	fld  	4096,dl
004163  aa   010366 3520 04	epp2 	4342,ic		014551 = 000160627000
004164  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1066
	mask_str = "0"b;

004165  aa  6 00277 4501 00	stz  	pr6|191		mask_str
						STATEMENT 1 ON LINE 1067
	call default_handler_$set (cond_hdlr);

004166  aa   011221 3520 04	epp2 	4753,ic		015407 = 000140627000
004167  aa  6 01014 2521 00	spri2	pr6|524		cp.789
004170  aa  6 01016 6521 00	spri6	pr6|526		cp.789
004171  aa  6 01014 3521 00	epp2 	pr6|524		cp.789
004172  aa  6 01024 2521 00	spri2	pr6|532
004173  aa  6 01022 6211 00	eax1 	pr6|530
004174  aa   004000 4310 07	fld  	2048,dl
004175  aa  6 00044 3701 20	epp4 	pr6|36,*
004176  la  4 00162 3521 20	epp2 	pr4|114,*		default_handler_$set
004177  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1068
	call hcs_$set_ips_mask (mask_str, mask_str);

004200  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
004201  aa  6 01024 2521 00	spri2	pr6|532
004202  aa  6 01026 2521 00	spri2	pr6|534
004203  aa  6 01022 6211 00	eax1 	pr6|530
004204  aa   010000 4310 07	fld  	4096,dl
004205  aa  6 00044 3701 20	epp4 	pr6|36,*
004206  la  4 00156 3521 20	epp2 	pr4|110,*		hcs_$set_ips_mask
004207  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1072
	real_iocb_ptr -> close = rdisk_close;

004210  aa   004017 3520 04	epp2 	2063,ic		010227 = 002120627000
004211  aa  6 00142 3735 20	epp7 	pr6|98,*		real_iocb_ptr
004212  aa  7 00036 2521 00	spri2	pr7|30		iocb.close
004213  aa   013545 2370 04	ldaq 	5989,ic		017760 = 077777000043 000001000000
004214  aa  7 00040 7571 00	staq 	pr7|32		iocb.close
						STATEMENT 1 ON LINE 1073
	real_iocb_ptr -> open, real_iocb_ptr -> detach_iocb = iox_$err_not_closed;

004215  aa  6 00044 3701 20	epp4 	pr6|36,*
004216  la  4 00110 3521 20	epp2 	pr4|72,*		iox_$err_not_closed
004217  aa  6 01014 2521 00	spri2	pr6|524		cp.137
004220  aa  6 01016 7571 00	staq 	pr6|526		cp.137
004221  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.137
004222  aa  7 00032 2521 00	spri2	pr7|26		iocb.open
004223  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.137
004224  aa  7 00034 2521 00	spri2	pr7|28		iocb.open
004225  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.137
004226  aa  7 00026 2521 00	spri2	pr7|22		iocb.detach_iocb
004227  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.137
004230  aa  7 00030 2521 00	spri2	pr7|24		iocb.detach_iocb
						STATEMENT 1 ON LINE 1076
	real_iocb_ptr -> open_descrip_ptr = addr (open_descrip);

004231  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
004232  aa  5 00110 3715 00	epp5 	pr5|72		disk_data.open_descrip
004233  aa  7 00020 6515 00	spri5	pr7|16		iocb.open_descrip_ptr
						STATEMENT 1 ON LINE 1079
	call iox_$propagate (iocb_ptr);

004234  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
004235  aa  6 01016 2521 00	spri2	pr6|526
004236  aa  6 01014 6211 00	eax1 	pr6|524
004237  aa   004000 4310 07	fld  	2048,dl
004240  la  4 00126 3521 20	epp2 	pr4|86,*		iox_$propagate
004241  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1081
	call hcs_$reset_ips_mask (mask_str, mask_str);

004242  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
004243  aa  6 01024 2521 00	spri2	pr6|532
004244  aa  6 01026 2521 00	spri2	pr6|534
004245  aa  6 01022 6211 00	eax1 	pr6|530
004246  aa   010000 4310 07	fld  	4096,dl
004247  aa  6 00044 3701 20	epp4 	pr6|36,*
004250  la  4 00160 3521 20	epp2 	pr4|112,*		hcs_$reset_ips_mask
004251  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1083
	a_code = 0;

004252  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 1084
	return;

004253  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_seek                                         STATEMENT 1 ON LINE 1090
rdisk_seek:
     entry (a_iocb_ptr, a_key, a_rec_len, a_code);

004254  at     000004000521
004255  tt     000513000517
004256  ta     000520000000
004257  ta     004254000000
004260  da     000651300000
004261  aa   002120 6270 00	eax7 	1104
004262  aa  7 00034 3521 20	epp2 	pr7|28,*
004263  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004264  aa     000010000000
004265  aa     000000000000
004266  aa  6 00032 3735 20	epp7 	pr6|26,*
004267  aa  7 00006 3715 20	epp5 	pr7|6,*
004270  aa  6 00346 6515 00	spri5	pr6|230
004271  aa  7 00010 3535 20	epp3 	pr7|8,*
004272  aa  6 00344 2535 00	spri3	pr6|228
004273  aa   775715 7000 04	tsx0 	-1075,ic		002210
						STATEMENT 1 ON LINE 1107
	call setup ("open");

004274  aa   774203 2350 04	lda  	-1917,ic		000477 = 157160145156
004275  aa  6 01021 7551 00	sta  	pr6|529
004276  aa   013446 3520 04	epp2 	5926,ic		017744 = 000002000000
004277  aa  2 00000 2351 00	lda  	pr2|0
004300  aa   010027 6700 04	tsp4 	4119,ic		014327
						STATEMENT 1 ON LINE 1108
	if mode = Direct_input | mode = Direct_update
	     then ;

004301  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004302  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
004303  aa   000013 1160 07	cmpq 	11,dl
004304  aa   000024 6000 04	tze  	20,ic		004330
004305  aa   000015 1160 07	cmpq 	13,dl
004306  aa   000002 6010 04	tnz  	2,ic		004310
004307  aa   000021 7100 04	tra  	17,ic		004330
						STATEMENT 1 ON LINE 1110
	     else call error (error_table_$no_record, "seek valid only for direct openings.");

004310  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004311  aa   774715 00 0044	desc9a	-1587,36		001225 = 163145145153
004312  aa  6 01022 00 0044	desc9a	pr6|530,36
004313  aa  6 00044 3701 20	epp4 	pr6|36,*
004314  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
004315  aa  6 01074 2521 00	spri2	pr6|572
004316  aa  6 01022 3521 00	epp2 	pr6|530
004317  aa  6 01076 2521 00	spri2	pr6|574
004320  aa   774200 3520 04	epp2 	-1920,ic		000520 = 404000000043
004321  aa  6 01102 2521 00	spri2	pr6|578
004322  aa   774153 3520 04	epp2 	-1941,ic		000475 = 524000000044
004323  aa  6 01104 2521 00	spri2	pr6|580
004324  aa  6 01072 6211 00	eax1 	pr6|570
004325  aa   010000 4310 07	fld  	4096,dl
004326  aa   010223 3520 04	epp2 	4243,ic		014551 = 000160627000
004327  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1112
	temp_key = cv_dec_check_ (ltrim (rtrim (a_key)), code);

004330  aa  6 00032 3735 20	epp7 	pr6|26,*
004331  aa  7 00004 3715 20	epp5 	pr7|4,*
004332  aa  5 77777 7271 00	lxl7 	pr5|-1		a_key
004333  aa  000 000 165 540	tctr 	(pr,rl)
004334  aa  5 00000 00 0017	desc9a	pr5|0,x7		a_key
004335  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
004336  aa  6 00056 0001 00	arg  	pr6|46
004337  aa  6 00056 2361 00	ldq  	pr6|46
004340  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
004341  aa  6 01034 7561 00	stq  	pr6|540
004342  aa  5 77777 2361 00	ldq  	pr5|-1		a_key
004343  aa  6 01034 1761 00	sbq  	pr6|540
004344  aa  6 01034 7561 00	stq  	pr6|540
004345  aa  000 000 164 540	tct  	(pr,rl)
004346  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_key
004347  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
004350  aa  6 00056 0001 00	arg  	pr6|46
004351  aa  6 00056 2361 00	ldq  	pr6|46
004352  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
004353  aa  6 01020 7561 00	stq  	pr6|528
004354  aa  6 01034 2361 00	ldq  	pr6|540
004355  aa  6 01020 1761 00	sbq  	pr6|528
004356  aa  6 01034 7561 00	stq  	pr6|540
004357  aa   524000 2760 03	orq  	174080,du
004360  aa  6 01021 7561 00	stq  	pr6|529
004361  aa  6 01034 2361 00	ldq  	pr6|540
004362  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
004363  aa  6 01040 2521 00	spri2	pr6|544
004364  aa  6 01020 2351 00	lda  	pr6|528
004365  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
004366  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_key
004367  aa  2 00000 00 0006	desc9a	pr2|0,ql
004370  aa  6 00157 3521 00	epp2 	pr6|111		code
004371  aa  6 01042 2521 00	spri2	pr6|546
004372  aa  6 00300 3521 00	epp2 	pr6|192		temp_key
004373  aa  6 01044 2521 00	spri2	pr6|548
004374  aa  6 01021 3521 00	epp2 	pr6|529
004375  aa  6 01046 2521 00	spri2	pr6|550
004376  aa   774122 3520 04	epp2 	-1966,ic		000520 = 404000000043
004377  aa  6 01050 2521 00	spri2	pr6|552
004400  aa  6 01052 2521 00	spri2	pr6|554
004401  aa  6 01036 6211 00	eax1 	pr6|542
004402  aa   014000 4310 07	fld  	6144,dl
004403  aa  6 00044 3701 20	epp4 	pr6|36,*
004404  la  4 00132 3521 20	epp2 	pr4|90,*		cv_dec_check_
004405  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1113
	if code ^= 0 then call error (error_table_$no_record, (a_key));

004406  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
004407  aa  6 00157 2361 00	ldq  	pr6|111		code
004410  aa   000030 6000 04	tze  	24,ic		004440
004411  aa  6 00032 3735 20	epp7 	pr6|26,*
004412  aa  7 00004 3715 20	epp5 	pr7|4,*
004413  aa  5 77777 2361 00	ldq  	pr5|-1		a_key
004414  aa   524000 2760 03	orq  	174080,du
004415  aa  6 01021 7561 00	stq  	pr6|529
004416  aa  5 77777 2361 00	ldq  	pr5|-1		a_key
004417  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
004420  aa  6 01076 2521 00	spri2	pr6|574
004421  aa  5 77777 7271 00	lxl7 	pr5|-1		a_key
004422  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
004423  aa  5 00000 00 0017	desc9a	pr5|0,x7		a_key
004424  aa  2 00000 00 0006	desc9a	pr2|0,ql
004425  aa  6 00044 3701 20	epp4 	pr6|36,*
004426  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
004427  aa  6 01074 2521 00	spri2	pr6|572
004430  aa   774070 3520 04	epp2 	-1992,ic		000520 = 404000000043
004431  aa  6 01102 2521 00	spri2	pr6|578
004432  aa  6 01021 3521 00	epp2 	pr6|529
004433  aa  6 01104 2521 00	spri2	pr6|580
004434  aa  6 01072 6211 00	eax1 	pr6|570
004435  aa   010000 4310 07	fld  	4096,dl
004436  aa   010113 3520 04	epp2 	4171,ic		014551 = 000160627000
004437  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1115
	if (temp_key < bounds.low) | (temp_key > bounds.high)
	     then call error (error_table_$no_record, "Requested sector outside available area.");

004440  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
004441  aa  6 00300 2361 00	ldq  	pr6|192		temp_key
004442  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004443  aa  7 00137 1161 00	cmpq 	pr7|95		disk_data.low
004444  aa   000003 6040 04	tmi  	3,ic		004447
004445  aa  7 00140 1161 00	cmpq 	pr7|96		disk_data.high
004446  aa   000022 6044 04	tmoz 	18,ic		004470
004447  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004450  aa   774625 00 0050	desc9a	-1643,40		001274 = 122145161165
004451  aa  6 01022 00 0050	desc9a	pr6|530,40
004452  aa  6 00044 3701 20	epp4 	pr6|36,*
004453  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
004454  aa  6 01074 2521 00	spri2	pr6|572
004455  aa  6 01022 3521 00	epp2 	pr6|530
004456  aa  6 01076 2521 00	spri2	pr6|574
004457  aa   774041 3520 04	epp2 	-2015,ic		000520 = 404000000043
004460  aa  6 01102 2521 00	spri2	pr6|578
004461  aa   774017 3520 04	epp2 	-2033,ic		000500 = 524000000050
004462  aa  6 01104 2521 00	spri2	pr6|580
004463  aa  6 01072 6211 00	eax1 	pr6|570
004464  aa   010000 4310 07	fld  	4096,dl
004465  aa   010064 3520 04	epp2 	4148,ic		014551 = 000160627000
004466  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
004467  aa   000003 7100 04	tra  	3,ic		004472
						STATEMENT 1 ON LINE 1117
	     else next_key, current_key = temp_key;

004470  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
004471  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1119
	a_rec_len = 4 * sect_size;

004472  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004473  aa  7 00101 2361 00	ldq  	pr7|65		disk_data.sect_size
004474  aa   000002 7360 00	qls  	2
004475  aa  6 00346 7561 20	stq  	pr6|230,*		a_rec_len
						STATEMENT 1 ON LINE 1120
	a_code = 0;

004476  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 1121
	return;

004477  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_position                                     STATEMENT 1 ON LINE 1127
rdisk_position:
     entry (a_iocb_ptr, a_type, a_quantity, a_code);

004500  at     000004000521
004501  tt     000514000517
004502  ta     000520000000
004503  ta     004500000000
004504  da     000660300000
004505  aa   002120 6270 00	eax7 	1104
004506  aa  7 00034 3521 20	epp2 	pr7|28,*
004507  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004510  aa     000010000000
004511  aa     000000000000
004512  aa  6 00032 3735 20	epp7 	pr6|26,*
004513  aa  7 00010 3715 20	epp5 	pr7|8,*
004514  aa  6 00344 6515 00	spri5	pr6|228
004515  aa   775473 7000 04	tsx0 	-1221,ic		002210
						STATEMENT 1 ON LINE 1192
	call setup ("open");

004516  aa   773761 2350 04	lda  	-2063,ic		000477 = 157160145156
004517  aa  6 01021 7551 00	sta  	pr6|529
004520  aa   013224 3520 04	epp2 	5780,ic		017744 = 000002000000
004521  aa  2 00000 2351 00	lda  	pr2|0
004522  aa   007605 6700 04	tsp4 	3973,ic		014327
						STATEMENT 1 ON LINE 1195
	if mode = Direct_update | mode = Direct_input
	     then call error (error_table_$no_operation,
		     "Position operation valid only for sequential or stream openings.");

004523  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004524  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
004525  aa   000015 1160 07	cmpq 	13,dl
004526  aa   000003 6000 04	tze  	3,ic		004531
004527  aa   000013 1160 07	cmpq 	11,dl
004530  aa   000021 6010 04	tnz  	17,ic		004551
004531  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004532  aa   775235 00 0100	desc9a	-1379,64		001766 = 120157163151
004533  aa  6 01036 00 0100	desc9a	pr6|542,64
004534  aa  6 00044 3701 20	epp4 	pr6|36,*
004535  la  4 00052 3521 20	epp2 	pr4|42,*		error_table_$no_operation
004536  aa  6 01074 2521 00	spri2	pr6|572
004537  aa  6 01036 3521 00	epp2 	pr6|542
004540  aa  6 01076 2521 00	spri2	pr6|574
004541  aa   773757 3520 04	epp2 	-2065,ic		000520 = 404000000043
004542  aa  6 01102 2521 00	spri2	pr6|578
004543  aa   773731 3520 04	epp2 	-2087,ic		000474 = 524000000100
004544  aa  6 01104 2521 00	spri2	pr6|580
004545  aa  6 01072 6211 00	eax1 	pr6|570
004546  aa   010000 4310 07	fld  	4096,dl
004547  aa   010002 3520 04	epp2 	4098,ic		014551 = 000160627000
004550  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1199
	type = a_type;

004551  aa  6 00032 3735 20	epp7 	pr6|26,*
004552  aa  7 00004 2361 20	ldq  	pr7|4,*		a_type
004553  aa  6 00332 7561 00	stq  	pr6|218		type
						STATEMENT 1 ON LINE 1201
	quantity = a_quantity;

004554  aa  7 00006 2361 20	ldq  	pr7|6,*		a_quantity
004555  aa  6 00333 7561 00	stq  	pr6|219		quantity
						STATEMENT 1 ON LINE 1203
	if (type < -1) | (2 < type)
	     then call error (error_table_$no_operation, "Only legal values for type are -1, 0, +1, and +2");

004556  aa  6 00332 2361 00	ldq  	pr6|218		type
004557  aa   013212 1160 04	cmpq 	5770,ic		017771 = 777777777777
004560  aa   000003 6040 04	tmi  	3,ic		004563
004561  aa   000002 1160 07	cmpq 	2,dl
004562  aa   000021 6044 04	tmoz 	17,ic		004603
004563  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004564  aa   774670 00 0060	desc9a	-1608,48		001453 = 117156154171
004565  aa  6 01072 00 0060	desc9a	pr6|570,48
004566  aa  6 00044 3701 20	epp4 	pr6|36,*
004567  la  4 00052 3521 20	epp2 	pr4|42,*		error_table_$no_operation
004570  aa  6 01040 2521 00	spri2	pr6|544
004571  aa  6 01072 3521 00	epp2 	pr6|570
004572  aa  6 01042 2521 00	spri2	pr6|546
004573  aa   773725 3520 04	epp2 	-2091,ic		000520 = 404000000043
004574  aa  6 01046 2521 00	spri2	pr6|550
004575  aa   773706 3520 04	epp2 	-2106,ic		000503 = 524000000060
004576  aa  6 01050 2521 00	spri2	pr6|552
004577  aa  6 01036 6211 00	eax1 	pr6|542
004600  aa   010000 4310 07	fld  	4096,dl
004601  aa   007750 3520 04	epp2 	4072,ic		014551 = 000160627000
004602  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1206
	if mode = Stream_input | mode = Stream_output | mode = Stream_input_output
	     then do;

004603  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004604  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
004605  aa   000001 1160 07	cmpq 	1,dl
004606  aa   000005 6000 04	tze  	5,ic		004613
004607  aa   000002 1160 07	cmpq 	2,dl
004610  aa   000003 6000 04	tze  	3,ic		004613
004611  aa   000003 1160 07	cmpq 	3,dl
004612  aa   000041 6010 04	tnz  	33,ic		004653
						STATEMENT 1 ON LINE 1208
		if mod (quantity, sect_size * 4) ^= 0
		     then do;

004613  aa  7 00101 2361 00	ldq  	pr7|65		disk_data.sect_size
004614  aa   000002 7360 00	qls  	2
004615  aa  6 01021 7561 00	stq  	pr6|529
004616  aa  6 00333 2361 00	ldq  	pr6|219		quantity
004617  aa  6 01021 3521 00	epp2 	pr6|529
004620  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
004621  aa   000023 6000 04	tze  	19,ic		004644
						STATEMENT 1 ON LINE 1210
			next_key = NULL;

004622  aa   000001 3360 07	lcq  	1,dl
004623  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1211
			call error (error_table_$no_record, "Byte offset specified not at begining of sector");

004624  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004625  aa   774613 00 0060	desc9a	-1653,48		001437 = 102171164145
004626  aa  6 01072 00 0060	desc9a	pr6|570,48
004627  aa  6 00044 3701 20	epp4 	pr6|36,*
004630  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
004631  aa  6 01040 2521 00	spri2	pr6|544
004632  aa  6 01072 3521 00	epp2 	pr6|570
004633  aa  6 01042 2521 00	spri2	pr6|546
004634  aa   773664 3520 04	epp2 	-2124,ic		000520 = 404000000043
004635  aa  6 01046 2521 00	spri2	pr6|550
004636  aa   773635 3520 04	epp2 	-2147,ic		000473 = 524000000057
004637  aa  6 01050 2521 00	spri2	pr6|552
004640  aa  6 01036 6211 00	eax1 	pr6|542
004641  aa   010000 4310 07	fld  	4096,dl
004642  aa   007707 3520 04	epp2 	4039,ic		014551 = 000160627000
004643  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1212
		     end;

						STATEMENT 1 ON LINE 1214
		quantity = divide (quantity, sect_size * 4, 17, 0);

004644  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004645  aa  7 00101 2361 00	ldq  	pr7|65		disk_data.sect_size
004646  aa   000002 7360 00	qls  	2
004647  aa  6 01021 7561 00	stq  	pr6|529
004650  aa  6 00333 2361 00	ldq  	pr6|219		quantity
004651  aa  6 01021 5061 00	div  	pr6|529
004652  aa  6 00333 7561 00	stq  	pr6|219		quantity
						STATEMENT 1 ON LINE 1215
	     end;

						STATEMENT 1 ON LINE 1217
	if type = -1
	     then do;

004653  aa  6 00332 2361 00	ldq  	pr6|218		type
004654  aa   013115 1160 04	cmpq 	5709,ic		017771 = 777777777777
004655  aa   000004 6010 04	tnz  	4,ic		004661
						STATEMENT 1 ON LINE 1219
		next_key = bounds.low;

004656  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
004657  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1220
	     end;

004660  aa   000367 7100 04	tra  	247,ic		005247
						STATEMENT 1 ON LINE 1222
	else if type = +1
	     then do;

004661  aa   000001 1160 07	cmpq 	1,dl
004662  aa   000004 6010 04	tnz  	4,ic		004666
						STATEMENT 1 ON LINE 1224
		next_key = END;

004663  aa   000005 3360 07	lcq  	5,dl
004664  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1225
	     end;

004665  aa   000362 7100 04	tra  	242,ic		005247
						STATEMENT 1 ON LINE 1227
	else if (type = 2) & (quantity < bounds.low)
	     then do;

004666  aa   000002 1160 07	cmpq 	2,dl
004667  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
004670  aa  6 01021 7551 00	sta  	pr6|529
004671  aa   000030 6000 04	tze  	24,ic		004721
004672  aa  6 00333 2361 00	ldq  	pr6|219		quantity
004673  aa  7 00137 1161 00	cmpq 	pr7|95		disk_data.low
004674  aa   000025 6050 04	tpl  	21,ic		004721
						STATEMENT 1 ON LINE 1229
		call error (error_table_$end_of_info, "quantity is before first available sector");

004675  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004676  aa   774451 00 0054	desc9a	-1751,44		001346 = 161165141156
004677  aa  6 01072 00 0054	desc9a	pr6|570,44
004700  aa  6 00044 3701 20	epp4 	pr6|36,*
004701  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
004702  aa  6 01040 2521 00	spri2	pr6|544
004703  aa  6 01072 3521 00	epp2 	pr6|570
004704  aa  6 01042 2521 00	spri2	pr6|546
004705  aa   773613 3520 04	epp2 	-2165,ic		000520 = 404000000043
004706  aa  6 01046 2521 00	spri2	pr6|550
004707  aa   773563 3520 04	epp2 	-2189,ic		000472 = 524000000051
004710  aa  6 01050 2521 00	spri2	pr6|552
004711  aa  6 01036 6211 00	eax1 	pr6|542
004712  aa   010000 4310 07	fld  	4096,dl
004713  aa   007636 3520 04	epp2 	3998,ic		014551 = 000160627000
004714  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1230
		next_key = bounds.low;

004715  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004716  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
004717  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1231
	     end;

004720  aa   000327 7100 04	tra  	215,ic		005247
						STATEMENT 1 ON LINE 1233
	else if (type = 2) & (bounds.low <= quantity) & (quantity <= bounds.high)
	     then do;

004721  aa  6 01021 2351 00	lda  	pr6|529
004722  aa   000011 6000 04	tze  	9,ic		004733
004723  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
004724  aa  6 00333 1161 00	cmpq 	pr6|219		quantity
004725  aa   000006 6054 04	tpnz 	6,ic		004733
004726  aa  6 00333 2361 00	ldq  	pr6|219		quantity
004727  aa  7 00140 1161 00	cmpq 	pr7|96		disk_data.high
004730  aa   000003 6054 04	tpnz 	3,ic		004733
						STATEMENT 1 ON LINE 1235
		next_key = quantity;

004731  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1236
	     end;

004732  aa   000315 7100 04	tra  	205,ic		005247
						STATEMENT 1 ON LINE 1238
	else if (type = 2) & (quantity > bounds.high)
	     then do;

004733  aa   400000 3150 03	cana 	131072,du
004734  aa   000030 6000 04	tze  	24,ic		004764
004735  aa  6 00333 2361 00	ldq  	pr6|219		quantity
004736  aa  7 00140 1161 00	cmpq 	pr7|96		disk_data.high
004737  aa   000025 6044 04	tmoz 	21,ic		004764
						STATEMENT 1 ON LINE 1240
		call error (error_table_$end_of_info, "quantity is after last available sector");

004740  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004741  aa   774322 00 0050	desc9a	-1838,40		001262 = 161165141156
004742  aa  6 01022 00 0050	desc9a	pr6|530,40
004743  aa  6 00044 3701 20	epp4 	pr6|36,*
004744  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
004745  aa  6 01074 2521 00	spri2	pr6|572
004746  aa  6 01022 3521 00	epp2 	pr6|530
004747  aa  6 01076 2521 00	spri2	pr6|574
004750  aa   773550 3520 04	epp2 	-2200,ic		000520 = 404000000043
004751  aa  6 01102 2521 00	spri2	pr6|578
004752  aa   773517 3520 04	epp2 	-2225,ic		000471 = 524000000047
004753  aa  6 01104 2521 00	spri2	pr6|580
004754  aa  6 01072 6211 00	eax1 	pr6|570
004755  aa   010000 4310 07	fld  	4096,dl
004756  aa   007573 3520 04	epp2 	3963,ic		014551 = 000160627000
004757  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1241
		next_key = END;

004760  aa   000005 3360 07	lcq  	5,dl
004761  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
004762  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1242
	     end;

004763  aa   000264 7100 04	tra  	180,ic		005247
						STATEMENT 1 ON LINE 1245
	else if (type = 0) & (next_key = NULL)
	     then call error (error_table_$no_current_record, "Present position is undefined.");

004764  aa  6 00332 2361 00	ldq  	pr6|218		type
004765  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
004766  aa  6 01021 7551 00	sta  	pr6|529
004767  aa   000025 6000 04	tze  	21,ic		005014
004770  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
004771  aa   013000 1160 04	cmpq 	5632,ic		017771 = 777777777777
004772  aa   000022 6010 04	tnz  	18,ic		005014
004773  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004774  aa   774167 00 0040	desc9a	-1929,32		001162 = 120162145163
004775  aa  6 01022 00 0040	desc9a	pr6|530,32
004776  aa  6 00044 3701 20	epp4 	pr6|36,*
004777  la  4 00050 3521 20	epp2 	pr4|40,*		error_table_$no_current_record
005000  aa  6 01074 2521 00	spri2	pr6|572
005001  aa  6 01022 3521 00	epp2 	pr6|530
005002  aa  6 01076 2521 00	spri2	pr6|574
005003  aa   773515 3520 04	epp2 	-2227,ic		000520 = 404000000043
005004  aa  6 01102 2521 00	spri2	pr6|578
005005  aa   773463 3520 04	epp2 	-2253,ic		000470 = 524000000036
005006  aa  6 01104 2521 00	spri2	pr6|580
005007  aa  6 01072 6211 00	eax1 	pr6|570
005010  aa   010000 4310 07	fld  	4096,dl
005011  aa   007540 3520 04	epp2 	3936,ic		014551 = 000160627000
005012  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
005013  aa   000234 7100 04	tra  	156,ic		005247
						STATEMENT 1 ON LINE 1248
	else if (type = 0) & (next_key ^= NULL) & (next_key ^= END)
	     then do;

005014  aa  6 01021 2351 00	lda  	pr6|529
005015  aa   000074 6000 04	tze  	60,ic		005111
005016  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005017  aa   012752 1160 04	cmpq 	5610,ic		017771 = 777777777777
005020  aa   000071 6000 04	tze  	57,ic		005111
005021  aa   012751 1160 04	cmpq 	5609,ic		017772 = 777777777773
005022  aa   000067 6000 04	tze  	55,ic		005111
						STATEMENT 1 ON LINE 1250
		desired_key = next_key + quantity;

005023  aa   000044 7770 00	llr  	36
005024  aa   000044 7330 00	lrs  	36
005025  aa  6 00333 0331 00	adl  	pr6|219		quantity
005026  aa  6 00334 7561 00	stq  	pr6|220		desired_key
						STATEMENT 1 ON LINE 1251
		if (bounds.low <= desired_key) & (desired_key <= bounds.high)
		     then do;

005027  aa  7 00137 1161 00	cmpq 	pr7|95		disk_data.low
005030  aa   000005 6040 04	tmi  	5,ic		005035
005031  aa  7 00140 1161 00	cmpq 	pr7|96		disk_data.high
005032  aa   000003 6054 04	tpnz 	3,ic		005035
						STATEMENT 1 ON LINE 1253
			next_key = desired_key;

005033  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1254
		     end;

005034  aa   000213 7100 04	tra  	139,ic		005247
						STATEMENT 1 ON LINE 1256
		else if (desired_key < bounds.low)
		     then do;

005035  aa  7 00137 1161 00	cmpq 	pr7|95		disk_data.low
005036  aa   000025 6050 04	tpl  	21,ic		005063
						STATEMENT 1 ON LINE 1258
			call error (error_table_$end_of_info,
			     "Present position plus quantity is before start of the file.");

005037  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005040  aa   774670 00 0074	desc9a	-1608,60		001727 = 120162145163
005041  aa  6 01036 00 0074	desc9a	pr6|542,60
005042  aa  6 00044 3701 20	epp4 	pr6|36,*
005043  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
005044  aa  6 01074 2521 00	spri2	pr6|572
005045  aa  6 01036 3521 00	epp2 	pr6|542
005046  aa  6 01076 2521 00	spri2	pr6|574
005047  aa   773451 3520 04	epp2 	-2263,ic		000520 = 404000000043
005050  aa  6 01102 2521 00	spri2	pr6|578
005051  aa   773416 3520 04	epp2 	-2290,ic		000467 = 524000000073
005052  aa  6 01104 2521 00	spri2	pr6|580
005053  aa  6 01072 6211 00	eax1 	pr6|570
005054  aa   010000 4310 07	fld  	4096,dl
005055  aa   007474 3520 04	epp2 	3900,ic		014551 = 000160627000
005056  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1260
			next_key = bounds.low;

005057  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005060  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
005061  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1261
		     end;

005062  aa   000165 7100 04	tra  	117,ic		005247
						STATEMENT 1 ON LINE 1263
		else if (desired_key > bounds.high)
		     then do;

005063  aa  7 00140 1161 00	cmpq 	pr7|96		disk_data.high
005064  aa   000163 6044 04	tmoz 	115,ic		005247
						STATEMENT 1 ON LINE 1265
			call error (error_table_$end_of_info,
			     "Present position plus quantity is past end of the file.");

005065  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005066  aa   774605 00 0070	desc9a	-1659,56		001672 = 120162145163
005067  aa  6 01036 00 0070	desc9a	pr6|542,56
005070  aa  6 00044 3701 20	epp4 	pr6|36,*
005071  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
005072  aa  6 01074 2521 00	spri2	pr6|572
005073  aa  6 01036 3521 00	epp2 	pr6|542
005074  aa  6 01076 2521 00	spri2	pr6|574
005075  aa   773423 3520 04	epp2 	-2285,ic		000520 = 404000000043
005076  aa  6 01102 2521 00	spri2	pr6|578
005077  aa   773367 3520 04	epp2 	-2313,ic		000466 = 524000000067
005100  aa  6 01104 2521 00	spri2	pr6|580
005101  aa  6 01072 6211 00	eax1 	pr6|570
005102  aa   010000 4310 07	fld  	4096,dl
005103  aa   007446 3520 04	epp2 	3878,ic		014551 = 000160627000
005104  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1267
			next_key = END;

005105  aa   000005 3360 07	lcq  	5,dl
005106  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005107  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1268
		     end;

						STATEMENT 1 ON LINE 1269
	     end;

005110  aa   000137 7100 04	tra  	95,ic		005247
						STATEMENT 1 ON LINE 1274
	else if (type = 0) & (next_key = END) & (quantity <= 0) & (abs (quantity) <= (bounds.high - bounds.low + 1))
	     then do;

005111  aa  7 00140 3361 00	lcq  	pr7|96		disk_data.high
005112  aa   000044 7770 00	llr  	36
005113  aa   000044 7330 00	lrs  	36
005114  aa  7 00137 0331 00	adl  	pr7|95		disk_data.low
005115  aa   000000 5330 00	negl 	0
005116  aa   000001 0330 07	adl  	1,dl
005117  aa  6 01070 7571 00	staq 	pr6|568
005120  aa  6 00333 2361 00	ldq  	pr6|219		quantity
005121  aa   000003 6050 04	tpl  	3,ic		005124
005122  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
005123  aa   000001 0760 07	adq  	1,dl
005124  aa  6 01034 7561 00	stq  	pr6|540
005125  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005126  aa   012644 1160 04	cmpq 	5540,ic		017772 = 777777777773
005127  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
005130  aa  6 01021 3751 00	ana  	pr6|529
005131  aa  6 01021 7551 00	sta  	pr6|529
005132  aa   000014 6000 04	tze  	12,ic		005146
005133  aa  6 00333 2361 00	ldq  	pr6|219		quantity
005134  aa   000012 6054 04	tpnz 	10,ic		005146
005135  aa  6 01034 2351 00	lda  	pr6|540
005136  aa   000044 7330 00	lrs  	36
005137  aa  6 01070 1171 00	cmpaq	pr6|568
005140  aa   000006 6054 04	tpnz 	6,ic		005146
						STATEMENT 1 ON LINE 1276
		next_key = bounds.high + quantity;

005141  aa  7 00140 2351 00	lda  	pr7|96		disk_data.high
005142  aa   000044 7330 00	lrs  	36
005143  aa  6 00333 0331 00	adl  	pr6|219		quantity
005144  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1277
	     end;

005145  aa   000102 7100 04	tra  	66,ic		005247
						STATEMENT 1 ON LINE 1279
	else if (type = 0) & (next_key = END) & (quantity > 0)
	     then call error (error_table_$end_of_info, "Were at file end; quantity attempted to move forward.");

005146  aa  6 01021 2351 00	lda  	pr6|529
005147  aa   000024 6000 04	tze  	20,ic		005173
005150  aa  6 00333 2361 00	ldq  	pr6|219		quantity
005151  aa   000022 6044 04	tmoz 	18,ic		005173
005152  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005153  aa   774502 00 0070	desc9a	-1726,56		001654 = 127145162145
005154  aa  6 01036 00 0070	desc9a	pr6|542,56
005155  aa  6 00044 3701 20	epp4 	pr6|36,*
005156  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
005157  aa  6 01074 2521 00	spri2	pr6|572
005160  aa  6 01036 3521 00	epp2 	pr6|542
005161  aa  6 01076 2521 00	spri2	pr6|574
005162  aa   773336 3520 04	epp2 	-2338,ic		000520 = 404000000043
005163  aa  6 01102 2521 00	spri2	pr6|578
005164  aa   773301 3520 04	epp2 	-2367,ic		000465 = 524000000065
005165  aa  6 01104 2521 00	spri2	pr6|580
005166  aa  6 01072 6211 00	eax1 	pr6|570
005167  aa   010000 4310 07	fld  	4096,dl
005170  aa   007361 3520 04	epp2 	3825,ic		014551 = 000160627000
005171  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
005172  aa   000055 7100 04	tra  	45,ic		005247
						STATEMENT 1 ON LINE 1284
	else if (type = 0) & (next_key = END) & (quantity < 0) & (abs (quantity) > (bounds.high - bounds.low + 1))
	     then do;

005173  aa   400000 3150 03	cana 	131072,du
005174  aa   000033 6000 04	tze  	27,ic		005227
005175  aa  6 00333 2361 00	ldq  	pr6|219		quantity
005176  aa   000031 6050 04	tpl  	25,ic		005227
005177  aa  6 01034 2351 00	lda  	pr6|540
005200  aa   000044 7330 00	lrs  	36
005201  aa  6 01070 1171 00	cmpaq	pr6|568
005202  aa   000025 6044 04	tmoz 	21,ic		005227
						STATEMENT 1 ON LINE 1286
		call error (error_table_$end_of_info, "Were at file end; quantity would put you before file.");

005203  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005204  aa   774433 00 0070	desc9a	-1765,56		001636 = 127145162145
005205  aa  6 01036 00 0070	desc9a	pr6|542,56
005206  aa  6 00044 3701 20	epp4 	pr6|36,*
005207  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
005210  aa  6 01074 2521 00	spri2	pr6|572
005211  aa  6 01036 3521 00	epp2 	pr6|542
005212  aa  6 01076 2521 00	spri2	pr6|574
005213  aa   773305 3520 04	epp2 	-2363,ic		000520 = 404000000043
005214  aa  6 01102 2521 00	spri2	pr6|578
005215  aa   773250 3520 04	epp2 	-2392,ic		000465 = 524000000065
005216  aa  6 01104 2521 00	spri2	pr6|580
005217  aa  6 01072 6211 00	eax1 	pr6|570
005220  aa   010000 4310 07	fld  	4096,dl
005221  aa   007330 3520 04	epp2 	3800,ic		014551 = 000160627000
005222  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1287
		next_key = bounds.low;

005223  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005224  aa  7 00137 2361 00	ldq  	pr7|95		disk_data.low
005225  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1288
	     end;

005226  aa   000021 7100 04	tra  	17,ic		005247
						STATEMENT 1 ON LINE 1290
	else call error (error_table_$no_operation, "Should never get to this point.");

005227  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005230  aa   773723 00 0040	desc9a	-2093,32		001152 = 123150157165
005231  aa  6 01022 00 0040	desc9a	pr6|530,32
005232  aa  6 00044 3701 20	epp4 	pr6|36,*
005233  la  4 00052 3521 20	epp2 	pr4|42,*		error_table_$no_operation
005234  aa  6 01074 2521 00	spri2	pr6|572
005235  aa  6 01022 3521 00	epp2 	pr6|530
005236  aa  6 01076 2521 00	spri2	pr6|574
005237  aa   773261 3520 04	epp2 	-2383,ic		000520 = 404000000043
005240  aa  6 01102 2521 00	spri2	pr6|578
005241  aa   773223 3520 04	epp2 	-2413,ic		000464 = 524000000037
005242  aa  6 01104 2521 00	spri2	pr6|580
005243  aa  6 01072 6211 00	eax1 	pr6|570
005244  aa   010000 4310 07	fld  	4096,dl
005245  aa   007304 3520 04	epp2 	3780,ic		014551 = 000160627000
005246  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1293
	if mode = Sequential_update then current_key = next_key;

005247  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005250  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
005251  aa   000007 1160 07	cmpq 	7,dl
005252  aa   000003 6010 04	tnz  	3,ic		005255
005253  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005254  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1294
	a_code = 0;

005255  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 1295
	return;

005256  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_read                                         STATEMENT 1 ON LINE 1302
rdisk_read:
     entry (a_iocb_ptr, a_ubuf_ptr, a_ubuf_len, a_rec_len, a_code);

005257  at     000005000521
005260  tt     000521000517
005261  tt     000517000520
005262  ta     005257000000
005263  da     000666300000
005264  aa   002120 6270 00	eax7 	1104
005265  aa  7 00034 3521 20	epp2 	pr7|28,*
005266  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
005267  aa     000012000000
005270  aa     000000000000
005271  aa  6 00032 3735 20	epp7 	pr6|26,*
005272  aa  7 00010 3715 20	epp5 	pr7|8,*
005273  aa  6 00346 6515 00	spri5	pr6|230
005274  aa  7 00012 3535 20	epp3 	pr7|10,*
005275  aa  6 00344 2535 00	spri3	pr6|228
005276  aa   774712 7000 04	tsx0 	-1590,ic		002210
						STATEMENT 1 ON LINE 1311
	call setup ("open");

005277  aa   773200 2350 04	lda  	-2432,ic		000477 = 157160145156
005300  aa  6 01034 7551 00	sta  	pr6|540
005301  aa   012435 3520 04	epp2 	5405,ic		017736 = 000002000000
005302  aa  2 00000 2351 00	lda  	pr2|0
005303  aa   007024 6700 04	tsp4 	3604,ic		014327
						STATEMENT 1 ON LINE 1313
	if mode = Sequential_output | mode = Stream_output
	     then					/* read OK for all other modes */
		call error (error_table_$invalid_read, "read not supported for sqo or so.");

005304  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005305  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
005306  aa   000005 1160 07	cmpq 	5,dl
005307  aa   000003 6000 04	tze  	3,ic		005312
005310  aa   000002 1160 07	cmpq 	2,dl
005311  aa   000021 6010 04	tnz  	17,ic		005332
005312  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005313  aa   773702 00 0044	desc9a	-2110,36		001214 = 162145141144
005314  aa  6 01022 00 0044	desc9a	pr6|530,36
005315  aa  6 00044 3701 20	epp4 	pr6|36,*
005316  la  4 00044 3521 20	epp2 	pr4|36,*		error_table_$invalid_read
005317  aa  6 01074 2521 00	spri2	pr6|572
005320  aa  6 01022 3521 00	epp2 	pr6|530
005321  aa  6 01076 2521 00	spri2	pr6|574
005322  aa   773176 3520 04	epp2 	-2434,ic		000520 = 404000000043
005323  aa  6 01102 2521 00	spri2	pr6|578
005324  aa   773137 3520 04	epp2 	-2465,ic		000463 = 524000000041
005325  aa  6 01104 2521 00	spri2	pr6|580
005326  aa  6 01072 6211 00	eax1 	pr6|570
005327  aa   010000 4310 07	fld  	4096,dl
005330  aa   007221 3520 04	epp2 	3729,ic		014551 = 000160627000
005331  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1316
	if next_key = NULL then call error (error_table_$no_record, "next_key must be non-null to read");

005332  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005333  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005334  aa   012435 1160 04	cmpq 	5405,ic		017771 = 777777777777
005335  aa   000022 6010 04	tnz  	18,ic		005357
005336  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005337  aa   773645 00 0044	desc9a	-2139,36		001203 = 156145170164
005340  aa  6 01022 00 0044	desc9a	pr6|530,36
005341  aa  6 00044 3701 20	epp4 	pr6|36,*
005342  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
005343  aa  6 01074 2521 00	spri2	pr6|572
005344  aa  6 01022 3521 00	epp2 	pr6|530
005345  aa  6 01076 2521 00	spri2	pr6|574
005346  aa   773152 3520 04	epp2 	-2454,ic		000520 = 404000000043
005347  aa  6 01102 2521 00	spri2	pr6|578
005350  aa   773113 3520 04	epp2 	-2485,ic		000463 = 524000000041
005351  aa  6 01104 2521 00	spri2	pr6|580
005352  aa  6 01072 6211 00	eax1 	pr6|570
005353  aa   010000 4310 07	fld  	4096,dl
005354  aa   007175 3520 04	epp2 	3709,ic		014551 = 000160627000
005355  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
005356  aa   000056 7100 04	tra  	46,ic		005434
						STATEMENT 1 ON LINE 1317
	else if next_key = END
	     then do;

005357  aa   012413 1160 04	cmpq 	5387,ic		017772 = 777777777773
005360  aa   000054 6010 04	tnz  	44,ic		005434
						STATEMENT 1 ON LINE 1319
		if mode = Sequential_input | mode = Sequential_update
		     then do;

005361  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
005362  aa   000004 1160 07	cmpq 	4,dl
005363  aa   000003 6000 04	tze  	3,ic		005366
005364  aa   000007 1160 07	cmpq 	7,dl
005365  aa   000024 6010 04	tnz  	20,ic		005411
						STATEMENT 1 ON LINE 1321
			current_key = NULL;

005366  aa   000001 3360 07	lcq  	1,dl
005367  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1322
			call error (error_table_$end_of_info,
			     "Attempted to read (sqi, squ) past end of available area.");

005370  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005371  aa   774230 00 0070	desc9a	-1896,56		001620 = 101164164145
005372  aa  6 01036 00 0070	desc9a	pr6|542,56
005373  aa  6 00044 3701 20	epp4 	pr6|36,*
005374  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$end_of_info
005375  aa  6 01074 2521 00	spri2	pr6|572
005376  aa  6 01036 3521 00	epp2 	pr6|542
005377  aa  6 01076 2521 00	spri2	pr6|574
005400  aa   773120 3520 04	epp2 	-2480,ic		000520 = 404000000043
005401  aa  6 01102 2521 00	spri2	pr6|578
005402  aa   773060 3520 04	epp2 	-2512,ic		000462 = 524000000070
005403  aa  6 01104 2521 00	spri2	pr6|580
005404  aa  6 01072 6211 00	eax1 	pr6|570
005405  aa   010000 4310 07	fld  	4096,dl
005406  aa   007143 3520 04	epp2 	3683,ic		014551 = 000160627000
005407  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1324
		     end;

005410  aa   000024 7100 04	tra  	20,ic		005434
						STATEMENT 1 ON LINE 1325
		     else do;

						STATEMENT 1 ON LINE 1326
			next_key = NULL;

005411  aa   000001 3360 07	lcq  	1,dl
005412  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1327
			current_key = NULL;

005413  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1328
			call error (error_table_$device_end,
			     "Attempted to read (di, du) past end of avilable area.");

005414  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005415  aa   774166 00 0070	desc9a	-1930,56		001602 = 101164164145
005416  aa  6 01036 00 0070	desc9a	pr6|542,56
005417  aa  6 00044 3701 20	epp4 	pr6|36,*
005420  la  4 00032 3521 20	epp2 	pr4|26,*		error_table_$device_end
005421  aa  6 01074 2521 00	spri2	pr6|572
005422  aa  6 01036 3521 00	epp2 	pr6|542
005423  aa  6 01076 2521 00	spri2	pr6|574
005424  aa   773074 3520 04	epp2 	-2500,ic		000520 = 404000000043
005425  aa  6 01102 2521 00	spri2	pr6|578
005426  aa   773037 3520 04	epp2 	-2529,ic		000465 = 524000000065
005427  aa  6 01104 2521 00	spri2	pr6|580
005430  aa  6 01072 6211 00	eax1 	pr6|570
005431  aa   010000 4310 07	fld  	4096,dl
005432  aa   007117 3520 04	epp2 	3663,ic		014551 = 000160627000
005433  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1330
		     end;

						STATEMENT 1 ON LINE 1331
	     end;

						STATEMENT 1 ON LINE 1332
	io_command = "read";

005434  aa   773560 2350 04	lda  	-2192,ic		001214 = 162145141144
005435  aa  6 00307 7551 00	sta  	pr6|199		io_command
005436  aa   000004 2360 07	ldq  	4,dl
005437  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 1335
	if sze ^= 0
	     then rec_len = min (sze, a_ubuf_len);

005440  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005441  aa  7 00054 2361 00	ldq  	pr7|44		disk_data.sze
005442  aa   000007 6000 04	tze  	7,ic		005451
005443  aa  6 00032 3715 20	epp5 	pr6|26,*
005444  aa  5 00006 1161 20	cmpq 	pr5|6,*		a_ubuf_len
005445  aa   000002 6040 04	tmi  	2,ic		005447
005446  aa  5 00006 2361 20	ldq  	pr5|6,*		a_ubuf_len
005447  aa  6 00160 7561 00	stq  	pr6|112		rec_len
005450  aa   000004 7100 04	tra  	4,ic		005454
						STATEMENT 1 ON LINE 1337
	     else rec_len = a_ubuf_len;

005451  aa  6 00032 3715 20	epp5 	pr6|26,*
005452  aa  5 00006 2361 20	ldq  	pr5|6,*		a_ubuf_len
005453  aa  6 00160 7561 00	stq  	pr6|112		rec_len
						STATEMENT 1 ON LINE 1338
	a_rec_len = 0;

005454  aa  6 00346 4501 20	stz  	pr6|230,*		a_rec_len
						STATEMENT 1 ON LINE 1339
	key = next_key;

005455  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005456  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 1340
	go to read_write_common;

005457  aa   000300 7100 04	tra  	192,ic		005757
ENTRY TO rdisk_rewrite                                      STATEMENT 1 ON LINE 1342
rdisk_rewrite:
     entry (a_iocb_ptr, a_ubuf_ptr, a_rec_len, a_code);

005460  at     000004000521
005461  tt     000521000517
005462  ta     000520000000
005463  ta     005460000000
005464  da     000675300000
005465  aa   002120 6270 00	eax7 	1104
005466  aa  7 00034 3521 20	epp2 	pr7|28,*
005467  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
005470  aa     000010000000
005471  aa     000000000000
005472  aa  6 00032 3735 20	epp7 	pr6|26,*
005473  aa  7 00006 3715 20	epp5 	pr7|6,*
005474  aa  6 00346 6515 00	spri5	pr6|230
005475  aa  7 00010 3535 20	epp3 	pr7|8,*
005476  aa  6 00344 2535 00	spri3	pr6|228
005477  aa   774511 7000 04	tsx0 	-1719,ic		002210
						STATEMENT 1 ON LINE 1353
	call setup ("open");

005500  aa   772777 2350 04	lda  	-2561,ic		000477 = 157160145156
005501  aa  6 01034 7551 00	sta  	pr6|540
005502  aa   012234 3520 04	epp2 	5276,ic		017736 = 000002000000
005503  aa  2 00000 2351 00	lda  	pr2|0
005504  aa   006623 6700 04	tsp4 	3475,ic		014327
						STATEMENT 1 ON LINE 1355
	if mode = Sequential_update | mode = Direct_update
	     then ;

005505  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005506  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
005507  aa   000007 1160 07	cmpq 	7,dl
005510  aa   000024 6000 04	tze  	20,ic		005534
005511  aa   000015 1160 07	cmpq 	13,dl
005512  aa   000002 6010 04	tnz  	2,ic		005514
005513  aa   000021 7100 04	tra  	17,ic		005534
						STATEMENT 1 ON LINE 1357
	     else call error (error_table_$invalid_write, "rewrite valid only for update.");

005514  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005515  aa   773426 00 0040	desc9a	-2282,32		001142 = 162145167162
005516  aa  6 01022 00 0040	desc9a	pr6|530,32
005517  aa  6 00044 3701 20	epp4 	pr6|36,*
005520  la  4 00046 3521 20	epp2 	pr4|38,*		error_table_$invalid_write
005521  aa  6 01074 2521 00	spri2	pr6|572
005522  aa  6 01022 3521 00	epp2 	pr6|530
005523  aa  6 01076 2521 00	spri2	pr6|574
005524  aa   772774 3520 04	epp2 	-2564,ic		000520 = 404000000043
005525  aa  6 01102 2521 00	spri2	pr6|578
005526  aa   772742 3520 04	epp2 	-2590,ic		000470 = 524000000036
005527  aa  6 01104 2521 00	spri2	pr6|580
005530  aa  6 01072 6211 00	eax1 	pr6|570
005531  aa   010000 4310 07	fld  	4096,dl
005532  aa   007017 3520 04	epp2 	3599,ic		014551 = 000160627000
005533  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1359
	if current_key = NULL
	     then call error (error_table_$no_record, "Attempted to rewrite before the start of the file.");

005534  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005535  aa  7 00135 2361 00	ldq  	pr7|93		disk_data.current_key
005536  aa   012233 1160 04	cmpq 	5275,ic		017771 = 777777777777
005537  aa   000022 6010 04	tnz  	18,ic		005561
005540  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005541  aa   774025 00 0064	desc9a	-2027,52		001565 = 101164164145
005542  aa  6 01036 00 0064	desc9a	pr6|542,52
005543  aa  6 00044 3701 20	epp4 	pr6|36,*
005544  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
005545  aa  6 01074 2521 00	spri2	pr6|572
005546  aa  6 01036 3521 00	epp2 	pr6|542
005547  aa  6 01076 2521 00	spri2	pr6|574
005550  aa   772750 3520 04	epp2 	-2584,ic		000520 = 404000000043
005551  aa  6 01102 2521 00	spri2	pr6|578
005552  aa   772707 3520 04	epp2 	-2617,ic		000461 = 524000000062
005553  aa  6 01104 2521 00	spri2	pr6|580
005554  aa  6 01072 6211 00	eax1 	pr6|570
005555  aa   010000 4310 07	fld  	4096,dl
005556  aa   006773 3520 04	epp2 	3579,ic		014551 = 000160627000
005557  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
005560  aa   000025 7100 04	tra  	21,ic		005605
						STATEMENT 1 ON LINE 1361
	else if current_key = END
	     then do;

005561  aa   012211 1160 04	cmpq 	5257,ic		017772 = 777777777773
005562  aa   000023 6010 04	tnz  	19,ic		005605
						STATEMENT 1 ON LINE 1363
		next_key = END;

005563  aa   000005 3360 07	lcq  	5,dl
005564  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1364
		call error (error_table_$device_end, "Attempted to rewrite when already at the end of the file.");

005565  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005566  aa   774123 00 0074	desc9a	-1965,60		001710 = 101164164145
005567  aa  6 01036 00 0074	desc9a	pr6|542,60
005570  aa  6 00044 3701 20	epp4 	pr6|36,*
005571  la  4 00032 3521 20	epp2 	pr4|26,*		error_table_$device_end
005572  aa  6 01074 2521 00	spri2	pr6|572
005573  aa  6 01036 3521 00	epp2 	pr6|542
005574  aa  6 01076 2521 00	spri2	pr6|574
005575  aa   772723 3520 04	epp2 	-2605,ic		000520 = 404000000043
005576  aa  6 01102 2521 00	spri2	pr6|578
005577  aa   772661 3520 04	epp2 	-2639,ic		000460 = 524000000071
005600  aa  6 01104 2521 00	spri2	pr6|580
005601  aa  6 01072 6211 00	eax1 	pr6|570
005602  aa   010000 4310 07	fld  	4096,dl
005603  aa   006746 3520 04	epp2 	3558,ic		014551 = 000160627000
005604  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1365
	     end;

						STATEMENT 1 ON LINE 1367
	io_command = "rewrite";

005605  aa   772777 2370 04	ldaq 	-2561,ic		000604 = 162145167162 151164145000
005606  aa  6 00307 7551 00	sta  	pr6|199		io_command
005607  aa  6 00310 7561 00	stq  	pr6|200		io_command
005610  aa   000007 2360 07	ldq  	7,dl
005611  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 1370
	rec_len = a_rec_len;

005612  aa  6 00346 2361 20	ldq  	pr6|230,*		a_rec_len
005613  aa  6 00160 7561 00	stq  	pr6|112		rec_len
						STATEMENT 1 ON LINE 1371
	key = current_key;

005614  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005615  aa  7 00135 2361 00	ldq  	pr7|93		disk_data.current_key
005616  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 1372
	go to read_write_common;

005617  aa   000140 7100 04	tra  	96,ic		005757
ENTRY TO rdisk_write                                        STATEMENT 1 ON LINE 1374
rdisk_write:
     entry (a_iocb_ptr, a_ubuf_ptr, a_rec_len, a_code);

005620  ta     005460000000
005621  da     000703300000
005622  aa   002120 6270 00	eax7 	1104
005623  aa  7 00034 3521 20	epp2 	pr7|28,*
005624  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
005625  aa     000010000000
005626  aa     000000000000
005627  aa  6 00032 3735 20	epp7 	pr6|26,*
005630  aa  7 00006 3715 20	epp5 	pr7|6,*
005631  aa  6 00346 6515 00	spri5	pr6|230
005632  aa  7 00010 3535 20	epp3 	pr7|8,*
005633  aa  6 00344 2535 00	spri3	pr6|228
005634  aa   774354 7000 04	tsx0 	-1812,ic		002210
						STATEMENT 1 ON LINE 1388
	call setup ("open");

005635  aa   772642 2350 04	lda  	-2654,ic		000477 = 157160145156
005636  aa  6 01034 7551 00	sta  	pr6|540
005637  aa   012077 3520 04	epp2 	5183,ic		017736 = 000002000000
005640  aa  2 00000 2351 00	lda  	pr2|0
005641  aa   006466 6700 04	tsp4 	3382,ic		014327
						STATEMENT 1 ON LINE 1390
	if mode = Sequential_output | mode = Stream_output | mode = Stream_input_output
	     then ;

005642  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005643  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
005644  aa   000005 1160 07	cmpq 	5,dl
005645  aa   000026 6000 04	tze  	22,ic		005673
005646  aa   000002 1160 07	cmpq 	2,dl
005647  aa   000024 6000 04	tze  	20,ic		005673
005650  aa   000003 1160 07	cmpq 	3,dl
005651  aa   000002 6010 04	tnz  	2,ic		005653
005652  aa   000021 7100 04	tra  	17,ic		005673
						STATEMENT 1 ON LINE 1392
	     else call error (error_table_$invalid_write, "write supported only for sqo, so, and sio.");

005653  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005654  aa   773460 00 0054	desc9a	-2256,44		001333 = 167162151164
005655  aa  6 01072 00 0054	desc9a	pr6|570,44
005656  aa  6 00044 3701 20	epp4 	pr6|36,*
005657  la  4 00046 3521 20	epp2 	pr4|38,*		error_table_$invalid_write
005660  aa  6 01040 2521 00	spri2	pr6|544
005661  aa  6 01072 3521 00	epp2 	pr6|570
005662  aa  6 01042 2521 00	spri2	pr6|546
005663  aa   772635 3520 04	epp2 	-2659,ic		000520 = 404000000043
005664  aa  6 01046 2521 00	spri2	pr6|550
005665  aa   772617 3520 04	epp2 	-2673,ic		000504 = 524000000052
005666  aa  6 01050 2521 00	spri2	pr6|552
005667  aa  6 01036 6211 00	eax1 	pr6|542
005670  aa   010000 4310 07	fld  	4096,dl
005671  aa   006660 3520 04	epp2 	3504,ic		014551 = 000160627000
005672  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1394
	if next_key = END
	     then do;

005673  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005674  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005675  aa   012075 1160 04	cmpq 	5181,ic		017772 = 777777777773
005676  aa   000024 6010 04	tnz  	20,ic		005722
						STATEMENT 1 ON LINE 1396
		current_key = NULL;

005677  aa   000001 3360 07	lcq  	1,dl
005700  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1397
		call error (error_table_$device_end, "Already at end of the file.");

005701  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005702  aa   773173 00 0034	desc9a	-2437,28		001074 = 101154162145
005703  aa  6 01022 00 0034	desc9a	pr6|530,28
005704  aa  6 00044 3701 20	epp4 	pr6|36,*
005705  la  4 00032 3521 20	epp2 	pr4|26,*		error_table_$device_end
005706  aa  6 01074 2521 00	spri2	pr6|572
005707  aa  6 01022 3521 00	epp2 	pr6|530
005710  aa  6 01076 2521 00	spri2	pr6|574
005711  aa   772607 3520 04	epp2 	-2681,ic		000520 = 404000000043
005712  aa  6 01102 2521 00	spri2	pr6|578
005713  aa   772544 3520 04	epp2 	-2716,ic		000457 = 524000000033
005714  aa  6 01104 2521 00	spri2	pr6|580
005715  aa  6 01072 6211 00	eax1 	pr6|570
005716  aa   010000 4310 07	fld  	4096,dl
005717  aa   006632 3520 04	epp2 	3482,ic		014551 = 000160627000
005720  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1398
	     end;

005721  aa   000023 7100 04	tra  	19,ic		005744
						STATEMENT 1 ON LINE 1400
	else if next_key = NULL then call error (error_table_$no_record, "Next record designator was NULL.");

005722  aa   012047 1160 04	cmpq 	5159,ic		017771 = 777777777777
005723  aa   000021 6010 04	tnz  	17,ic		005744
005724  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005725  aa   773206 00 0040	desc9a	-2426,32		001132 = 116145170164
005726  aa  6 01022 00 0040	desc9a	pr6|530,32
005727  aa  6 00044 3701 20	epp4 	pr6|36,*
005730  la  4 00054 3521 20	epp2 	pr4|44,*		error_table_$no_record
005731  aa  6 01074 2521 00	spri2	pr6|572
005732  aa  6 01022 3521 00	epp2 	pr6|530
005733  aa  6 01076 2521 00	spri2	pr6|574
005734  aa   772564 3520 04	epp2 	-2700,ic		000520 = 404000000043
005735  aa  6 01102 2521 00	spri2	pr6|578
005736  aa   772520 3520 04	epp2 	-2736,ic		000456 = 524000000040
005737  aa  6 01104 2521 00	spri2	pr6|580
005740  aa  6 01072 6211 00	eax1 	pr6|570
005741  aa   010000 4310 07	fld  	4096,dl
005742  aa   006607 3520 04	epp2 	3463,ic		014551 = 000160627000
005743  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1402
	io_command = "write";

005744  aa   772636 2370 04	ldaq 	-2658,ic		000602 = 167162151164 145000000000
005745  aa  6 00307 7551 00	sta  	pr6|199		io_command
005746  aa  6 00310 7561 00	stq  	pr6|200		io_command
005747  aa   000005 2360 07	ldq  	5,dl
005750  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 1403
	rec_len = a_rec_len;

005751  aa  6 00346 2361 20	ldq  	pr6|230,*		a_rec_len
005752  aa  6 00160 7561 00	stq  	pr6|112		rec_len
						STATEMENT 1 ON LINE 1404
	key = next_key;

005753  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
005754  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
005755  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 1405
	go to read_write_common;

005756  aa   000001 7100 04	tra  	1,ic		005757
						STATEMENT 1 ON LINE 1426
	sectors_for_record = ceil (rec_len / (4 * sect_size));

005757  aa  7 00101 2361 00	ldq  	pr7|65		disk_data.sect_size
005760  aa   000002 7360 00	qls  	2
005761  aa  6 01034 7561 00	stq  	pr6|540
005762  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
005763  aa  6 01034 3521 00	epp2 	pr6|540
005764  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
005765  aa     000000000044
005766  aa   000044 7220 07	lxl2 	36,dl
005767  aa   777670 7230 07	lxl3 	262072,dl
005770  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
005771  aa  6 00335 7561 00	stq  	pr6|221		sectors_for_record
						STATEMENT 1 ON LINE 1428
	potential_next_sector = key + sectors_for_record;

005772  aa  6 00165 0761 00	adq  	pr6|117		key
005773  aa  6 00336 7561 00	stq  	pr6|222		potential_next_sector
						STATEMENT 1 ON LINE 1430
	if key = NULL
	     then do;

005774  aa  6 00165 2361 00	ldq  	pr6|117		key
005775  aa   011774 1160 04	cmpq 	5116,ic		017771 = 777777777777
005776  aa   000010 6010 04	tnz  	8,ic		006006
						STATEMENT 1 ON LINE 1432
		code = error_table_$no_record;

005777  aa  6 00044 3701 20	epp4 	pr6|36,*
006000  la  4 00054 2361 20	ldq  	pr4|44,*		error_table_$no_record
006001  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 1433
		call io_err ("0"b);

006002  aa   000000 2350 07	lda  	0,dl
006003  aa  6 01034 7551 00	sta  	pr6|540
006004  aa   011726 3520 04	epp2 	5078,ic		017732 = 000002000000
006005  aa   004113 6700 04	tsp4 	2123,ic		012120
						STATEMENT 1 ON LINE 1434
	     end;

						STATEMENT 1 ON LINE 1436
	if (io_command = "write") | (io_command = "rewrite")
	     then if potential_next_sector > bounds.high + 1
		     then call error (error_table_$no_operation, "Record will not fit in space left on disk.");

006006  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
006007  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006010  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
006011  aa   772573 00 0005	desc9a	-2693,5		000602 = 167162151164
006012  aa   000006 6000 04	tze  	6,ic		006020
006013  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
006014  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006015  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
006016  aa   772570 00 0007	desc9a	-2696,7		000604 = 162145167162
006017  aa   000032 6010 04	tnz  	26,ic		006051
006020  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006021  aa  7 00140 2351 00	lda  	pr7|96		disk_data.high
006022  aa   000044 7330 00	lrs  	36
006023  aa   000001 0330 07	adl  	1,dl
006024  aa  6 01070 7571 00	staq 	pr6|568
006025  aa  6 00336 2351 00	lda  	pr6|222		potential_next_sector
006026  aa   000044 7330 00	lrs  	36
006027  aa  6 01070 1171 00	cmpaq	pr6|568
006030  aa   000021 6044 04	tmoz 	17,ic		006051
006031  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006032  aa   773267 00 0054	desc9a	-2377,44		001320 = 122145143157
006033  aa  6 01072 00 0054	desc9a	pr6|570,44
006034  aa  6 00044 3701 20	epp4 	pr6|36,*
006035  la  4 00052 3521 20	epp2 	pr4|42,*		error_table_$no_operation
006036  aa  6 01040 2521 00	spri2	pr6|544
006037  aa  6 01072 3521 00	epp2 	pr6|570
006040  aa  6 01042 2521 00	spri2	pr6|546
006041  aa   772457 3520 04	epp2 	-2769,ic		000520 = 404000000043
006042  aa  6 01046 2521 00	spri2	pr6|550
006043  aa   772441 3520 04	epp2 	-2783,ic		000504 = 524000000052
006044  aa  6 01050 2521 00	spri2	pr6|552
006045  aa  6 01036 6211 00	eax1 	pr6|542
006046  aa   010000 4310 07	fld  	4096,dl
006047  aa   006502 3520 04	epp2 	3394,ic		014551 = 000160627000
006050  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1440
	tot_rec_len = 0;

006051  aa  6 00161 4501 00	stz  	pr6|113		tot_rec_len
						STATEMENT 1 ON LINE 1441
	ubuf_ptr = a_ubuf_ptr;

006052  aa  6 00032 3735 20	epp7 	pr6|26,*
006053  aa  7 00004 3715 20	epp5 	pr7|4,*		a_ubuf_ptr
006054  aa  5 00000 3715 20	epp5 	pr5|0,*		a_ubuf_ptr
006055  aa  6 00144 6515 00	spri5	pr6|100		ubuf_ptr
						STATEMENT 1 ON LINE 1442
	cont_sw = "0"b;

006056  aa  6 00206 4501 00	stz  	pr6|134		cont_sw
						STATEMENT 1 ON LINE 1443
	track_indicators = "00"b;

006057  aa  6 00167 4501 00	stz  	pr6|119		track_indicators
						STATEMENT 1 ON LINE 1444
	if rec_len > 4 * (floor ((max_buff_size - overhead) / sect_size) * sect_size)
	     then do;

006060  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
006061  aa  3 00067 2361 00	ldq  	pr3|55		disk_data.max_buff_size
006062  aa   000300 1760 07	sbq  	192,dl
006063  aa  3 00101 3521 00	epp2 	pr3|65		disk_data.sect_size
006064  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006065  aa     000000000063
006066  aa   000063 7220 07	lxl2 	51,dl
006067  aa   777632 7230 07	lxl3 	262042,dl
006070  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
006071  aa  2 00000 4021 00	mpy  	pr2|0		disk_data.sect_size
006072  aa   000004 4020 07	mpy  	4,dl
006073  aa  6 01070 7571 00	staq 	pr6|568
006074  aa  6 00160 2351 00	lda  	pr6|112		rec_len
006075  aa   000044 7330 00	lrs  	36
006076  aa  6 01070 1171 00	cmpaq	pr6|568
006077  aa   000117 6044 04	tmoz 	79,ic		006216
						STATEMENT 1 ON LINE 1447
		if buf_len < max_buff_size
		     then do;

006100  aa  3 00127 2361 00	ldq  	pr3|87		disk_data.buf_len
006101  aa  3 00067 1161 00	cmpq 	pr3|55		disk_data.max_buff_size
006102  aa   000031 6050 04	tpl  	25,ic		006133
						STATEMENT 1 ON LINE 1449
			call ioi_$workspace (devx, buf_ptr, max_buff_size, code);

006103  aa  3 00075 3521 00	epp2 	pr3|61		disk_data.devx
006104  aa  6 01024 2521 00	spri2	pr6|532
006105  aa  3 00124 3521 00	epp2 	pr3|84		disk_data.buf_ptr
006106  aa  6 01026 2521 00	spri2	pr6|534
006107  aa  3 00067 3521 00	epp2 	pr3|55		disk_data.max_buff_size
006110  aa  6 01030 2521 00	spri2	pr6|536
006111  aa  6 00157 3521 00	epp2 	pr6|111		code
006112  aa  6 01032 2521 00	spri2	pr6|538
006113  aa  6 01022 6211 00	eax1 	pr6|530
006114  aa   020000 4310 07	fld  	8192,dl
006115  aa  6 00044 3701 20	epp4 	pr6|36,*
006116  la  4 00116 3521 20	epp2 	pr4|78,*		ioi_$workspace
006117  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1451
			if code ^= 0 then call io_err ("1"b);

006120  aa  6 00157 2361 00	ldq  	pr6|111		code
006121  aa   000005 6000 04	tze  	5,ic		006126
006122  aa   400000 2350 03	lda  	131072,du
006123  aa  6 01034 7551 00	sta  	pr6|540
006124  aa   011606 3520 04	epp2 	4998,ic		017732 = 000002000000
006125  aa   003773 6700 04	tsp4 	2043,ic		012120
						STATEMENT 1 ON LINE 1453
			buf_len = max_buff_size;

006126  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006127  aa  7 00067 2361 00	ldq  	pr7|55		disk_data.max_buff_size
006130  aa  7 00127 7561 00	stq  	pr7|87		disk_data.buf_len
						STATEMENT 1 ON LINE 1454
			data_len = buf_len - overhead;

006131  aa   000300 1760 07	sbq  	192,dl
006132  aa  7 00130 7561 00	stq  	pr7|88		disk_data.data_len
						STATEMENT 1 ON LINE 1455
		     end;

						STATEMENT 1 ON LINE 1457
		block_len = ceil (ceil (data_len / 4) / sect_size) * sect_size;

006133  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006134  aa  7 00130 2361 00	ldq  	pr7|88		disk_data.data_len
006135  aa   011644 3520 04	epp2 	5028,ic		020001 = 000000000004
006136  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006137  aa     000000000064
006140  aa   000064 7220 07	lxl2 	52,dl
006141  aa   777630 7230 07	lxl3 	262040,dl
006142  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
006143  aa  7 00101 3521 00	epp2 	pr7|65		disk_data.sect_size
006144  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006145  aa     000000000063
006146  aa   000063 7220 07	lxl2 	51,dl
006147  aa   777632 7230 07	lxl3 	262042,dl
006150  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
006151  aa  2 00000 4021 00	mpy  	pr2|0		disk_data.sect_size
006152  aa  6 00171 7561 00	stq  	pr6|121		block_len
						STATEMENT 1 ON LINE 1459
		block_ptr = ubuf_ptr;

006153  aa  6 00144 3715 20	epp5 	pr6|100,*		ubuf_ptr
006154  aa  6 00146 6515 00	spri5	pr6|102		block_ptr
						STATEMENT 1 ON LINE 1460
		data_left = rec_len;

006155  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
006156  aa  6 00162 7561 00	stq  	pr6|114		data_left
						STATEMENT 1 ON LINE 1462
		do while (data_left > 0);

006157  aa   000000 0110 03	nop  	0,du
006160  aa  6 00162 2361 00	ldq  	pr6|114		data_left
006161  aa   000157 6044 04	tmoz 	111,ic		006340
						STATEMENT 1 ON LINE 1463
		     call do_io;

006162  aa   003770 6700 04	tsp4 	2040,ic		012152
						STATEMENT 1 ON LINE 1464
		     block_ptr = addrel (block_ptr, block_len);

006163  aa  6 00171 2361 00	ldq  	pr6|121		block_len
006164  aa  6 00146 3521 66	epp2 	pr6|102,*ql	block_ptr
006165  aa   000000 0520 03	adwp2	0,du
006166  aa  6 00146 2521 00	spri2	pr6|102		block_ptr
						STATEMENT 1 ON LINE 1466
		     tot_rec_len = tot_rec_len + rec_len;

006167  aa  6 00161 2351 00	lda  	pr6|113		tot_rec_len
006170  aa   000044 7330 00	lrs  	36
006171  aa  6 00160 0331 00	adl  	pr6|112		rec_len
006172  aa  6 00161 7561 00	stq  	pr6|113		tot_rec_len
						STATEMENT 1 ON LINE 1468
		     data_left = data_left - block_len * 4;

006173  aa  6 00171 2361 00	ldq  	pr6|121		block_len
006174  aa   000002 7360 00	qls  	2
006175  aa  6 01034 7561 00	stq  	pr6|540
006176  aa  6 00162 3361 00	lcq  	pr6|114		data_left
006177  aa   000044 7770 00	llr  	36
006200  aa   000044 7330 00	lrs  	36
006201  aa  6 01034 0331 00	adl  	pr6|540
006202  aa   000000 5330 00	negl 	0
006203  aa  6 00162 7561 00	stq  	pr6|114		data_left
						STATEMENT 1 ON LINE 1470
		     key = key + fixed (block_len / sect_size, 21);

006204  aa  6 00171 2361 00	ldq  	pr6|121		block_len
006205  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006206  aa  7 00101 3521 00	epp2 	pr7|65		disk_data.sect_size
006207  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006210  aa     000000000073
006211  aa   000073 7220 07	lxl2 	59,dl
006212  aa  0 01115 7001 00	tsx0 	pr0|589		trunc_fx2
006213  aa  6 00165 0561 00	asq  	pr6|117		key
						STATEMENT 1 ON LINE 1472
		     end;

006214  aa   777744 7100 04	tra  	-28,ic		006160
						STATEMENT 1 ON LINE 1474
	     end;

006215  aa   000123 7100 04	tra  	83,ic		006340
						STATEMENT 1 ON LINE 1476
	     else do;

						STATEMENT 1 ON LINE 1478
		if rec_len > 4 * floor (data_len / sect_size) * sect_size
		     then do;

006216  aa  3 00130 2361 00	ldq  	pr3|88		disk_data.data_len
006217  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006220  aa     000000000064
006221  aa   000064 7220 07	lxl2 	52,dl
006222  aa   777630 7230 07	lxl3 	262040,dl
006223  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
006224  aa   000002 7360 00	qls  	2
006225  aa  2 00000 4021 00	mpy  	pr2|0		disk_data.sect_size
006226  aa  6 01070 7571 00	staq 	pr6|568
006227  aa  6 00160 2351 00	lda  	pr6|112		rec_len
006230  aa   000044 7330 00	lrs  	36
006231  aa  6 01070 1171 00	cmpaq	pr6|568
006232  aa   000056 6044 04	tmoz 	46,ic		006310
						STATEMENT 1 ON LINE 1481
			data_len = max (1024 - overhead, ceil (ceil (rec_len / 4) / sect_size) * sect_size);

006233  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
006234  aa   011545 3520 04	epp2 	4965,ic		020001 = 000000000004
006235  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006236  aa     000000000044
006237  aa   000044 7220 07	lxl2 	36,dl
006240  aa   777670 7230 07	lxl3 	262072,dl
006241  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
006242  aa  3 00101 3521 00	epp2 	pr3|65		disk_data.sect_size
006243  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
006244  aa     000000000043
006245  aa   000043 7220 07	lxl2 	35,dl
006246  aa   777672 7230 07	lxl3 	262074,dl
006247  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
006250  aa  6 01070 7571 00	staq 	pr6|568
006251  aa  2 00000 2361 00	ldq  	pr2|0		disk_data.sect_size
006252  aa  6 01070 3521 00	epp2 	pr6|568
006253  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
006254  aa  6 01070 7571 00	staq 	pr6|568
006255  aa   001500 2350 07	lda  	832,dl
006256  aa   000044 7330 00	lrs  	36
006257  aa  6 01070 1171 00	cmpaq	pr6|568
006260  aa   000002 6050 04	tpl  	2,ic		006262
006261  aa  6 01070 2371 00	ldaq 	pr6|568
006262  aa  3 00130 7561 00	stq  	pr3|88		disk_data.data_len
						STATEMENT 1 ON LINE 1482
			buf_len = data_len + overhead;

006263  aa   000300 0760 07	adq  	192,dl
006264  aa  3 00127 7561 00	stq  	pr3|87		disk_data.buf_len
						STATEMENT 1 ON LINE 1483
			call ioi_$workspace (devx, buf_ptr, buf_len, code);

006265  aa  3 00075 3521 00	epp2 	pr3|61		disk_data.devx
006266  aa  6 01024 2521 00	spri2	pr6|532
006267  aa  3 00124 3521 00	epp2 	pr3|84		disk_data.buf_ptr
006270  aa  6 01026 2521 00	spri2	pr6|534
006271  aa  3 00127 3521 00	epp2 	pr3|87		disk_data.buf_len
006272  aa  6 01030 2521 00	spri2	pr6|536
006273  aa  6 00157 3521 00	epp2 	pr6|111		code
006274  aa  6 01032 2521 00	spri2	pr6|538
006275  aa  6 01022 6211 00	eax1 	pr6|530
006276  aa   020000 4310 07	fld  	8192,dl
006277  aa  6 00044 3701 20	epp4 	pr6|36,*
006300  la  4 00116 3521 20	epp2 	pr4|78,*		ioi_$workspace
006301  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1485
			if code ^= 0 then call io_err ("1"b);

006302  aa  6 00157 2361 00	ldq  	pr6|111		code
006303  aa   000005 6000 04	tze  	5,ic		006310
006304  aa   400000 2350 03	lda  	131072,du
006305  aa  6 01034 7551 00	sta  	pr6|540
006306  aa   011424 3520 04	epp2 	4884,ic		017732 = 000002000000
006307  aa   003611 6700 04	tsp4 	1929,ic		012120
						STATEMENT 1 ON LINE 1488
		     end;

						STATEMENT 1 ON LINE 1490
		block_ptr = ubuf_ptr;

006310  aa  6 00144 3735 20	epp7 	pr6|100,*		ubuf_ptr
006311  aa  6 00146 6535 00	spri7	pr6|102		block_ptr
						STATEMENT 1 ON LINE 1491
		block_len = ceil (ceil (rec_len / 4) / sect_size) * sect_size;

006312  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
006313  aa   011466 3520 04	epp2 	4918,ic		020001 = 000000000004
006314  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
006315  aa     000000000044
006316  aa   000044 7220 07	lxl2 	36,dl
006317  aa   777670 7230 07	lxl3 	262072,dl
006320  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
006321  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
006322  aa  5 00101 3521 00	epp2 	pr5|65		disk_data.sect_size
006323  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
006324  aa     000000000043
006325  aa   000043 7220 07	lxl2 	35,dl
006326  aa   777672 7230 07	lxl3 	262074,dl
006327  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
006330  aa  6 01070 7571 00	staq 	pr6|568
006331  aa  2 00000 2361 00	ldq  	pr2|0		disk_data.sect_size
006332  aa  6 01070 3521 00	epp2 	pr6|568
006333  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
006334  aa  6 00171 7561 00	stq  	pr6|121		block_len
						STATEMENT 1 ON LINE 1493
		data_left = rec_len;

006335  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
006336  aa  6 00162 7561 00	stq  	pr6|114		data_left
						STATEMENT 1 ON LINE 1494
		call do_io;

006337  aa   003613 6700 04	tsp4 	1931,ic		012152
						STATEMENT 1 ON LINE 1496
	     end;

						STATEMENT 1 ON LINE 1499
io_succeeded:					/* 			PATH 1 */
	if io_command = "read"
	     then do;

006340  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
006341  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006342  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
006343  aa   772653 00 0004	desc9a	-2645,4		001214 = 162145141144
006344  aa   000052 6010 04	tnz  	42,ic		006416
						STATEMENT 1 ON LINE 1503
		current_key = next_key;

006345  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006346  aa  7 00134 2361 00	ldq  	pr7|92		disk_data.next_key
006347  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1504
		if tot_rec_len = 0
		     then a_rec_len = rec_len;

006350  aa  6 00161 2361 00	ldq  	pr6|113		tot_rec_len
006351  aa   000004 6010 04	tnz  	4,ic		006355
006352  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
006353  aa  6 00346 7561 20	stq  	pr6|230,*		a_rec_len
006354  aa   000002 7100 04	tra  	2,ic		006356
						STATEMENT 1 ON LINE 1506
		     else a_rec_len = tot_rec_len;

006355  aa  6 00346 7561 20	stq  	pr6|230,*		a_rec_len
						STATEMENT 1 ON LINE 1510
		if potential_next_sector < bounds.high + 1
		     then do;

006356  aa  7 00140 2351 00	lda  	pr7|96		disk_data.high
006357  aa   000044 7330 00	lrs  	36
006360  aa   000001 0330 07	adl  	1,dl
006361  aa  6 01070 7571 00	staq 	pr6|568
006362  aa  6 00336 2351 00	lda  	pr6|222		potential_next_sector
006363  aa   000044 7330 00	lrs  	36
006364  aa  6 01070 1171 00	cmpaq	pr6|568
006365  aa   000016 6050 04	tpl  	14,ic		006403
						STATEMENT 1 ON LINE 1515
			if mode = Direct_input | mode = Direct_update
			     then next_key = NULL;

006366  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
006367  aa   000013 1160 07	cmpq 	11,dl
006370  aa   000003 6000 04	tze  	3,ic		006373
006371  aa   000015 1160 07	cmpq 	13,dl
006372  aa   000004 6010 04	tnz  	4,ic		006376
006373  aa   000001 3360 07	lcq  	1,dl
006374  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
006375  aa   000104 7100 04	tra  	68,ic		006501
						STATEMENT 1 ON LINE 1520
			     else next_key = next_key + sectors_for_record;

006376  aa  7 00134 2351 00	lda  	pr7|92		disk_data.next_key
006377  aa   000044 7330 00	lrs  	36
006400  aa  6 00335 0331 00	adl  	pr6|221		sectors_for_record
006401  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1521
		     end;

006402  aa   000077 7100 04	tra  	63,ic		006501
						STATEMENT 1 ON LINE 1525
		     else do;

						STATEMENT 1 ON LINE 1530
			if mode = Direct_input | mode = Direct_update
			     then next_key = NULL;

006403  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
006404  aa   000013 1160 07	cmpq 	11,dl
006405  aa   000003 6000 04	tze  	3,ic		006410
006406  aa   000015 1160 07	cmpq 	13,dl
006407  aa   000004 6010 04	tnz  	4,ic		006413
006410  aa   000001 3360 07	lcq  	1,dl
006411  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
006412  aa   000067 7100 04	tra  	55,ic		006501
						STATEMENT 1 ON LINE 1535
			     else next_key = END;

006413  aa   000005 3360 07	lcq  	5,dl
006414  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1537
		     end;

						STATEMENT 1 ON LINE 1539
	     end;

006415  aa   000064 7100 04	tra  	52,ic		006501
						STATEMENT 1 ON LINE 1544
	else if io_command = "rewrite"
	     then do;

006416  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
006417  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006420  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
006421  aa   772165 00 0007	desc9a	-2955,7		000604 = 162145167162
006422  aa   000030 6010 04	tnz  	24,ic		006452
						STATEMENT 1 ON LINE 1549
		if mode = Sequential_update
		     then				/* 			PATH 2a1 */
			if potential_next_sector < bounds.high + 1
			     then			/* Record will _n_o_t reach end of available area. */
				next_key = current_key + sectors_for_record;

006423  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006424  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
006425  aa   000007 1160 07	cmpq 	7,dl
006426  aa   000021 6010 04	tnz  	17,ic		006447
006427  aa  7 00140 2351 00	lda  	pr7|96		disk_data.high
006430  aa   000044 7330 00	lrs  	36
006431  aa   000001 0330 07	adl  	1,dl
006432  aa  6 01070 7571 00	staq 	pr6|568
006433  aa  6 00336 2351 00	lda  	pr6|222		potential_next_sector
006434  aa   000044 7330 00	lrs  	36
006435  aa  6 01070 1171 00	cmpaq	pr6|568
006436  aa   000006 6050 04	tpl  	6,ic		006444
006437  aa  7 00135 2351 00	lda  	pr7|93		disk_data.current_key
006440  aa   000044 7330 00	lrs  	36
006441  aa  6 00335 0331 00	adl  	pr6|221		sectors_for_record
006442  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
006443  aa   000036 7100 04	tra  	30,ic		006501
						STATEMENT 1 ON LINE 1557
			     else next_key = END;

006444  aa   000005 3360 07	lcq  	5,dl
006445  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
006446  aa   000033 7100 04	tra  	27,ic		006501
						STATEMENT 1 ON LINE 1562
		     else next_key = NULL;

006447  aa   000001 3360 07	lcq  	1,dl
006450  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1564
	     end;

006451  aa   000030 7100 04	tra  	24,ic		006501
						STATEMENT 1 ON LINE 1568
	else if io_command = "write"
	     then do;

006452  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
006453  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006454  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
006455  aa   772127 00 0005	desc9a	-2985,5		000602 = 167162151164
006456  aa   000023 6010 04	tnz  	19,ic		006501
						STATEMENT 1 ON LINE 1571
		current_key = NULL;

006457  aa   000001 3360 07	lcq  	1,dl
006460  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006461  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
						STATEMENT 1 ON LINE 1575
		if potential_next_sector < bounds.high + 1
		     then				/* Record will _n_o_t reach end of available area. */
			next_key = next_key + sectors_for_record;

006462  aa  7 00140 2351 00	lda  	pr7|96		disk_data.high
006463  aa   000044 7330 00	lrs  	36
006464  aa   000001 0330 07	adl  	1,dl
006465  aa  6 01070 7571 00	staq 	pr6|568
006466  aa  6 00336 2351 00	lda  	pr6|222		potential_next_sector
006467  aa   000044 7330 00	lrs  	36
006470  aa  6 01070 1171 00	cmpaq	pr6|568
006471  aa   000006 6050 04	tpl  	6,ic		006477
006472  aa  7 00134 2351 00	lda  	pr7|92		disk_data.next_key
006473  aa   000044 7330 00	lrs  	36
006474  aa  6 00335 0331 00	adl  	pr6|221		sectors_for_record
006475  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
006476  aa   000003 7100 04	tra  	3,ic		006501
						STATEMENT 1 ON LINE 1581
		     else next_key = END;

006477  aa   000005 3360 07	lcq  	5,dl
006500  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
						STATEMENT 1 ON LINE 1584
	     end;

						STATEMENT 1 ON LINE 1588
	a_code = 0;

006501  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 1589
	return;

006502  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_control                                      STATEMENT 1 ON LINE 1932
rdisk_control:
     entry (a_iocb_ptr, order, a_info_ptr, a_code);

006503  at     000004000521
006504  tt     000512000521
006505  ta     000520000000
006506  ta     006503000000
006507  da     000712300000
006510  aa   002120 6270 00	eax7 	1104
006511  aa  7 00034 3521 20	epp2 	pr7|28,*
006512  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
006513  aa     000010000000
006514  aa     000000000000
006515  aa  6 00042 3735 20	epp7 	pr6|34,*
006516  aa  7 00002 2361 20	ldq  	pr7|2,*
006517  aa   000002 6040 04	tmi  	2,ic		006521
006520  aa   777777 3760 07	anq  	262143,dl
006521  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
006522  aa  6 01013 7561 00	stq  	pr6|523
006523  aa  6 00032 3715 20	epp5 	pr6|26,*
006524  aa  5 00010 3535 20	epp3 	pr5|8,*
006525  aa  6 00344 2535 00	spri3	pr6|228
006526  aa   773462 7000 04	tsx0 	-2254,ic		002210
						STATEMENT 1 ON LINE 2168
	call setup ("don't_care");

006527  aa   772127 2370 04	ldaq 	-2985,ic		000656 = 144157156047 164137143141
006530  aa  6 01014 7571 00	staq 	pr6|524
006531  aa   162145 2350 03	lda  	58469,du
006532  aa  6 01016 7551 00	sta  	pr6|526
006533  aa   011171 3520 04	epp2 	4729,ic		017724 = 000002000000
006534  aa  2 00000 2351 00	lda  	pr2|0
006535  aa   005572 6700 04	tsp4 	2938,ic		014327
						STATEMENT 1 ON LINE 2169
	if order = "io_call"
	     then do;

006536  aa  6 00032 3735 20	epp7 	pr6|26,*
006537  aa  7 00004 3715 20	epp5 	pr7|4,*
006540  aa  6 01013 2351 00	lda  	pr6|523
006541  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006542  aa  5 00000 00 0005	desc9a	pr5|0,al		order
006543  aa   772037 00 0007	desc9a	-3041,7		000600 = 151157137143
006544  aa   000005 6010 04	tnz  	5,ic		006551
						STATEMENT 1 ON LINE 2171
		call io_call_order;

006545  aa   006751 6700 04	tsp4 	3561,ic		015516
						STATEMENT 1 ON LINE 2172
		a_code = code;

006546  aa  6 00157 2361 00	ldq  	pr6|111		code
006547  aa  6 00344 7561 20	stq  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 2173
		return;

006550  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2174
	     end;

						STATEMENT 1 ON LINE 2175
	if order ^= "getbounds"
	     then if real_iocb_ptr -> open_descrip_ptr = null
		     then call error (error_table_$not_open, "Only getbounds is allowed when file is not open.");

006551  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006552  aa  5 00000 00 0005	desc9a	pr5|0,al		order
006553  aa   772102 00 0011	desc9a	-3006,9		000653 = 147145164142
006554  aa   000026 6000 04	tze  	22,ic		006602
006555  aa  6 00142 3535 20	epp3 	pr6|98,*		real_iocb_ptr
006556  aa  3 00020 2371 00	ldaq 	pr3|16		iocb.open_descrip_ptr
006557  aa   772037 6770 04	eraq 	-3041,ic		000616 = 077777000043 000001000000
006560  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006561  aa   000021 6010 04	tnz  	17,ic		006602
006562  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006563  aa   772641 00 0060	desc9a	-2655,48		001423 = 117156154171
006564  aa  6 01072 00 0060	desc9a	pr6|570,48
006565  aa  6 00044 3701 20	epp4 	pr6|36,*
006566  la  4 00066 3521 20	epp2 	pr4|54,*		error_table_$not_open
006567  aa  6 01040 2521 00	spri2	pr6|544
006570  aa  6 01072 3521 00	epp2 	pr6|570
006571  aa  6 01042 2521 00	spri2	pr6|546
006572  aa   771726 3520 04	epp2 	-3114,ic		000520 = 404000000043
006573  aa  6 01046 2521 00	spri2	pr6|550
006574  aa   771707 3520 04	epp2 	-3129,ic		000503 = 524000000060
006575  aa  6 01050 2521 00	spri2	pr6|552
006576  aa  6 01036 6211 00	eax1 	pr6|542
006577  aa   010000 4310 07	fld  	4096,dl
006600  aa   005751 3520 04	epp2 	3049,ic		014551 = 000160627000
006601  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2178
	info_ptr = a_info_ptr;

006602  aa  6 00032 3735 20	epp7 	pr6|26,*
006603  aa  7 00006 3715 20	epp5 	pr7|6,*		a_info_ptr
006604  aa  5 00000 3715 20	epp5 	pr5|0,*		a_info_ptr
006605  aa  6 00152 6515 00	spri5	pr6|106		info_ptr
						STATEMENT 1 ON LINE 2180
	if (order = "changepack") & media_removable (dev_type)
	     then do;

006606  aa  7 00004 3535 20	epp3 	pr7|4,*
006607  aa  6 01013 2351 00	lda  	pr6|523
006610  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006611  aa  3 00000 00 0005	desc9a	pr3|0,al		order
006612  aa   772040 00 0012	desc9a	-3040,10		000650 = 143150141156
006613  aa   000205 6010 04	tnz  	133,ic		007020
006614  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
006615  aa  1 00074 7271 00	lxl7 	pr1|60		disk_data.dev_type
006616  aa  000 000 066 417	cmpb 	(x7),(),fill(0)
006617  ta   000310 70 0001	descb	200(35),1
006620  aa   000000 00 0000	descb	0,0
006621  aa   000177 6000 04	tze  	127,ic		007020
						STATEMENT 1 ON LINE 2182
		call rcp_$detach (rcp_id, (RETAIN), errors, "", code);

006622  aa   400000 2350 03	lda  	131072,du
006623  aa  6 01034 7551 00	sta  	pr6|540
006624  aa  1 00066 3521 00	epp2 	pr1|54		disk_data.rcp_id
006625  aa  6 01040 2521 00	spri2	pr6|544
006626  aa  6 01034 3521 00	epp2 	pr6|540
006627  aa  6 01042 2521 00	spri2	pr6|546
006630  aa  1 00077 3521 00	epp2 	pr1|63		disk_data.errors
006631  aa  6 01044 2521 00	spri2	pr6|548
006632  aa  6 01021 3521 00	epp2 	pr6|529
006633  aa  6 01046 2521 00	spri2	pr6|550
006634  aa  6 00157 3521 00	epp2 	pr6|111		code
006635  aa  6 01050 2521 00	spri2	pr6|552
006636  aa   771616 3520 04	epp2 	-3186,ic		000454 = 514000000044
006637  aa  6 01052 2521 00	spri2	pr6|554
006640  aa   771655 3520 04	epp2 	-3155,ic		000515 = 514000000001
006641  aa  6 01054 2521 00	spri2	pr6|556
006642  aa   771652 3520 04	epp2 	-3158,ic		000514 = 404000000021
006643  aa  6 01056 2521 00	spri2	pr6|558
006644  aa   771644 3520 04	epp2 	-3164,ic		000510 = 524000000000
006645  aa  6 01060 2521 00	spri2	pr6|560
006646  aa   771652 3520 04	epp2 	-3158,ic		000520 = 404000000043
006647  aa  6 01062 2521 00	spri2	pr6|562
006650  aa  6 01036 6211 00	eax1 	pr6|542
006651  aa   024000 4310 07	fld  	10240,dl
006652  aa  6 00044 3701 20	epp4 	pr6|36,*
006653  la  4 00172 3521 20	epp2 	pr4|122,*		rcp_$detach
006654  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2184
		if code ^= 0 then call error (code, "");

006655  aa  6 00157 2361 00	ldq  	pr6|111		code
006656  aa   000015 6000 04	tze  	13,ic		006673
006657  aa  6 00157 3521 00	epp2 	pr6|111		code
006660  aa  6 01074 2521 00	spri2	pr6|572
006661  aa  6 01021 3521 00	epp2 	pr6|529
006662  aa  6 01076 2521 00	spri2	pr6|574
006663  aa   771635 3520 04	epp2 	-3171,ic		000520 = 404000000043
006664  aa  6 01102 2521 00	spri2	pr6|578
006665  aa   771623 3520 04	epp2 	-3181,ic		000510 = 524000000000
006666  aa  6 01104 2521 00	spri2	pr6|580
006667  aa  6 01072 6211 00	eax1 	pr6|570
006670  aa   010000 4310 07	fld  	4096,dl
006671  aa   005660 3520 04	epp2 	2992,ic		014551 = 000160627000
006672  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2185
		pack_id = new_pack_id;

006673  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006674  aa  6 00152 3715 20	epp5 	pr6|106,*		info_ptr
006675  aa  5 00000 7271 00	lxl7 	pr5|0		new_pack_id
006676  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
006677  aa  5 00001 00 0017	desc9a	pr5|1,x7		new_pack_id
006700  aa  7 00056 00 0040	desc9a	pr7|46,32		disk_data.pack_id
						STATEMENT 1 ON LINE 2186
		call mount ();

006701  aa  6 00056 6211 00	eax1 	pr6|46
006702  aa   000000 4310 07	fld  	0,dl
006703  aa   006035 3520 04	epp2 	3101,ic		014740 = 000220627000
006704  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 2187
		if code ^= 0 then call error (code, "");

006705  aa  6 00157 2361 00	ldq  	pr6|111		code
006706  aa   000015 6000 04	tze  	13,ic		006723
006707  aa  6 00157 3521 00	epp2 	pr6|111		code
006710  aa  6 01074 2521 00	spri2	pr6|572
006711  aa  6 01021 3521 00	epp2 	pr6|529
006712  aa  6 01076 2521 00	spri2	pr6|574
006713  aa   771605 3520 04	epp2 	-3195,ic		000520 = 404000000043
006714  aa  6 01102 2521 00	spri2	pr6|578
006715  aa   771573 3520 04	epp2 	-3205,ic		000510 = 524000000000
006716  aa  6 01104 2521 00	spri2	pr6|580
006717  aa  6 01072 6211 00	eax1 	pr6|570
006720  aa   010000 4310 07	fld  	4096,dl
006721  aa   005630 3520 04	epp2 	2968,ic		014551 = 000160627000
006722  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2189
		new_length = index (pack_id, " ") - 1;

006723  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
006724  aa  000 003 124 500	scm  	(pr),(du),mask(000)
006725  aa  7 00056 00 0040	desc9a	pr7|46,32		disk_data.pack_id
006726  aa   040000 00 0001	desc9a	16384,1
006727  aa  6 00056 0001 00	arg  	pr6|46
006730  aa  6 00056 2361 00	ldq  	pr6|46
006731  aa   000002 6070 04	ttf  	2,ic		006733
006732  aa   000001 3360 07	lcq  	1,dl
006733  aa  6 00177 7561 00	stq  	pr6|127		new_length
						STATEMENT 1 ON LINE 2190
		old_length = index (substr (attach_descrip.descrip, 13), " ") - 1;

006734  aa  000 003 124 500	scm  	(pr),(du),mask(000)
006735  aa  7 00004 00 0234	desc9a	pr7|4,156		disk_data.descrip
006736  aa   040000 00 0001	desc9a	16384,1
006737  aa  6 00056 0001 00	arg  	pr6|46
006740  aa  6 00056 2361 00	ldq  	pr6|46
006741  aa   000002 6070 04	ttf  	2,ic		006743
006742  aa   000001 3360 07	lcq  	1,dl
006743  aa  6 00176 7561 00	stq  	pr6|126		old_length
						STATEMENT 1 ON LINE 2192
		if new_length = old_length
		     then				/* if the same, just overlay the old one in the att. desc. */
			substr (attach_descrip.descrip, 13, old_length) = substr (pack_id, 1, new_length);

006744  aa  6 00177 1161 00	cmpq 	pr6|127		new_length
006745  aa   000006 6010 04	tnz  	6,ic		006753
006746  aa  6 00177 7271 00	lxl7 	pr6|127		new_length
006747  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
006750  aa  7 00056 00 0017	desc9a	pr7|46,x7		disk_data.pack_id
006751  aa  7 00004 00 0006	desc9a	pr7|4,ql		disk_data.descrip
006752  aa   000711 7100 04	tra  	457,ic		007663
						STATEMENT 1 ON LINE 2195
		     else do;

						STATEMENT 1 ON LINE 2196
			old_descrip = attach_descrip.descrip;

006753  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
006754  aa  7 00001 00 0250	desc9a	pr7|1,168		disk_data.descrip
006755  aa  6 00214 00 0250	desc9a	pr6|140,168	old_descrip
						STATEMENT 1 ON LINE 2198
			attach_descrip.descrip = substr (old_descrip, 1, 12) || substr (pack_id, 1, new_length)
						/* and build */
			     || substr (old_descrip, 13 + old_length, attach_descrip.length - old_length - 12);

006756  aa  7 00000 2361 00	ldq  	pr7|0		disk_data.length
006757  aa  6 00176 1761 00	sbq  	pr6|126		old_length
006760  aa   000014 1760 07	sbq  	12,dl
006761  aa  6 01021 7561 00	stq  	pr6|529
006762  aa   000014 2360 07	ldq  	12,dl
006763  aa  6 00177 0761 00	adq  	pr6|127		new_length
006764  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
006765  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006766  aa  6 00214 00 0014	desc9a	pr6|140,12	old_descrip
006767  aa  2 00000 00 0014	desc9a	pr2|0,12
006770  aa  6 00177 7271 00	lxl7 	pr6|127		new_length
006771  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
006772  aa  7 00056 00 0017	desc9a	pr7|46,x7		disk_data.pack_id
006773  aa  2 00003 00 0017	desc9a	pr2|3,x7
006774  aa  6 01034 7561 00	stq  	pr6|540
006775  aa  6 01021 0761 00	adq  	pr6|529
006776  aa  6 01020 7561 00	stq  	pr6|528
006777  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
007000  aa  6 01034 2351 00	lda  	pr6|540
007001  aa  6 00176 2361 00	ldq  	pr6|126		old_length
007002  aa  6 01021 7261 00	lxl6 	pr6|529
007003  aa  040 145 100 546	mlr  	(pr,rl,ql),(pr,rl,al),fill(040)
007004  aa  6 00217 00 0016	desc9a	pr6|143,x6	old_descrip
007005  aa  2 00000 00 0016	desc9a	pr2|0,x6
007006  aa  6 01020 2351 00	lda  	pr6|528
007007  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
007010  aa  2 00000 00 0005	desc9a	pr2|0,al
007011  aa  7 00001 00 0250	desc9a	pr7|1,168		disk_data.descrip
						STATEMENT 1 ON LINE 2202
			attach_descrip.length = attach_descrip.length + new_length - old_length;

007012  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
007013  aa  7 00000 2361 00	ldq  	pr7|0		disk_data.length
007014  aa  6 00177 0761 00	adq  	pr6|127		new_length
007015  aa  6 00176 1761 00	sbq  	pr6|126		old_length
007016  aa  7 00000 7561 00	stq  	pr7|0		disk_data.length
						STATEMENT 1 ON LINE 2204
		     end;

						STATEMENT 1 ON LINE 2205
	     end;

007017  aa   000644 7100 04	tra  	420,ic		007663
						STATEMENT 1 ON LINE 2207
	else if order = "getbounds"
	     then do;

007020  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007021  aa  3 00000 00 0005	desc9a	pr3|0,al		order
007022  aa   771633 00 0011	desc9a	-3173,9		000653 = 147145164142
007023  aa   000007 6010 04	tnz  	7,ic		007032
						STATEMENT 1 ON LINE 2209
		user_bounds.low = bounds.low;

007024  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
007025  aa  1 00137 2361 00	ldq  	pr1|95		disk_data.low
007026  aa  5 00000 7561 00	stq  	pr5|0		user_bounds.low
						STATEMENT 1 ON LINE 2210
		user_bounds.high = bounds.high;

007027  aa  1 00140 2361 00	ldq  	pr1|96		disk_data.high
007030  aa  5 00001 7561 00	stq  	pr5|1		user_bounds.high
						STATEMENT 1 ON LINE 2211
	     end;

007031  aa   000632 7100 04	tra  	410,ic		007663
						STATEMENT 1 ON LINE 2213
	else if order = "setsize" then sze = new_size;

007032  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007033  aa  3 00000 00 0005	desc9a	pr3|0,al		order
007034  aa   771544 00 0007	desc9a	-3228,7		000576 = 163145164163
007035  aa   000005 6010 04	tnz  	5,ic		007042
007036  aa  5 00000 2361 00	ldq  	pr5|0		new_size
007037  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
007040  aa  1 00054 7561 00	stq  	pr1|44		disk_data.sze
007041  aa   000622 7100 04	tra  	402,ic		007663
						STATEMENT 1 ON LINE 2215
	else if order = "disk_info"
	     then do;

007042  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007043  aa  3 00000 00 0005	desc9a	pr3|0,al		order
007044  aa   771603 00 0011	desc9a	-3197,9		000645 = 144151163153
007045  aa   000017 6010 04	tnz  	15,ic		007064
						STATEMENT 1 ON LINE 2217
		disk_info_ptr = addr (rcp_data);

007046  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
007047  aa  1 00152 3515 00	epp1 	pr1|106		disk_data.rcp_data
007050  aa  6 00106 2515 00	spri1	pr6|70		disk_info_ptr
						STATEMENT 1 ON LINE 2218
		if info_ptr -> disk_info.version_num ^= disk_info.version_num
		     then do;

007051  aa  5 00000 2361 00	ldq  	pr5|0		disk_info.version_num
007052  aa  1 00000 1161 00	cmpq 	pr1|0		disk_info.version_num
007053  aa   000005 6000 04	tze  	5,ic		007060
						STATEMENT 1 ON LINE 2220
			a_code = error_table_$unimplemented_version;

007054  aa  6 00044 3701 20	epp4 	pr6|36,*
007055  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$unimplemented_version
007056  aa  6 00344 7561 20	stq  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 2221
			return;

007057  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2222
		     end;

						STATEMENT 1 ON LINE 2223
		info_ptr -> disk_info = disk_info;

007060  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
007061  aa  1 00000 00 0100	desc9a	pr1|0,64		disk_info
007062  aa  5 00000 00 0100	desc9a	pr5|0,64		disk_info
						STATEMENT 1 ON LINE 2224
	     end;

007063  aa   000600 7100 04	tra  	384,ic		007663
						STATEMENT 1 ON LINE 2226
	else if order = "device_info"
	     then do;

007064  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007065  aa  3 00000 00 0005	desc9a	pr3|0,al		order
007066  aa   771556 00 0013	desc9a	-3218,11		000642 = 144145166151
007067  aa   000036 6010 04	tnz  	30,ic		007125
						STATEMENT 1 ON LINE 2228
		disk_info_ptr = addr (rcp_data);

007070  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
007071  aa  1 00152 3515 00	epp1 	pr1|106		disk_data.rcp_data
007072  aa  6 00106 2515 00	spri1	pr6|70		disk_info_ptr
						STATEMENT 1 ON LINE 2229
		user_dev_char_table.user_subsystem_name = device_names (dev_type);

007073  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
007074  aa  5 00074 7271 00	lxl7 	pr5|60		disk_data.dev_type
007075  ta   000311 2350 17	lda  	201,7
007076  aa  6 00152 7551 20	sta  	pr6|106,*		user_dev_char_table.user_subsystem_name
						STATEMENT 1 ON LINE 2230
		user_dev_char_table.user_device_name = disk_info.device_name;

007077  aa  1 00004 2351 00	lda  	pr1|4		disk_info.device_name
007100  aa  1 00005 2361 00	ldq  	pr1|5		disk_info.device_name
007101  aa  6 00152 3535 20	epp3 	pr6|106,*		info_ptr
007102  aa  3 00001 7551 00	sta  	pr3|1		user_dev_char_table.user_device_name
007103  aa  3 00002 7561 00	stq  	pr3|2		user_dev_char_table.user_device_name
						STATEMENT 1 ON LINE 2231
		user_dev_char_table.user_sect_per_dev = sect_per_dev;

007104  aa  5 00100 2361 00	ldq  	pr5|64		disk_data.sect_per_dev
007105  aa  3 00003 7561 00	stq  	pr3|3		user_dev_char_table.user_sect_per_dev
						STATEMENT 1 ON LINE 2232
		user_dev_char_table.user_cyl_per_dev = cyl_per_dev (dev_type);

007106  ta   000265 2360 17	ldq  	181,7
007107  aa  3 00004 7561 00	stq  	pr3|4		user_dev_char_table.user_cyl_per_dev
						STATEMENT 1 ON LINE 2233
		user_dev_char_table.user_sect_per_cyl = sect_per_cyl (dev_type);

007110  aa  5 00074 7261 00	lxl6 	pr5|60		disk_data.dev_type
007111  ta   000210 2360 16	ldq  	136,6
007112  aa  3 00005 7561 00	stq  	pr3|5		user_dev_char_table.user_sect_per_cyl
						STATEMENT 1 ON LINE 2234
		user_dev_char_table.user_sect_per_track = sect_per_track (dev_type);

007113  aa  5 00074 7251 00	lxl5 	pr5|60		disk_data.dev_type
007114  ta   000166 2360 15	ldq  	118,5
007115  aa  3 00006 7561 00	stq  	pr3|6		user_dev_char_table.user_sect_per_track
						STATEMENT 1 ON LINE 2235
		user_dev_char_table.user_num_label_sect = num_label_sect;

007116  aa   000010 2360 07	ldq  	8,dl
007117  aa  3 00007 7561 00	stq  	pr3|7		user_dev_char_table.user_num_label_sect
						STATEMENT 1 ON LINE 2236
		user_dev_char_table.user_num_alt_sect = num_alt_sect;

007120  aa  5 00102 2361 00	ldq  	pr5|66		disk_data.num_alt_sect
007121  aa  3 00010 7561 00	stq  	pr3|8		user_dev_char_table.user_num_alt_sect
						STATEMENT 1 ON LINE 2237
		user_dev_char_table.user_sect_size = sect_size;

007122  aa  5 00101 2361 00	ldq  	pr5|65		disk_data.sect_size
007123  aa  3 00011 7561 00	stq  	pr3|9		user_dev_char_table.user_sect_size
						STATEMENT 1 ON LINE 2238
	     end;

007124  aa   000537 7100 04	tra  	351,ic		007663
						STATEMENT 1 ON LINE 2240
	else if (order = "format_trk") & device_group = MSU04XX
	     then do;

007125  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
007126  aa  1 00103 2361 00	ldq  	pr1|67		disk_data.device_group
007127  aa   000001 1160 07	cmpq 	1,dl
007130  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
007131  aa  6 01020 7551 00	sta  	pr6|528
007132  aa   000257 6000 04	tze  	175,ic		007411
007133  aa  6 01013 2361 00	ldq  	pr6|523
007134  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007135  aa  3 00000 00 0006	desc9a	pr3|0,ql		order
007136  aa   771503 00 0012	desc9a	-3261,10		000637 = 146157162155
007137  aa   000252 6010 04	tnz  	170,ic		007411
						STATEMENT 1 ON LINE 2242
		fmdp = addr (buffer.data);

007140  aa  1 00124 3715 20	epp5 	pr1|84,*		disk_data.buf_ptr
007141  aa  5 00135 3535 00	epp3 	pr5|93		buffer.data
007142  aa  6 00154 2535 00	spri3	pr6|108		fmdp
						STATEMENT 1 ON LINE 2243
		key = current_key;

007143  aa  1 00135 2361 00	ldq  	pr1|93		disk_data.current_key
007144  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 2244
		if key < sect_per_cyl (dev_type)
		     then cyl = 0;

007145  aa  1 00074 7271 00	lxl7 	pr1|60		disk_data.dev_type
007146  ta   000210 1160 17	cmpq 	136,7
007147  aa   000003 6050 04	tpl  	3,ic		007152
007150  aa  6 00201 4501 00	stz  	pr6|129		cyl
007151  aa   000003 7100 04	tra  	3,ic		007154
						STATEMENT 1 ON LINE 2246
		     else cyl = divide (key, sect_per_cyl (dev_type), 16, 0);

007152  ta   000210 5060 17	div  	136,7
007153  aa  6 00201 7561 00	stq  	pr6|129		cyl
						STATEMENT 1 ON LINE 2248
		i = mod (key, sect_per_cyl (dev_type));

007154  aa  6 00165 2361 00	ldq  	pr6|117		key
007155  ta   000210 3520 17	epp2 	136,7
007156  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
007157  aa  6 00172 7561 00	stq  	pr6|122		i
						STATEMENT 1 ON LINE 2249
		if i <= 0
		     then head = 0;

007160  aa   000003 6054 04	tpnz 	3,ic		007163
007161  aa  6 00202 4501 00	stz  	pr6|130		head
007162  aa   000003 7100 04	tra  	3,ic		007165
						STATEMENT 1 ON LINE 2251
		     else head = divide (i, sect_per_track (dev_type), 16, 0);

007163  ta   000166 5060 17	div  	118,7
007164  aa  6 00202 7561 00	stq  	pr6|130		head
						STATEMENT 1 ON LINE 2252
		fmt_dta = "0"b;

007165  aa   010535 2350 04	lda  	4445,ic		017722 = 000003777777
007166  aa  3 00000 3551 00	ansa 	pr3|0		fmt_dta.svcyl
007167  aa   010532 2350 04	lda  	4442,ic		017721 = 777774000017
007170  aa  3 00000 3551 00	ansa 	pr3|0		fmt_dta.svhd
007171  aa   010527 2350 04	lda  	4439,ic		017720 = 777777777763
007172  aa  3 00000 3551 00	ansa 	pr3|0		fmt_dta.hz
007173  aa   010524 2350 04	lda  	4436,ic		017717 = 777777777774
007174  aa  3 00000 3551 00	ansa 	pr3|0		fmt_dta.ti
007175  aa   010521 2350 04	lda  	4433,ic		017716 = 000377777777
007176  aa  3 00001 3551 00	ansa 	pr3|1		fmt_dta.pad1
007177  aa   010516 2350 04	lda  	4430,ic		017715 = 777477777777
007200  aa  3 00001 3551 00	ansa 	pr3|1		fmt_dta.r0cti
007201  aa   010513 2350 04	lda  	4427,ic		017714 = 777700000377
007202  aa  3 00001 3551 00	ansa 	pr3|1		fmt_dta.r0ccyl
007203  aa   010507 2370 04	ldaq 	4423,ic		017712 = 777777777400 001777777777
007204  aa  3 00001 3551 00	ansa 	pr3|1		fmt_dta.r0chd
007205  aa  3 00002 3561 00	ansq 	pr3|2		fmt_dta.r0chd
007206  aa   010502 2350 04	lda  	4418,ic		017710 = 776377777777
007207  aa  3 00002 3551 00	ansa 	pr3|2		fmt_dta.pad2
007210  aa   010477 2350 04	lda  	4415,ic		017707 = 777403777777
007211  aa  3 00002 3551 00	ansa 	pr3|2		fmt_dta.chk_chr
007212  aa   010474 2350 04	lda  	4412,ic		017706 = 777774000377
007213  aa  3 00002 3551 00	ansa 	pr3|2		fmt_dta.pad3
007214  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
007215  aa   000000 00 0000	descb	0,0
007216  aa  3 00002 61 0110	descb	pr3|2(28),72	fmt_dta.pad4
						STATEMENT 1 ON LINE 2253
		fmt_dta.svcyl = bit (cyl);

007217  aa  6 00201 2351 00	lda  	pr6|129		cyl
007220  aa   000002 6050 04	tpl  	2,ic		007222
007221  aa   000000 5310 00	neg  	0
007222  aa   000024 7350 00	als  	20
007223  aa  3 00000 6751 00	era  	pr3|0		fmt_dta.svcyl
007224  aa  0 00040 3751 00	ana  	pr0|32		= 777774000000
007225  aa  3 00000 6551 00	ersa 	pr3|0		fmt_dta.svcyl
						STATEMENT 1 ON LINE 2254
		fmt_dta.svhd = bit (head);

007226  aa  6 00202 2351 00	lda  	pr6|130		head
007227  aa   000002 6050 04	tpl  	2,ic		007231
007230  aa   000000 5310 00	neg  	0
007231  aa   000024 7350 00	als  	20
007232  aa   000020 7710 00	arl  	16
007233  aa  3 00000 6751 00	era  	pr3|0		fmt_dta.svhd
007234  aa   010451 3750 04	ana  	4393,ic		017705 = 000003777760
007235  aa  3 00000 6551 00	ersa 	pr3|0		fmt_dta.svhd
						STATEMENT 1 ON LINE 2255
		if fmt_info.ti = "01"b | fmt_info.ti = "10"b
		     then do;

007236  aa  6 00152 2351 20	lda  	pr6|106,*		fmt_info.ti
007237  aa   000002 7350 00	als  	2
007240  aa  0 00004 3771 00	anaq 	pr0|4		= 600000000000 000000000000
007241  aa  6 01034 7551 00	sta  	pr6|540		fmt_info.ti
007242  aa   200000 1150 03	cmpa 	65536,du
007243  aa   000003 6000 04	tze  	3,ic		007246
007244  aa   400000 1150 03	cmpa 	131072,du
007245  aa   000052 6010 04	tnz  	42,ic		007317
						STATEMENT 1 ON LINE 2257
			fmt_dta.r0ccyl = bit (fmt_info.alt_def_cyl);

007246  aa  6 00152 2351 20	lda  	pr6|106,*		fmt_info.alt_def_cyl
007247  aa   000004 7350 00	als  	4
007250  aa   000067 7330 00	lrs  	55
007251  aa   000003 6050 04	tpl  	3,ic		007254
007252  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
007253  aa   000001 0760 07	adq  	1,dl
007254  aa   000070 7370 00	lls  	56
007255  aa   000014 7730 00	lrl  	12
007256  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0ccyl
007257  aa   010425 3750 04	ana  	4373,ic		017704 = 000077777400
007260  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0ccyl
						STATEMENT 1 ON LINE 2259
			fmt_dta.r0chd = bit (fmt_info.alt_def_hd);

007261  aa  6 00152 3715 20	epp5 	pr6|106,*		info_ptr
007262  aa  5 00000 2351 00	lda  	pr5|0		fmt_info.alt_def_hd
007263  aa  5 00001 2361 00	ldq  	pr5|1		fmt_info.alt_def_hd
007264  aa   000025 7370 00	lls  	21
007265  aa   000067 7330 00	lrs  	55
007266  aa   000003 6050 04	tpl  	3,ic		007271
007267  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
007270  aa   000001 0760 07	adq  	1,dl
007271  aa   000070 7370 00	lls  	56
007272  aa   000034 7730 00	lrl  	28
007273  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0chd
007274  aa  3 00002 6761 00	erq  	pr3|2		fmt_dta.r0chd
007275  aa   010405 3770 04	anaq 	4357,ic		017702 = 000000000377 776000000000
007276  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0chd
007277  aa  3 00002 6561 00	ersq 	pr3|2		fmt_dta.r0chd
						STATEMENT 1 ON LINE 2261
			if fmt_info.ti = "10"b
			     then			/* for r0 count field */
				fmt_dta.r0cti = "01"b;

007300  aa  5 00000 2351 00	lda  	pr5|0		fmt_info.ti
007301  aa   000002 7350 00	als  	2
007302  aa  0 00004 3771 00	anaq 	pr0|4		= 600000000000 000000000000
007303  aa   400000 1150 03	cmpa 	131072,du
007304  aa   000006 6010 04	tnz  	6,ic		007312
007305  aa   000100 2350 03	lda  	64,du
007306  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0cti
007307  aa   000300 3750 03	ana  	192,du
007310  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0cti
007311  aa   000035 7100 04	tra  	29,ic		007346
						STATEMENT 1 ON LINE 2264
			     else fmt_dta.r0cti = "10"b;

007312  aa   000200 2350 03	lda  	128,du
007313  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0cti
007314  aa   000300 3750 03	ana  	192,du
007315  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0cti
						STATEMENT 1 ON LINE 2265
		     end;

007316  aa   000030 7100 04	tra  	24,ic		007346
						STATEMENT 1 ON LINE 2266
		     else do;

						STATEMENT 1 ON LINE 2267
			fmt_dta.r0ccyl = bit (cyl);

007317  aa  6 00201 2351 00	lda  	pr6|129		cyl
007320  aa   000002 6050 04	tpl  	2,ic		007322
007321  aa   000000 5310 00	neg  	0
007322  aa   000024 7350 00	als  	20
007323  aa   000014 7710 00	arl  	12
007324  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0ccyl
007325  aa   010357 3750 04	ana  	4335,ic		017704 = 000077777400
007326  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0ccyl
						STATEMENT 1 ON LINE 2268
			fmt_dta.r0chd = bit (head);

007327  aa  6 00202 2351 00	lda  	pr6|130		head
007330  aa   000002 6050 04	tpl  	2,ic		007332
007331  aa   000000 5310 00	neg  	0
007332  aa   000024 7350 00	als  	20
007333  aa   000034 7730 00	lrl  	28
007334  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0chd
007335  aa  3 00002 6761 00	erq  	pr3|2		fmt_dta.r0chd
007336  aa   010344 3770 04	anaq 	4324,ic		017702 = 000000000377 776000000000
007337  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0chd
007340  aa  3 00002 6561 00	ersq 	pr3|2		fmt_dta.r0chd
						STATEMENT 1 ON LINE 2269
			fmt_dta.r0cti = fmt_info.ti;

007341  aa  6 00152 2351 20	lda  	pr6|106,*		fmt_info.ti
007342  aa   000010 7710 00	arl  	8
007343  aa  3 00001 6751 00	era  	pr3|1		fmt_dta.r0cti
007344  aa   000300 3750 03	ana  	192,du
007345  aa  3 00001 6551 00	ersa 	pr3|1		fmt_dta.r0cti
						STATEMENT 1 ON LINE 2270
		     end;

						STATEMENT 1 ON LINE 2271
		fmt_dta.hz = fmt_info.hz;

007346  aa  6 00152 2351 20	lda  	pr6|106,*		fmt_info.hz
007347  aa   000040 7710 00	arl  	32
007350  aa  3 00000 6751 00	era  	pr3|0		fmt_dta.hz
007351  aa   000014 3750 07	ana  	12,dl
007352  aa  3 00000 6551 00	ersa 	pr3|0		fmt_dta.hz
						STATEMENT 1 ON LINE 2272
		fmt_dta.ti = fmt_info.ti;

007353  aa  6 00152 2351 20	lda  	pr6|106,*		fmt_info.ti
007354  aa   000040 7710 00	arl  	32
007355  aa  3 00000 6751 00	era  	pr3|0		fmt_dta.ti
007356  aa   000003 3750 07	ana  	3,dl
007357  aa  3 00000 6551 00	ersa 	pr3|0		fmt_dta.ti
						STATEMENT 1 ON LINE 2273
		fmt_dta.chk_chr = cksum ();

007360  aa   000012 7260 07	lxl6 	10,dl
007361  aa  3 00002 3521 00	epp2 	pr3|2		fmt_dta.chk_chr
007362  aa  2 00000 5035 16	abd  	pr2|0,6
007363  aa  6 01024 2521 00	spri2	pr6|532
007364  aa  6 01022 3521 00	epp2 	pr6|530
007365  aa   004000 4310 07	fld  	2048,dl
007366  aa  2 00000 7571 00	staq 	pr2|0
007367  aa   006077 6700 04	tsp4 	3135,ic		015466
						STATEMENT 1 ON LINE 2274
		track_indicators = fmt_info.ti;

007370  aa  6 00152 2351 20	lda  	pr6|106,*		fmt_info.ti
007371  aa   000002 7350 00	als  	2
007372  aa  0 00004 3771 00	anaq 	pr0|4		= 600000000000 000000000000
007373  aa  6 00167 7551 00	sta  	pr6|119		track_indicators
						STATEMENT 1 ON LINE 2275
		control_command = FORMAT_TRK;

007374  aa   170000 2350 03	lda  	61440,du
007375  aa  6 00166 7551 00	sta  	pr6|118		control_command
						STATEMENT 1 ON LINE 2276
		io_command = "format";

007376  aa   771174 2370 04	ldaq 	-3460,ic		000572 = 146157162155 141164000000
007377  aa  6 00307 7551 00	sta  	pr6|199		io_command
007400  aa  6 00310 7561 00	stq  	pr6|200		io_command
007401  aa   000006 2360 07	ldq  	6,dl
007402  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 2277
		cont_sw = "1"b;

007403  aa   400000 2350 03	lda  	131072,du
007404  aa  6 00206 7551 00	sta  	pr6|134		cont_sw
						STATEMENT 1 ON LINE 2278
		block_len = 5;

007405  aa   000005 2360 07	ldq  	5,dl
007406  aa  6 00171 7561 00	stq  	pr6|121		block_len
						STATEMENT 1 ON LINE 2279
		call do_io ();

007407  aa   002543 6700 04	tsp4 	1379,ic		012152
						STATEMENT 1 ON LINE 2280
	     end;

007410  aa   000253 7100 04	tra  	171,ic		007663
						STATEMENT 1 ON LINE 2282
	else if order = "rd_trk_header" & device_group = MSU04XX
	     then do;

007411  aa  6 01013 2361 00	ldq  	pr6|523
007412  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007413  aa  3 00000 00 0006	desc9a	pr3|0,ql		order
007414  aa   771304 00 0015	desc9a	-3388,13		000716 = 162144137164
007415  aa   000022 6010 04	tnz  	18,ic		007437
007416  aa   400000 3150 03	cana 	131072,du
007417  aa   000020 6000 04	tze  	16,ic		007437
						STATEMENT 1 ON LINE 2284
		key = next_key;

007420  aa  1 00134 2361 00	ldq  	pr1|92		disk_data.next_key
007421  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 2285
		cont_sw = "1"b;

007422  aa   400000 2350 03	lda  	131072,du
007423  aa  6 00206 7551 00	sta  	pr6|134		cont_sw
						STATEMENT 1 ON LINE 2286
		io_command = "read";

007424  aa   771570 2350 04	lda  	-3208,ic		001214 = 162145141144
007425  aa  6 00307 7551 00	sta  	pr6|199		io_command
007426  aa   000004 2360 07	ldq  	4,dl
007427  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 2287
		block_len = 5;

007430  aa   000005 2360 07	ldq  	5,dl
007431  aa  6 00171 7561 00	stq  	pr6|121		block_len
						STATEMENT 1 ON LINE 2288
		track_indicators = "00"b;

007432  aa  6 00167 4501 00	stz  	pr6|119		track_indicators
						STATEMENT 1 ON LINE 2289
		control_command = RD_TRK_HEADER;

007433  aa   270000 2350 03	lda  	94208,du
007434  aa  6 00166 7551 00	sta  	pr6|118		control_command
						STATEMENT 1 ON LINE 2290
		call do_io ();

007435  aa   002515 6700 04	tsp4 	1357,ic		012152
						STATEMENT 1 ON LINE 2291
	     end;

007436  aa   000225 7100 04	tra  	149,ic		007663
						STATEMENT 1 ON LINE 2293
	else if order = "read_track_header"		/* New style read track header order for 451s or 500s. */
	     then do;

007437  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007440  aa  3 00000 00 0006	desc9a	pr3|0,ql		order
007441  aa   771327 00 0021	desc9a	-3369,17		000766 = 162145141144
007442  aa   000053 6010 04	tnz  	43,ic		007515
						STATEMENT 1 ON LINE 2295
		thi_ptr = info_ptr;

007443  aa  6 00104 6515 00	spri5	pr6|68		thi_ptr
						STATEMENT 1 ON LINE 2296
		if thi.version ^= thi_version_1	/* wrong version number in structure */
		     then call error (error_table_$unimplemented_version, "");

007444  aa  6 00104 2361 20	ldq  	pr6|68,*		thi.version
007445  aa   000001 1160 07	cmpq 	1,dl
007446  aa   000016 6000 04	tze  	14,ic		007464
007447  aa  6 00044 3701 20	epp4 	pr6|36,*
007450  la  4 00100 3521 20	epp2 	pr4|64,*		error_table_$unimplemented_version
007451  aa  6 01074 2521 00	spri2	pr6|572
007452  aa  6 01020 3521 00	epp2 	pr6|528
007453  aa  6 01076 2521 00	spri2	pr6|574
007454  aa   771044 3520 04	epp2 	-3548,ic		000520 = 404000000043
007455  aa  6 01102 2521 00	spri2	pr6|578
007456  aa   771032 3520 04	epp2 	-3558,ic		000510 = 524000000000
007457  aa  6 01104 2521 00	spri2	pr6|580
007460  aa  6 01072 6211 00	eax1 	pr6|570
007461  aa   010000 4310 07	fld  	4096,dl
007462  aa   005067 3520 04	epp2 	2615,ic		014551 = 000160627000
007463  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2298
		info_ptr = addr (thi.msu4xx_info);

007464  aa  6 00104 3735 20	epp7 	pr6|68,*		thi_ptr
007465  aa  7 00001 3735 00	epp7 	pr7|1		thi.msu4xx_info
007466  aa  6 00152 6535 00	spri7	pr6|106		info_ptr
						STATEMENT 1 ON LINE 2299
		key = next_key;

007467  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
007470  aa  5 00134 2361 00	ldq  	pr5|92		disk_data.next_key
007471  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 2300
		cont_sw = "1"b;

007472  aa   400000 2350 03	lda  	131072,du
007473  aa  6 00206 7551 00	sta  	pr6|134		cont_sw
						STATEMENT 1 ON LINE 2301
		io_command = "read";

007474  aa   771520 2350 04	lda  	-3248,ic		001214 = 162145141144
007475  aa  6 00307 7551 00	sta  	pr6|199		io_command
007476  aa   000004 2360 07	ldq  	4,dl
007477  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 2302
		block_len = FORMAT_DATA_LEN (dev_type);

007500  aa  5 00074 7271 00	lxl7 	pr5|60		disk_data.dev_type
007501  ta   000015 2360 17	ldq  	13,7
007502  aa  6 00171 7561 00	stq  	pr6|121		block_len
						STATEMENT 1 ON LINE 2303
		unspec (info_ptr -> block) = "0"b;

007503  aa   000002 7360 00	qls  	2
007504  aa   000011 4020 07	mpy  	9,dl
007505  aa  003 140 060 400	csl  	(),(pr,rl),fill(0),bool(move)
007506  aa   000000 00 0000	descb	0,0
007507  aa  7 00000 00 0006	descb	pr7|0,ql
						STATEMENT 1 ON LINE 2304
		track_indicators = "00"b;

007510  aa  6 00167 4501 00	stz  	pr6|119		track_indicators
						STATEMENT 1 ON LINE 2305
		control_command = RD_TRK_HEADER;

007511  aa   270000 2350 03	lda  	94208,du
007512  aa  6 00166 7551 00	sta  	pr6|118		control_command
						STATEMENT 1 ON LINE 2306
		call do_io ();

007513  aa   002437 6700 04	tsp4 	1311,ic		012152
						STATEMENT 1 ON LINE 2307
	     end;

007514  aa   000147 7100 04	tra  	103,ic		007663
						STATEMENT 1 ON LINE 2309
	else if order = "format_track"
	     then do;

007515  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007516  aa  3 00000 00 0006	desc9a	pr3|0,ql		order
007517  aa   771117 00 0014	desc9a	-3505,12		000634 = 146157162155
007520  aa   000114 6010 04	tnz  	76,ic		007634
						STATEMENT 1 ON LINE 2311
		thi_ptr = info_ptr;

007521  aa  6 00104 6515 00	spri5	pr6|68		thi_ptr
						STATEMENT 1 ON LINE 2312
		if thi.version ^= thi_version_1	/* wrong version number */
		     then call error (error_table_$unimplemented_version, "Bad header version.");

007522  aa  6 00104 2361 20	ldq  	pr6|68,*		thi.version
007523  aa   000001 1160 07	cmpq 	1,dl
007524  aa   000021 6000 04	tze  	17,ic		007545
007525  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
007526  aa   771234 00 0024	desc9a	-3428,20		000761 = 102141144040
007527  aa  6 01022 00 0024	desc9a	pr6|530,20
007530  aa  6 00044 3701 20	epp4 	pr6|36,*
007531  la  4 00100 3521 20	epp2 	pr4|64,*		error_table_$unimplemented_version
007532  aa  6 01074 2521 00	spri2	pr6|572
007533  aa  6 01022 3521 00	epp2 	pr6|530
007534  aa  6 01076 2521 00	spri2	pr6|574
007535  aa   770763 3520 04	epp2 	-3597,ic		000520 = 404000000043
007536  aa  6 01102 2521 00	spri2	pr6|578
007537  aa   770714 3520 04	epp2 	-3636,ic		000453 = 524000000023
007540  aa  6 01104 2521 00	spri2	pr6|580
007541  aa  6 01072 6211 00	eax1 	pr6|570
007542  aa   010000 4310 07	fld  	4096,dl
007543  aa   005006 3520 04	epp2 	2566,ic		014551 = 000160627000
007544  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2314
		if dev_type > 7 then call error (error_table_$unimplemented_version, "Bad header version.");

007545  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
007546  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
007547  aa   000007 1160 07	cmpq 	7,dl
007550  aa   000021 6044 04	tmoz 	17,ic		007571
007551  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
007552  aa   771210 00 0024	desc9a	-3448,20		000761 = 102141144040
007553  aa  6 01022 00 0024	desc9a	pr6|530,20
007554  aa  6 00044 3701 20	epp4 	pr6|36,*
007555  la  4 00100 3521 20	epp2 	pr4|64,*		error_table_$unimplemented_version
007556  aa  6 01074 2521 00	spri2	pr6|572
007557  aa  6 01022 3521 00	epp2 	pr6|530
007560  aa  6 01076 2521 00	spri2	pr6|574
007561  aa   770737 3520 04	epp2 	-3617,ic		000520 = 404000000043
007562  aa  6 01102 2521 00	spri2	pr6|578
007563  aa   770670 3520 04	epp2 	-3656,ic		000453 = 524000000023
007564  aa  6 01104 2521 00	spri2	pr6|580
007565  aa  6 01072 6211 00	eax1 	pr6|570
007566  aa   010000 4310 07	fld  	4096,dl
007567  aa   004762 3520 04	epp2 	2546,ic		014551 = 000160627000
007570  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2315
		key = current_key;

007571  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
007572  aa  7 00135 2361 00	ldq  	pr7|93		disk_data.current_key
007573  aa  6 00165 7561 00	stq  	pr6|117		key
						STATEMENT 1 ON LINE 2316
		track_indicators = bit (thi.msu4xx_info.ti);

007574  aa  6 00104 3715 20	epp5 	pr6|68,*		thi_ptr
007575  aa  5 00001 2361 00	ldq  	pr5|1		thi.ti
007576  aa  0 00434 3771 00	anaq 	pr0|284		= 000000000000 000000000003
007577  aa   000106 7370 00	lls  	70
007600  aa  6 00167 7551 00	sta  	pr6|119		track_indicators
						STATEMENT 1 ON LINE 2317
		control_command = FORMAT_TRK;

007601  aa   170000 2350 03	lda  	61440,du
007602  aa  6 00166 7551 00	sta  	pr6|118		control_command
						STATEMENT 1 ON LINE 2318
		io_command = "format";

007603  aa   770767 2370 04	ldaq 	-3593,ic		000572 = 146157162155 141164000000
007604  aa  6 00307 7551 00	sta  	pr6|199		io_command
007605  aa  6 00310 7561 00	stq  	pr6|200		io_command
007606  aa   000006 2360 07	ldq  	6,dl
007607  aa  6 00306 7561 00	stq  	pr6|198		io_command
						STATEMENT 1 ON LINE 2319
		cont_sw = "1"b;

007610  aa   400000 2350 03	lda  	131072,du
007611  aa  6 00206 7551 00	sta  	pr6|134		cont_sw
						STATEMENT 1 ON LINE 2320
		block_len = FORMAT_DATA_LEN (dev_type);

007612  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
007613  ta   000015 2360 17	ldq  	13,7
007614  aa  6 00171 7561 00	stq  	pr6|121		block_len
						STATEMENT 1 ON LINE 2321
		addr (data) -> block = addrel (addr (thi), 1) -> block;

007615  aa  7 00130 2361 00	ldq  	pr7|88		disk_data.data_len
007616  aa   000002 7360 00	qls  	2
007617  aa  6 01020 7561 00	stq  	pr6|528
007620  aa  6 00171 2361 00	ldq  	pr6|121		block_len
007621  aa   000002 7360 00	qls  	2
007622  aa  5 00000 3535 00	epp3 	pr5|0		thi
007623  aa  3 00000 3521 00	epp2 	pr3|0
007624  aa   000001 0520 03	adwp2	1,du
007625  aa  7 00124 3515 20	epp1 	pr7|84,*		disk_data.buf_ptr
007626  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
007627  aa  2 00000 00 0006	desc9a	pr2|0,ql		block
007630  aa  1 00135 00 0006	desc9a	pr1|93,ql		block
						STATEMENT 1 ON LINE 2322
		call do_io ();

007631  aa  6 01070 2535 00	spri3	pr6|568
007632  aa   002320 6700 04	tsp4 	1232,ic		012152
						STATEMENT 1 ON LINE 2323
	     end;

007633  aa   000030 7100 04	tra  	24,ic		007663
						STATEMENT 1 ON LINE 2325
	else if order = "hardware_status" then user_hardware_status = iom_stat;

007634  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007635  aa  3 00000 00 0006	desc9a	pr3|0,ql		order
007636  aa   771056 00 0017	desc9a	-3538,15		000712 = 150141162144
007637  aa   000006 6010 04	tnz  	6,ic		007645
007640  aa  1 00124 3535 20	epp3 	pr1|84,*		disk_data.buf_ptr
007641  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
007642  aa  3 00131 00 0110	descb	pr3|89,72		buffer.iom_stat
007643  aa  5 00000 00 0110	descb	pr5|0,72		user_hardware_status
007644  aa   000017 7100 04	tra  	15,ic		007663
						STATEMENT 1 ON LINE 2327
	else call error (error_table_$no_operation, order);

007645  aa  6 00044 3701 20	epp4 	pr6|36,*
007646  la  4 00052 3521 20	epp2 	pr4|42,*		error_table_$no_operation
007647  aa  6 01074 2521 00	spri2	pr6|572
007650  aa  7 00004 3521 20	epp2 	pr7|4,*		order
007651  aa  6 01076 2521 00	spri2	pr6|574
007652  aa   770646 3520 04	epp2 	-3674,ic		000520 = 404000000043
007653  aa  6 01102 2521 00	spri2	pr6|578
007654  aa  6 00042 3715 20	epp5 	pr6|34,*
007655  aa  5 00002 3521 20	epp2 	pr5|2,*
007656  aa  6 01104 2521 00	spri2	pr6|580
007657  aa  6 01072 6211 00	eax1 	pr6|570
007660  aa   010000 4310 07	fld  	4096,dl
007661  aa   004670 3520 04	epp2 	2488,ic		014551 = 000160627000
007662  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2330
	a_code = 0;

007663  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 2331
	return;

007664  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_modes                                        STATEMENT 1 ON LINE 2339
rdisk_modes:
     entry (a_iocb_ptr, a_new_modes, a_old_modes, a_code);

007665  at     000004000521
007666  tt     000512000512
007667  ta     000520000000
007670  ta     007665000000
007671  da     000720300000
007672  aa   002120 6270 00	eax7 	1104
007673  aa  7 00034 3521 20	epp2 	pr7|28,*
007674  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
007675  aa     000010000000
007676  aa     000000000000
007677  aa  6 00042 3735 20	epp7 	pr6|34,*
007700  aa  7 00002 2361 20	ldq  	pr7|2,*
007701  aa   000002 6040 04	tmi  	2,ic		007703
007702  aa   777777 3760 07	anq  	262143,dl
007703  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
007704  aa  6 01013 7561 00	stq  	pr6|523
007705  aa  7 00004 2361 20	ldq  	pr7|4,*
007706  aa   000002 6040 04	tmi  	2,ic		007710
007707  aa   777777 3760 07	anq  	262143,dl
007710  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
007711  aa  6 01106 7561 00	stq  	pr6|582
007712  aa  6 00032 3715 20	epp5 	pr6|26,*
007713  aa  5 00010 3535 20	epp3 	pr5|8,*
007714  aa  6 00344 2535 00	spri3	pr6|228
007715  aa   772273 7000 04	tsx0 	-2885,ic		002210
						STATEMENT 1 ON LINE 2391
	call setup ("don't_care");

007716  aa   770740 2370 04	ldaq 	-3616,ic		000656 = 144157156047 164137143141
007717  aa  6 01014 7571 00	staq 	pr6|524
007720  aa   162145 2350 03	lda  	58469,du
007721  aa  6 01016 7551 00	sta  	pr6|526
007722  aa   010002 3520 04	epp2 	4098,ic		017724 = 000002000000
007723  aa  2 00000 2351 00	lda  	pr2|0
007724  aa   004403 6700 04	tsp4 	2307,ic		014327
						STATEMENT 1 ON LINE 2393
	if length (a_old_modes) > 0 then a_old_modes = mode_string;

007725  aa  6 01106 2361 00	ldq  	pr6|582
007726  aa   000010 6044 04	tmoz 	8,ic		007736
007727  aa  6 00032 3735 20	epp7 	pr6|26,*
007730  aa  7 00006 3715 20	epp5 	pr7|6,*
007731  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
007732  aa  3 00141 7271 00	lxl7 	pr3|97		disk_data.mode_string
007733  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
007734  aa  3 00142 00 0017	desc9a	pr3|98,x7		disk_data.mode_string
007735  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_old_modes
						STATEMENT 1 ON LINE 2396
	mode_len = length (a_new_modes);

007736  aa  6 01013 2361 00	ldq  	pr6|523
007737  aa  6 00163 7561 00	stq  	pr6|115		mode_len
						STATEMENT 1 ON LINE 2397
	if mode_len > 0
	     then do;

007740  aa   000215 6044 04	tmoz 	141,ic		010155
						STATEMENT 1 ON LINE 2400
		new_modes = a_new_modes;

007741  aa  6 00032 3735 20	epp7 	pr6|26,*
007742  aa  7 00004 3715 20	epp5 	pr7|4,*
007743  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
007744  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_new_modes
007745  aa  6 00266 00 0030	desc9a	pr6|182,24	new_modes
						STATEMENT 1 ON LINE 2401
		mode_start = 1;

007746  aa   000001 2360 07	ldq  	1,dl
007747  aa  6 00164 7561 00	stq  	pr6|116		mode_start
						STATEMENT 1 ON LINE 2403
		do while (next_mode ^= "");

007750  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
007751  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007752  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
007753  aa   010022 00 0000	desc9a	4114,0		017773 = 136000000000
007754  aa   000201 6000 04	tze  	129,ic		010155
						STATEMENT 1 ON LINE 2405
		     call get_next_mode;

007755  aa   004005 6700 04	tsp4 	2053,ic		013762
						STATEMENT 1 ON LINE 2406
		     if next_mode ^= ""
			then do;

007756  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
007757  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007760  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
007761  aa   010014 00 0000	desc9a	4108,0		017773 = 136000000000
007762  aa   777766 6000 04	tze  	-10,ic		007750
						STATEMENT 1 ON LINE 2409
			     mode_err_sw = "0"b;

007763  aa  6 00205 4501 00	stz  	pr6|133		mode_err_sw
						STATEMENT 1 ON LINE 2411
			     if next_mode = "label"
				then do;

007764  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
007765  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
007766  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
007767  aa   770603 00 0005	desc9a	-3709,5		000570 = 154141142145
007770  aa   000007 6010 04	tnz  	7,ic		007777
						STATEMENT 1 ON LINE 2413
				     bounds.low = num_label_sect;

007771  aa   000010 2360 07	ldq  	8,dl
007772  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
007773  aa  7 00137 7561 00	stq  	pr7|95		disk_data.low
						STATEMENT 1 ON LINE 2415
				     label_sw = "1"b;

007774  aa   010000 2350 03	lda  	4096,du
007775  aa  7 00055 2551 00	orsa 	pr7|45		disk_data.label_sw
						STATEMENT 1 ON LINE 2416
				end;

007776  aa   000153 7100 04	tra  	107,ic		010151
						STATEMENT 1 ON LINE 2417
			     else if next_mode = "^label"
				then do;

007777  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010000  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010001  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010002  aa   770566 00 0006	desc9a	-3722,6		000566 = 136154141142
010003  aa   000006 6010 04	tnz  	6,ic		010011
						STATEMENT 1 ON LINE 2419
				     bounds.low = 0;

010004  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010005  aa  7 00137 4501 00	stz  	pr7|95		disk_data.low
						STATEMENT 1 ON LINE 2420
				     label_sw = "0"b;

010006  aa   007673 2350 04	lda  	4027,ic		017701 = 767777777777
010007  aa  7 00055 3551 00	ansa 	pr7|45		disk_data.label_sw
						STATEMENT 1 ON LINE 2421
				end;

010010  aa   000141 7100 04	tra  	97,ic		010151
						STATEMENT 1 ON LINE 2423
			     else if (next_mode = "alttrk")
				then do;

010011  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010012  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010013  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010014  aa   770552 00 0006	desc9a	-3734,6		000564 = 141154164164
010015  aa   000010 6010 04	tnz  	8,ic		010025
						STATEMENT 1 ON LINE 2425
				     bounds.high = last_sect_num (dev_type);

010016  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010017  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
010020  ta   000254 2360 17	ldq  	172,7
010021  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
						STATEMENT 1 ON LINE 2427
				     alt_sw = "1"b;

010022  aa   020000 2350 03	lda  	8192,du
010023  aa  7 00055 2551 00	orsa 	pr7|45		disk_data.alt_sw
						STATEMENT 1 ON LINE 2428
				end;

010024  aa   000125 7100 04	tra  	85,ic		010151
						STATEMENT 1 ON LINE 2429
			     else if next_mode = "^alttrk"
				then do;

010025  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010026  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010027  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010030  aa   770534 00 0007	desc9a	-3748,7		000562 = 136141154164
010031  aa   000017 6010 04	tnz  	15,ic		010050
						STATEMENT 1 ON LINE 2431
				     if device_group = MSU04XX
					then bounds.high = last_alt_sect_num (dev_type);

010032  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010033  aa  7 00103 2361 00	ldq  	pr7|67		disk_data.device_group
010034  aa   000001 1160 07	cmpq 	1,dl
010035  aa   000005 6010 04	tnz  	5,ic		010042
010036  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
010037  ta   000232 2360 17	ldq  	154,7
010040  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
010041  aa   000004 7100 04	tra  	4,ic		010045
						STATEMENT 1 ON LINE 2433
					else bounds.high = last_sect_num (dev_type);

010042  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
010043  ta   000254 2360 17	ldq  	172,7
010044  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
						STATEMENT 1 ON LINE 2434
				     alt_sw = "0"b;

010045  aa   007715 2350 04	lda  	4045,ic		017762 = 757777777777
010046  aa  7 00055 3551 00	ansa 	pr7|45		disk_data.alt_sw
						STATEMENT 1 ON LINE 2435
				end;

010047  aa   000102 7100 04	tra  	66,ic		010151
						STATEMENT 1 ON LINE 2437
			     else if next_mode = "wrtcmp" then compare_sw = "1"b;

010050  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010051  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010052  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010053  aa   770507 00 0006	desc9a	-3769,6		000560 = 167162164143
010054  aa   000005 6010 04	tnz  	5,ic		010061
010055  aa   100000 2350 03	lda  	32768,du
010056  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010057  aa  7 00055 2551 00	orsa 	pr7|45		disk_data.compare_sw
010060  aa   000071 7100 04	tra  	57,ic		010151
						STATEMENT 1 ON LINE 2439
			     else if next_mode = "^wrtcmp" then compare_sw = "0"b;

010061  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010062  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010063  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010064  aa   770474 00 0007	desc9a	-3780,7		000556 = 136167162164
010065  aa   000005 6010 04	tnz  	5,ic		010072
010066  aa   007612 2350 04	lda  	3978,ic		017700 = 677777777777
010067  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010070  aa  7 00055 3551 00	ansa 	pr7|45		disk_data.compare_sw
010071  aa   000060 7100 04	tra  	48,ic		010151
						STATEMENT 1 ON LINE 2442
			     else if next_mode = "raw"
				then do;

010072  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010073  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010074  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010075  aa   770357 00 0003	desc9a	-3857,3		000452 = 162141167000
010076  aa   000011 6010 04	tnz  	9,ic		010107
						STATEMENT 1 ON LINE 2444
				     bounds.low = 0;

010077  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010100  aa  7 00137 4501 00	stz  	pr7|95		disk_data.low
						STATEMENT 1 ON LINE 2445
				     bounds.high = last_physical_sect_num (dev_type);

010101  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
010102  ta   000221 2360 17	ldq  	145,7
010103  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
						STATEMENT 1 ON LINE 2446
				     raw_sw = "1"b;

010104  aa   040000 2350 03	lda  	16384,du
010105  aa  7 00055 2551 00	orsa 	pr7|45		disk_data.raw_sw
						STATEMENT 1 ON LINE 2447
				end;

010106  aa   000043 7100 04	tra  	35,ic		010151
						STATEMENT 1 ON LINE 2448
			     else if next_mode = "^raw"
				then do;

010107  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010110  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010111  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010112  aa   770341 00 0004	desc9a	-3871,4		000451 = 136162141167
010113  aa   000031 6010 04	tnz  	25,ic		010144
						STATEMENT 1 ON LINE 2450
				     if label_sw	/* in label mode */
					then bounds.low = num_label_sect;

010114  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010115  aa  7 00055 2351 00	lda  	pr7|45		disk_data.label_sw
010116  aa   010000 3150 03	cana 	4096,du
010117  aa   000004 6000 04	tze  	4,ic		010123
010120  aa   000010 2360 07	ldq  	8,dl
010121  aa  7 00137 7561 00	stq  	pr7|95		disk_data.low
010122  aa   000002 7100 04	tra  	2,ic		010124
						STATEMENT 1 ON LINE 2453
					else bounds.low = 0;

010123  aa  7 00137 4501 00	stz  	pr7|95		disk_data.low
						STATEMENT 1 ON LINE 2454
				     if ^alt_sw	/* in alt mode */
					& device_group = MSU04XX
						/* and on a 400 series device */
					then bounds.high = last_alt_sect_num (dev_type);

010124  aa  7 00055 2351 00	lda  	pr7|45		disk_data.alt_sw
010125  aa   020000 3150 03	cana 	8192,du
010126  aa   000010 6010 04	tnz  	8,ic		010136
010127  aa  7 00103 2361 00	ldq  	pr7|67		disk_data.device_group
010130  aa   000001 1160 07	cmpq 	1,dl
010131  aa   000005 6010 04	tnz  	5,ic		010136
010132  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
010133  ta   000232 2360 17	ldq  	154,7
010134  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
010135  aa   000004 7100 04	tra  	4,ic		010141
						STATEMENT 1 ON LINE 2458
					else bounds.high = last_sect_num (dev_type);

010136  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
010137  ta   000254 2360 17	ldq  	172,7
010140  aa  7 00140 7561 00	stq  	pr7|96		disk_data.high
						STATEMENT 1 ON LINE 2459
				     raw_sw = "0"b;

010141  aa   007622 2350 04	lda  	3986,ic		017763 = 737777777777
010142  aa  7 00055 3551 00	ansa 	pr7|45		disk_data.raw_sw
						STATEMENT 1 ON LINE 2460
				end;

010143  aa   000006 7100 04	tra  	6,ic		010151
						STATEMENT 1 ON LINE 2461
			     else do;

						STATEMENT 1 ON LINE 2462
				code = error_table_$bad_mode;

010144  aa  6 00044 3701 20	epp4 	pr6|36,*
010145  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$bad_mode
010146  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 2464
				mode_err_sw = "1"b;

010147  aa   400000 2350 03	lda  	131072,du
010150  aa  6 00205 7551 00	sta  	pr6|133		mode_err_sw
						STATEMENT 1 ON LINE 2465
			     end;

						STATEMENT 1 ON LINE 2467
			     if ^mode_err_sw then call set_mode;

010151  aa  6 00205 2351 00	lda  	pr6|133		mode_err_sw
010152  aa   777576 6010 04	tnz  	-130,ic		007750
010153  aa   003673 6700 04	tsp4 	1979,ic		014046
						STATEMENT 1 ON LINE 2470
			end;

						STATEMENT 1 ON LINE 2471
		     end;

010154  aa   777574 7100 04	tra  	-132,ic		007750
						STATEMENT 1 ON LINE 2472
	     end;

						STATEMENT 1 ON LINE 2474
	temp_next_mode = next_mode || "                ";

010155  aa  6 00274 2361 00	ldq  	pr6|188		next_mode
010156  aa   000020 0760 07	adq  	16,dl
010157  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
010160  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010161  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
010162  aa  6 00275 00 0017	desc9a	pr6|189,x7	next_mode
010163  aa  2 00000 00 0017	desc9a	pr2|0,x7
010164  aa  6 00274 7271 00	lxl7 	pr6|188		next_mode
010165  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
010166  aa   007616 00 0020	desc9a	3982,16		020003 = 040040040040
010167  aa  2 00000 00 0020	desc9a	pr2|0,16
010170  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
010171  aa  2 00000 00 0006	desc9a	pr2|0,ql
010172  aa  6 00337 00 0020	desc9a	pr6|223,16	temp_next_mode
						STATEMENT 1 ON LINE 2475
	temp_next_mode = substr (temp_next_mode, 1, 16);

010173  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
010174  aa  6 00337 2351 00	lda  	pr6|223		temp_next_mode
010175  aa  6 00337 7551 00	sta  	pr6|223		temp_next_mode
010176  aa  6 00340 2371 00	ldaq 	pr6|224		temp_next_mode
010177  aa  6 00340 7571 00	staq 	pr6|224		temp_next_mode
010200  aa  6 00342 2351 00	lda  	pr6|226		temp_next_mode
010201  aa  6 00342 7551 00	sta  	pr6|226		temp_next_mode
						STATEMENT 1 ON LINE 2476
	if code ^= 0
	     then call error (code, temp_next_mode);

010202  aa  6 00157 2361 00	ldq  	pr6|111		code
010203  aa   000016 6000 04	tze  	14,ic		010221
010204  aa  6 00157 3521 00	epp2 	pr6|111		code
010205  aa  6 01074 2521 00	spri2	pr6|572
010206  aa  6 00337 3521 00	epp2 	pr6|223		temp_next_mode
010207  aa  6 01076 2521 00	spri2	pr6|574
010210  aa   770310 3520 04	epp2 	-3896,ic		000520 = 404000000043
010211  aa  6 01102 2521 00	spri2	pr6|578
010212  aa   770236 3520 04	epp2 	-3938,ic		000450 = 526000000020
010213  aa  6 01104 2521 00	spri2	pr6|580
010214  aa  6 01072 6211 00	eax1 	pr6|570
010215  aa   010000 4310 07	fld  	4096,dl
010216  aa   004333 3520 04	epp2 	2267,ic		014551 = 000160627000
010217  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
010220  aa   000002 7100 04	tra  	2,ic		010222
						STATEMENT 1 ON LINE 2478
	     else a_code = 0;

010221  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 2480
	return;

010222  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_close                                        STATEMENT 1 ON LINE 2542
rdisk_close:
     entry (a_iocb_ptr, a_code);

010223  at     000002000521
010224  ta     000520000000
010225  ta     010223000000
010226  da     000726300000
010227  aa   002120 6270 00	eax7 	1104
010230  aa  7 00034 3521 20	epp2 	pr7|28,*
010231  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
010232  aa     000004000000
010233  aa     000000000000
010234  aa  6 00032 3735 20	epp7 	pr6|26,*
010235  aa  7 00004 3715 20	epp5 	pr7|4,*
010236  aa  6 00344 6515 00	spri5	pr6|228
010237  aa   771751 7000 04	tsx0 	-3095,ic		002210
						STATEMENT 1 ON LINE 2550
	call setup ("open");

010240  aa   770237 2350 04	lda  	-3937,ic		000477 = 157160145156
010241  aa  6 01034 7551 00	sta  	pr6|540
010242  aa   007474 3520 04	epp2 	3900,ic		017736 = 000002000000
010243  aa  2 00000 2351 00	lda  	pr2|0
010244  aa   004063 6700 04	tsp4 	2099,ic		014327
						STATEMENT 1 ON LINE 2552
	mask_str = "0"b;

010245  aa  6 00277 4501 00	stz  	pr6|191		mask_str
						STATEMENT 1 ON LINE 2553
	call default_handler_$set (cond_hdlr);

010246  aa   005141 3520 04	epp2 	2657,ic		015407 = 000140627000
010247  aa  6 01014 2521 00	spri2	pr6|524		cp.789
010250  aa  6 01016 6521 00	spri6	pr6|526		cp.789
010251  aa  6 01014 3521 00	epp2 	pr6|524		cp.789
010252  aa  6 01024 2521 00	spri2	pr6|532
010253  aa  6 01022 6211 00	eax1 	pr6|530
010254  aa   004000 4310 07	fld  	2048,dl
010255  aa  6 00044 3701 20	epp4 	pr6|36,*
010256  la  4 00162 3521 20	epp2 	pr4|114,*		default_handler_$set
010257  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2554
	call hcs_$set_ips_mask (mask_str, mask_str);

010260  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
010261  aa  6 01024 2521 00	spri2	pr6|532
010262  aa  6 01026 2521 00	spri2	pr6|534
010263  aa  6 01022 6211 00	eax1 	pr6|530
010264  aa   010000 4310 07	fld  	4096,dl
010265  aa  6 00044 3701 20	epp4 	pr6|36,*
010266  la  4 00156 3521 20	epp2 	pr4|110,*		hcs_$set_ips_mask
010267  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2556
	real_iocb_ptr -> open_descrip_ptr = null;

010270  aa   770326 2370 04	ldaq 	-3882,ic		000616 = 077777000043 000001000000
010271  aa  6 00142 3735 20	epp7 	pr6|98,*		real_iocb_ptr
010272  aa  7 00020 7571 00	staq 	pr7|16		iocb.open_descrip_ptr
						STATEMENT 1 ON LINE 2558
	real_iocb_ptr -> open = rdisk_open;

010273  aa   773174 3520 04	epp2 	-2436,ic		003467 = 002120627000
010274  aa  7 00032 2521 00	spri2	pr7|26		iocb.open
010275  aa   007463 2370 04	ldaq 	3891,ic		017760 = 077777000043 000001000000
010276  aa  7 00034 7571 00	staq 	pr7|28		iocb.open
						STATEMENT 1 ON LINE 2559
	real_iocb_ptr -> detach_iocb = rdisk_detach;

010277  aa   000066 3520 04	epp2 	54,ic		010365 = 002120627000
010300  aa  7 00026 2521 00	spri2	pr7|22		iocb.detach_iocb
010301  aa  7 00030 7571 00	staq 	pr7|24		iocb.detach_iocb
						STATEMENT 1 ON LINE 2561
	real_iocb_ptr -> close,			/* shut the close entry */
	     real_iocb_ptr -> read_record,		/* and the read record entry */
	     real_iocb_ptr -> rewrite_record,		/* and the rewrite record entry */
	     real_iocb_ptr -> position,		/* and the position entry */
	     real_iocb_ptr -> write_record,		/* and the write record entry */
	     real_iocb_ptr -> seek_key = iox_$err_not_open;

010302  aa  6 00044 3701 20	epp4 	pr6|36,*
010303  la  4 00112 3521 20	epp2 	pr4|74,*		iox_$err_not_open
010304  aa  6 01014 2521 00	spri2	pr6|524		cp.418
010305  aa  6 01016 7571 00	staq 	pr6|526		cp.418
010306  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.418
010307  aa  7 00036 2521 00	spri2	pr7|30		iocb.close
010310  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.418
010311  aa  7 00040 2521 00	spri2	pr7|32		iocb.close
010312  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.418
010313  aa  7 00072 2521 00	spri2	pr7|58		iocb.read_record
010314  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.418
010315  aa  7 00074 2521 00	spri2	pr7|60		iocb.read_record
010316  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.418
010317  aa  7 00102 2521 00	spri2	pr7|66		iocb.rewrite_record
010320  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.418
010321  aa  7 00104 2521 00	spri2	pr7|68		iocb.rewrite_record
010322  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.418
010323  aa  7 00062 2521 00	spri2	pr7|50		iocb.position
010324  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.418
010325  aa  7 00064 2521 00	spri2	pr7|52		iocb.position
010326  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.418
010327  aa  7 00076 2521 00	spri2	pr7|62		iocb.write_record
010330  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.418
010331  aa  7 00100 2521 00	spri2	pr7|64		iocb.write_record
010332  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.418
010333  aa  7 00112 2521 00	spri2	pr7|74		iocb.seek_key
010334  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.418
010335  aa  7 00114 2521 00	spri2	pr7|76		iocb.seek_key
						STATEMENT 1 ON LINE 2569
	call iox_$propagate (iocb_ptr);

010336  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
010337  aa  6 01016 2521 00	spri2	pr6|526
010340  aa  6 01014 6211 00	eax1 	pr6|524
010341  aa   004000 4310 07	fld  	2048,dl
010342  la  4 00126 3521 20	epp2 	pr4|86,*		iox_$propagate
010343  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2571
	call hcs_$reset_ips_mask (mask_str, mask_str);

010344  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
010345  aa  6 01024 2521 00	spri2	pr6|532
010346  aa  6 01026 2521 00	spri2	pr6|534
010347  aa  6 01022 6211 00	eax1 	pr6|530
010350  aa   010000 4310 07	fld  	4096,dl
010351  aa  6 00044 3701 20	epp4 	pr6|36,*
010352  la  4 00160 3521 20	epp2 	pr4|112,*		hcs_$reset_ips_mask
010353  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2573
	next_key, current_key, key_for_insertion = NULL;

010354  aa   000001 3360 07	lcq  	1,dl
010355  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010356  aa  7 00134 7561 00	stq  	pr7|92		disk_data.next_key
010357  aa  7 00135 7561 00	stq  	pr7|93		disk_data.current_key
010360  aa  7 00136 7561 00	stq  	pr7|94		disk_data.key_for_insertion
						STATEMENT 1 ON LINE 2575
	a_code = 0;

010361  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 2576
	return;

010362  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO rdisk_detach                                       STATEMENT 1 ON LINE 2582
rdisk_detach:
     entry (a_iocb_ptr, a_code);

010363  ta     010223000000
010364  da     000735300000
010365  aa   002120 6270 00	eax7 	1104
010366  aa  7 00034 3521 20	epp2 	pr7|28,*
010367  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
010370  aa     000004000000
010371  aa     000000000000
010372  aa  6 00032 3735 20	epp7 	pr6|26,*
010373  aa  7 00004 3715 20	epp5 	pr7|4,*
010374  aa  6 00344 6515 00	spri5	pr6|228
010375  aa   771613 7000 04	tsx0 	-3189,ic		002210
						STATEMENT 1 ON LINE 2589
	call setup ("closed");

010376  aa   770210 2370 04	ldaq 	-3960,ic		000606 = 143154157163 145144000000
010377  aa  6 01110 7571 00	staq 	pr6|584
010400  aa   007272 3520 04	epp2 	3770,ic		017672 = 000002000000
010401  aa  2 00000 2351 00	lda  	pr2|0
010402  aa   003725 6700 04	tsp4 	2005,ic		014327
						STATEMENT 1 ON LINE 2590
	rcp_detachment = "0"b;

010403  aa  6 00331 4501 00	stz  	pr6|217		rcp_detachment
						STATEMENT 1 ON LINE 2591
	call delete_attach (rcp_detachment);

010404  aa   007262 3520 04	epp2 	3762,ic		017666 = 000002000000
010405  aa   003577 6700 04	tsp4 	1919,ic		014204
						STATEMENT 1 ON LINE 2593
	if rcp_detachment
	     then do;

010406  aa  6 00331 2351 00	lda  	pr6|217		rcp_detachment
010407  aa   400000 3150 03	cana 	131072,du
010410  aa   000047 6000 04	tze  	39,ic		010457
						STATEMENT 1 ON LINE 2595
		call rcp_$detach (rcp_id, (DEFAULT), errors, "", code);

010411  aa   000000 2350 07	lda  	0,dl
010412  aa  6 01107 7551 00	sta  	pr6|583
010413  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010414  aa  7 00066 3521 00	epp2 	pr7|54		disk_data.rcp_id
010415  aa  6 01040 2521 00	spri2	pr6|544
010416  aa  6 01107 3521 00	epp2 	pr6|583
010417  aa  6 01042 2521 00	spri2	pr6|546
010420  aa  7 00077 3521 00	epp2 	pr7|63		disk_data.errors
010421  aa  6 01044 2521 00	spri2	pr6|548
010422  aa  6 01034 3521 00	epp2 	pr6|540
010423  aa  6 01046 2521 00	spri2	pr6|550
010424  aa  6 00157 3521 00	epp2 	pr6|111		code
010425  aa  6 01050 2521 00	spri2	pr6|552
010426  aa   770026 3520 04	epp2 	-4074,ic		000454 = 514000000044
010427  aa  6 01052 2521 00	spri2	pr6|554
010430  aa   770065 3520 04	epp2 	-4043,ic		000515 = 514000000001
010431  aa  6 01054 2521 00	spri2	pr6|556
010432  aa   770062 3520 04	epp2 	-4046,ic		000514 = 404000000021
010433  aa  6 01056 2521 00	spri2	pr6|558
010434  aa   770054 3520 04	epp2 	-4052,ic		000510 = 524000000000
010435  aa  6 01060 2521 00	spri2	pr6|560
010436  aa   770062 3520 04	epp2 	-4046,ic		000520 = 404000000043
010437  aa  6 01062 2521 00	spri2	pr6|562
010440  aa  6 01036 6211 00	eax1 	pr6|542
010441  aa   024000 4310 07	fld  	10240,dl
010442  aa  6 00044 3701 20	epp4 	pr6|36,*
010443  la  4 00172 3521 20	epp2 	pr4|122,*		rcp_$detach
010444  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2597
		call ipc_$delete_ev_chn (ev_chan, code);

010445  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
010446  aa  7 00072 3521 00	epp2 	pr7|58		disk_data.ev_chan
010447  aa  6 01024 2521 00	spri2	pr6|532
010450  aa  6 00157 3521 00	epp2 	pr6|111		code
010451  aa  6 01026 2521 00	spri2	pr6|534
010452  aa  6 01022 6211 00	eax1 	pr6|530
010453  aa   010000 4310 07	fld  	4096,dl
010454  aa  6 00044 3701 20	epp4 	pr6|36,*
010455  la  4 00104 3521 20	epp2 	pr4|68,*		ipc_$delete_ev_chn
010456  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2598
	     end;

						STATEMENT 1 ON LINE 2600
	call hcs_$delentry_seg (disk_ptr, code);

010457  aa  6 00136 3521 00	epp2 	pr6|94		disk_ptr
010460  aa  6 01024 2521 00	spri2	pr6|532
010461  aa  6 00157 3521 00	epp2 	pr6|111		code
010462  aa  6 01026 2521 00	spri2	pr6|534
010463  aa  6 01022 6211 00	eax1 	pr6|530
010464  aa   010000 4310 07	fld  	4096,dl
010465  aa  6 00044 3701 20	epp4 	pr6|36,*
010466  la  4 00124 3521 20	epp2 	pr4|84,*		hcs_$delentry_seg
010467  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2601
	disk_ptr = null;

010470  aa   770126 2370 04	ldaq 	-4010,ic		000616 = 077777000043 000001000000
010471  aa  6 00136 7571 00	staq 	pr6|94		disk_ptr
						STATEMENT 1 ON LINE 2603
	mask_str = "0"b;

010472  aa  6 00277 4501 00	stz  	pr6|191		mask_str
						STATEMENT 1 ON LINE 2604
	call default_handler_$set (cond_hdlr);

010473  aa   004714 3520 04	epp2 	2508,ic		015407 = 000140627000
010474  aa  6 01014 2521 00	spri2	pr6|524		cp.789
010475  aa  6 01016 6521 00	spri6	pr6|526		cp.789
010476  aa  6 01014 3521 00	epp2 	pr6|524		cp.789
010477  aa  6 01024 2521 00	spri2	pr6|532
010500  aa  6 01022 6211 00	eax1 	pr6|530
010501  aa   004000 4310 07	fld  	2048,dl
010502  aa  6 00044 3701 20	epp4 	pr6|36,*
010503  la  4 00162 3521 20	epp2 	pr4|114,*		default_handler_$set
010504  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2605
	call hcs_$set_ips_mask (mask_str, mask_str);

010505  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
010506  aa  6 01024 2521 00	spri2	pr6|532
010507  aa  6 01026 2521 00	spri2	pr6|534
010510  aa  6 01022 6211 00	eax1 	pr6|530
010511  aa   010000 4310 07	fld  	4096,dl
010512  aa  6 00044 3701 20	epp4 	pr6|36,*
010513  la  4 00156 3521 20	epp2 	pr4|110,*		hcs_$set_ips_mask
010514  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2607
	iocb_ptr -> attach_data_ptr = null;

010515  aa   770101 2370 04	ldaq 	-4031,ic		000616 = 077777000043 000001000000
010516  aa  6 00140 3735 20	epp7 	pr6|96,*		iocb_ptr
010517  aa  7 00016 7571 00	staq 	pr7|14		iocb.attach_data_ptr
						STATEMENT 1 ON LINE 2608
	iocb_ptr -> attach_descrip_ptr = null;

010520  aa  7 00014 7571 00	staq 	pr7|12		iocb.attach_descrip_ptr
						STATEMENT 1 ON LINE 2610
	iocb_ptr -> iocb.control,			/* reset control */
	     iocb_ptr -> iocb.modes = iox_$err_no_operation;

010521  aa  6 00044 3701 20	epp4 	pr6|36,*
010522  la  4 00106 3521 20	epp2 	pr4|70,*		iox_$err_no_operation
010523  aa  6 01014 2521 00	spri2	pr6|524		cp.423
010524  aa   007234 2370 04	ldaq 	3740,ic		017760 = 077777000043 000001000000
010525  aa  6 01016 7571 00	staq 	pr6|526		cp.423
010526  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.423
010527  aa  7 00066 2521 00	spri2	pr7|54		iocb.control
010530  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.423
010531  aa  7 00070 2521 00	spri2	pr7|56		iocb.control
010532  aa  6 01014 3521 20	epp2 	pr6|524,*		cp.423
010533  aa  7 00056 2521 00	spri2	pr7|46		iocb.modes
010534  aa  6 01016 3521 20	epp2 	pr6|526,*		cp.423
010535  aa  7 00060 2521 00	spri2	pr7|48		iocb.modes
						STATEMENT 1 ON LINE 2614
	call iox_$propagate (iocb_ptr);

010536  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
010537  aa  6 01016 2521 00	spri2	pr6|526
010540  aa  6 01014 6211 00	eax1 	pr6|524
010541  aa   004000 4310 07	fld  	2048,dl
010542  la  4 00126 3521 20	epp2 	pr4|86,*		iox_$propagate
010543  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2616
	call hcs_$reset_ips_mask (mask_str, mask_str);

010544  aa  6 00277 3521 00	epp2 	pr6|191		mask_str
010545  aa  6 01024 2521 00	spri2	pr6|532
010546  aa  6 01026 2521 00	spri2	pr6|534
010547  aa  6 01022 6211 00	eax1 	pr6|530
010550  aa   010000 4310 07	fld  	4096,dl
010551  aa  6 00044 3701 20	epp4 	pr6|36,*
010552  la  4 00160 3521 20	epp2 	pr4|112,*		hcs_$reset_ips_mask
010553  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2618
	if code ^= 0 then call error (code, "Problem in detaching.");

010554  aa  6 00157 2361 00	ldq  	pr6|111		code
010555  aa   000023 6000 04	tze  	19,ic		010600
010556  aa   770272 2370 04	ldaq 	-3910,ic		001050 = 120162157142 154145155040
010557  aa  6 01022 7571 00	staq 	pr6|530
010560  aa   770272 2370 04	ldaq 	-3910,ic		001052 = 151156040144 145164141143
010561  aa  6 01024 7571 00	staq 	pr6|532
010562  aa   770272 2370 04	ldaq 	-3910,ic		001054 = 150151156147 056000000000
010563  aa  6 01026 7571 00	staq 	pr6|534
010564  aa  6 00157 3521 00	epp2 	pr6|111		code
010565  aa  6 01074 2521 00	spri2	pr6|572
010566  aa  6 01022 3521 00	epp2 	pr6|530
010567  aa  6 01076 2521 00	spri2	pr6|574
010570  aa   767730 3520 04	epp2 	-4136,ic		000520 = 404000000043
010571  aa  6 01102 2521 00	spri2	pr6|578
010572  aa   767655 3520 04	epp2 	-4179,ic		000447 = 524000000025
010573  aa  6 01104 2521 00	spri2	pr6|580
010574  aa  6 01072 6211 00	eax1 	pr6|570
010575  aa   010000 4310 07	fld  	4096,dl
010576  aa   003753 3520 04	epp2 	2027,ic		014551 = 000160627000
010577  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2621
	a_code = 0;

010600  aa  6 00344 4501 20	stz  	pr6|228,*		a_code
						STATEMENT 1 ON LINE 2622
	return;

010601  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 3065
     end rdisk_;

BEGIN PROCEDURE parse_attach_options
ENTRY TO parse_attach_options                               STATEMENT 1 ON LINE 712
parse_attach_options:
     proc;

010602  aa  6 00360 6501 00	spri4	pr6|240
						STATEMENT 1 ON LINE 736
	at_opt.err_sw = a_err_sw;

010603  aa  6 00032 3735 20	epp7 	pr6|26,*
010604  aa  7 00006 2351 20	lda  	pr7|6,*		a_err_sw
010605  aa  6 00367 6751 00	era  	pr6|247		at_opt.err_sw
010606  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
010607  aa  6 00367 6551 00	ersa 	pr6|247		at_opt.err_sw
						STATEMENT 1 ON LINE 737
	at_opt.write_sw, at_opt.sys_sw, at_opt.compare_sw = "0"b;

010610  aa   007160 2350 04	lda  	3696,ic		017770 = 577777777777
010611  aa  6 00367 3551 00	ansa 	pr6|247		at_opt.write_sw
010612  aa   007052 2350 04	lda  	3626,ic		017664 = 773777777777
010613  aa  6 00367 3551 00	ansa 	pr6|247		at_opt.sys_sw
010614  aa   007064 2350 04	lda  	3636,ic		017700 = 677777777777
010615  aa  6 00367 3551 00	ansa 	pr6|247		at_opt.compare_sw
						STATEMENT 1 ON LINE 739
	at_opt.pack_id = " ";

010616  aa  040 100 100 400	mlr  	(),(pr),fill(040)
010617  aa   000000 00 0000	desc9a	0,0
010620  aa  6 00367 20 0040	desc9a	pr6|247(1),32	at_opt.pack_id
						STATEMENT 1 ON LINE 740
	at_opt.sze = 0;

010621  aa  6 00366 4501 00	stz  	pr6|246		at_opt.sze
						STATEMENT 1 ON LINE 741
	drive = NOT_SET;

010622  aa   000001 3360 07	lcq  	1,dl
010623  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
010624  aa  5 00076 7561 00	stq  	pr5|62		disk_data.drive
						STATEMENT 1 ON LINE 742
	drive_name = "";

010625  aa   767767 2370 04	ldaq 	-4105,ic		000614 = 040040040040 040040040040
010626  aa  6 00302 7571 00	staq 	pr6|194		drive_name
						STATEMENT 1 ON LINE 743
	model_number = 0;

010627  aa  6 00304 4501 00	stz  	pr6|196		model_number
						STATEMENT 1 ON LINE 745
	at_opt.is_sv = "0"b;

010630  aa  6 00401 4501 00	stz  	pr6|257		at_opt.is_sv
						STATEMENT 1 ON LINE 746
	at_opt.sv_num = -1;

010631  aa   000001 3360 07	lcq  	1,dl
010632  aa  6 00402 7561 00	stq  	pr6|258		at_opt.sv_num
						STATEMENT 1 ON LINE 747
	num_opts = hbound (options, 1);

010633  aa  6 00042 3535 20	epp3 	pr6|34,*
010634  aa  3 00002 3515 20	epp1 	pr3|2,*
010635  aa  1 00002 2361 00	ldq  	pr1|2
010636  aa  6 00174 7561 00	stq  	pr6|124		num_opts
						STATEMENT 1 ON LINE 749
	if num_opts >= 2
	     then do;

010637  aa   000002 1160 07	cmpq 	2,dl
010640  aa   000025 6040 04	tmi  	21,ic		010665
						STATEMENT 1 ON LINE 751
		dev_id = options (1);

010641  aa  1 00003 2361 00	ldq  	pr1|3
010642  aa  1 00001 4021 00	mpy  	pr1|1
010643  aa  6 01112 7561 00	stq  	pr6|586
010644  aa  1 00003 2361 00	ldq  	pr1|3
010645  aa  6 01112 1761 00	sbq  	pr6|586
010646  aa  7 00004 3515 66	epp1 	pr7|4,*ql		options
010647  aa  1 77777 2351 00	lda  	pr1|-1		options
010650  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
010651  aa  1 00000 00 0005	desc9a	pr1|0,al		options
010652  aa  6 00212 00 0004	desc9a	pr6|138,4		dev_id
						STATEMENT 1 ON LINE 752
		at_opt.pack_id = options (2);

010653  aa  3 00002 3515 20	epp1 	pr3|2,*
010654  aa  1 00003 2361 00	ldq  	pr1|3
010655  aa   000001 7360 00	qls  	1
010656  aa  6 01112 1761 00	sbq  	pr6|586
010657  aa  7 00004 3515 66	epp1 	pr7|4,*ql		options
010660  aa  1 77777 2351 00	lda  	pr1|-1		options
010661  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
010662  aa  1 00000 00 0005	desc9a	pr1|0,al		options
010663  aa  6 00367 20 0040	desc9a	pr6|247(1),32	at_opt.pack_id
						STATEMENT 1 ON LINE 753
	     end;

010664  aa   000010 7100 04	tra  	8,ic		010674
						STATEMENT 1 ON LINE 754
	     else call att_err (error_table_$noarg);

010665  aa  6 00044 3701 20	epp4 	pr6|36,*
010666  la  4 00056 3521 20	epp2 	pr4|46,*		error_table_$noarg
010667  aa  6 01116 2521 00	spri2	pr6|590
010670  aa  6 01114 3521 00	epp2 	pr6|588
010671  aa   004000 4310 07	fld  	2048,dl
010672  aa  2 00000 7571 00	staq 	pr2|0
010673  aa   001127 6700 04	tsp4 	599,ic		012022
						STATEMENT 1 ON LINE 756
	if dev_id = "d191" | dev_id = "D191" then dev_id = "d400";

010674  aa  6 00212 2351 00	lda  	pr6|138		dev_id
010675  aa   767551 1150 04	cmpa 	-4247,ic		000446 = 144061071061
010676  aa   000003 6000 04	tze  	3,ic		010701
010677  aa   767546 1150 04	cmpa 	-4250,ic		000445 = 104061071061
010700  aa   000003 6010 04	tnz  	3,ic		010703
010701  aa   767543 2350 04	lda  	-4253,ic		000444 = 144064060060
010702  aa  6 00212 7551 00	sta  	pr6|138		dev_id
						STATEMENT 1 ON LINE 759
	if dev_id = "d450" then dev_id = "d451";

010703  aa   767540 1150 04	cmpa 	-4256,ic		000443 = 144064065060
010704  aa   000003 6010 04	tnz  	3,ic		010707
010705  aa   767535 2350 04	lda  	-4259,ic		000442 = 144064065061
010706  aa  6 00212 7551 00	sta  	pr6|138		dev_id
						STATEMENT 1 ON LINE 761
	if dev_id = "m400" then dev_id = "d400";

010707  aa   767532 1150 04	cmpa 	-4262,ic		000441 = 155064060060
010710  aa   000004 6010 04	tnz  	4,ic		010714
010711  aa   767533 2350 04	lda  	-4261,ic		000444 = 144064060060
010712  aa  6 00212 7551 00	sta  	pr6|138		dev_id
010713  aa   000005 7100 04	tra  	5,ic		010720
						STATEMENT 1 ON LINE 762
	else if dev_id = "m451" then dev_id = "d451";

010714  aa   767524 1150 04	cmpa 	-4268,ic		000440 = 155064065061
010715  aa   000003 6010 04	tnz  	3,ic		010720
010716  aa   767524 2350 04	lda  	-4268,ic		000442 = 144064065061
010717  aa  6 00212 7551 00	sta  	pr6|138		dev_id
						STATEMENT 1 ON LINE 764
	at_opt.dev_type = 0;

010720  aa  6 00400 4501 00	stz  	pr6|256		at_opt.dev_type
						STATEMENT 1 ON LINE 765
	do i = 1 to maxdevt while (at_opt.dev_type = 0);

010721  aa   000011 2360 07	ldq  	9,dl
010722  aa  6 00405 7561 00	stq  	pr6|261
010723  aa   000001 2360 07	ldq  	1,dl
010724  aa  6 00172 7561 00	stq  	pr6|122		i
010725  aa   000000 0110 03	nop  	0,du
010726  aa  6 00172 2361 00	ldq  	pr6|122		i
010727  aa  6 00405 1161 00	cmpq 	pr6|261
010730  aa   000013 6054 04	tpnz 	11,ic		010743
010731  aa  6 00400 2361 00	ldq  	pr6|256		at_opt.dev_type
010732  aa   000011 6010 04	tnz  	9,ic		010743
						STATEMENT 1 ON LINE 766
	     if dev_id = device_names (i) then at_opt.dev_type = i;

010733  aa  6 00212 2351 00	lda  	pr6|138		dev_id
010734  aa  6 00172 7271 00	lxl7 	pr6|122		i
010735  ta   000311 1150 17	cmpa 	201,7
010736  aa   000003 6010 04	tnz  	3,ic		010741
010737  aa  6 00172 2361 00	ldq  	pr6|122		i
010740  aa  6 00400 7561 00	stq  	pr6|256		at_opt.dev_type
						STATEMENT 1 ON LINE 768
	     end;

010741  aa  6 00172 0541 00	aos  	pr6|122		i
010742  aa   777764 7100 04	tra  	-12,ic		010726
						STATEMENT 1 ON LINE 770
	do i = 3 to num_opts;

010743  aa  6 00174 2361 00	ldq  	pr6|124		num_opts
010744  aa  6 00406 7561 00	stq  	pr6|262
010745  aa   000003 2360 07	ldq  	3,dl
010746  aa  6 00172 7561 00	stq  	pr6|122		i
010747  aa   000000 0110 03	nop  	0,du
010750  aa  6 00172 2361 00	ldq  	pr6|122		i
010751  aa  6 00406 1161 00	cmpq 	pr6|262
010752  aa   000537 6054 04	tpnz 	351,ic		011511
						STATEMENT 1 ON LINE 772
	     if options (i) = "-write" then at_opt.write_sw = "1"b;

010753  aa  6 00042 3735 20	epp7 	pr6|34,*
010754  aa  7 00002 3715 20	epp5 	pr7|2,*
010755  aa  5 00003 2361 00	ldq  	pr5|3
010756  aa  5 00001 4021 00	mpy  	pr5|1
010757  aa  6 01113 7561 00	stq  	pr6|587
010760  aa  5 00003 2361 00	ldq  	pr5|3
010761  aa  6 00172 4021 00	mpy  	pr6|122		i
010762  aa  6 01113 1761 00	sbq  	pr6|587
010763  aa  6 01113 7561 00	stq  	pr6|587
010764  aa  6 00032 3535 20	epp3 	pr6|26,*
010765  aa  3 00004 3515 66	epp1 	pr3|4,*ql		options
010766  aa  1 77777 2351 00	lda  	pr1|-1		options
010767  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
010770  aa  1 00000 00 0005	desc9a	pr1|0,al		options
010771  aa   767563 00 0006	desc9a	-4237,6		000552 = 055167162151
010772  aa   000004 6010 04	tnz  	4,ic		010776
010773  aa   200000 2350 03	lda  	65536,du
010774  aa  6 00367 2551 00	orsa 	pr6|247		at_opt.write_sw
010775  aa   000512 7100 04	tra  	330,ic		011507
						STATEMENT 1 ON LINE 774
	     else if options (i) = "-size"
		then do;

010776  aa  1 77777 2351 00	lda  	pr1|-1		options
010777  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011000  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011001  aa   767551 00 0005	desc9a	-4247,5		000550 = 055163151172
011002  aa   000115 6010 04	tnz  	77,ic		011117
						STATEMENT 1 ON LINE 776
		     if i >= num_opts then call att_err (error_table_$noarg);

011003  aa  6 00172 2361 00	ldq  	pr6|122		i
011004  aa  6 00174 1161 00	cmpq 	pr6|124		num_opts
011005  aa   000010 6040 04	tmi  	8,ic		011015
011006  aa  6 00044 3701 20	epp4 	pr6|36,*
011007  la  4 00056 3521 20	epp2 	pr4|46,*		error_table_$noarg
011010  aa  6 01116 2521 00	spri2	pr6|590
011011  aa  6 01114 3521 00	epp2 	pr6|588
011012  aa   004000 4310 07	fld  	2048,dl
011013  aa  2 00000 7571 00	staq 	pr2|0
011014  aa   001006 6700 04	tsp4 	518,ic		012022
						STATEMENT 1 ON LINE 778
		     i = i + 1;

011015  aa  6 00172 0541 00	aos  	pr6|122		i
						STATEMENT 1 ON LINE 779
		     at_opt.sze = cv_dec_check_ ((options (i)), code);

011016  aa  6 00042 3735 20	epp7 	pr6|34,*
011017  aa  7 00002 3715 20	epp5 	pr7|2,*
011020  aa  5 00003 2361 00	ldq  	pr5|3
011021  aa  5 00001 4021 00	mpy  	pr5|1
011022  aa  6 01122 7561 00	stq  	pr6|594
011023  aa  5 00003 2361 00	ldq  	pr5|3
011024  aa  6 00172 4021 00	mpy  	pr6|122		i
011025  aa  6 01122 1761 00	sbq  	pr6|594
011026  aa  6 00032 3535 20	epp3 	pr6|26,*
011027  aa  3 00004 3515 20	epp1 	pr3|4,*
011030  aa   000000 6270 06	eax7 	0,ql
011031  aa  1 77777 2361 06	ldq  	pr1|-1,ql		options
011032  aa   524000 2760 03	orq  	174080,du
011033  aa  6 01112 7561 00	stq  	pr6|586
011034  aa  1 77777 2361 17	ldq  	pr1|-1,7		options
011035  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
011036  aa  6 01130 2521 00	spri2	pr6|600
011037  aa  3 00004 3715 77	epp5 	pr3|4,*7		options
011040  aa  5 77777 2351 00	lda  	pr5|-1		options
011041  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
011042  aa  5 00000 00 0005	desc9a	pr5|0,al		options
011043  aa  2 00000 00 0006	desc9a	pr2|0,ql
011044  aa  6 00157 3521 00	epp2 	pr6|111		code
011045  aa  6 01132 2521 00	spri2	pr6|602
011046  aa  6 00366 3521 00	epp2 	pr6|246		at_opt.sze
011047  aa  6 01134 2521 00	spri2	pr6|604
011050  aa  6 01112 3521 00	epp2 	pr6|586
011051  aa  6 01136 2521 00	spri2	pr6|606
011052  aa   767446 3520 04	epp2 	-4314,ic		000520 = 404000000043
011053  aa  6 01140 2521 00	spri2	pr6|608
011054  aa  6 01142 2521 00	spri2	pr6|610
011055  aa  6 01126 6211 00	eax1 	pr6|598
011056  aa   014000 4310 07	fld  	6144,dl
011057  aa  6 00044 3701 20	epp4 	pr6|36,*
011060  la  4 00132 3521 20	epp2 	pr4|90,*		cv_dec_check_
011061  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 781
		     if code ^= 0 then call att_err (error_table_$bad_conversion);

011062  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
011063  aa  6 00157 2361 00	ldq  	pr6|111		code
011064  aa   000010 6000 04	tze  	8,ic		011074
011065  aa  6 00044 3701 20	epp4 	pr6|36,*
011066  la  4 00026 3521 20	epp2 	pr4|22,*		error_table_$bad_conversion
011067  aa  6 01116 2521 00	spri2	pr6|590
011070  aa  6 01114 3521 00	epp2 	pr6|588
011071  aa   004000 4310 07	fld  	2048,dl
011072  aa  2 00000 7571 00	staq 	pr2|0
011073  aa   000727 6700 04	tsp4 	471,ic		012022
						STATEMENT 1 ON LINE 783
		     if at_opt.sze <= 0
			then call error (error_table_$bad_arg, "Value of size option must be positive.");

011074  aa  6 00366 2361 00	ldq  	pr6|246		at_opt.sze
011075  aa   000412 6054 04	tpnz 	266,ic		011507
011076  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
011077  aa   770152 00 0050	desc9a	-3990,40		001250 = 126141154165
011100  aa  6 01126 00 0050	desc9a	pr6|598,40
011101  aa  6 00044 3701 20	epp4 	pr6|36,*
011102  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$bad_arg
011103  aa  6 01146 2521 00	spri2	pr6|614
011104  aa  6 01126 3521 00	epp2 	pr6|598
011105  aa  6 01150 2521 00	spri2	pr6|616
011106  aa   767412 3520 04	epp2 	-4342,ic		000520 = 404000000043
011107  aa  6 01154 2521 00	spri2	pr6|620
011110  aa   767327 3520 04	epp2 	-4393,ic		000437 = 524000000046
011111  aa  6 01156 2521 00	spri2	pr6|622
011112  aa  6 01144 6211 00	eax1 	pr6|612
011113  aa   010000 4310 07	fld  	4096,dl
011114  aa   003435 3520 04	epp2 	1821,ic		014551 = 000160627000
011115  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 785
		end;

011116  aa   000371 7100 04	tra  	249,ic		011507
						STATEMENT 1 ON LINE 787
	     else if options (i) = "-system" | options (i) = "-sys" | options (i) = "-priv"
						/* obsolete */
		then do;

011117  aa  1 77777 2351 00	lda  	pr1|-1		options
011120  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011121  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011122  aa   767426 00 0007	desc9a	-4330,7		000546 = 055163171163
011123  aa   000013 6000 04	tze  	11,ic		011136
011124  aa  1 77777 2351 00	lda  	pr1|-1		options
011125  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011126  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011127  aa   767421 00 0004	desc9a	-4335,4		000546 = 055163171163
011130  aa   000006 6000 04	tze  	6,ic		011136
011131  aa  1 77777 2351 00	lda  	pr1|-1		options
011132  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011133  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011134  aa   767412 00 0005	desc9a	-4342,5		000544 = 055160162151
011135  aa   000120 6010 04	tnz  	80,ic		011255
						STATEMENT 1 ON LINE 791
		     call hcs_$initiate (">system_library_1", "rcp_sys_", "", 0, 0, rs_ptr, code);

011136  aa   767616 2370 04	ldaq 	-4210,ic		000754 = 076163171163 164145155137
011137  aa  6 01114 7571 00	staq 	pr6|588
011140  aa   767616 2370 04	ldaq 	-4210,ic		000756 = 154151142162 141162171137
011141  aa  6 01116 7571 00	staq 	pr6|590
011142  aa   061000 2350 03	lda  	25088,du
011143  aa  6 01120 7551 00	sta  	pr6|592
011144  aa   767376 2370 04	ldaq 	-4354,ic		000542 = 162143160137 163171163137
011145  aa  6 01124 7571 00	staq 	pr6|596
011146  aa  6 01123 4501 00	stz  	pr6|595
011147  aa  6 01122 4501 00	stz  	pr6|594
011150  aa  6 01114 3521 00	epp2 	pr6|588
011151  aa  6 01162 2521 00	spri2	pr6|626
011152  aa  6 01124 3521 00	epp2 	pr6|596
011153  aa  6 01164 2521 00	spri2	pr6|628
011154  aa  6 01112 3521 00	epp2 	pr6|586
011155  aa  6 01166 2521 00	spri2	pr6|630
011156  aa  6 01123 3521 00	epp2 	pr6|595
011157  aa  6 01170 2521 00	spri2	pr6|632
011160  aa  6 01122 3521 00	epp2 	pr6|594
011161  aa  6 01172 2521 00	spri2	pr6|634
011162  aa  6 00150 3521 00	epp2 	pr6|104		rs_ptr
011163  aa  6 01174 2521 00	spri2	pr6|636
011164  aa  6 00157 3521 00	epp2 	pr6|111		code
011165  aa  6 01176 2521 00	spri2	pr6|638
011166  aa   767250 3520 04	epp2 	-4440,ic		000436 = 524000000021
011167  aa  6 01200 2521 00	spri2	pr6|640
011170  aa   767245 3520 04	epp2 	-4443,ic		000435 = 524000000010
011171  aa  6 01202 2521 00	spri2	pr6|642
011172  aa   767316 3520 04	epp2 	-4402,ic		000510 = 524000000000
011173  aa  6 01204 2521 00	spri2	pr6|644
011174  aa   767240 3520 04	epp2 	-4448,ic		000434 = 404000000001
011175  aa  6 01206 2521 00	spri2	pr6|646
011176  aa   767235 3520 04	epp2 	-4451,ic		000433 = 404000000002
011177  aa  6 01210 2521 00	spri2	pr6|648
011200  aa   767321 3520 04	epp2 	-4399,ic		000521 = 464000000000
011201  aa  6 01212 2521 00	spri2	pr6|650
011202  aa   767316 3520 04	epp2 	-4402,ic		000520 = 404000000043
011203  aa  6 01214 2521 00	spri2	pr6|652
011204  aa  6 01160 6211 00	eax1 	pr6|624
011205  aa   034000 4310 07	fld  	14336,dl
011206  aa  6 00044 3701 20	epp4 	pr6|36,*
011207  la  4 00152 3521 20	epp2 	pr4|106,*		hcs_$initiate
011210  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 793
		     if rs_ptr ^= null
			then do;

011211  aa  6 00150 2371 00	ldaq 	pr6|104		rs_ptr
011212  aa   767404 6770 04	eraq 	-4348,ic		000616 = 077777000043 000001000000
011213  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011214  aa   000026 6000 04	tze  	22,ic		011242
						STATEMENT 1 ON LINE 795
			     call hcs_$fs_get_mode (rs_ptr, rs_mode, code);

011215  aa  6 00150 3521 00	epp2 	pr6|104		rs_ptr
011216  aa  6 01146 2521 00	spri2	pr6|614
011217  aa  6 00213 3521 00	epp2 	pr6|139		rs_mode
011220  aa  6 01150 2521 00	spri2	pr6|616
011221  aa  6 00157 3521 00	epp2 	pr6|111		code
011222  aa  6 01152 2521 00	spri2	pr6|618
011223  aa  6 01144 6211 00	eax1 	pr6|612
011224  aa   014000 4310 07	fld  	6144,dl
011225  aa  6 00044 3701 20	epp4 	pr6|36,*
011226  la  4 00154 3521 20	epp2 	pr4|108,*		hcs_$fs_get_mode
011227  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 797
			     if code = 0
				then if bit (rs_mode) & EXEC then at_opt.sys_sw = "1"b;

011230  aa  6 00157 2361 00	ldq  	pr6|111		code
011231  aa   000011 6010 04	tnz  	9,ic		011242
011232  aa  6 00213 2351 00	lda  	pr6|139		rs_mode
011233  aa   000002 6050 04	tpl  	2,ic		011235
011234  aa   000000 5310 00	neg  	0
011235  aa   000037 7350 00	als  	31
011236  aa   100000 3150 03	cana 	32768,du
011237  aa   000003 6000 04	tze  	3,ic		011242
011240  aa   004000 2350 03	lda  	2048,du
011241  aa  6 00367 2551 00	orsa 	pr6|247		at_opt.sys_sw
						STATEMENT 1 ON LINE 800
			end;

						STATEMENT 1 ON LINE 801
		     if ^at_opt.sys_sw then call att_err (error_table_$user_not_found);

011242  aa  6 00367 2351 00	lda  	pr6|247		at_opt.sys_sw
011243  aa   004000 3150 03	cana 	2048,du
011244  aa   000243 6010 04	tnz  	163,ic		011507
011245  aa  6 00044 3701 20	epp4 	pr6|36,*
011246  la  4 00076 3521 20	epp2 	pr4|62,*		error_table_$user_not_found
011247  aa  6 01116 2521 00	spri2	pr6|590
011250  aa  6 01114 3521 00	epp2 	pr6|588
011251  aa   004000 4310 07	fld  	2048,dl
011252  aa  2 00000 7571 00	staq 	pr2|0
011253  aa   000547 6700 04	tsp4 	359,ic		012022
						STATEMENT 1 ON LINE 803
		end;

011254  aa   000233 7100 04	tra  	155,ic		011507
						STATEMENT 1 ON LINE 805
	     else if options (i) = "-device" | options (i) = "-dv"
		then do;

011255  aa  1 77777 2351 00	lda  	pr1|-1		options
011256  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011257  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011260  aa   767262 00 0007	desc9a	-4430,7		000540 = 055144145166
011261  aa   000006 6000 04	tze  	6,ic		011267
011262  aa  1 77777 2351 00	lda  	pr1|-1		options
011263  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011264  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011265  aa   767147 00 0003	desc9a	-4505,3		000432 = 055144166000
011266  aa   000055 6010 04	tnz  	45,ic		011343
						STATEMENT 1 ON LINE 807
		     if i >= num_opts then call att_err (error_table_$noarg);

011267  aa  6 00172 2361 00	ldq  	pr6|122		i
011270  aa  6 00174 1161 00	cmpq 	pr6|124		num_opts
011271  aa   000010 6040 04	tmi  	8,ic		011301
011272  aa  6 00044 3701 20	epp4 	pr6|36,*
011273  la  4 00056 3521 20	epp2 	pr4|46,*		error_table_$noarg
011274  aa  6 01116 2521 00	spri2	pr6|590
011275  aa  6 01114 3521 00	epp2 	pr6|588
011276  aa   004000 4310 07	fld  	2048,dl
011277  aa  2 00000 7571 00	staq 	pr2|0
011300  aa   000522 6700 04	tsp4 	338,ic		012022
						STATEMENT 1 ON LINE 808
		     i = i + 1;

011301  aa  6 00172 0541 00	aos  	pr6|122		i
						STATEMENT 1 ON LINE 809
		     drive_name = options (i);

011302  aa  6 00042 3735 20	epp7 	pr6|34,*
011303  aa  7 00002 3715 20	epp5 	pr7|2,*
011304  aa  5 00003 2361 00	ldq  	pr5|3
011305  aa  5 00001 4021 00	mpy  	pr5|1
011306  aa  6 01122 7561 00	stq  	pr6|594
011307  aa  5 00003 2361 00	ldq  	pr5|3
011310  aa  6 00172 4021 00	mpy  	pr6|122		i
011311  aa  6 01122 1761 00	sbq  	pr6|594
011312  aa  6 00032 3535 20	epp3 	pr6|26,*
011313  aa  3 00004 3515 66	epp1 	pr3|4,*ql		options
011314  aa  1 77777 2351 00	lda  	pr1|-1		options
011315  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
011316  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011317  aa  6 00302 00 0010	desc9a	pr6|194,8		drive_name
						STATEMENT 1 ON LINE 810
		     if drive_name ^= options (i) then call att_err (error_table_$bad_arg);

011320  aa  1 77777 2351 00	lda  	pr1|-1		options
011321  aa  040 140 106 500	cmpc 	(pr),(pr,rl),fill(040)
011322  aa  6 00302 00 0010	desc9a	pr6|194,8		drive_name
011323  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011324  aa   000010 6000 04	tze  	8,ic		011334
011325  aa  6 00044 3701 20	epp4 	pr6|36,*
011326  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$bad_arg
011327  aa  6 01116 2521 00	spri2	pr6|590
011330  aa  6 01114 3521 00	epp2 	pr6|588
011331  aa   004000 4310 07	fld  	2048,dl
011332  aa  2 00000 7571 00	staq 	pr2|0
011333  aa   000467 6700 04	tsp4 	311,ic		012022
						STATEMENT 1 ON LINE 811
		     call check_dev (drive_name);

011334  aa   006324 3520 04	epp2 	3284,ic		017660 = 000002000000
011335  aa   000362 6700 04	tsp4 	242,ic		011717
						STATEMENT 1 ON LINE 812
		     if code ^= 0 then call att_err (code);

011336  aa  6 00157 2361 00	ldq  	pr6|111		code
011337  aa   000150 6000 04	tze  	104,ic		011507
011340  aa   006424 3520 04	epp2 	3348,ic		017764 = 000002000000
011341  aa   000461 6700 04	tsp4 	305,ic		012022
						STATEMENT 1 ON LINE 814
		end;

011342  aa   000145 7100 04	tra  	101,ic		011507
						STATEMENT 1 ON LINE 816
	     else if options (i) = "-model"
		then do;

011343  aa  1 77777 2351 00	lda  	pr1|-1		options
011344  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
011345  aa  1 00000 00 0005	desc9a	pr1|0,al		options
011346  aa   767172 00 0006	desc9a	-4486,6		000536 = 055155157144
011347  aa   000131 6010 04	tnz  	89,ic		011500
						STATEMENT 1 ON LINE 818
		     if i >= num_opts then call att_err (error_table_$noarg);

011350  aa  6 00172 2361 00	ldq  	pr6|122		i
011351  aa  6 00174 1161 00	cmpq 	pr6|124		num_opts
011352  aa   000010 6040 04	tmi  	8,ic		011362
011353  aa  6 00044 3701 20	epp4 	pr6|36,*
011354  la  4 00056 3521 20	epp2 	pr4|46,*		error_table_$noarg
011355  aa  6 01116 2521 00	spri2	pr6|590
011356  aa  6 01114 3521 00	epp2 	pr6|588
011357  aa   004000 4310 07	fld  	2048,dl
011360  aa  2 00000 7571 00	staq 	pr2|0
011361  aa   000441 6700 04	tsp4 	289,ic		012022
						STATEMENT 1 ON LINE 819
		     i = i + 1;

011362  aa  6 00172 0541 00	aos  	pr6|122		i
						STATEMENT 1 ON LINE 820
		     model_number = cv_dec_check_ ((options (i)), code);

011363  aa  6 00042 3735 20	epp7 	pr6|34,*
011364  aa  7 00002 3715 20	epp5 	pr7|2,*
011365  aa  5 00003 2361 00	ldq  	pr5|3
011366  aa  5 00001 4021 00	mpy  	pr5|1
011367  aa  6 01122 7561 00	stq  	pr6|594
011370  aa  5 00003 2361 00	ldq  	pr5|3
011371  aa  6 00172 4021 00	mpy  	pr6|122		i
011372  aa  6 01122 1761 00	sbq  	pr6|594
011373  aa  6 00032 3535 20	epp3 	pr6|26,*
011374  aa  3 00004 3515 20	epp1 	pr3|4,*
011375  aa   000000 6270 06	eax7 	0,ql
011376  aa  1 77777 2361 06	ldq  	pr1|-1,ql		options
011377  aa   524000 2760 03	orq  	174080,du
011400  aa  6 01113 7561 00	stq  	pr6|587
011401  aa  1 77777 2361 17	ldq  	pr1|-1,7		options
011402  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
011403  aa  6 01130 2521 00	spri2	pr6|600
011404  aa  3 00004 3715 77	epp5 	pr3|4,*7		options
011405  aa  5 77777 2351 00	lda  	pr5|-1		options
011406  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
011407  aa  5 00000 00 0005	desc9a	pr5|0,al		options
011410  aa  2 00000 00 0006	desc9a	pr2|0,ql
011411  aa  6 00157 3521 00	epp2 	pr6|111		code
011412  aa  6 01132 2521 00	spri2	pr6|602
011413  aa  6 01122 3521 00	epp2 	pr6|594
011414  aa  6 01134 2521 00	spri2	pr6|604
011415  aa  6 01113 3521 00	epp2 	pr6|587
011416  aa  6 01136 2521 00	spri2	pr6|606
011417  aa   767101 3520 04	epp2 	-4543,ic		000520 = 404000000043
011420  aa  6 01140 2521 00	spri2	pr6|608
011421  aa  6 01142 2521 00	spri2	pr6|610
011422  aa  6 01126 6211 00	eax1 	pr6|598
011423  aa   014000 4310 07	fld  	6144,dl
011424  aa  6 00044 3701 20	epp4 	pr6|36,*
011425  la  4 00132 3521 20	epp2 	pr4|90,*		cv_dec_check_
011426  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
011427  aa  6 01122 2361 00	ldq  	pr6|594
011430  aa  6 00304 7561 00	stq  	pr6|196		model_number
						STATEMENT 1 ON LINE 821
		     if code ^= 0 then call att_err (error_table_$bad_conversion);

011431  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
011432  aa  6 00157 2361 00	ldq  	pr6|111		code
011433  aa   000010 6000 04	tze  	8,ic		011443
011434  aa  6 00044 3701 20	epp4 	pr6|36,*
011435  la  4 00026 3521 20	epp2 	pr4|22,*		error_table_$bad_conversion
011436  aa  6 01116 2521 00	spri2	pr6|590
011437  aa  6 01114 3521 00	epp2 	pr6|588
011440  aa   004000 4310 07	fld  	2048,dl
011441  aa  2 00000 7571 00	staq 	pr2|0
011442  aa   000360 6700 04	tsp4 	240,ic		012022
						STATEMENT 1 ON LINE 822
		     at_opt.dev_type = 0;

011443  aa  6 00400 4501 00	stz  	pr6|256		at_opt.dev_type
						STATEMENT 1 ON LINE 823
		     do j = 1 to hbound (MODEL, 1) while (at_opt.dev_type = 0);

011444  aa   000001 2360 07	ldq  	1,dl
011445  aa  6 00173 7561 00	stq  	pr6|123		j
011446  aa  6 00173 2361 00	ldq  	pr6|123		j
011447  aa   000014 1160 07	cmpq 	12,dl
011450  aa   000013 6054 04	tpnz 	11,ic		011463
011451  aa  6 00400 2361 00	ldq  	pr6|256		at_opt.dev_type
011452  aa   000011 6010 04	tnz  	9,ic		011463
						STATEMENT 1 ON LINE 824
			if model_number = MODEL (j) then at_opt.dev_type = MODELX (j);

011453  aa  6 00304 2361 00	ldq  	pr6|196		model_number
011454  aa  6 00173 7271 00	lxl7 	pr6|123		j
011455  ta   000347 1160 17	cmpq 	231,7
011456  aa   000003 6010 04	tnz  	3,ic		011461
011457  ta   000333 2360 17	ldq  	219,7
011460  aa  6 00400 7561 00	stq  	pr6|256		at_opt.dev_type
						STATEMENT 1 ON LINE 825
			end;

011461  aa  6 00173 0541 00	aos  	pr6|123		j
011462  aa   777764 7100 04	tra  	-12,ic		011446
						STATEMENT 1 ON LINE 826
		     if at_opt.dev_type = 0 then call att_err (error_table_$bad_arg);

011463  aa  6 00400 2361 00	ldq  	pr6|256		at_opt.dev_type
011464  aa   000010 6010 04	tnz  	8,ic		011474
011465  aa  6 00044 3701 20	epp4 	pr6|36,*
011466  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$bad_arg
011467  aa  6 01116 2521 00	spri2	pr6|590
011470  aa  6 01114 3521 00	epp2 	pr6|588
011471  aa   004000 4310 07	fld  	2048,dl
011472  aa  2 00000 7571 00	staq 	pr2|0
011473  aa   000327 6700 04	tsp4 	215,ic		012022
						STATEMENT 1 ON LINE 827
		     model_number = MODELN (at_opt.dev_type);

011474  aa  6 00400 7271 00	lxl7 	pr6|256		at_opt.dev_type
011475  ta   000322 2360 17	ldq  	210,7
011476  aa  6 00304 7561 00	stq  	pr6|196		model_number
						STATEMENT 1 ON LINE 828
		end;

011477  aa   000010 7100 04	tra  	8,ic		011507
						STATEMENT 1 ON LINE 830
	     else call att_err (error_table_$request_not_recognized);

011500  aa  6 00044 3701 20	epp4 	pr6|36,*
011501  la  4 00070 3521 20	epp2 	pr4|56,*		error_table_$request_not_recognized
011502  aa  6 01116 2521 00	spri2	pr6|590
011503  aa  6 01114 3521 00	epp2 	pr6|588
011504  aa   004000 4310 07	fld  	2048,dl
011505  aa  2 00000 7571 00	staq 	pr2|0
011506  aa   000314 6700 04	tsp4 	204,ic		012022
						STATEMENT 1 ON LINE 833
	     end;

011507  aa  6 00172 0541 00	aos  	pr6|122		i
011510  aa   777240 7100 04	tra  	-352,ic		010750
						STATEMENT 1 ON LINE 835
	found_dev_att = "0"b;

011511  aa  6 00330 4501 00	stz  	pr6|216		found_dev_att
						STATEMENT 1 ON LINE 837
	if drive_name ^= ""
	     then do;

011512  aa   000000 4310 07	fld  	0,dl
011513  aa  0 00440 2771 00	oraq 	pr0|288		= 040040040040 040040040040
011514  aa  6 00302 1171 00	cmpaq	pr6|194		drive_name
011515  aa   000123 6000 04	tze  	83,ic		011640
						STATEMENT 1 ON LINE 839
		do dv = 1 to attachments.number_used while (^found_dev_att);

011516  aa  6 00044 3701 20	epp4 	pr6|36,*
011517  ia  4 00010 3735 20	epp7 	pr4|8,*		attachments_ptr
011520  aa  7 00001 2361 00	ldq  	pr7|1		attachments.number_used
011521  aa  6 00407 7561 00	stq  	pr6|263
011522  aa   000001 2360 07	ldq  	1,dl
011523  aa  6 00403 7561 00	stq  	pr6|259		dv
011524  aa  6 00403 2361 00	ldq  	pr6|259		dv
011525  aa  6 00407 1161 00	cmpq 	pr6|263
011526  aa   000112 6054 04	tpnz 	74,ic		011640
011527  aa  6 00330 2351 00	lda  	pr6|216		found_dev_att
011530  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
011531  aa   000107 6000 04	tze  	71,ic		011640
						STATEMENT 1 ON LINE 840
		     if attachments.device_att (dv) = substr (drive_name, 1, 7)
			then do;

011532  aa  6 01113 7551 00	sta  	pr6|587
011533  aa   000016 4020 07	mpy  	14,dl
011534  aa   000000 6270 06	eax7 	0,ql
011535  aa  6 00302 2371 00	ldaq 	pr6|194		drive_name
011536  aa  0 00176 3771 00	anaq 	pr0|126		= 777777777777 777777777000
011537  aa  0 00456 2771 00	oraq 	pr0|302		= 000000000000 000000000040
011540  aa  6 00044 3701 20	epp4 	pr6|36,*
011541  ia  4 00010 3735 20	epp7 	pr4|8,*		attachments_ptr
011542  aa  7 77764 1151 17	cmpa 	pr7|-12,7		attachments.device_att
011543  aa   000002 6010 04	tnz  	2,ic		011545
011544  aa  7 77765 1161 17	cmpq 	pr7|-11,7		attachments.device_att
011545  aa   000071 6010 04	tnz  	57,ic		011636
						STATEMENT 1 ON LINE 842
			     if ^found_dev_att
				then do;

011546  aa  6 01113 2351 00	lda  	pr6|587
011547  aa   000067 6000 04	tze  	55,ic		011636
						STATEMENT 1 ON LINE 844
				     found_dev_att = "1"b;

011550  aa   400000 2350 03	lda  	131072,du
011551  aa  6 00330 7551 00	sta  	pr6|216		found_dev_att
						STATEMENT 1 ON LINE 846
				     if at_opt.sv_num = -1 then call att_err (error_table_$resource_assigned);

011552  aa  6 00402 2361 00	ldq  	pr6|258		at_opt.sv_num
011553  aa   006216 1160 04	cmpq 	3214,ic		017771 = 777777777777
011554  aa   000007 6010 04	tnz  	7,ic		011563
011555  la  4 00072 3521 20	epp2 	pr4|58,*		error_table_$resource_assigned
011556  aa  6 01116 2521 00	spri2	pr6|590
011557  aa  6 01114 3521 00	epp2 	pr6|588
011560  aa   004000 4310 07	fld  	2048,dl
011561  aa  2 00000 7571 00	staq 	pr2|0
011562  aa   000240 6700 04	tsp4 	160,ic		012022
						STATEMENT 1 ON LINE 848
				     do sv = 1 to 3;

011563  aa   000001 2360 07	ldq  	1,dl
011564  aa  6 00404 7561 00	stq  	pr6|260		sv
011565  aa   000000 0110 03	nop  	0,du
011566  aa  6 00404 2361 00	ldq  	pr6|260		sv
011567  aa   000003 1160 07	cmpq 	3,dl
011570  aa   000046 6054 04	tpnz 	38,ic		011636
						STATEMENT 1 ON LINE 849
					if attachments.array (dv).this_iocbp (sv) ^= null
					     then do;

011571  aa  6 00403 2361 00	ldq  	pr6|259		dv
011572  aa   000016 4020 07	mpy  	14,dl
011573  aa  6 01113 7561 00	stq  	pr6|587
011574  aa  6 00404 2361 00	ldq  	pr6|260		sv
011575  aa   000002 7360 00	qls  	2
011576  aa  6 01113 0761 00	adq  	pr6|587
011577  aa  6 00044 3701 20	epp4 	pr6|36,*
011600  ia  4 00010 3735 20	epp7 	pr4|8,*		attachments_ptr
011601  aa  6 01113 7561 00	stq  	pr6|587
011602  aa  7 77764 2371 06	ldaq 	pr7|-12,ql	attachments.this_iocbp
011603  aa   767013 6770 04	eraq 	-4597,ic		000616 = 077777000043 000001000000
011604  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011605  aa   000027 6000 04	tze  	23,ic		011634
						STATEMENT 1 ON LINE 851
						if attachments.array (dv).this_sv (sv) = -1
						     | at_opt.sv_num = attachments.array (dv).this_sv (sv)
						     then call att_err (error_table_$resource_assigned);

011606  aa  6 01113 7271 00	lxl7 	pr6|587
011607  aa  7 77762 2361 17	ldq  	pr7|-14,7		attachments.this_sv
011610  aa   006161 1160 04	cmpq 	3185,ic		017771 = 777777777777
011611  aa   000003 6000 04	tze  	3,ic		011614
011612  aa  6 00402 1161 00	cmpq 	pr6|258		at_opt.sv_num
011613  aa   000007 6010 04	tnz  	7,ic		011622
011614  la  4 00072 3521 20	epp2 	pr4|58,*		error_table_$resource_assigned
011615  aa  6 01116 2521 00	spri2	pr6|590
011616  aa  6 01114 3521 00	epp2 	pr6|588
011617  aa   004000 4310 07	fld  	2048,dl
011620  aa  2 00000 7571 00	staq 	pr2|0
011621  aa   000201 6700 04	tsp4 	129,ic		012022
						STATEMENT 1 ON LINE 854
						pri_iocb_ptr = attachments.array (dv).this_iocbp (sv);

011622  aa  6 00403 2361 00	ldq  	pr6|259		dv
011623  aa   000016 4020 07	mpy  	14,dl
011624  aa  6 01113 7561 00	stq  	pr6|587
011625  aa  6 00404 2361 00	ldq  	pr6|260		sv
011626  aa   000002 7360 00	qls  	2
011627  aa  6 01113 0761 00	adq  	pr6|587
011630  aa  6 00044 3701 20	epp4 	pr6|36,*
011631  ia  4 00010 3735 20	epp7 	pr4|8,*		attachments_ptr
011632  aa  7 77764 3735 26	epp7 	pr7|-12,ql*	attachments.this_iocbp
011633  aa  6 00134 6535 00	spri7	pr6|92		pri_iocb_ptr
						STATEMENT 1 ON LINE 855
					     end;

						STATEMENT 1 ON LINE 856
					end;

011634  aa  6 00404 0541 00	aos  	pr6|260		sv
011635  aa   777731 7100 04	tra  	-39,ic		011566
						STATEMENT 1 ON LINE 857
				end;

						STATEMENT 1 ON LINE 858
			end;

						STATEMENT 1 ON LINE 859
		     end;

011636  aa  6 00403 0541 00	aos  	pr6|259		dv
011637  aa   777665 7100 04	tra  	-75,ic		011524
						STATEMENT 1 ON LINE 860
	     end;

						STATEMENT 1 ON LINE 862
	if found_dev_att then disk_data = pri_iocb_ptr -> attach_data_ptr -> disk_data;

011640  aa  6 00330 2351 00	lda  	pr6|216		found_dev_att
011641  aa   000007 6000 04	tze  	7,ic		011650
011642  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
011643  aa  6 00134 3715 20	epp5 	pr6|92,*		pri_iocb_ptr
011644  aa  5 00016 3535 20	epp3 	pr5|14,*		iocb.attach_data_ptr
011645  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
011646  aa  3 00000 00 0750	desc9a	pr3|0,488		disk_data
011647  aa  7 00000 00 0750	desc9a	pr7|0,488		disk_data
						STATEMENT 1 ON LINE 863
	disk_data.attach_data = at_opt, by name;

011650  aa  6 00366 2361 00	ldq  	pr6|246		at_opt.sze
011651  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
011652  aa  7 00054 7561 00	stq  	pr7|44		disk_data.sze
011653  aa  6 00367 2351 00	lda  	pr6|247		at_opt.err_sw
011654  aa  7 00055 6751 00	era  	pr7|45		disk_data.err_sw
011655  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
011656  aa  7 00055 6551 00	ersa 	pr7|45		disk_data.err_sw
011657  aa  6 00367 2351 00	lda  	pr6|247		at_opt.write_sw
011660  aa  7 00055 6751 00	era  	pr7|45		disk_data.write_sw
011661  aa   200000 3750 03	ana  	65536,du
011662  aa  7 00055 6551 00	ersa 	pr7|45		disk_data.write_sw
011663  aa  6 00367 2351 00	lda  	pr6|247		at_opt.compare_sw
011664  aa  7 00055 6751 00	era  	pr7|45		disk_data.compare_sw
011665  aa   100000 3750 03	ana  	32768,du
011666  aa  7 00055 6551 00	ersa 	pr7|45		disk_data.compare_sw
011667  aa  6 00367 2351 00	lda  	pr6|247		at_opt.raw_sw
011670  aa  7 00055 6751 00	era  	pr7|45		disk_data.raw_sw
011671  aa   040000 3750 03	ana  	16384,du
011672  aa  7 00055 6551 00	ersa 	pr7|45		disk_data.raw_sw
011673  aa  6 00367 2351 00	lda  	pr6|247		at_opt.alt_sw
011674  aa  7 00055 6751 00	era  	pr7|45		disk_data.alt_sw
011675  aa   020000 3750 03	ana  	8192,du
011676  aa  7 00055 6551 00	ersa 	pr7|45		disk_data.alt_sw
011677  aa  6 00367 2351 00	lda  	pr6|247		at_opt.label_sw
011700  aa  7 00055 6751 00	era  	pr7|45		disk_data.label_sw
011701  aa   010000 3750 03	ana  	4096,du
011702  aa  7 00055 6551 00	ersa 	pr7|45		disk_data.label_sw
011703  aa  6 00367 2351 00	lda  	pr6|247		at_opt.sys_sw
011704  aa  7 00055 7511 20	stca 	pr7|45,20		disk_data.sys_sw
011705  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
011706  aa  6 00367 20 0040	desc9a	pr6|247(1),32	at_opt.pack_id
011707  aa  7 00056 00 0040	desc9a	pr7|46,32		disk_data.pack_id
011710  aa  6 00400 2361 00	ldq  	pr6|256		at_opt.dev_type
011711  aa  7 00074 7561 00	stq  	pr7|60		disk_data.dev_type
011712  aa  6 00401 2351 00	lda  	pr6|257		at_opt.is_sv
011713  aa  7 00104 7551 00	sta  	pr7|68		disk_data.is_sv
011714  aa  6 00402 2361 00	ldq  	pr6|258		at_opt.sv_num
011715  aa  7 00105 7561 00	stq  	pr7|69		disk_data.sv_num
						STATEMENT 1 ON LINE 864
	return;

011716  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 900
     end parse_attach_options;

BEGIN PROCEDURE check_dev
ENTRY TO check_dev                                          STATEMENT 1 ON LINE 866
check_dev:
     proc (at_dev);

011717  aa  6 00410 6501 00	spri4	pr6|264
011720  aa  6 00412 2521 00	spri2	pr6|266
						STATEMENT 1 ON LINE 874
	at_dev_len = length (rtrim (at_dev));

011721  aa  2 00002 3735 20	epp7 	pr2|2,*
011722  aa  000 000 165 500	tctr 	(pr)
011723  aa  7 00000 00 0010	desc9a	pr7|0,8		at_dev
011724  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
011725  aa  6 00056 0001 00	arg  	pr6|46
011726  aa  6 00056 2361 00	ldq  	pr6|46
011727  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
011730  aa  6 01216 7561 00	stq  	pr6|654
011731  aa   000010 2360 07	ldq  	8,dl
011732  aa  6 01216 1761 00	sbq  	pr6|654
011733  aa  6 00416 7561 00	stq  	pr6|270		at_dev_len
						STATEMENT 1 ON LINE 875
	if at_dev_len < 7 then goto invalid_device;

011734  aa   000007 1160 07	cmpq 	7,dl
011735  aa   000061 6040 04	tmi  	49,ic		012016
						STATEMENT 1 ON LINE 877
	if substr (at_dev, 1, 3) ^= "dsk" | substr (at_dev, 5, 1) ^= "_" then goto invalid_device;

011736  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
011737  aa  7 00000 00 0003	desc9a	pr7|0,3		at_dev
011740  aa   766472 00 0003	desc9a	-4806,3		000430 = 144163153000
011741  aa   000055 6010 04	tnz  	45,ic		012016
011742  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
011743  aa  7 00001 00 0001	desc9a	pr7|1,1		at_dev
011744  aa   006033 00 0001	desc9a	3099,1		017775 = 137000000000
011745  aa   000051 6010 04	tnz  	41,ic		012016
						STATEMENT 1 ON LINE 879
	s_code = verify (substr (at_dev, 6, 2), "0123456789");

011746  aa  000 000 164 500	tct  	(pr)
011747  aa  7 00001 20 0002	desc9a	pr7|1(1),2	at_dev
011750  aa   005511 0000 04	arg  	2889,ic		017457 = 777777777777
011751  aa  6 00056 0001 00	arg  	pr6|46
011752  aa  6 00056 2361 00	ldq  	pr6|46
011753  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
011754  aa   000002 6070 04	ttf  	2,ic		011756
011755  aa   000001 3360 07	lcq  	1,dl
011756  aa   000001 0760 07	adq  	1,dl
011757  aa  6 00417 7561 00	stq  	pr6|271		s_code
						STATEMENT 1 ON LINE 880
	if s_code ^= 0 then goto invalid_device;

011760  aa   000036 6010 04	tnz  	30,ic		012016
						STATEMENT 1 ON LINE 882
	if at_dev_len = 8
	     then do;

011761  aa  6 00416 2361 00	ldq  	pr6|270		at_dev_len
011762  aa   000010 1160 07	cmpq 	8,dl
011763  aa   000026 6010 04	tnz  	22,ic		012011
						STATEMENT 1 ON LINE 884
		s_code = verify (substr (at_dev, 8, 1), valid_sv_string);

011764  aa  000 100 124 404	scm  	(ic),(pr),mask(000)
011765  aa   766313 00 0003	desc9a	-4917,3		000277 = 141142143000
011766  aa  7 00001 60 0001	desc9a	pr7|1(3),1	at_dev
011767  aa  6 00056 0001 00	arg  	pr6|46
011770  aa   000001 2360 07	ldq  	1,dl
011771  aa   000002 6064 04	ttn  	2,ic		011773
011772  aa   000000 2360 07	ldq  	0,dl
011773  aa  6 00417 7561 00	stq  	pr6|271		s_code
						STATEMENT 1 ON LINE 885
		if s_code ^= 0 then goto invalid_device;

011774  aa   000022 6010 04	tnz  	18,ic		012016
						STATEMENT 1 ON LINE 886
		at_opt.is_sv = "1"b;

011775  aa   400000 2350 03	lda  	131072,du
011776  aa  6 00401 7551 00	sta  	pr6|257		at_opt.is_sv
						STATEMENT 1 ON LINE 887
		at_opt.sv_num = (search (valid_sv_string, substr (at_dev, 8, 1))) - 1;

011777  aa   766300 3520 04	epp2 	-4928,ic		000277 = 141142143000
012000  aa   000003 2360 07	ldq  	3,dl
012001  aa   000003 7270 07	lxl7 	3,dl
012002  aa  7 00001 3515 00	epp1 	pr7|1		at_dev
012003  aa  1 00000 5005 17	a9bd 	pr1|0,7
012004  aa   000001 2350 07	lda  	1,dl
012005  aa  0 01245 7001 00	tsx0 	pr0|677		search_eis
012006  aa   000001 1760 07	sbq  	1,dl
012007  aa  6 00402 7561 00	stq  	pr6|258		at_opt.sv_num
						STATEMENT 1 ON LINE 888
	     end;

012010  aa   000004 7100 04	tra  	4,ic		012014
						STATEMENT 1 ON LINE 889
	     else do;

						STATEMENT 1 ON LINE 890
		at_opt.is_sv = "0"b;

012011  aa  6 00401 4501 00	stz  	pr6|257		at_opt.is_sv
						STATEMENT 1 ON LINE 891
		at_opt.sv_num = -1;

012012  aa   000001 3360 07	lcq  	1,dl
012013  aa  6 00402 7561 00	stq  	pr6|258		at_opt.sv_num
						STATEMENT 1 ON LINE 892
	     end;

						STATEMENT 1 ON LINE 893
	code = 0;

012014  aa  6 00157 4501 00	stz  	pr6|111		code
						STATEMENT 1 ON LINE 894
	return;

012015  aa  6 00410 6101 00	rtcd 	pr6|264
						STATEMENT 1 ON LINE 896
invalid_device:
	code = error_table_$invalid_device;

012016  aa  6 00044 3701 20	epp4 	pr6|36,*
012017  la  4 00042 2361 20	ldq  	pr4|34,*		error_table_$invalid_device
012020  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 898
     end check_dev;

012021  aa  6 00410 6101 00	rtcd 	pr6|264
  END PROCEDURE check_dev
  END PROCEDURE parse_attach_options
BEGIN PROCEDURE att_err
ENTRY TO att_err                                            STATEMENT 1 ON LINE 904
att_err:
     proc (b_code);

012022  aa  6 00420 6501 00	spri4	pr6|272
012023  aa  6 00422 2521 00	spri2	pr6|274
						STATEMENT 1 ON LINE 909
	c_code = b_code;

012024  aa  2 00002 2361 20	ldq  	pr2|2,*		b_code
012025  aa  6 00426 7561 00	stq  	pr6|278		c_code
						STATEMENT 1 ON LINE 910
	if err_sw then call sub_err_ (c_code, "rdisk_", "c", null, retval, "^a", iocb_ptr -> iocb.name);

012026  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012027  aa  7 00055 2351 00	lda  	pr7|45		disk_data.err_sw
012030  aa   400000 3150 03	cana 	131072,du
012031  aa   000052 6000 04	tze  	42,ic		012103
012032  aa   766502 2370 04	ldaq 	-4798,ic		000534 = 162144151163 153137000000
012033  aa  6 01220 7571 00	staq 	pr6|656
012034  aa   143000 2350 03	lda  	50688,du
012035  aa  6 01217 7551 00	sta  	pr6|655
012036  aa   766560 3714 24	epp5 	-4752,ic*
012037  aa  6 01222 6515 00	spri5	pr6|658
012040  aa   136141 2350 03	lda  	48225,du
012041  aa  6 01224 7551 00	sta  	pr6|660
012042  aa  6 00426 3521 00	epp2 	pr6|278		c_code
012043  aa  6 01230 2521 00	spri2	pr6|664
012044  aa  6 01220 3521 00	epp2 	pr6|656
012045  aa  6 01232 2521 00	spri2	pr6|666
012046  aa  6 01217 3521 00	epp2 	pr6|655
012047  aa  6 01234 2521 00	spri2	pr6|668
012050  aa  6 01222 3521 00	epp2 	pr6|658
012051  aa  6 01236 2521 00	spri2	pr6|670
012052  aa  6 00305 3521 00	epp2 	pr6|197		retval
012053  aa  6 01240 2521 00	spri2	pr6|672
012054  aa  6 01224 3521 00	epp2 	pr6|660
012055  aa  6 01242 2521 00	spri2	pr6|674
012056  aa  6 00140 3535 20	epp3 	pr6|96,*		iocb_ptr
012057  aa  3 00001 3521 00	epp2 	pr3|1		iocb.name
012060  aa  6 01244 2521 00	spri2	pr6|676
012061  aa   766437 3520 04	epp2 	-4833,ic		000520 = 404000000043
012062  aa  6 01246 2521 00	spri2	pr6|678
012063  aa  6 01256 2521 00	spri2	pr6|686
012064  aa   766421 3520 04	epp2 	-4847,ic		000505 = 524000000006
012065  aa  6 01250 2521 00	spri2	pr6|680
012066  aa   766341 3520 04	epp2 	-4895,ic		000427 = 524000000001
012067  aa  6 01252 2521 00	spri2	pr6|682
012070  aa   766431 3520 04	epp2 	-4839,ic		000521 = 464000000000
012071  aa  6 01254 2521 00	spri2	pr6|684
012072  aa   766334 3520 04	epp2 	-4900,ic		000426 = 524000000002
012073  aa  6 01260 2521 00	spri2	pr6|688
012074  aa   766362 3520 04	epp2 	-4878,ic		000456 = 524000000040
012075  aa  6 01262 2521 00	spri2	pr6|690
012076  aa  6 01226 6211 00	eax1 	pr6|662
012077  aa   034000 4310 07	fld  	14336,dl
012100  aa  6 00044 3701 20	epp4 	pr6|36,*
012101  la  4 00120 3521 20	epp2 	pr4|80,*		sub_err_
012102  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 911
	call hcs_$delentry_seg (disk_ptr, c_code);

012103  aa  6 00136 3521 00	epp2 	pr6|94		disk_ptr
012104  aa  6 01230 2521 00	spri2	pr6|664
012105  aa  6 00426 3521 00	epp2 	pr6|278		c_code
012106  aa  6 01232 2521 00	spri2	pr6|666
012107  aa  6 01226 6211 00	eax1 	pr6|662
012110  aa   010000 4310 07	fld  	4096,dl
012111  aa  6 00044 3701 20	epp4 	pr6|36,*
012112  la  4 00124 3521 20	epp2 	pr4|84,*		hcs_$delentry_seg
012113  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 912
	code = b_code;

012114  aa  6 00422 3735 20	epp7 	pr6|274,*
012115  aa  7 00002 2361 20	ldq  	pr7|2,*		b_code
012116  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 913
	go to exit;

012117  aa   771340 7100 04	tra  	-3360,ic		003457
						STATEMENT 1 ON LINE 915
     end att_err;

  END PROCEDURE att_err
BEGIN PROCEDURE io_err
ENTRY TO io_err                                             STATEMENT 1 ON LINE 1595
io_err:
     proc (clear_space);

012120  aa  6 00430 6501 00	spri4	pr6|280
012121  aa  6 00432 2521 00	spri2	pr6|282
						STATEMENT 1 ON LINE 1600
	if clear_space
	     then do;

012122  aa  2 00002 3735 20	epp7 	pr2|2,*
012123  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
012124  aa  7 00000 00 0001	descb	pr7|0,1		clear_space
012125  aa   000000 00 0000	descb	0,0
012126  aa   000007 6000 04	tze  	7,ic		012135
						STATEMENT 1 ON LINE 1602
		buf_ptr = null;

012127  aa   766467 2370 04	ldaq 	-4809,ic		000616 = 077777000043 000001000000
012130  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
012131  aa  5 00124 7571 00	staq 	pr5|84		disk_data.buf_ptr
						STATEMENT 1 ON LINE 1603
		buf_len, data_len = 0;

012132  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
012133  aa  5 00127 4501 00	stz  	pr5|87		disk_data.buf_len
012134  aa  5 00130 4501 00	stz  	pr5|88		disk_data.data_len
						STATEMENT 1 ON LINE 1604
	     end;

						STATEMENT 1 ON LINE 1606
	call error (code, "");

012135  aa  6 00157 3521 00	epp2 	pr6|111		code
012136  aa  6 01270 2521 00	spri2	pr6|696
012137  aa  6 01264 3521 00	epp2 	pr6|692
012140  aa  6 01272 2521 00	spri2	pr6|698
012141  aa   766357 3520 04	epp2 	-4881,ic		000520 = 404000000043
012142  aa  6 01276 2521 00	spri2	pr6|702
012143  aa   766345 3520 04	epp2 	-4891,ic		000510 = 524000000000
012144  aa  6 01300 2521 00	spri2	pr6|704
012145  aa  6 01266 6211 00	eax1 	pr6|694
012146  aa   010000 4310 07	fld  	4096,dl
012147  aa   002402 3520 04	epp2 	1282,ic		014551 = 000160627000
012150  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 1608
     end io_err;

012151  aa  6 00430 6101 00	rtcd 	pr6|280
  END PROCEDURE io_err
BEGIN PROCEDURE do_io
ENTRY TO do_io                                              STATEMENT 1 ON LINE 1614
do_io:
     proc;

012152  aa  6 00436 6501 00	spri4	pr6|286
						STATEMENT 1 ON LINE 1619
	true_len = min (4 * block_len, data_left);

012153  aa  6 00171 2361 00	ldq  	pr6|121		block_len
012154  aa   000002 7360 00	qls  	2
012155  aa  6 01302 7561 00	stq  	pr6|706
012156  aa  6 00162 1161 00	cmpq 	pr6|114		data_left
012157  aa   000002 6040 04	tmi  	2,ic		012161
012160  aa  6 00162 2361 00	ldq  	pr6|114		data_left
012161  aa  6 00444 7561 00	stq  	pr6|292		true_len
						STATEMENT 1 ON LINE 1627
	if io_command ^= "read" & ^cont_sw
	     then do;

012162  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
012163  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
012164  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
012165  aa   767031 00 0004	desc9a	-4583,4		001214 = 162145141144
012166  aa   000025 6000 04	tze  	21,ic		012213
012167  aa  6 00206 2351 00	lda  	pr6|134		cont_sw
012170  aa   000023 6010 04	tnz  	19,ic		012213
						STATEMENT 1 ON LINE 1630
		substr (data, 1, true_len) = substr (block, 1, true_len);

012171  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012172  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
012173  aa  6 00146 3535 20	epp3 	pr6|102,*		block_ptr
012174  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
012175  aa  3 00000 00 0006	desc9a	pr3|0,ql		block
012176  aa  5 00135 00 0006	desc9a	pr5|93,ql		buffer.data
						STATEMENT 1 ON LINE 1632
		if true_len < 4 * block_len
		     then unspec (substr (data, true_len + 1, 4 * block_len - true_len)) = fill;

012177  aa  6 01302 1161 00	cmpq 	pr6|706
012200  aa   000013 6050 04	tpl  	11,ic		012213
012201  aa  6 01302 2361 00	ldq  	pr6|706
012202  aa  6 00444 1761 00	sbq  	pr6|292		true_len
012203  aa   000011 4020 07	mpy  	9,dl
012204  aa  6 01302 7561 00	stq  	pr6|706
012205  aa  6 00444 2361 00	ldq  	pr6|292		true_len
012206  aa   000011 4020 07	mpy  	9,dl
012207  aa  6 01302 2351 00	lda  	pr6|706
012210  aa  003 146 060 500	csl  	(pr),(pr,rl,ql),fill(0),bool(move)
012211  aa  7 00126 00 0011	descb	pr7|86,9		disk_data.fill
012212  aa  5 00135 00 0005	descb	pr5|93,al
						STATEMENT 1 ON LINE 1634
	     end;

						STATEMENT 1 ON LINE 1636
	idcwp = addr (sk_idcw);

012213  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012214  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
012215  aa  5 00001 3535 00	epp3 	pr5|1		buffer.sk_idcw
012216  aa  6 00100 2535 00	spri3	pr6|64		idcwp
						STATEMENT 1 ON LINE 1637
	idcw = seek_idcw_template;

012217  aa  6 00044 3701 20	epp4 	pr6|36,*
012220  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.command
012221  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
012222  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.device
012223  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
012224  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.ext
012225  aa  3 00000 7511 10	stca 	pr3|0,10		idcw.ext
012226  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.code
012227  aa  3 00000 6751 00	era  	pr3|0		idcw.code
012230  aa   700000 3750 07	ana  	229376,dl
012231  aa  3 00000 6551 00	ersa 	pr3|0		idcw.code
012232  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.ext_ctl
012233  aa  3 00000 6751 00	era  	pr3|0		idcw.ext_ctl
012234  aa   040000 3750 07	ana  	16384,dl
012235  aa  3 00000 6551 00	ersa 	pr3|0		idcw.ext_ctl
012236  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.control
012237  aa  3 00000 6751 00	era  	pr3|0		idcw.control
012240  aa   030000 3750 07	ana  	12288,dl
012241  aa  3 00000 6551 00	ersa 	pr3|0		idcw.control
012242  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.chan_cmd
012243  aa  3 00000 7511 02	stca 	pr3|0,02		idcw.chan_cmd
012244  ia  4 00013 2351 00	lda  	pr4|11		seek_idcw_template.count
012245  aa  3 00000 7511 01	stca 	pr3|0,01		idcw.count
						STATEMENT 1 ON LINE 1638
	idcw.device = bit (drive);

012246  aa  7 00076 2351 00	lda  	pr7|62		disk_data.drive
012247  aa   000002 6050 04	tpl  	2,ic		012251
012250  aa   000000 5310 00	neg  	0
012251  aa   000036 7350 00	als  	30
012252  aa   000006 7710 00	arl  	6
012253  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
						STATEMENT 1 ON LINE 1639
	count_limit_fixed = ceil (block_len / sect_size);

012254  aa  6 00171 2361 00	ldq  	pr6|121		block_len
012255  aa  7 00101 3521 00	epp2 	pr7|65		disk_data.sect_size
012256  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
012257  aa     000000000073
012260  aa   000073 7220 07	lxl2 	59,dl
012261  aa   777612 7230 07	lxl3 	262026,dl
012262  aa  0 01117 7001 00	tsx0 	pr0|591		ceil_fx2
012263  aa  6 00170 7561 00	stq  	pr6|120		count_limit_fixed
						STATEMENT 1 ON LINE 1641
	if key <= last_sect_num (dev_type)		/* in the data region */
	     then goto BUILD_NORMAL_SEEK;

012264  aa  6 00165 2361 00	ldq  	pr6|117		key
012265  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
012266  ta   000254 1160 17	cmpq 	172,7
012267  aa   000011 6044 04	tmoz 	9,ic		012300
						STATEMENT 1 ON LINE 1643
	else if key <= last_alt_sect_num (dev_type)	/* in the alternate region */
	     then goto BUILD_ALT_SEEK (device_group);

012270  ta   000232 1160 17	cmpq 	154,7
012271  aa   000003 6054 04	tpnz 	3,ic		012274
012272  aa  7 00103 7261 00	lxl6 	pr7|67		disk_data.device_group
012273  ta   000002 7100 16	tra  	2,6
						STATEMENT 1 ON LINE 1645
	else goto BUILD_TANDD_SEEK (device_group);

012274  aa  7 00103 7261 00	lxl6 	pr7|67		disk_data.device_group
012275  ta   777777 7100 16	tra  	-1,6
						STATEMENT 1 ON LINE 1648
BUILD_TANDD_SEEK (1):				/* T&D region on MSU04XX device */
	idcw.command = SPECIAL_SEEK;

012276  aa   360000 2350 03	lda  	122880,du
012277  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
						STATEMENT 1 ON LINE 1651
BUILD_ALT_SEEK (1):					/* Alternate track region on MSU04XX device */
BUILD_NORMAL_SEEK:
	idcw.command = seek_command (dev_type);

012300  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
012301  aa   000006 4020 07	mpy  	6,dl
012302  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
012303  aa  6 00107 63 0006	descb	pr6|71(30),6	seek_command
012304  aa  3 00000 00 0006	descb	pr3|0,6		idcw.command
						STATEMENT 1 ON LINE 1654
	unspec (seek) = "0"b;

012305  aa  6 00114 4501 00	stz  	pr6|76
						STATEMENT 1 ON LINE 1655
	seek.block_count_limit = count_limit_fixed;

012306  aa  6 00170 2361 00	ldq  	pr6|120		count_limit_fixed
012307  aa   000074 7370 00	lls  	60
012310  aa  6 00114 7511 60	stca 	pr6|76,60		seek.block_count_limit
						STATEMENT 1 ON LINE 1656
	seek.ti = track_indicators;

012311  aa  6 00167 2351 00	lda  	pr6|119		track_indicators
012312  aa   000014 7710 00	arl  	12
012313  aa  6 00114 6751 00	era  	pr6|76		seek.ti
012314  aa   000060 3750 03	ana  	48,du
012315  aa  6 00114 6551 00	ersa 	pr6|76		seek.ti
						STATEMENT 1 ON LINE 1657
	if is_sv
	     then do;

012316  aa  7 00104 2351 00	lda  	pr7|68		disk_data.is_sv
012317  aa   000021 6000 04	tze  	17,ic		012340
						STATEMENT 1 ON LINE 1659
		sector_offset = mod (key, sect_per_cyl (dev_type));

012320  aa  6 00165 2361 00	ldq  	pr6|117		key
012321  ta   000210 3520 17	epp2 	136,7
012322  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
012323  aa  6 00446 7561 00	stq  	pr6|294		sector_offset
						STATEMENT 1 ON LINE 1660
		seek.sector =
		     ((key - sector_offset) * number_of_sv (dev_type)) + (sv_num * sect_per_cyl (dev_type))
		     + sector_offset;

012324  aa  7 00105 2361 00	ldq  	pr7|69		disk_data.sv_num
012325  aa  2 00000 4021 00	mpy  	pr2|0		sect_per_cyl
012326  aa  6 01302 7561 00	stq  	pr6|706
012327  aa  6 00165 2361 00	ldq  	pr6|117		key
012330  aa  6 00446 1761 00	sbq  	pr6|294		sector_offset
012331  ta   000277 4020 17	mpy  	191,7
012332  aa  6 01302 0331 00	adl  	pr6|706
012333  aa  6 00446 0331 00	adl  	pr6|294		sector_offset
012334  aa  6 00114 6761 00	erq  	pr6|76		seek.sector
012335  aa   005121 3760 04	anq  	2641,ic		017456 = 000007777777
012336  aa  6 00114 6561 00	ersq 	pr6|76		seek.sector
						STATEMENT 1 ON LINE 1663
	     end;

012337  aa   000005 7100 04	tra  	5,ic		012344
						STATEMENT 1 ON LINE 1664
	     else seek.sector = key;

012340  aa  6 00165 2361 00	ldq  	pr6|117		key
012341  aa  6 00114 6761 00	erq  	pr6|76		seek.sector
012342  aa   005114 3760 04	anq  	2636,ic		017456 = 000007777777
012343  aa  6 00114 6561 00	ersq 	pr6|76		seek.sector
						STATEMENT 1 ON LINE 1665
	unspec (seek_data) = unspec (seek);

012344  aa  6 00114 2351 00	lda  	pr6|76
012345  aa  5 00114 7551 00	sta  	pr5|76
						STATEMENT 1 ON LINE 1666
	goto SEEK_BUILT;

012346  aa   000106 7100 04	tra  	70,ic		012454
						STATEMENT 1 ON LINE 1669
BUILD_ALT_SEEK (2):					/* Alternate track region on MSU0500/1 device */
BUILD_TANDD_SEEK (2):				/* T&D region on MSU0500/1 device */
	idcw.command = SPECIAL_SEEK;

012347  aa   360000 2350 03	lda  	122880,du
012350  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
						STATEMENT 1 ON LINE 1674
BUILD_SUPER_SEEK:
	unspec (super_seek) = "0"b;

012351  aa  6 00115 4501 00	stz  	pr6|77
						STATEMENT 1 ON LINE 1676
	super_seek.sector_number = mod (key, sect_per_track (dev_type));

012352  aa  6 00165 2361 00	ldq  	pr6|117		key
012353  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012354  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
012355  ta   000166 3520 17	epp2 	118,7
012356  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
012357  aa   000100 7370 00	lls  	64
012360  aa  6 00115 6751 00	era  	pr6|77		super_seek.sector_number
012361  aa  0 00020 3751 00	ana  	pr0|16		= 776000000000
012362  aa  6 00115 6551 00	ersa 	pr6|77		super_seek.sector_number
						STATEMENT 1 ON LINE 1677
	super_seek.ti = track_indicators;

012363  aa  6 00167 2351 00	lda  	pr6|119		track_indicators
012364  aa   000014 7710 00	arl  	12
012365  aa  6 00115 6751 00	era  	pr6|77		super_seek.ti
012366  aa   000060 3750 03	ana  	48,du
012367  aa  6 00115 6551 00	ersa 	pr6|77		super_seek.ti
						STATEMENT 1 ON LINE 1678
	super_seek.is_super_seek = "1"b;

012370  aa   000010 2350 03	lda  	8,du
012371  aa  6 00115 2551 00	orsa 	pr6|77		super_seek.is_super_seek
						STATEMENT 1 ON LINE 1679
	super_seek.flag = "1"b;

012372  aa   000004 2350 03	lda  	4,du
012373  aa  6 00115 2551 00	orsa 	pr6|77		super_seek.flag
						STATEMENT 1 ON LINE 1680
	cyl = divide (key, sect_per_cyl (dev_type), 16, 0);

012374  aa  6 00165 2361 00	ldq  	pr6|117		key
012375  ta   000210 5060 17	div  	136,7
012376  aa  6 00201 7561 00	stq  	pr6|129		cyl
						STATEMENT 1 ON LINE 1681
	head = mod (key, sect_per_cyl (dev_type));

012377  aa  6 00165 2361 00	ldq  	pr6|117		key
012400  ta   000210 3520 17	epp2 	136,7
012401  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
012402  aa  6 00202 7561 00	stq  	pr6|130		head
						STATEMENT 1 ON LINE 1682
	head = divide (head, sect_per_track (dev_type), 16, 0) * 2 + mod (cyl, 2);

012403  aa  6 00201 2361 00	ldq  	pr6|129		cyl
012404  aa   005376 3520 04	epp2 	2814,ic		020002 = 000000000002
012405  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
012406  aa  6 01302 7561 00	stq  	pr6|706
012407  aa  6 00202 2361 00	ldq  	pr6|130		head
012410  ta   000166 5060 17	div  	118,7
012411  aa  2 00000 4021 00	mpy  	pr2|0
012412  aa  6 01302 0761 00	adq  	pr6|706
012413  aa  6 00202 7561 00	stq  	pr6|130		head
						STATEMENT 1 ON LINE 1683
	if mod (cyl, 2) = mod (drive, 2)
	     then					/* see EPS for details of this crock */
		if mod (cyl, 2) = 0
		     then cyl = cyl + 1;

012414  aa  7 00076 2361 00	ldq  	pr7|62		disk_data.drive
012415  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
012416  aa  6 01302 1161 00	cmpq 	pr6|706
012417  aa   000007 6010 04	tnz  	7,ic		012426
012420  aa  6 01302 2361 00	ldq  	pr6|706
012421  aa   000003 6010 04	tnz  	3,ic		012424
012422  aa  6 00201 0541 00	aos  	pr6|129		cyl
012423  aa   000003 7100 04	tra  	3,ic		012426
						STATEMENT 1 ON LINE 1687
		     else cyl = cyl - 1;

012424  aa   000001 3360 07	lcq  	1,dl
012425  aa  6 00201 0561 00	asq  	pr6|129		cyl
						STATEMENT 1 ON LINE 1688
	super_seek.cyl_lower = mod (cyl, 256);

012426  aa  6 00201 2361 00	ldq  	pr6|129		cyl
012427  aa   005345 3520 04	epp2 	2789,ic		017774 = 000000000400
012430  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
012431  aa   000054 7370 00	lls  	44
012432  aa  6 00115 6751 00	era  	pr6|77		super_seek.cyl_lower
012433  aa   177400 3750 07	ana  	65280,dl
012434  aa  6 00115 6551 00	ersa 	pr6|77		super_seek.cyl_lower
						STATEMENT 1 ON LINE 1689
	super_seek.cyl_upper = divide (cyl, 256, 2, 0);

012435  aa  6 00201 2361 00	ldq  	pr6|129		cyl
012436  aa  2 00000 5061 00	div  	pr2|0
012437  aa   000052 7370 00	lls  	42
012440  aa  6 00115 6751 00	era  	pr6|77		super_seek.cyl_upper
012441  aa   000300 3750 07	ana  	192,dl
012442  aa  6 00115 6551 00	ersa 	pr6|77		super_seek.cyl_upper
						STATEMENT 1 ON LINE 1690
	super_seek.head = head;

012443  aa  6 00202 2361 00	ldq  	pr6|130		head
012444  aa  6 00115 7521 01	stcq 	pr6|77,01		super_seek.head
						STATEMENT 1 ON LINE 1691
	unspec (seek_data) = unspec (super_seek);

012445  aa  6 00115 2351 00	lda  	pr6|77
012446  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
012447  aa  5 00114 7551 00	sta  	pr5|76
						STATEMENT 1 ON LINE 1692
	goto SEEK_BUILT;

012450  aa   000004 7100 04	tra  	4,ic		012454
						STATEMENT 1 ON LINE 1697
BUILD_ALT_SEEK (3):					/* Alternate track region on MSU0509 device */
BUILD_TANDD_SEEK (3):				/* T&D region on MSU0509 device */
	idcw.command = SPECIAL_SEEK_512;

012451  aa   350000 2350 03	lda  	118784,du
012452  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
						STATEMENT 1 ON LINE 1700
	goto BUILD_SUPER_SEEK;

012453  aa   777676 7100 04	tra  	-66,ic		012351
						STATEMENT 1 ON LINE 1703
SEEK_BUILT:					/* Seek command and data are ready */
	dcwp = addr (sk_dcw);

012454  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
012455  aa  5 00002 3535 00	epp3 	pr5|2		buffer.sk_dcw
012456  aa  6 00102 2535 00	spri3	pr6|66		dcwp
						STATEMENT 1 ON LINE 1705
	dcw = seek_dcw_template;

012457  aa  6 00044 3701 20	epp4 	pr6|36,*
012460  ia  4 00014 2351 00	lda  	pr4|12		seek_dcw_template.address
012461  aa  3 00000 5511 60	stba 	pr3|0,60		dcw.address
012462  ia  4 00014 2351 00	lda  	pr4|12		seek_dcw_template.char_pos
012463  aa  3 00000 6751 00	era  	pr3|0		dcw.char_pos
012464  aa   700000 3750 07	ana  	229376,dl
012465  aa  3 00000 6551 00	ersa 	pr3|0		dcw.char_pos
012466  ia  4 00014 2351 00	lda  	pr4|12		seek_dcw_template.m64
012467  aa  3 00000 6751 00	era  	pr3|0		dcw.m64
012470  aa   040000 3750 07	ana  	16384,dl
012471  aa  3 00000 6551 00	ersa 	pr3|0		dcw.m64
012472  ia  4 00014 2351 00	lda  	pr4|12		seek_dcw_template.type
012473  aa  3 00000 6751 00	era  	pr3|0		dcw.type
012474  aa   030000 3750 07	ana  	12288,dl
012475  aa  3 00000 6551 00	ersa 	pr3|0		dcw.type
012476  ia  4 00014 2351 00	lda  	pr4|12		seek_dcw_template.tally
012477  aa  3 00000 7511 03	stca 	pr3|0,03		dcw.tally
						STATEMENT 1 ON LINE 1706
	dcw.address = rel (addr (seek_data));

012500  aa  5 00114 3515 00	epp1 	pr5|76		buffer.seek_data
012501  aa  1 00000 6351 00	eaa  	pr1|0
012502  aa  3 00000 5511 60	stba 	pr3|0,60		dcw.address
						STATEMENT 1 ON LINE 1708
	idcwp = addr (rw_idcw);

012503  aa  5 00003 3735 00	epp7 	pr5|3		buffer.rw_idcw
012504  aa  6 00100 6535 00	spri7	pr6|64		idcwp
						STATEMENT 1 ON LINE 1709
	if cont_sw
	     then do;

012505  aa  6 01304 2515 00	spri1	pr6|708
012506  aa  6 00206 2351 00	lda  	pr6|134		cont_sw
012507  aa   000032 6000 04	tze  	26,ic		012541
						STATEMENT 1 ON LINE 1711
		idcw = control_idcw_template;

012510  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.command
012511  aa  7 00000 7511 40	stca 	pr7|0,40		idcw.command
012512  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.device
012513  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
012514  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.ext
012515  aa  7 00000 7511 10	stca 	pr7|0,10		idcw.ext
012516  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.code
012517  aa  7 00000 6751 00	era  	pr7|0		idcw.code
012520  aa   700000 3750 07	ana  	229376,dl
012521  aa  7 00000 6551 00	ersa 	pr7|0		idcw.code
012522  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.ext_ctl
012523  aa  7 00000 6751 00	era  	pr7|0		idcw.ext_ctl
012524  aa   040000 3750 07	ana  	16384,dl
012525  aa  7 00000 6551 00	ersa 	pr7|0		idcw.ext_ctl
012526  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.control
012527  aa  7 00000 6751 00	era  	pr7|0		idcw.control
012530  aa   030000 3750 07	ana  	12288,dl
012531  aa  7 00000 6551 00	ersa 	pr7|0		idcw.control
012532  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.chan_cmd
012533  aa  7 00000 7511 02	stca 	pr7|0,02		idcw.chan_cmd
012534  ia  4 00020 2351 00	lda  	pr4|16		control_idcw_template.count
012535  aa  7 00000 7511 01	stca 	pr7|0,01		idcw.count
						STATEMENT 1 ON LINE 1712
		idcw.command = control_command;

012536  aa  6 00166 2351 00	lda  	pr6|118		control_command
012537  aa  7 00000 7511 40	stca 	pr7|0,40		idcw.command
						STATEMENT 1 ON LINE 1713
	     end;

012540  aa   000116 7100 04	tra  	78,ic		012656
						STATEMENT 1 ON LINE 1714
	else if (io_command = "read") then idcw = read_idcw_template;

012541  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
012542  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
012543  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
012544  aa   766452 00 0004	desc9a	-4822,4		001214 = 162145141144
012545  aa   000030 6010 04	tnz  	24,ic		012575
012546  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.command
012547  aa  7 00000 7511 40	stca 	pr7|0,40		idcw.command
012550  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.device
012551  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
012552  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.ext
012553  aa  7 00000 7511 10	stca 	pr7|0,10		idcw.ext
012554  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.code
012555  aa  7 00000 6751 00	era  	pr7|0		idcw.code
012556  aa   700000 3750 07	ana  	229376,dl
012557  aa  7 00000 6551 00	ersa 	pr7|0		idcw.code
012560  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.ext_ctl
012561  aa  7 00000 6751 00	era  	pr7|0		idcw.ext_ctl
012562  aa   040000 3750 07	ana  	16384,dl
012563  aa  7 00000 6551 00	ersa 	pr7|0		idcw.ext_ctl
012564  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.control
012565  aa  7 00000 6751 00	era  	pr7|0		idcw.control
012566  aa   030000 3750 07	ana  	12288,dl
012567  aa  7 00000 6551 00	ersa 	pr7|0		idcw.control
012570  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.chan_cmd
012571  aa  7 00000 7511 02	stca 	pr7|0,02		idcw.chan_cmd
012572  ia  4 00015 2351 00	lda  	pr4|13		read_idcw_template.count
012573  aa  7 00000 7511 01	stca 	pr7|0,01		idcw.count
012574  aa   000062 7100 04	tra  	50,ic		012656
						STATEMENT 1 ON LINE 1716
	else if compare_sw then idcw = write_and_compare_idcw_template;

012575  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
012576  aa  3 00055 2351 00	lda  	pr3|45		disk_data.compare_sw
012577  aa   100000 3150 03	cana 	32768,du
012600  aa   000030 6000 04	tze  	24,ic		012630
012601  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.command
012602  aa  7 00000 7511 40	stca 	pr7|0,40		idcw.command
012603  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.device
012604  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
012605  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.ext
012606  aa  7 00000 7511 10	stca 	pr7|0,10		idcw.ext
012607  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.code
012610  aa  7 00000 6751 00	era  	pr7|0		idcw.code
012611  aa   700000 3750 07	ana  	229376,dl
012612  aa  7 00000 6551 00	ersa 	pr7|0		idcw.code
012613  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.ext_ctl
012614  aa  7 00000 6751 00	era  	pr7|0		idcw.ext_ctl
012615  aa   040000 3750 07	ana  	16384,dl
012616  aa  7 00000 6551 00	ersa 	pr7|0		idcw.ext_ctl
012617  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.control
012620  aa  7 00000 6751 00	era  	pr7|0		idcw.control
012621  aa   030000 3750 07	ana  	12288,dl
012622  aa  7 00000 6551 00	ersa 	pr7|0		idcw.control
012623  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.chan_cmd
012624  aa  7 00000 7511 02	stca 	pr7|0,02		idcw.chan_cmd
012625  ia  4 00017 2351 00	lda  	pr4|15		write_and_compare_idcw_template.count
012626  aa  7 00000 7511 01	stca 	pr7|0,01		idcw.count
012627  aa   000027 7100 04	tra  	23,ic		012656
						STATEMENT 1 ON LINE 1718
	else idcw = write_idcw_template;

012630  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.command
012631  aa  7 00000 7511 40	stca 	pr7|0,40		idcw.command
012632  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.device
012633  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
012634  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.ext
012635  aa  7 00000 7511 10	stca 	pr7|0,10		idcw.ext
012636  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.code
012637  aa  7 00000 6751 00	era  	pr7|0		idcw.code
012640  aa   700000 3750 07	ana  	229376,dl
012641  aa  7 00000 6551 00	ersa 	pr7|0		idcw.code
012642  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.ext_ctl
012643  aa  7 00000 6751 00	era  	pr7|0		idcw.ext_ctl
012644  aa   040000 3750 07	ana  	16384,dl
012645  aa  7 00000 6551 00	ersa 	pr7|0		idcw.ext_ctl
012646  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.control
012647  aa  7 00000 6751 00	era  	pr7|0		idcw.control
012650  aa   030000 3750 07	ana  	12288,dl
012651  aa  7 00000 6551 00	ersa 	pr7|0		idcw.control
012652  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.chan_cmd
012653  aa  7 00000 7511 02	stca 	pr7|0,02		idcw.chan_cmd
012654  ia  4 00016 2351 00	lda  	pr4|14		write_idcw_template.count
012655  aa  7 00000 7511 01	stca 	pr7|0,01		idcw.count
						STATEMENT 1 ON LINE 1719
	idcw.device = bit (drive);

012656  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
012657  aa  3 00076 2351 00	lda  	pr3|62		disk_data.drive
012660  aa   000002 6050 04	tpl  	2,ic		012662
012661  aa   000000 5310 00	neg  	0
012662  aa   000036 7350 00	als  	30
012663  aa   000006 7710 00	arl  	6
012664  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
						STATEMENT 1 ON LINE 1721
	dcw_address = bin (rel (addr (data)));

012665  aa  5 00135 3535 00	epp3 	pr5|93		buffer.data
012666  aa  3 00000 6351 00	eaa  	pr3|0
012667  aa   000066 7730 00	lrl  	54
012670  aa  6 00320 7561 00	stq  	pr6|208		dcw_address
						STATEMENT 1 ON LINE 1722
	rw_length = block_len;

012671  aa  6 00171 2361 00	ldq  	pr6|121		block_len
012672  aa  6 00321 7561 00	stq  	pr6|209		rw_length
						STATEMENT 1 ON LINE 1723
	do dcwx = 1 by 1 while (rw_length > 0);

012673  aa   000001 2360 07	ldq  	1,dl
012674  aa  6 00317 7561 00	stq  	pr6|207		dcwx
012675  aa   000000 0110 03	nop  	0,du
012676  aa  6 01306 2535 00	spri3	pr6|710
012677  aa  6 00321 2361 00	ldq  	pr6|209		rw_length
012700  aa   000057 6044 04	tmoz 	47,ic		012757
						STATEMENT 1 ON LINE 1724
	     dcwp = addr (rw_dcw (dcwx));

012701  aa  6 00317 7271 00	lxl7 	pr6|207		dcwx
012702  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012703  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
012704  aa  5 00003 3735 17	epp7 	pr5|3,7		buffer.rw_dcw
012705  aa  6 00102 6535 00	spri7	pr6|66		dcwp
						STATEMENT 1 ON LINE 1725
	     dcw = read_write_dcw_template;

012706  aa  6 00044 3701 20	epp4 	pr6|36,*
012707  ia  4 00021 2351 00	lda  	pr4|17		read_write_dcw_template.address
012710  aa  7 00000 5511 60	stba 	pr7|0,60		dcw.address
012711  ia  4 00021 2351 00	lda  	pr4|17		read_write_dcw_template.char_pos
012712  aa  7 00000 6751 00	era  	pr7|0		dcw.char_pos
012713  aa   700000 3750 07	ana  	229376,dl
012714  aa  7 00000 6551 00	ersa 	pr7|0		dcw.char_pos
012715  ia  4 00021 2351 00	lda  	pr4|17		read_write_dcw_template.m64
012716  aa  7 00000 6751 00	era  	pr7|0		dcw.m64
012717  aa   040000 3750 07	ana  	16384,dl
012720  aa  7 00000 6551 00	ersa 	pr7|0		dcw.m64
012721  ia  4 00021 2351 00	lda  	pr4|17		read_write_dcw_template.type
012722  aa  7 00000 6751 00	era  	pr7|0		dcw.type
012723  aa   030000 3750 07	ana  	12288,dl
012724  aa  7 00000 6551 00	ersa 	pr7|0		dcw.type
012725  ia  4 00021 2351 00	lda  	pr4|17		read_write_dcw_template.tally
012726  aa  7 00000 7511 03	stca 	pr7|0,03		dcw.tally
						STATEMENT 1 ON LINE 1726
	     dcw.address = bit (bin (dcw_address, 18), 18);

012727  aa  6 00320 2351 00	lda  	pr6|208		dcw_address
012730  aa   000002 6050 04	tpl  	2,ic		012732
012731  aa   000000 5310 00	neg  	0
012732  aa   000022 7350 00	als  	18
012733  aa  7 00000 5511 60	stba 	pr7|0,60		dcw.address
						STATEMENT 1 ON LINE 1727
	     if rw_length >= MAX_DCW_TALLY
		then dcw.tally = bit (bin (MAX_DCW_TALLY, 12), 12);

012734  aa   010000 1160 07	cmpq 	4096,dl
012735  aa   000007 6040 04	tmi  	7,ic		012744
012736  aa   010000 2350 07	lda  	4096,dl
012737  aa   000002 6050 04	tpl  	2,ic		012741
012740  aa   000000 5310 00	neg  	0
012741  aa  0 00300 3771 00	anaq 	pr0|192		= 000000007777 777777777777
012742  aa  7 00000 7511 03	stca 	pr7|0,03		dcw.tally
012743  aa   000006 7100 04	tra  	6,ic		012751
						STATEMENT 1 ON LINE 1729
		else dcw.tally = bit (bin (rw_length, 12), 12);

012744  aa  6 00321 2351 00	lda  	pr6|209		rw_length
012745  aa   000002 6050 04	tpl  	2,ic		012747
012746  aa   000000 5310 00	neg  	0
012747  aa  0 00300 3771 00	anaq 	pr0|192		= 000000007777 777777777777
012750  aa  7 00000 7511 03	stca 	pr7|0,03		dcw.tally
						STATEMENT 1 ON LINE 1730
	     dcw_address = dcw_address + MAX_DCW_TALLY;

012751  aa   010000 2360 07	ldq  	4096,dl
012752  aa  6 00320 0561 00	asq  	pr6|208		dcw_address
						STATEMENT 1 ON LINE 1731
	     rw_length = rw_length - MAX_DCW_TALLY;

012753  aa   010000 3360 07	lcq  	4096,dl
012754  aa  6 00321 0561 00	asq  	pr6|209		rw_length
						STATEMENT 1 ON LINE 1732
	     end;

012755  aa  6 00317 0541 00	aos  	pr6|207		dcwx
012756  aa   777720 7100 04	tra  	-48,ic		012676
						STATEMENT 1 ON LINE 1734
	dcw.type = IOTD;

012757  aa   004476 2350 04	lda  	2366,ic		017455 = 777777747777
012760  aa  6 00102 3551 20	ansa 	pr6|66,*		dcw.type
						STATEMENT 1 ON LINE 1736
	dcw_offset = fixed (rel (addr (sk_idcw)));

012761  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012762  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
012763  aa  5 00001 3735 00	epp7 	pr5|1		buffer.sk_idcw
012764  aa  7 00000 6351 00	eaa  	pr7|0
012765  aa   000066 7730 00	lrl  	54
012766  aa  6 00156 7561 00	stq  	pr6|110		dcw_offset
						STATEMENT 1 ON LINE 1738
	again = "1"b;

012767  aa   400000 2350 03	lda  	131072,du
012770  aa  6 00203 7551 00	sta  	pr6|131		again
						STATEMENT 1 ON LINE 1739
	err_ct = 0;

012771  aa  6 00175 4501 00	stz  	pr6|125		err_ct
						STATEMENT 1 ON LINE 1741
	do while (again);

012772  aa  6 01310 6535 00	spri7	pr6|712
012773  aa  6 00203 2351 00	lda  	pr6|131		again
012774  aa   000276 6000 04	tze  	190,ic		013272
						STATEMENT 1 ON LINE 1743
	     completion.st = "0"b;

012775  aa   004457 2350 04	lda  	2351,ic		017454 = 377777777777
012776  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
012777  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013000  aa  5 00125 3551 00	ansa 	pr5|85		buffer.st
						STATEMENT 1 ON LINE 1744
	     completion.run = "1"b;

013001  aa   100000 2350 03	lda  	32768,du
013002  aa  5 00125 2551 00	orsa 	pr5|85		buffer.run
						STATEMENT 1 ON LINE 1746
	     call ioi_$connect (devx, dcw_offset, code);

013003  aa  7 00075 3521 00	epp2 	pr7|61		disk_data.devx
013004  aa  6 01314 2521 00	spri2	pr6|716
013005  aa  6 00156 3521 00	epp2 	pr6|110		dcw_offset
013006  aa  6 01316 2521 00	spri2	pr6|718
013007  aa  6 00157 3521 00	epp2 	pr6|111		code
013010  aa  6 01320 2521 00	spri2	pr6|720
013011  aa  6 01312 6211 00	eax1 	pr6|714
013012  aa   014000 4310 07	fld  	6144,dl
013013  aa  6 00044 3701 20	epp4 	pr6|36,*
013014  la  4 00134 3521 20	epp2 	pr4|92,*		ioi_$connect
013015  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1747
	     if code ^= 0 then call io_err ("0"b);

013016  aa  6 00157 2361 00	ldq  	pr6|111		code
013017  aa   000005 6000 04	tze  	5,ic		013024
013020  aa   000000 2350 07	lda  	0,dl
013021  aa  6 01303 7551 00	sta  	pr6|707
013022  aa   004426 3520 04	epp2 	2326,ic		017450 = 000002000000
013023  aa   777075 6700 04	tsp4 	-451,ic		012120
						STATEMENT 1 ON LINE 1749
	     do while (^completion.st & completion.run);

013024  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013025  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013026  aa  5 00125 2351 00	lda  	pr5|85		buffer.st
013027  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
013030  aa  6 01303 7551 00	sta  	pr6|707		buffer.st
013031  aa  5 00125 2351 00	lda  	pr5|85		buffer.run
013032  aa   000002 7350 00	als  	2
013033  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
013034  aa  6 01302 7551 00	sta  	pr6|706		buffer.run
013035  aa   000031 6000 04	tze  	25,ic		013066
013036  aa  6 01303 2351 00	lda  	pr6|707		buffer.st
013037  aa   000027 6010 04	tnz  	23,ic		013066
						STATEMENT 1 ON LINE 1751
		call ipc_$block (addr (wait_list), addr (event_info), code);

013040  aa  7 00070 3535 00	epp3 	pr7|56		disk_data.wait_list
013041  aa  6 01322 2535 00	spri3	pr6|722
013042  aa  6 00116 3515 00	epp1 	pr6|78		event_info
013043  aa  6 01324 2515 00	spri1	pr6|724
013044  aa  6 01322 3521 00	epp2 	pr6|722
013045  aa  6 01314 2521 00	spri2	pr6|716
013046  aa  6 01324 3521 00	epp2 	pr6|724
013047  aa  6 01316 2521 00	spri2	pr6|718
013050  aa  6 00157 3521 00	epp2 	pr6|111		code
013051  aa  6 01320 2521 00	spri2	pr6|720
013052  aa  6 01312 6211 00	eax1 	pr6|714
013053  aa   014000 4310 07	fld  	6144,dl
013054  aa  6 00044 3701 20	epp4 	pr6|36,*
013055  la  4 00136 3521 20	epp2 	pr4|94,*		ipc_$block
013056  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1753
		if code ^= 0 then call io_err ("0"b);

013057  aa  6 00157 2361 00	ldq  	pr6|111		code
013060  aa   777744 6000 04	tze  	-28,ic		013024
013061  aa   000000 2350 07	lda  	0,dl
013062  aa  6 01326 7551 00	sta  	pr6|726
013063  aa   004361 3520 04	epp2 	2289,ic		017444 = 000002000000
013064  aa   777034 6700 04	tsp4 	-484,ic		012120
						STATEMENT 1 ON LINE 1755
		end;

013065  aa   777737 7100 04	tra  	-33,ic		013024
						STATEMENT 1 ON LINE 1757
	     again = "0"b;

013066  aa  6 00203 4501 00	stz  	pr6|131		again
						STATEMENT 1 ON LINE 1759
	     if completion.time_out | ^(completion.st | completion.er | completion.run | completion.time_out)
						/* if nothing */
		then call retry;

013067  aa  5 00125 2351 00	lda  	pr5|85		buffer.time_out
013070  aa   000003 7350 00	als  	3
013071  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
013072  aa  6 01326 7551 00	sta  	pr6|726		buffer.time_out
013073  aa   000011 6010 04	tnz  	9,ic		013104
013074  aa   000012 6010 04	tnz  	10,ic		013106
013075  aa  6 01303 2351 00	lda  	pr6|707		buffer.st
013076  aa   000010 6010 04	tnz  	8,ic		013106
013077  aa  5 00125 2351 00	lda  	pr5|85		buffer.er
013100  aa   200000 3150 03	cana 	65536,du
013101  aa   000005 6010 04	tnz  	5,ic		013106
013102  aa  6 01302 2351 00	lda  	pr6|706		buffer.run
013103  aa   000003 6010 04	tnz  	3,ic		013106
013104  aa   000232 6700 04	tsp4 	154,ic		013336
013105  aa   777665 7100 04	tra  	-75,ic		012772
						STATEMENT 1 ON LINE 1763
	     else if level <= 1 then call perm_err;

013106  aa  5 00126 2361 00	ldq  	pr5|86		buffer.level
013107  aa   000001 1160 07	cmpq 	1,dl
013110  aa   000003 6054 04	tpnz 	3,ic		013113
013111  aa   000413 6700 04	tsp4 	267,ic		013524
013112  aa   777660 7100 04	tra  	-80,ic		012772
						STATEMENT 1 ON LINE 1765
	     else if level > 3 then call retry;

013113  aa   000003 1160 07	cmpq 	3,dl
013114  aa   000003 6044 04	tmoz 	3,ic		013117
013115  aa   000221 6700 04	tsp4 	145,ic		013336
013116  aa   777654 7100 04	tra  	-84,ic		012772
						STATEMENT 1 ON LINE 1767
	     else if status.maj = ATTENTION
		then if status.sub & STANDBY
			then call delay_retry;

013117  aa  5 00131 3535 00	epp3 	pr5|89		buffer.iom_stat
013120  aa  6 01324 2535 00	spri3	pr6|724
013121  aa  3 00000 2351 00	lda  	pr3|0		status.maj
013122  aa   000002 7350 00	als  	2
013123  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
013124  aa  6 01302 7551 00	sta  	pr6|706		status.maj
013125  aa   100000 1150 03	cmpa 	32768,du
013126  aa   000012 6010 04	tnz  	10,ic		013140
013127  aa  3 00000 2351 00	lda  	pr3|0		status.sub
013130  aa   000006 7350 00	als  	6
013131  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
013132  aa   200000 3150 03	cana 	65536,du
013133  aa   000003 6000 04	tze  	3,ic		013136
013134  aa   000266 6700 04	tsp4 	182,ic		013422
013135  aa   777635 7100 04	tra  	-99,ic		012772
						STATEMENT 1 ON LINE 1770
			else call loud_retry;

013136  aa   000313 6700 04	tsp4 	203,ic		013451
013137  aa   777633 7100 04	tra  	-101,ic		012772
						STATEMENT 1 ON LINE 1772
	     else if status.maj = EOF
		then if (status.sub & LAST_BLOCK_MASK = LAST_BLOCK)
			then do;

013140  aa   200000 1150 03	cmpa 	65536,du
013141  aa   000125 6010 04	tnz  	85,ic		013266
013142  aa  3 00000 2351 00	lda  	pr3|0		status.sub
013143  aa   000006 7350 00	als  	6
013144  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
013145  aa  6 01303 7551 00	sta  	pr6|707		status.sub
013146  aa   750000 2350 03	lda  	249856,du
013147  aa   010000 1150 03	cmpa 	4096,du
013150  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
013151  aa  6 01303 3151 00	cana 	pr6|707		status.sub
013152  aa   000077 6000 04	tze  	63,ic		013251
						STATEMENT 1 ON LINE 1775
			     if (io_command = "read")
				then do;

013153  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
013154  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
013155  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
013156  aa   766040 00 0004	desc9a	-5088,4		001214 = 162145141144
013157  aa   000051 6010 04	tnz  	41,ic		013230
						STATEMENT 1 ON LINE 1777
				     data_read = min (true_len, (block_len - fixed (status.residue) - 1) * 4);

013160  aa  3 00001 2361 00	ldq  	pr3|1		status.residue
013161  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
013162  aa   000000 5330 00	negl 	0
013163  aa  6 00171 0331 00	adl  	pr6|121		block_len
013164  aa   000000 5330 00	negl 	0
013165  aa   000001 0330 07	adl  	1,dl
013166  aa   000000 5330 00	negl 	0
013167  aa  6 01324 7571 00	staq 	pr6|724
013170  aa   000004 2360 07	ldq  	4,dl
013171  aa  6 01324 3521 00	epp2 	pr6|724
013172  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
013173  aa  6 01324 7571 00	staq 	pr6|724
013174  aa  6 00444 2351 00	lda  	pr6|292		true_len
013175  aa   000044 7330 00	lrs  	36
013176  aa  6 01324 1171 00	cmpaq	pr6|724
013177  aa   000002 6040 04	tmi  	2,ic		013201
013200  aa  6 01324 2371 00	ldaq 	pr6|724
013201  aa  6 00445 7561 00	stq  	pr6|293		data_read
						STATEMENT 1 ON LINE 1779
				     substr (block, 1, data_read) = substr (data, 1, data_read);

013202  aa  6 00146 3515 20	epp1 	pr6|102,*		block_ptr
013203  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
013204  aa  5 00135 00 0006	desc9a	pr5|93,ql		buffer.data
013205  aa  1 00000 00 0006	desc9a	pr1|0,ql		block
						STATEMENT 1 ON LINE 1781
				     a_rec_len, rec_len = rec_len - data_left + data_read;

013206  aa  6 00160 3361 00	lcq  	pr6|112		rec_len
013207  aa   000044 7770 00	llr  	36
013210  aa   000044 7330 00	lrs  	36
013211  aa  6 00162 0331 00	adl  	pr6|114		data_left
013212  aa   000000 5330 00	negl 	0
013213  aa  6 00445 0331 00	adl  	pr6|293		data_read
013214  aa  6 00346 7561 20	stq  	pr6|230,*		a_rec_len
013215  aa  6 00160 7561 00	stq  	pr6|112		rec_len
						STATEMENT 1 ON LINE 1783
				     unspec (substr (block, rec_len + 1, data_left - data_read)) = fill;

013216  aa  6 00162 2361 00	ldq  	pr6|114		data_left
013217  aa  6 00445 1761 00	sbq  	pr6|293		data_read
013220  aa   000011 4020 07	mpy  	9,dl
013221  aa  6 01326 7561 00	stq  	pr6|726
013222  aa  6 00160 2361 00	ldq  	pr6|112		rec_len
013223  aa   000011 4020 07	mpy  	9,dl
013224  aa  6 01326 2351 00	lda  	pr6|726
013225  aa  003 146 060 500	csl  	(pr),(pr,rl,ql),fill(0),bool(move)
013226  aa  7 00126 00 0011	descb	pr7|86,9		disk_data.fill
013227  aa  1 00000 00 0005	descb	pr1|0,al
						STATEMENT 1 ON LINE 1785
				end;

						STATEMENT 1 ON LINE 1788
			     if (mode = Sequential_input) | (mode = Sequential_update)
				then code = error_table_$end_of_info;

013230  aa  7 00122 2361 00	ldq  	pr7|82		disk_data.mode
013231  aa   000004 1160 07	cmpq 	4,dl
013232  aa   000003 6000 04	tze  	3,ic		013235
013233  aa   000007 1160 07	cmpq 	7,dl
013234  aa   000005 6010 04	tnz  	5,ic		013241
013235  aa  6 00044 3701 20	epp4 	pr6|36,*
013236  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$end_of_info
013237  aa  6 00157 7561 00	stq  	pr6|111		code
013240  aa   000004 7100 04	tra  	4,ic		013244
						STATEMENT 1 ON LINE 1790
				else code = error_table_$device_end;

013241  aa  6 00044 3701 20	epp4 	pr6|36,*
013242  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$device_end
013243  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 1794
			     call io_err ("0"b);

013244  aa   000000 2350 07	lda  	0,dl
013245  aa  6 01326 7551 00	sta  	pr6|726
013246  aa   004176 3520 04	epp2 	2174,ic		017444 = 000002000000
013247  aa   776651 6700 04	tsp4 	-599,ic		012120
						STATEMENT 1 ON LINE 1795
			end;

013250  aa   777522 7100 04	tra  	-174,ic		012772
						STATEMENT 1 ON LINE 1796
		     else if ((status.sub & TI_MASK) ^= "00"b3) & cont_sw & (io_command = "read") then ;

013251  aa  6 01303 2351 00	lda  	pr6|707		status.sub
013252  aa   340000 3150 03	cana 	114688,du
013253  aa   000011 6000 04	tze  	9,ic		013264
013254  aa  6 00206 2351 00	lda  	pr6|134		cont_sw
013255  aa   000007 6000 04	tze  	7,ic		013264
013256  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
013257  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
013260  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
013261  aa   765735 00 0004	desc9a	-5155,4		001214 = 162145141144
013262  aa   000002 6010 04	tnz  	2,ic		013264
013263  aa   777507 7100 04	tra  	-185,ic		012772
						STATEMENT 1 ON LINE 1797
		     else call perm_err;

013264  aa   000240 6700 04	tsp4 	160,ic		013524
013265  aa   777505 7100 04	tra  	-187,ic		012772
						STATEMENT 1 ON LINE 1799
	     else if status.maj ^= "0000"b then call retry;

013266  aa   740000 3150 03	cana 	245760,du
013267  aa   777503 6000 04	tze  	-189,ic		012772
013270  aa   000046 6700 04	tsp4 	38,ic		013336
						STATEMENT 1 ON LINE 1802
	     end;

013271  aa   777501 7100 04	tra  	-191,ic		012772
						STATEMENT 1 ON LINE 1804
	if (io_command = "read") & ^cont_sw
	     then do;

013272  aa  6 00306 7271 00	lxl7 	pr6|198		io_command
013273  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
013274  aa  6 00307 00 0017	desc9a	pr6|199,x7	io_command
013275  aa   765721 00 0004	desc9a	-5167,4		001214 = 162145141144
013276  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
013277  aa  6 01302 7551 00	sta  	pr6|706
013300  aa   000013 6000 04	tze  	11,ic		013313
013301  aa  6 00206 2351 00	lda  	pr6|134		cont_sw
013302  aa   000011 6010 04	tnz  	9,ic		013313
						STATEMENT 1 ON LINE 1806
		substr (block, 1, true_len) = substr (data, 1, true_len);

013303  aa  6 00146 3735 20	epp7 	pr6|102,*		block_ptr
013304  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
013305  aa  5 00124 3535 20	epp3 	pr5|84,*		disk_data.buf_ptr
013306  aa  6 00444 2361 00	ldq  	pr6|292		true_len
013307  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
013310  aa  3 00135 00 0006	desc9a	pr3|93,ql		buffer.data
013311  aa  7 00000 00 0006	desc9a	pr7|0,ql		block
						STATEMENT 1 ON LINE 1808
		rec_len = true_len;

013312  aa  6 00160 7561 00	stq  	pr6|112		rec_len
						STATEMENT 1 ON LINE 1809
	     end;

						STATEMENT 1 ON LINE 1811
	if (io_command = "read") & cont_sw
	     then substr (info_block, 1, 4 * (block_len - fixed (status.residue))) =
		     substr (data, 1, 4 * (block_len - fixed (status.residue)));

013313  aa  6 01302 2351 00	lda  	pr6|706
013314  aa   000021 6000 04	tze  	17,ic		013335
013315  aa  6 00206 2351 00	lda  	pr6|134		cont_sw
013316  aa   000017 6000 04	tze  	15,ic		013335
013317  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013320  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013321  aa  5 00132 2361 00	ldq  	pr5|90		status.residue
013322  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
013323  aa   000000 5330 00	negl 	0
013324  aa  6 00171 0331 00	adl  	pr6|121		block_len
013325  aa  6 01324 7571 00	staq 	pr6|724
013326  aa   000004 2360 07	ldq  	4,dl
013327  aa  6 01324 3521 00	epp2 	pr6|724
013330  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
013331  aa  6 00152 3535 20	epp3 	pr6|106,*		info_ptr
013332  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
013333  aa  5 00135 00 0006	desc9a	pr5|93,ql		buffer.data
013334  aa  3 00000 00 0006	desc9a	pr3|0,ql		info_block
						STATEMENT 1 ON LINE 1816
     end do_io;

013335  aa  6 00436 6101 00	rtcd 	pr6|286
  END PROCEDURE do_io
BEGIN PROCEDURE retry
ENTRY TO retry                                              STATEMENT 1 ON LINE 1822
retry:
     proc;

013336  aa  6 00450 6501 00	spri4	pr6|296
						STATEMENT 1 ON LINE 1825
	if status.maj ^= ATTENTION then err_ct = err_ct + 1;

013337  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013340  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013341  aa  5 00131 2351 00	lda  	pr5|89		status.maj
013342  aa   000002 7350 00	als  	2
013343  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
013344  aa   100000 1150 03	cmpa 	32768,du
013345  aa   000002 6000 04	tze  	2,ic		013347
013346  aa  6 00175 0541 00	aos  	pr6|125		err_ct
						STATEMENT 1 ON LINE 1828
	if err_ct <= max_retries
	     then do;

013347  aa  6 00175 2361 00	ldq  	pr6|125		err_ct
013350  aa   000012 1160 07	cmpq 	10,dl
013351  aa   000047 6054 04	tpnz 	39,ic		013420
						STATEMENT 1 ON LINE 1830
		idcwp = addr (rst_idcw);

013352  aa  5 00000 3535 00	epp3 	pr5|0		buffer.rst_idcw
013353  aa  6 00100 2535 00	spri3	pr6|64		idcwp
						STATEMENT 1 ON LINE 1831
		idcw = restore_idcw_template;

013354  aa  6 00044 3701 20	epp4 	pr6|36,*
013355  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.command
013356  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
013357  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.device
013360  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
013361  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.ext
013362  aa  3 00000 7511 10	stca 	pr3|0,10		idcw.ext
013363  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.code
013364  aa  3 00000 6751 00	era  	pr3|0		idcw.code
013365  aa   700000 3750 07	ana  	229376,dl
013366  aa  3 00000 6551 00	ersa 	pr3|0		idcw.code
013367  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.ext_ctl
013370  aa  3 00000 6751 00	era  	pr3|0		idcw.ext_ctl
013371  aa   040000 3750 07	ana  	16384,dl
013372  aa  3 00000 6551 00	ersa 	pr3|0		idcw.ext_ctl
013373  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.control
013374  aa  3 00000 6751 00	era  	pr3|0		idcw.control
013375  aa   030000 3750 07	ana  	12288,dl
013376  aa  3 00000 6551 00	ersa 	pr3|0		idcw.control
013377  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.chan_cmd
013400  aa  3 00000 7511 02	stca 	pr3|0,02		idcw.chan_cmd
013401  ia  4 00012 2351 00	lda  	pr4|10		restore_idcw_template.count
013402  aa  3 00000 7511 01	stca 	pr3|0,01		idcw.count
						STATEMENT 1 ON LINE 1832
		idcw.device = bit (drive);

013403  aa  7 00076 2351 00	lda  	pr7|62		disk_data.drive
013404  aa   000002 6050 04	tpl  	2,ic		013406
013405  aa   000000 5310 00	neg  	0
013406  aa   000036 7350 00	als  	30
013407  aa   000006 7710 00	arl  	6
013410  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
						STATEMENT 1 ON LINE 1833
		dcw_offset = fixed (rel (addr (rst_idcw)));

013411  aa  5 00000 3515 00	epp1 	pr5|0		buffer.rst_idcw
013412  aa  1 00000 6351 00	eaa  	pr1|0
013413  aa   000066 7730 00	lrl  	54
013414  aa  6 00156 7561 00	stq  	pr6|110		dcw_offset
						STATEMENT 1 ON LINE 1835
		again = "1"b;

013415  aa   400000 2350 03	lda  	131072,du
013416  aa  6 00203 7551 00	sta  	pr6|131		again
						STATEMENT 1 ON LINE 1836
	     end;

013417  aa   000002 7100 04	tra  	2,ic		013421
						STATEMENT 1 ON LINE 1837
	     else call perm_err;

013420  aa   000104 6700 04	tsp4 	68,ic		013524
						STATEMENT 1 ON LINE 1839
     end retry;

013421  aa  6 00450 6101 00	rtcd 	pr6|296
  END PROCEDURE retry
BEGIN PROCEDURE delay_retry
ENTRY TO delay_retry                                        STATEMENT 1 ON LINE 1845
delay_retry:
     proc;

013422  aa  6 00456 6501 00	spri4	pr6|302
						STATEMENT 1 ON LINE 1852
	err_ct = err_ct + 1;

013423  aa  6 00175 0541 00	aos  	pr6|125		err_ct
						STATEMENT 1 ON LINE 1854
	if err_ct >= max_retries
	     then do;

013424  aa  6 00175 2361 00	ldq  	pr6|125		err_ct
013425  aa   000012 1160 07	cmpq 	10,dl
013426  aa   000004 6040 04	tmi  	4,ic		013432
						STATEMENT 1 ON LINE 1856
		err_ct = 0;

013427  aa  6 00175 4501 00	stz  	pr6|125		err_ct
						STATEMENT 1 ON LINE 1857
		call loud_retry;

013430  aa   000021 6700 04	tsp4 	17,ic		013451
						STATEMENT 1 ON LINE 1858
	     end;

013431  aa   000017 7100 04	tra  	15,ic		013450
						STATEMENT 1 ON LINE 1859
	     else do;

						STATEMENT 1 ON LINE 1860
		call timer_manager_$sleep (500000, "10"b);

013432  aa   765100 2370 04	ldaq 	-5568,ic		000532 = 000000000000 000001720440
013433  aa  6 01330 7571 00	staq 	pr6|728
013434  aa   400000 2350 03	lda  	131072,du
013435  aa  6 01327 7551 00	sta  	pr6|727
013436  aa  6 01330 3521 00	epp2 	pr6|728
013437  aa  6 01334 2521 00	spri2	pr6|732
013440  aa  6 01327 3521 00	epp2 	pr6|727
013441  aa  6 01336 2521 00	spri2	pr6|734
013442  aa  6 01332 6211 00	eax1 	pr6|730
013443  aa   010000 4310 07	fld  	4096,dl
013444  aa  6 00044 3701 20	epp4 	pr6|36,*
013445  la  4 00150 3521 20	epp2 	pr4|104,*		timer_manager_$sleep
013446  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1862
		call retry;

013447  aa   777667 6700 04	tsp4 	-73,ic		013336
						STATEMENT 1 ON LINE 1863
	     end;

						STATEMENT 1 ON LINE 1865
     end delay_retry;

013450  aa  6 00456 6101 00	rtcd 	pr6|302
  END PROCEDURE delay_retry
BEGIN PROCEDURE loud_retry
ENTRY TO loud_retry                                         STATEMENT 1 ON LINE 1871
loud_retry:
     proc;

013451  aa  6 00464 6501 00	spri4	pr6|308
						STATEMENT 1 ON LINE 1876
	call command_query_ (addr (query_info), answer, "rdisk_",
	     "Your disk drive (No. ^d) needs attention.  Please have the operator
check it out and reply appropriately _a_f_t_e_r the device has been checked.

Do you wish to retry?", drive);

013452  aa  6 00130 3735 00	epp7 	pr6|88		query_info
013453  aa  6 01340 6535 00	spri7	pr6|736
013454  aa   765060 2370 04	ldaq 	-5584,ic		000534 = 162144151163 153137000000
013455  aa  6 01342 7571 00	staq 	pr6|738
013456  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
013457  aa   766457 00 0254	desc9a	-4817,172		002135 = 131157165162
013460  aa  6 01344 00 0254	desc9a	pr6|740,172
013461  aa  6 01340 3521 00	epp2 	pr6|736
013462  aa  6 01422 2521 00	spri2	pr6|786
013463  aa  6 00211 3521 00	epp2 	pr6|137		answer
013464  aa  6 01424 2521 00	spri2	pr6|788
013465  aa  6 01342 3521 00	epp2 	pr6|738
013466  aa  6 01426 2521 00	spri2	pr6|790
013467  aa  6 01344 3521 00	epp2 	pr6|740
013470  aa  6 01430 2521 00	spri2	pr6|792
013471  aa  6 00136 3715 20	epp5 	pr6|94,*		disk_ptr
013472  aa  5 00076 3521 00	epp2 	pr5|62		disk_data.drive
013473  aa  6 01432 2521 00	spri2	pr6|794
013474  aa   765025 3520 04	epp2 	-5611,ic		000521 = 464000000000
013475  aa  6 01434 2521 00	spri2	pr6|796
013476  aa   764726 3520 04	epp2 	-5674,ic		000424 = 530000000003
013477  aa  6 01436 2521 00	spri2	pr6|798
013500  aa   765005 3520 04	epp2 	-5627,ic		000505 = 524000000006
013501  aa  6 01440 2521 00	spri2	pr6|800
013502  aa   764721 3520 04	epp2 	-5679,ic		000423 = 524000000254
013503  aa  6 01442 2521 00	spri2	pr6|802
013504  aa   764716 3520 04	epp2 	-5682,ic		000422 = 404000000006
013505  aa  6 01444 2521 00	spri2	pr6|804
013506  aa  6 01420 6211 00	eax1 	pr6|784
013507  aa   024000 4310 07	fld  	10240,dl
013510  aa  6 00044 3701 20	epp4 	pr6|36,*
013511  la  4 00146 3521 20	epp2 	pr4|102,*		command_query_
013512  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1882
	if answer = "yes"
	     then call retry;

013513  aa  6 00210 7271 00	lxl7 	pr6|136		answer
013514  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
013515  aa  6 00211 00 0017	desc9a	pr6|137,x7	answer
013516  aa   764705 00 0003	desc9a	-5691,3		000421 = 171145163000
013517  aa   000003 6010 04	tnz  	3,ic		013522
013520  aa   777616 6700 04	tsp4 	-114,ic		013336
013521  aa   000002 7100 04	tra  	2,ic		013523
						STATEMENT 1 ON LINE 1884
	     else call perm_err;

013522  aa   000002 6700 04	tsp4 	2,ic		013524
						STATEMENT 1 ON LINE 1886
     end loud_retry;

013523  aa  6 00464 6101 00	rtcd 	pr6|308
  END PROCEDURE loud_retry
BEGIN PROCEDURE perm_err
ENTRY TO perm_err                                           STATEMENT 1 ON LINE 1893
perm_err:
     proc;

013524  aa  6 00472 6501 00	spri4	pr6|314
						STATEMENT 1 ON LINE 1904
	call ioi_$get_detailed_status (devx, found, buffer.control_info.rsr_data, code);

013525  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013526  aa  7 00075 3521 00	epp2 	pr7|61		disk_data.devx
013527  aa  6 01450 2521 00	spri2	pr6|808
013530  aa  6 00500 3521 00	epp2 	pr6|320		found
013531  aa  6 01452 2521 00	spri2	pr6|810
013532  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013533  aa  5 00115 3521 00	epp2 	pr5|77		buffer.rsr_data
013534  aa  6 01454 2521 00	spri2	pr6|812
013535  aa  6 00157 3521 00	epp2 	pr6|111		code
013536  aa  6 01456 2521 00	spri2	pr6|814
013537  aa   764755 3520 04	epp2 	-5651,ic		000514 = 404000000021
013540  aa  6 01460 2521 00	spri2	pr6|816
013541  aa   764754 3520 04	epp2 	-5652,ic		000515 = 514000000001
013542  aa  6 01462 2521 00	spri2	pr6|818
013543  aa   764655 3520 04	epp2 	-5715,ic		000420 = 516000000110
013544  aa  6 01464 2521 00	spri2	pr6|820
013545  aa   764753 3520 04	epp2 	-5653,ic		000520 = 404000000043
013546  aa  6 01466 2521 00	spri2	pr6|822
013547  aa  6 01446 6211 00	eax1 	pr6|806
013550  aa   020000 4310 07	fld  	8192,dl
013551  aa  6 00044 3701 20	epp4 	pr6|36,*
013552  la  4 00142 3521 20	epp2 	pr4|98,*		ioi_$get_detailed_status
013553  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1906
	idcwp = addrel (buf_ptr, offset);

013554  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013555  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013556  aa  5 00127 2361 00	ldq  	pr5|87		buffer.offset
013557  aa  5 00000 5075 06	awd  	pr5|0,ql
013560  aa  6 00100 6515 00	spri5	pr6|64		idcwp
						STATEMENT 1 ON LINE 1907
	do while (idcw.code ^= "111"b & fixed (rel (idcwp)) > 0);

013561  aa   000000 0110 03	nop  	0,du
013562  aa  6 00100 2351 20	lda  	pr6|64,*		idcw.code
013563  aa   000022 7350 00	als  	18
013564  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
013565  aa   700000 1150 03	cmpa 	229376,du
013566  aa   000010 6000 04	tze  	8,ic		013576
013567  aa  6 00100 6351 20	eaa  	pr6|64,*		idcwp
013570  aa   000066 7730 00	lrl  	54
013571  aa   000005 6044 04	tmoz 	5,ic		013576
						STATEMENT 1 ON LINE 1909
	     idcwp = addrel (idcwp, -1);

013572  aa  6 00100 3521 20	epp2 	pr6|64,*		idcwp
013573  aa   777777 0520 03	adwp2	262143,du
013574  aa  6 00100 2521 00	spri2	pr6|64		idcwp
						STATEMENT 1 ON LINE 1910
	     end;

013575  aa   777765 7100 04	tra  	-11,ic		013562
						STATEMENT 1 ON LINE 1911
	dcwp = addrel (idcwp, 1);

013576  aa  6 00100 3521 20	epp2 	pr6|64,*		idcwp
013577  aa   000001 0520 03	adwp2	1,du
013600  aa  6 00102 2521 00	spri2	pr6|66		dcwp
						STATEMENT 1 ON LINE 1913
	disk_info_ptr = addr (rcp_data);

013601  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013602  aa  7 00152 3735 00	epp7 	pr7|106		disk_data.rcp_data
013603  aa  6 00106 6535 00	spri7	pr6|70		disk_info_ptr
						STATEMENT 1 ON LINE 1914
	call sub_err_ (0, "rdisk_", "c", null, retval,
	     "Unrecoverable error on ^a device ^a, sector ^o (^d.).^/IOM Status:^-^w ^w^/IDCW/DCW Pair:^-^w ^w",
	     device_names (dev_type), disk_info.device_name, key, key, substr (string (status), 1, 36),
	     substr (string (status), 37, 36), idcw, dcw);

013604  aa  6 01470 4501 00	stz  	pr6|824
013605  aa   764727 2370 04	ldaq 	-5673,ic		000534 = 162144151163 153137000000
013606  aa  6 01472 7571 00	staq 	pr6|826
013607  aa   143000 2350 03	lda  	50688,du
013610  aa  6 01471 7551 00	sta  	pr6|825
013611  aa   765005 3714 24	epp5 	-5627,ic*
013612  aa  6 01474 6515 00	spri5	pr6|828
013613  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
013614  aa   766240 00 0140	desc9a	-4960,96		002053 = 125156162145
013615  aa  6 01476 00 0140	desc9a	pr6|830,96
013616  aa  6 00136 3535 20	epp3 	pr6|94,*		disk_ptr
013617  aa  3 00124 3515 20	epp1 	pr3|84,*		disk_data.buf_ptr
013620  aa  1 00131 2351 00	lda  	pr1|89
013621  aa  6 01526 7551 00	sta  	pr6|854
013622  aa  1 00132 2351 00	lda  	pr1|90
013623  aa  6 01527 7551 00	sta  	pr6|855
013624  aa  6 01470 3521 00	epp2 	pr6|824
013625  aa  6 01532 2521 00	spri2	pr6|858
013626  aa  6 01472 3521 00	epp2 	pr6|826
013627  aa  6 01534 2521 00	spri2	pr6|860
013630  aa  6 01471 3521 00	epp2 	pr6|825
013631  aa  6 01536 2521 00	spri2	pr6|862
013632  aa  6 01474 3521 00	epp2 	pr6|828
013633  aa  6 01540 2521 00	spri2	pr6|864
013634  aa  6 00305 3521 00	epp2 	pr6|197		retval
013635  aa  6 01542 2521 00	spri2	pr6|866
013636  aa  6 01476 3521 00	epp2 	pr6|830
013637  aa  6 01544 2521 00	spri2	pr6|868
013640  aa  3 00074 7271 00	lxl7 	pr3|60		disk_data.dev_type
013641  ta   000311 3520 17	epp2 	201,7
013642  aa  6 01546 2521 00	spri2	pr6|870
013643  aa  7 00004 3521 00	epp2 	pr7|4		disk_info.device_name
013644  aa  6 01550 2521 00	spri2	pr6|872
013645  aa  6 00165 3521 00	epp2 	pr6|117		key
013646  aa  6 01552 2521 00	spri2	pr6|874
013647  aa  6 01554 2521 00	spri2	pr6|876
013650  aa  6 01526 3521 00	epp2 	pr6|854
013651  aa  6 01556 2521 00	spri2	pr6|878
013652  aa  6 01527 3521 00	epp2 	pr6|855
013653  aa  6 01560 2521 00	spri2	pr6|880
013654  aa  6 00100 3521 20	epp2 	pr6|64,*		idcw
013655  aa  6 01562 2521 00	spri2	pr6|882
013656  aa  6 00102 3521 20	epp2 	pr6|66,*		dcw
013657  aa  6 01564 2521 00	spri2	pr6|884
013660  aa   764626 3520 04	epp2 	-5738,ic		000506 = 404000000005
013661  aa  6 01566 2521 00	spri2	pr6|886
013662  aa   764623 3520 04	epp2 	-5741,ic		000505 = 524000000006
013663  aa  6 01570 2521 00	spri2	pr6|888
013664  aa   764543 3520 04	epp2 	-5789,ic		000427 = 524000000001
013665  aa  6 01572 2521 00	spri2	pr6|890
013666  aa   764633 3520 04	epp2 	-5733,ic		000521 = 464000000000
013667  aa  6 01574 2521 00	spri2	pr6|892
013670  aa   764630 3520 04	epp2 	-5736,ic		000520 = 404000000043
013671  aa  6 01576 2521 00	spri2	pr6|894
013672  aa   764525 3520 04	epp2 	-5803,ic		000417 = 524000000140
013673  aa  6 01600 2521 00	spri2	pr6|896
013674  aa   764602 3520 04	epp2 	-5758,ic		000476 = 524000000004
013675  aa  6 01602 2521 00	spri2	pr6|898
013676  aa   764537 3520 04	epp2 	-5793,ic		000435 = 524000000010
013677  aa  6 01604 2521 00	spri2	pr6|900
013700  aa   764617 3520 04	epp2 	-5745,ic		000517 = 404000000025
013701  aa  6 01606 2521 00	spri2	pr6|902
013702  aa  6 01610 2521 00	spri2	pr6|904
013703  aa   764551 3520 04	epp2 	-5783,ic		000454 = 514000000044
013704  aa  6 01612 2521 00	spri2	pr6|906
013705  aa  6 01614 2521 00	spri2	pr6|908
013706  aa   765264 3520 04	epp2 	-5452,ic		001172 = 504000000010
013707  aa  6 01616 2521 00	spri2	pr6|910
013710  aa   765132 3520 04	epp2 	-5542,ic		001042 = 504000000005
013711  aa  6 01620 2521 00	spri2	pr6|912
013712  aa  6 01530 6211 00	eax1 	pr6|856
013713  aa   070000 4310 07	fld  	28672,dl
013714  aa  6 00044 3701 20	epp4 	pr6|36,*
013715  la  4 00120 3521 20	epp2 	pr4|80,*		sub_err_
013716  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1919
	if found then call ioa_$ioa_stream ("error_output", "Detailed Device Status: ^( ^2.4b^) (hex)", based_rsr_data);

013717  aa  6 00500 2351 00	lda  	pr6|320		found
013720  aa   400000 3150 03	cana 	131072,du
013721  aa   000033 6000 04	tze  	27,ic		013754
013722  aa   764704 2370 04	ldaq 	-5692,ic		000626 = 145162162157 162137157165
013723  aa  6 01446 7571 00	staq 	pr6|806
013724  aa   764704 2350 04	lda  	-5692,ic		000630 = 164160165164
013725  aa  6 01450 7551 00	sta  	pr6|808
013726  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
013727  aa   765310 00 0050	desc9a	-5432,40		001236 = 104145164141
013730  aa  6 01476 00 0050	desc9a	pr6|830,40
013731  aa  6 01446 3521 00	epp2 	pr6|806
013732  aa  6 01532 2521 00	spri2	pr6|858
013733  aa  6 01476 3521 00	epp2 	pr6|830
013734  aa  6 01534 2521 00	spri2	pr6|860
013735  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013736  aa  7 00124 3715 20	epp5 	pr7|84,*		disk_data.buf_ptr
013737  aa  5 00115 3521 00	epp2 	pr5|77		based_rsr_data
013740  aa  6 01536 2521 00	spri2	pr6|862
013741  aa   764455 3520 04	epp2 	-5843,ic		000416 = 524000000014
013742  aa  6 01540 2521 00	spri2	pr6|864
013743  aa   764535 3520 04	epp2 	-5795,ic		000500 = 524000000050
013744  aa  6 01542 2521 00	spri2	pr6|866
013745  aa   764741 3520 04	epp2 	-5663,ic		000706 = 516100000010
013746  aa  6 01544 2521 00	spri2	pr6|868
013747  aa  6 01530 6211 00	eax1 	pr6|856
013750  aa   014000 4310 07	fld  	6144,dl
013751  aa  6 00044 3701 20	epp4 	pr6|36,*
013752  la  4 00144 3521 20	epp2 	pr4|100,*		ioa_$ioa_stream
013753  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1921
	errors = errors + 1;

013754  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
013755  aa  7 00077 0541 00	aos  	pr7|63		disk_data.errors
						STATEMENT 1 ON LINE 1923
	code = error_table_$device_parity;

013756  aa  6 00044 3701 20	epp4 	pr6|36,*
013757  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$device_parity
013760  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 1924
	goto exit;

013761  aa   767476 7100 04	tra  	-4290,ic		003457
						STATEMENT 1 ON LINE 1926
     end perm_err;

  END PROCEDURE perm_err
BEGIN PROCEDURE get_next_mode
ENTRY TO get_next_mode                                      STATEMENT 1 ON LINE 2484
get_next_mode:
     proc;

013762  aa  6 00502 6501 00	spri4	pr6|322
						STATEMENT 1 ON LINE 2487
	if mode_len > 0
	     then do;

013763  aa  6 00163 2361 00	ldq  	pr6|115		mode_len
013764  aa   000060 6044 04	tmoz 	48,ic		014044
						STATEMENT 1 ON LINE 2490
		new_modes = substr (new_modes, mode_start, mode_len);

013765  aa  6 00164 2351 00	lda  	pr6|116		mode_start
013766  aa  040 100 100 545	mlr  	(pr,rl,al),(pr),fill(040)
013767  aa  6 00265 60 0006	desc9a	pr6|181(3),ql	new_modes
013770  aa  6 00266 00 0030	desc9a	pr6|182,24	new_modes
						STATEMENT 1 ON LINE 2493
		i = index (new_modes, ",");

013771  aa  000 003 124 500	scm  	(pr),(du),mask(000)
013772  aa  6 00266 00 0030	desc9a	pr6|182,24	new_modes
013773  aa   054000 00 0001	desc9a	22528,1
013774  aa  6 00056 0001 00	arg  	pr6|46
013775  aa  6 00056 2361 00	ldq  	pr6|46
013776  aa   000002 6070 04	ttf  	2,ic		014000
013777  aa   000001 3360 07	lcq  	1,dl
014000  aa   000001 0760 07	adq  	1,dl
014001  aa  6 00172 7561 00	stq  	pr6|122		i
						STATEMENT 1 ON LINE 2494
		if i = 0
		     then do;

014002  aa   000017 6010 04	tnz  	15,ic		014021
						STATEMENT 1 ON LINE 2496
			i = index (new_modes, " ");

014003  aa  000 003 124 500	scm  	(pr),(du),mask(000)
014004  aa  6 00266 00 0030	desc9a	pr6|182,24	new_modes
014005  aa   040000 00 0001	desc9a	16384,1
014006  aa  6 00056 0001 00	arg  	pr6|46
014007  aa  6 00056 2361 00	ldq  	pr6|46
014010  aa   000002 6070 04	ttf  	2,ic		014012
014011  aa   000001 3360 07	lcq  	1,dl
014012  aa   000001 0760 07	adq  	1,dl
014013  aa  6 00172 7561 00	stq  	pr6|122		i
						STATEMENT 1 ON LINE 2497
			if i = 0 then i = mode_len + 1;

014014  aa   000005 6010 04	tnz  	5,ic		014021
014015  aa  6 00163 2351 00	lda  	pr6|115		mode_len
014016  aa   000044 7330 00	lrs  	36
014017  aa   000001 0330 07	adl  	1,dl
014020  aa  6 00172 7561 00	stq  	pr6|122		i
						STATEMENT 1 ON LINE 2498
		     end;

						STATEMENT 1 ON LINE 2500
		mode_len = mode_len - i;

014021  aa  6 00163 3361 00	lcq  	pr6|115		mode_len
014022  aa   000044 7770 00	llr  	36
014023  aa   000044 7330 00	lrs  	36
014024  aa  6 00172 0331 00	adl  	pr6|122		i
014025  aa   000000 5330 00	negl 	0
014026  aa  6 00163 7561 00	stq  	pr6|115		mode_len
						STATEMENT 1 ON LINE 2501
		mode_start = i + 1;

014027  aa  6 00172 2361 00	ldq  	pr6|122		i
014030  aa   000001 0760 07	adq  	1,dl
014031  aa  6 00164 7561 00	stq  	pr6|116		mode_start
						STATEMENT 1 ON LINE 2502
		next_mode = substr (new_modes, 1, i - 1);

014032  aa  6 00172 2361 00	ldq  	pr6|122		i
014033  aa   000001 1760 07	sbq  	1,dl
014034  aa   000010 1160 07	cmpq 	8,dl
014035  aa   000002 6040 04	tmi  	2,ic		014037
014036  aa   000010 2360 07	ldq  	8,dl
014037  aa  6 00274 7561 00	stq  	pr6|188		next_mode
014040  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
014041  aa  6 00266 00 0006	desc9a	pr6|182,ql	new_modes
014042  aa  6 00275 00 0006	desc9a	pr6|189,ql	next_mode
						STATEMENT 1 ON LINE 2505
	     end;

014043  aa   000002 7100 04	tra  	2,ic		014045
						STATEMENT 1 ON LINE 2507
	     else next_mode = "";

014044  aa  6 00274 4501 00	stz  	pr6|188		next_mode
						STATEMENT 1 ON LINE 2509
     end get_next_mode;

014045  aa  6 00502 6101 00	rtcd 	pr6|322
  END PROCEDURE get_next_mode
BEGIN PROCEDURE set_mode
ENTRY TO set_mode                                           STATEMENT 1 ON LINE 2513
set_mode:
     proc;

014046  aa  6 00510 6501 00	spri4	pr6|328
						STATEMENT 1 ON LINE 2516
	not_sw = (substr (next_mode, 1, 1) = "^");

014047  aa  6 00275 2351 00	lda  	pr6|189		next_mode
014050  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
014051  aa   136000 1150 03	cmpa 	48128,du
014052  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
014053  aa  6 00204 7551 00	sta  	pr6|132		not_sw
						STATEMENT 1 ON LINE 2518
	i = index (mode_string, substr (next_mode, 1 + fixed (not_sw)));

014054  aa   000107 7730 00	lrl  	71
014055  aa  6 01622 7571 00	staq 	pr6|914
014056  aa   000001 0330 07	adl  	1,dl
014057  aa   000000 5330 00	negl 	0
014060  aa   000001 0330 07	adl  	1,dl
014061  aa   000000 5330 00	negl 	0
014062  aa   000000 5330 00	negl 	0
014063  aa  6 00274 0331 00	adl  	pr6|188		next_mode
014064  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
014065  aa  6 01624 7571 00	staq 	pr6|916
014066  aa  7 00141 2361 00	ldq  	pr7|97		disk_data.mode_string
014067  aa  7 00142 3521 00	epp2 	pr7|98		disk_data.mode_string
014070  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
014071  aa  6 01625 2361 00	ldq  	pr6|917
014072  aa  6 01623 2351 00	lda  	pr6|915
014073  aa  6 00275 3521 00	epp2 	pr6|189		next_mode
014074  aa  2 00000 5005 05	a9bd 	pr2|0,al
014075  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
014076  aa  6 00172 7561 00	stq  	pr6|122		i
						STATEMENT 1 ON LINE 2521
	if i <= 1
	     then if not_sw
		     then mode_string = "^" || mode_string;

014077  aa   000001 1160 07	cmpq 	1,dl
014100  aa   000026 6054 04	tpnz 	22,ic		014126
014101  aa  6 00204 2351 00	lda  	pr6|132		not_sw
014102  aa   000101 6000 04	tze  	65,ic		014203
014103  aa   000001 2360 07	ldq  	1,dl
014104  aa  7 00141 0761 00	adq  	pr7|97		disk_data.mode_string
014105  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
014106  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
014107  aa   003665 00 0001	desc9a	1973,1		017773 = 136000000000
014110  aa  2 00000 00 0001	desc9a	pr2|0,1
014111  aa  7 00141 7271 00	lxl7 	pr7|97		disk_data.mode_string
014112  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
014113  aa  7 00142 00 0017	desc9a	pr7|98,x7		disk_data.mode_string
014114  aa  2 00000 20 0017	desc9a	pr2|0(1),x7
014115  aa   000040 1160 07	cmpq 	32,dl
014116  aa   000002 6040 04	tmi  	2,ic		014120
014117  aa   000040 2360 07	ldq  	32,dl
014120  aa  7 00141 7561 00	stq  	pr7|97		disk_data.mode_string
014121  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
014122  aa  2 00000 00 0006	desc9a	pr2|0,ql
014123  aa  7 00142 00 0006	desc9a	pr7|98,ql		disk_data.mode_string
						STATEMENT 1 ON LINE 2524
		     else ;

014124  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
014125  aa   000056 7100 04	tra  	46,ic		014203
						STATEMENT 1 ON LINE 2526
	else if not_sw & (substr (mode_string, i - 1, 1) ^= "^")
						/* insert a  "^" */
	     then substr (mode_string, i) = "^" || substr (mode_string, i);

014126  aa  000 100 100 506	mlr  	(pr,ql),(pr),fill(000)
014127  aa  7 00141 40 0001	desc9a	pr7|97(2),1	disk_data.mode_string
014130  aa  6 01626 00 0004	desc9a	pr6|918,4		disk_data.mode_string
014131  aa  6 00204 2351 00	lda  	pr6|132		not_sw
014132  aa   000026 6000 04	tze  	22,ic		014160
014133  aa  6 01626 2351 00	lda  	pr6|918		disk_data.mode_string
014134  aa   136000 1150 03	cmpa 	48128,du
014135  aa   000023 6000 04	tze  	19,ic		014160
014136  aa   000001 1760 07	sbq  	1,dl
014137  aa  6 01627 7561 00	stq  	pr6|919
014140  aa  7 00141 2361 00	ldq  	pr7|97		disk_data.mode_string
014141  aa  6 01627 1761 00	sbq  	pr6|919
014142  aa   000000 6260 06	eax6 	0,ql
014143  aa   000001 0760 07	adq  	1,dl
014144  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
014145  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
014146  aa   003626 00 0001	desc9a	1942,1		017773 = 136000000000
014147  aa  2 00000 00 0001	desc9a	pr2|0,1
014150  aa  6 00172 7271 00	lxl7 	pr6|122		i
014151  aa  040 140 100 557	mlr  	(pr,rl,x7),(pr,rl),fill(040)
014152  aa  7 00141 60 0016	desc9a	pr7|97(3),x6	disk_data.mode_string
014153  aa  2 00000 20 0016	desc9a	pr2|0(1),x6
014154  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
014155  aa  2 00000 00 0006	desc9a	pr2|0,ql
014156  aa  7 00141 60 0016	desc9a	pr7|97(3),x6	disk_data.mode_string
014157  aa   000024 7100 04	tra  	20,ic		014203
						STATEMENT 1 ON LINE 2530
	else if ^not_sw & (substr (mode_string, i - 1, 1) = "^")
	     then					/* delete a "^" */
		substr (mode_string, i - 1) = substr (mode_string, i);

014160  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
014161  aa  6 00204 2351 00	lda  	pr6|132		not_sw
014162  aa   000021 6010 04	tnz  	17,ic		014203
014163  aa  6 01626 2351 00	lda  	pr6|918		disk_data.mode_string
014164  aa   136000 1150 03	cmpa 	48128,du
014165  aa   000016 6010 04	tnz  	14,ic		014203
014166  aa   000001 1760 07	sbq  	1,dl
014167  aa  6 01626 7561 00	stq  	pr6|918
014170  aa   000001 1760 07	sbq  	1,dl
014171  aa  6 01627 7561 00	stq  	pr6|919
014172  aa  7 00141 2361 00	ldq  	pr7|97		disk_data.mode_string
014173  aa  6 01627 1761 00	sbq  	pr6|919
014174  aa   000000 6260 06	eax6 	0,ql
014175  aa  7 00141 2361 00	ldq  	pr7|97		disk_data.mode_string
014176  aa  6 01626 1761 00	sbq  	pr6|918
014177  aa  6 00172 7271 00	lxl7 	pr6|122		i
014200  aa  040 157 100 557	mlr  	(pr,rl,x7),(pr,rl,x7),fill(040)
014201  aa  7 00141 60 0006	desc9a	pr7|97(3),ql	disk_data.mode_string
014202  aa  7 00141 40 0016	desc9a	pr7|97(2),x6	disk_data.mode_string
						STATEMENT 1 ON LINE 2534
     end set_mode;

014203  aa  6 00510 6101 00	rtcd 	pr6|328
  END PROCEDURE set_mode
BEGIN PROCEDURE delete_attach
ENTRY TO delete_attach                                      STATEMENT 1 ON LINE 2624
delete_attach:
     proc (detach_rcp);

014204  aa  6 00516 6501 00	spri4	pr6|334
014205  aa  6 00520 2521 00	spri2	pr6|336
						STATEMENT 1 ON LINE 2632
	count_att = 0;

014206  aa  6 00525 4501 00	stz  	pr6|341		count_att
						STATEMENT 1 ON LINE 2633
	if attachments_ptr = null () then detach_rcp = "1"b;

014207  aa  6 00044 3701 20	epp4 	pr6|36,*
014210  ia  4 00010 2371 00	ldaq 	pr4|8		attachments_ptr
014211  aa   764405 6770 04	eraq 	-5883,ic		000616 = 077777000043 000001000000
014212  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014213  aa   000005 6010 04	tnz  	5,ic		014220
014214  aa  2 00002 3735 20	epp7 	pr2|2,*
014215  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
014216  aa   000000 00 0000	descb	0,0
014217  aa  7 00000 00 0001	descb	pr7|0,1		detach_rcp
						STATEMENT 1 ON LINE 2635
	if attachments.array (att_dev_idx).sv (1).this_sv = -1
						/* attached as one device can only be one attachment */
	     then count_att = 1;

014220  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
014221  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
014222  aa   000016 4020 07	mpy  	14,dl
014223  aa  6 01630 7561 00	stq  	pr6|920
014224  ia  4 00010 3715 20	epp5 	pr4|8,*		attachments_ptr
014225  aa  5 77766 2361 06	ldq  	pr5|-10,ql	attachments.this_sv
014226  aa   003543 1160 04	cmpq 	1891,ic		017771 = 777777777777
014227  aa   000004 6010 04	tnz  	4,ic		014233
014230  aa   000001 2360 07	ldq  	1,dl
014231  aa  6 00525 7561 00	stq  	pr6|341		count_att
014232  aa   000030 7100 04	tra  	24,ic		014262
						STATEMENT 1 ON LINE 2638
	     else do sv_att_idx = 1 to 3;

014233  aa   000001 2360 07	ldq  	1,dl
014234  aa  6 00524 7561 00	stq  	pr6|340		sv_att_idx
014235  aa   000000 0110 03	nop  	0,du
014236  aa  6 00524 2361 00	ldq  	pr6|340		sv_att_idx
014237  aa   000003 1160 07	cmpq 	3,dl
014240  aa   000022 6054 04	tpnz 	18,ic		014262
						STATEMENT 1 ON LINE 2639
		     if attachments.array (att_dev_idx).sv (sv_att_idx).this_iocbp ^= null ()
			then count_att = count_att + 1;

014241  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
014242  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
014243  aa   000016 4020 07	mpy  	14,dl
014244  aa  6 01630 7561 00	stq  	pr6|920
014245  aa  6 00524 2361 00	ldq  	pr6|340		sv_att_idx
014246  aa   000002 7360 00	qls  	2
014247  aa  6 01630 0761 00	adq  	pr6|920
014250  aa  6 01630 7561 00	stq  	pr6|920
014251  aa  6 00044 3701 20	epp4 	pr6|36,*
014252  ia  4 00010 3715 20	epp5 	pr4|8,*		attachments_ptr
014253  aa  5 77764 2371 06	ldaq 	pr5|-12,ql	attachments.this_iocbp
014254  aa   764342 6770 04	eraq 	-5918,ic		000616 = 077777000043 000001000000
014255  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014256  aa   000002 6000 04	tze  	2,ic		014260
014257  aa  6 00525 0541 00	aos  	pr6|341		count_att
						STATEMENT 1 ON LINE 2641
		     end;

014260  aa  6 00524 0541 00	aos  	pr6|340		sv_att_idx
014261  aa   777755 7100 04	tra  	-19,ic		014236
						STATEMENT 1 ON LINE 2642
	attachments.array (att_dev_idx).sv (att_sv_idx).this_iocbp = null ();

014262  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
014263  aa  7 00106 2361 00	ldq  	pr7|70		disk_data.att_dev_idx
014264  aa   000016 4020 07	mpy  	14,dl
014265  aa  6 01630 7561 00	stq  	pr6|920
014266  aa  7 00107 2361 00	ldq  	pr7|71		disk_data.att_sv_idx
014267  aa   000002 7360 00	qls  	2
014270  aa  6 01630 0761 00	adq  	pr6|920
014271  aa   000000 6270 06	eax7 	0,ql
014272  aa   764324 2370 04	ldaq 	-5932,ic		000616 = 077777000043 000001000000
014273  aa  6 00044 3701 20	epp4 	pr6|36,*
014274  ia  4 00010 3715 20	epp5 	pr4|8,*		attachments_ptr
014275  aa  5 77764 7571 17	staq 	pr5|-12,7		attachments.this_iocbp
						STATEMENT 1 ON LINE 2643
	if count_att = 1
	     then do;

014276  aa  6 00525 2361 00	ldq  	pr6|341		count_att
014277  aa   000001 1160 07	cmpq 	1,dl
014300  aa   000015 6010 04	tnz  	13,ic		014315
						STATEMENT 1 ON LINE 2645
		detach_rcp = "1"b;

014301  aa  6 00520 3735 20	epp7 	pr6|336,*
014302  aa  7 00002 3535 20	epp3 	pr7|2,*
014303  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
014304  aa   000000 00 0000	descb	0,0
014305  aa  3 00000 00 0001	descb	pr3|0,1		detach_rcp
						STATEMENT 1 ON LINE 2646
		attachments.array (att_dev_idx).device_att = "";

014306  aa  6 00136 3515 20	epp1 	pr6|94,*		disk_ptr
014307  aa  1 00106 2361 00	ldq  	pr1|70		disk_data.att_dev_idx
014310  aa   000016 4020 07	mpy  	14,dl
014311  aa   000000 6260 06	eax6 	0,ql
014312  aa   764302 2370 04	ldaq 	-5950,ic		000614 = 040040040040 040040040040
014313  aa  5 77764 7551 16	sta  	pr5|-12,6		attachments.device_att
014314  aa  5 77765 7561 16	stq  	pr5|-11,6		attachments.device_att
						STATEMENT 1 ON LINE 2647
	     end;

						STATEMENT 1 ON LINE 2648
	attachments.number_attached = attachments.number_attached - 1;

014315  aa   000001 3360 07	lcq  	1,dl
014316  aa  5 00000 0561 00	asq  	pr5|0		attachments.number_attached
						STATEMENT 1 ON LINE 2649
	if attachments.number_attached = 0
	     then do;

014317  aa  5 00000 2361 00	ldq  	pr5|0		attachments.number_attached
014320  aa   000006 6010 04	tnz  	6,ic		014326
						STATEMENT 1 ON LINE 2651
		free attachments in (system_area);

014321  ia  4 00010 3715 00	epp5 	pr4|8		attachments_ptr
014322  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 2652
		attachments_ptr = null ();

014323  aa   764273 2370 04	ldaq 	-5957,ic		000616 = 077777000043 000001000000
014324  aa  6 00044 3701 20	epp4 	pr6|36,*
014325  ia  4 00010 7571 00	staq 	pr4|8		attachments_ptr
						STATEMENT 1 ON LINE 2653
	     end;

						STATEMENT 1 ON LINE 2654
	return;

014326  aa  6 00516 6101 00	rtcd 	pr6|334
						STATEMENT 1 ON LINE 2655
     end delete_attach;

  END PROCEDURE delete_attach
BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 2662
setup:
     proc (setup_input_arg);

014327  aa  6 00526 6501 00	spri4	pr6|342
014330  aa  6 00530 2521 00	spri2	pr6|344
014331  aa  2 00002 3521 01	epp2 	pr2|2,au
014332  aa  6 00532 2521 00	spri2	pr6|346
014333  aa  2 00000 2361 20	ldq  	pr2|0,*
014334  aa   000002 6040 04	tmi  	2,ic		014336
014335  aa   777777 3760 07	anq  	262143,dl
014336  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
014337  aa  6 01631 7561 00	stq  	pr6|921
						STATEMENT 1 ON LINE 2675
	code = 0;

014340  aa  6 00157 4501 00	stz  	pr6|111		code
						STATEMENT 1 ON LINE 2677
	desired_switch_state = setup_input_arg;

014341  aa   000014 1160 07	cmpq 	12,dl
014342  aa   000002 6040 04	tmi  	2,ic		014344
014343  aa   000014 2360 07	ldq  	12,dl
014344  aa  6 00534 7561 00	stq  	pr6|348		desired_switch_state
014345  aa  6 00530 3735 20	epp7 	pr6|344,*
014346  aa  7 00002 3715 20	epp5 	pr7|2,*
014347  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
014350  aa  5 00000 00 0006	desc9a	pr5|0,ql		setup_input_arg
014351  aa  6 00535 00 0006	desc9a	pr6|349,ql	desired_switch_state
						STATEMENT 1 ON LINE 2678
	iocb_ptr = a_iocb_ptr;

014352  aa  6 00032 3535 20	epp3 	pr6|26,*
014353  aa  3 00002 3515 20	epp1 	pr3|2,*		a_iocb_ptr
014354  aa  1 00000 3515 20	epp1 	pr1|0,*		a_iocb_ptr
014355  aa  6 00140 2515 00	spri1	pr6|96		iocb_ptr
						STATEMENT 1 ON LINE 2679
	real_iocb_ptr = iocb_ptr -> actual_iocb_ptr;

014356  aa  1 00012 3715 20	epp5 	pr1|10,*		iocb.actual_iocb_ptr
014357  aa  6 00142 6515 00	spri5	pr6|98		real_iocb_ptr
						STATEMENT 1 ON LINE 2680
	disk_ptr = real_iocb_ptr -> attach_data_ptr;

014360  aa  5 00016 3515 20	epp1 	pr5|14,*		iocb.attach_data_ptr
014361  aa  6 00136 2515 00	spri1	pr6|94		disk_ptr
						STATEMENT 1 ON LINE 2682
	if real_iocb_ptr -> attach_descrip_ptr = null then call error (error_table_$not_attached, "");

014362  aa  5 00014 2371 00	ldaq 	pr5|12		iocb.attach_descrip_ptr
014363  aa   764233 6770 04	eraq 	-5989,ic		000616 = 077777000043 000001000000
014364  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014365  aa   000016 6010 04	tnz  	14,ic		014403
014366  aa  6 00044 3701 20	epp4 	pr6|36,*
014367  la  4 00060 3521 20	epp2 	pr4|48,*		error_table_$not_attached
014370  aa  6 01636 2521 00	spri2	pr6|926
014371  aa  6 01632 3521 00	epp2 	pr6|922
014372  aa  6 01640 2521 00	spri2	pr6|928
014373  aa   764125 3520 04	epp2 	-6059,ic		000520 = 404000000043
014374  aa  6 01644 2521 00	spri2	pr6|932
014375  aa   764113 3520 04	epp2 	-6069,ic		000510 = 524000000000
014376  aa  6 01646 2521 00	spri2	pr6|934
014377  aa  6 01634 6211 00	eax1 	pr6|924
014400  aa   010000 4310 07	fld  	4096,dl
014401  aa   000150 3520 04	epp2 	104,ic		014551 = 000160627000
014402  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2685
	who_did_the_attach = substr (attach_descrip.descrip, 1, index (attach_descrip.descrip, " ") - 1);

014403  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
014404  aa  000 003 124 500	scm  	(pr),(du),mask(000)
014405  aa  7 00001 00 0250	desc9a	pr7|1,168		disk_data.descrip
014406  aa   040000 00 0001	desc9a	16384,1
014407  aa  6 00056 0001 00	arg  	pr6|46
014410  aa  6 00056 2361 00	ldq  	pr6|46
014411  aa   000002 6070 04	ttf  	2,ic		014413
014412  aa   000001 3360 07	lcq  	1,dl
014413  aa   000040 1160 07	cmpq 	32,dl
014414  aa   000002 6040 04	tmi  	2,ic		014416
014415  aa   000040 2360 07	ldq  	32,dl
014416  aa  6 00540 7561 00	stq  	pr6|352		who_did_the_attach
014417  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
014420  aa  7 00001 00 0006	desc9a	pr7|1,ql		disk_data.descrip
014421  aa  6 00541 00 0006	desc9a	pr6|353,ql	who_did_the_attach
						STATEMENT 1 ON LINE 2686
	if who_did_the_attach ^= "rdisk_"
	     then do;

014422  aa  6 00540 7271 00	lxl7 	pr6|352		who_did_the_attach
014423  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
014424  aa  6 00541 00 0017	desc9a	pr6|353,x7	who_did_the_attach
014425  aa   764111 00 0006	desc9a	-6071,6		000534 = 162144151163
014426  aa   000034 6000 04	tze  	28,ic		014462
						STATEMENT 1 ON LINE 2688
		setup_error_msg = "Not attached by rdisk_ but by " || who_did_the_attach;

014427  aa   000036 2360 07	ldq  	30,dl
014430  aa  6 00540 0761 00	adq  	pr6|352		who_did_the_attach
014431  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
014432  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
014433  aa   764470 00 0036	desc9a	-5832,30		001122 = 116157164040
014434  aa  2 00000 00 0036	desc9a	pr2|0,30
014435  aa  6 00540 7271 00	lxl7 	pr6|352		who_did_the_attach
014436  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
014437  aa  6 00541 00 0017	desc9a	pr6|353,x7	who_did_the_attach
014440  aa  2 00007 40 0017	desc9a	pr2|7(2),x7
014441  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
014442  aa  2 00000 00 0006	desc9a	pr2|0,ql
014443  aa  6 00551 00 0044	desc9a	pr6|361,36	setup_error_msg
						STATEMENT 1 ON LINE 2689
		call error (error_table_$not_attached, setup_error_msg);

014444  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
014445  aa  6 00044 3701 20	epp4 	pr6|36,*
014446  la  4 00060 3521 20	epp2 	pr4|48,*		error_table_$not_attached
014447  aa  6 01636 2521 00	spri2	pr6|926
014450  aa  6 00551 3521 00	epp2 	pr6|361		setup_error_msg
014451  aa  6 01640 2521 00	spri2	pr6|928
014452  aa   764046 3520 04	epp2 	-6106,ic		000520 = 404000000043
014453  aa  6 01644 2521 00	spri2	pr6|932
014454  aa   763741 3520 04	epp2 	-6175,ic		000415 = 526000000044
014455  aa  6 01646 2521 00	spri2	pr6|934
014456  aa  6 01634 6211 00	eax1 	pr6|924
014457  aa   010000 4310 07	fld  	4096,dl
014460  aa   000071 3520 04	epp2 	57,ic		014551 = 000160627000
014461  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 2690
	     end;

						STATEMENT 1 ON LINE 2693
	if desired_switch_state = "open"
	     then if real_iocb_ptr -> open_descrip_ptr = null then call error (error_table_$not_open, "");

014462  aa  6 00534 7271 00	lxl7 	pr6|348		desired_switch_state
014463  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
014464  aa  6 00535 00 0017	desc9a	pr6|349,x7	desired_switch_state
014465  aa   764014 00 0004	desc9a	-6132,4		000477 = 157160145156
014466  aa   000061 6010 04	tnz  	49,ic		014547
014467  aa  6 00142 3735 20	epp7 	pr6|98,*		real_iocb_ptr
014470  aa  7 00020 2371 00	ldaq 	pr7|16		iocb.open_descrip_ptr
014471  aa   764125 6770 04	eraq 	-6059,ic		000616 = 077777000043 000001000000
014472  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014473  aa   000017 6010 04	tnz  	15,ic		014512
014474  aa  6 00044 3701 20	epp4 	pr6|36,*
014475  la  4 00066 3521 20	epp2 	pr4|54,*		error_table_$not_open
014476  aa  6 01636 2521 00	spri2	pr6|926
014477  aa  6 01632 3521 00	epp2 	pr6|922
014500  aa  6 01640 2521 00	spri2	pr6|928
014501  aa   764017 3520 04	epp2 	-6129,ic		000520 = 404000000043
014502  aa  6 01644 2521 00	spri2	pr6|932
014503  aa   764005 3520 04	epp2 	-6139,ic		000510 = 524000000000
014504  aa  6 01646 2521 00	spri2	pr6|934
014505  aa  6 01634 6211 00	eax1 	pr6|924
014506  aa   010000 4310 07	fld  	4096,dl
014507  aa   000042 3520 04	epp2 	34,ic		014551 = 000160627000
014510  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
014511  aa   000036 7100 04	tra  	30,ic		014547
						STATEMENT 1 ON LINE 2696
		else if desired_switch_state = "closed"
		     then if real_iocb_ptr -> open_descrip_ptr ^= null then call error (error_table_$not_closed, "");

014512  aa  6 00534 7271 00	lxl7 	pr6|348		desired_switch_state
014513  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
014514  aa  6 00535 00 0017	desc9a	pr6|349,x7	desired_switch_state
014515  aa   764073 00 0006	desc9a	-6085,6		000606 = 143154157163
014516  aa   000031 6010 04	tnz  	25,ic		014547
014517  aa  7 00020 2371 00	ldaq 	pr7|16		iocb.open_descrip_ptr
014520  aa   764076 6770 04	eraq 	-6082,ic		000616 = 077777000043 000001000000
014521  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014522  aa   000017 6000 04	tze  	15,ic		014541
014523  aa  6 00044 3701 20	epp4 	pr6|36,*
014524  la  4 00062 3521 20	epp2 	pr4|50,*		error_table_$not_closed
014525  aa  6 01636 2521 00	spri2	pr6|926
014526  aa  6 01632 3521 00	epp2 	pr6|922
014527  aa  6 01640 2521 00	spri2	pr6|928
014530  aa   763770 3520 04	epp2 	-6152,ic		000520 = 404000000043
014531  aa  6 01644 2521 00	spri2	pr6|932
014532  aa   763756 3520 04	epp2 	-6162,ic		000510 = 524000000000
014533  aa  6 01646 2521 00	spri2	pr6|934
014534  aa  6 01634 6211 00	eax1 	pr6|924
014535  aa   010000 4310 07	fld  	4096,dl
014536  aa   000013 3520 04	epp2 	11,ic		014551 = 000160627000
014537  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
014540  aa   000007 7100 04	tra  	7,ic		014547
						STATEMENT 1 ON LINE 2699
			else if desired_switch_state = "don't_care" then return;

014541  aa  6 00534 7271 00	lxl7 	pr6|348		desired_switch_state
014542  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
014543  aa  6 00535 00 0017	desc9a	pr6|349,x7	desired_switch_state
014544  aa   764114 00 0012	desc9a	-6068,10		000656 = 144157156047
014545  aa   000002 6010 04	tnz  	2,ic		014547
014546  aa  6 00526 6101 00	rtcd 	pr6|342
						STATEMENT 1 ON LINE 2701
     end setup;

014547  aa  6 00526 6101 00	rtcd 	pr6|342
  END PROCEDURE setup
BEGIN PROCEDURE error
ENTRY TO error                                              STATEMENT 1 ON LINE 2705
error:
     proc (cd, err_msg);

014550  da     000742200000
014551  aa   000160 6270 00	eax7 	112
014552  aa  7 00034 3521 20	epp2 	pr7|28,*
014553  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
014554  aa     000004000000
014555  aa     000000000000
014556  aa  6 00042 3735 20	epp7 	pr6|34,*
014557  aa  7 00002 2361 20	ldq  	pr7|2,*
014560  aa   000002 6040 04	tmi  	2,ic		014562
014561  aa   777777 3760 07	anq  	262143,dl
014562  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
014563  aa  6 00100 7561 00	stq  	pr6|64
						STATEMENT 1 ON LINE 2711
	if disk_ptr ^= null
	     then					/* if we have a work seg, we can check print-error switch */
		if err_sw
		     then call sub_err_ (cd, "rdisk_", "c", null, retval, "^a  ^a", iocb_ptr -> iocb.name, err_msg);

014564  aa  6 00040 3715 20	epp5 	pr6|32,*
014565  aa  5 00136 2371 00	ldaq 	pr5|94		disk_ptr
014566  aa   764030 6770 04	eraq 	-6120,ic		000616 = 077777000043 000001000000
014567  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014570  aa   000063 6000 04	tze  	51,ic		014653
014571  aa  5 00136 3535 20	epp3 	pr5|94,*		disk_ptr
014572  aa  3 00055 2351 00	lda  	pr3|45		disk_data.err_sw
014573  aa   400000 3150 03	cana 	131072,du
014574  aa   000134 6000 04	tze  	92,ic		014730
014575  aa   763737 2370 04	ldaq 	-6177,ic		000534 = 162144151163 153137000000
014576  aa  6 00102 7571 00	staq 	pr6|66
014577  aa   143000 2350 03	lda  	50688,du
014600  aa  6 00101 7551 00	sta  	pr6|65
014601  aa   764015 3514 24	epp1 	-6131,ic*
014602  aa  6 00104 2515 00	spri1	pr6|68
014603  aa   763725 2370 04	ldaq 	-6187,ic		000530 = 136141040040 136141000000
014604  aa  6 00106 7571 00	staq 	pr6|70
014605  aa  6 00032 3735 20	epp7 	pr6|26,*
014606  aa  7 00002 3521 20	epp2 	pr7|2,*		cd
014607  aa  6 00112 2521 00	spri2	pr6|74
014610  aa  6 00102 3521 00	epp2 	pr6|66
014611  aa  6 00114 2521 00	spri2	pr6|76
014612  aa  6 00101 3521 00	epp2 	pr6|65
014613  aa  6 00116 2521 00	spri2	pr6|78
014614  aa  6 00104 3521 00	epp2 	pr6|68
014615  aa  6 00120 2521 00	spri2	pr6|80
014616  aa  5 00305 3521 00	epp2 	pr5|197		retval
014617  aa  6 00122 2521 00	spri2	pr6|82
014620  aa  6 00106 3521 00	epp2 	pr6|70
014621  aa  6 00124 2521 00	spri2	pr6|84
014622  aa  5 00140 3535 20	epp3 	pr5|96,*		iocb_ptr
014623  aa  3 00001 3521 00	epp2 	pr3|1		iocb.name
014624  aa  6 00126 2521 00	spri2	pr6|86
014625  aa  7 00004 3521 20	epp2 	pr7|4,*		err_msg
014626  aa  6 00130 2521 00	spri2	pr6|88
014627  aa   763671 3520 04	epp2 	-6215,ic		000520 = 404000000043
014630  aa  6 00132 2521 00	spri2	pr6|90
014631  aa  6 00142 2521 00	spri2	pr6|98
014632  aa   763653 3520 04	epp2 	-6229,ic		000505 = 524000000006
014633  aa  6 00134 2521 00	spri2	pr6|92
014634  aa  6 00144 2521 00	spri2	pr6|100
014635  aa   763572 3520 04	epp2 	-6278,ic		000427 = 524000000001
014636  aa  6 00136 2521 00	spri2	pr6|94
014637  aa   763662 3520 04	epp2 	-6222,ic		000521 = 464000000000
014640  aa  6 00140 2521 00	spri2	pr6|96
014641  aa   763615 3520 04	epp2 	-6259,ic		000456 = 524000000040
014642  aa  6 00146 2521 00	spri2	pr6|102
014643  aa  6 00042 3515 20	epp1 	pr6|34,*
014644  aa  1 00002 3521 20	epp2 	pr1|2,*
014645  aa  6 00150 2521 00	spri2	pr6|104
014646  aa  6 00110 6211 00	eax1 	pr6|72
014647  aa   040000 4310 07	fld  	16384,dl
014650  la  4 00120 3521 20	epp2 	pr4|80,*		sub_err_
014651  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2716
		     else ;

014652  aa   000056 7100 04	tra  	46,ic		014730
						STATEMENT 1 ON LINE 2717
	     else call sub_err_ (cd, "rdisk_", "c", null, retval, "^a  ^a", iocb_ptr -> iocb.name, err_msg);

014653  aa   763661 2370 04	ldaq 	-6223,ic		000534 = 162144151163 153137000000
014654  aa  6 00106 7571 00	staq 	pr6|70
014655  aa   143000 2350 03	lda  	50688,du
014656  aa  6 00101 7551 00	sta  	pr6|65
014657  aa   763737 3534 24	epp3 	-6177,ic*
014660  aa  6 00104 2535 00	spri3	pr6|68
014661  aa   763647 2370 04	ldaq 	-6233,ic		000530 = 136141040040 136141000000
014662  aa  6 00102 7571 00	staq 	pr6|66
014663  aa  6 00032 3515 20	epp1 	pr6|26,*
014664  aa  1 00002 3521 20	epp2 	pr1|2,*		cd
014665  aa  6 00112 2521 00	spri2	pr6|74
014666  aa  6 00106 3521 00	epp2 	pr6|70
014667  aa  6 00114 2521 00	spri2	pr6|76
014670  aa  6 00101 3521 00	epp2 	pr6|65
014671  aa  6 00116 2521 00	spri2	pr6|78
014672  aa  6 00104 3521 00	epp2 	pr6|68
014673  aa  6 00120 2521 00	spri2	pr6|80
014674  aa  5 00305 3521 00	epp2 	pr5|197		retval
014675  aa  6 00122 2521 00	spri2	pr6|82
014676  aa  6 00102 3521 00	epp2 	pr6|66
014677  aa  6 00124 2521 00	spri2	pr6|84
014700  aa  5 00140 3735 20	epp7 	pr5|96,*		iocb_ptr
014701  aa  7 00001 3521 00	epp2 	pr7|1		iocb.name
014702  aa  6 00126 2521 00	spri2	pr6|86
014703  aa  1 00004 3521 20	epp2 	pr1|4,*		err_msg
014704  aa  6 00130 2521 00	spri2	pr6|88
014705  aa   763613 3520 04	epp2 	-6261,ic		000520 = 404000000043
014706  aa  6 00132 2521 00	spri2	pr6|90
014707  aa  6 00142 2521 00	spri2	pr6|98
014710  aa   763575 3520 04	epp2 	-6275,ic		000505 = 524000000006
014711  aa  6 00134 2521 00	spri2	pr6|92
014712  aa  6 00144 2521 00	spri2	pr6|100
014713  aa   763514 3520 04	epp2 	-6324,ic		000427 = 524000000001
014714  aa  6 00136 2521 00	spri2	pr6|94
014715  aa   763604 3520 04	epp2 	-6268,ic		000521 = 464000000000
014716  aa  6 00140 2521 00	spri2	pr6|96
014717  aa   763537 3520 04	epp2 	-6305,ic		000456 = 524000000040
014720  aa  6 00146 2521 00	spri2	pr6|102
014721  aa  6 00042 3535 20	epp3 	pr6|34,*
014722  aa  3 00002 3521 20	epp2 	pr3|2,*
014723  aa  6 00150 2521 00	spri2	pr6|104
014724  aa  6 00110 6211 00	eax1 	pr6|72
014725  aa   040000 4310 07	fld  	16384,dl
014726  la  4 00120 3521 20	epp2 	pr4|80,*		sub_err_
014727  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2720
	code = cd;

014730  aa  6 00032 3735 20	epp7 	pr6|26,*
014731  aa  7 00002 2361 20	ldq  	pr7|2,*		cd
014732  aa  6 00040 3715 20	epp5 	pr6|32,*
014733  aa  5 00157 7561 00	stq  	pr5|111		code
						STATEMENT 1 ON LINE 2722
	go to exit;

014734  aa   766523 3520 04	epp2 	-4781,ic		003457 = 600157236100
014735  aa   000001 7270 07	lxl7 	1,dl
014736  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 2724
     end error;

  END PROCEDURE error
BEGIN PROCEDURE mount
ENTRY TO mount                                              STATEMENT 1 ON LINE 2730
mount:
     proc;

014737  da     000747200000
014740  aa   000220 6270 00	eax7 	144
014741  aa  7 00034 3521 20	epp2 	pr7|28,*
014742  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
014743  aa     000000000000
014744  aa     000000000000
						STATEMENT 1 ON LINE 2734
	errors = 0;

014745  aa  6 00040 3735 20	epp7 	pr6|32,*
014746  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
014747  aa  5 00077 4501 00	stz  	pr5|63		disk_data.errors
						STATEMENT 1 ON LINE 2736
	disk_info_ptr = addr (rcp_data);

014750  aa  5 00152 3535 00	epp3 	pr5|106		disk_data.rcp_data
014751  aa  7 00106 2535 00	spri3	pr7|70		disk_info_ptr
						STATEMENT 1 ON LINE 2737
	disk_info.volume_name = pack_id;

014752  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
014753  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
014754  aa  5 00056 00 0040	desc9a	pr5|46,32		disk_data.pack_id
014755  aa  3 00007 00 0040	desc9a	pr3|7,32		disk_info.volume_name
						STATEMENT 1 ON LINE 2739
	call rcp_$attach ((rcp_dev_type), disk_info_ptr, ev_chan, "", rcp_id, code);

014756  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
014757  aa   763030 00 0040	desc9a	-6632,32		000006 = 144151163153
014760  aa  6 00106 00 0040	desc9a	pr6|70,32
014761  aa  6 00106 3521 00	epp2 	pr6|70
014762  aa  6 00122 2521 00	spri2	pr6|82
014763  aa  7 00106 3521 00	epp2 	pr7|70		disk_info_ptr
014764  aa  6 00124 2521 00	spri2	pr6|84
014765  aa  5 00072 3521 00	epp2 	pr5|58		disk_data.ev_chan
014766  aa  6 00126 2521 00	spri2	pr6|86
014767  aa  6 00116 3521 00	epp2 	pr6|78
014770  aa  6 00130 2521 00	spri2	pr6|88
014771  aa  5 00066 3521 00	epp2 	pr5|54		disk_data.rcp_id
014772  aa  6 00132 2521 00	spri2	pr6|90
014773  aa  7 00157 3521 00	epp2 	pr7|111		code
014774  aa  6 00134 2521 00	spri2	pr6|92
014775  aa   763461 3520 04	epp2 	-6351,ic		000456 = 524000000040
014776  aa  6 00136 2521 00	spri2	pr6|94
014777  aa   763522 3520 04	epp2 	-6318,ic		000521 = 464000000000
015000  aa  6 00140 2521 00	spri2	pr6|96
015001  aa   763413 3520 04	epp2 	-6389,ic		000414 = 410000000107
015002  aa  6 00142 2521 00	spri2	pr6|98
015003  aa   763505 3520 04	epp2 	-6331,ic		000510 = 524000000000
015004  aa  6 00144 2521 00	spri2	pr6|100
015005  aa   763447 3520 04	epp2 	-6361,ic		000454 = 514000000044
015006  aa  6 00146 2521 00	spri2	pr6|102
015007  aa   763511 3520 04	epp2 	-6327,ic		000520 = 404000000043
015010  aa  6 00150 2521 00	spri2	pr6|104
015011  aa  6 00120 6211 00	eax1 	pr6|80
015012  aa   030000 4310 07	fld  	12288,dl
015013  la  4 00166 3521 20	epp2 	pr4|118,*		rcp_$attach
015014  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2741
	if code ^= 0 then return;

015015  aa  6 00040 3735 20	epp7 	pr6|32,*
015016  aa  7 00157 2361 00	ldq  	pr7|111		code
015017  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2743
	call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, time_int, rcp_state, code);

015020  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015021  aa  5 00066 3521 00	epp2 	pr5|54		disk_data.rcp_id
015022  aa  6 00154 2521 00	spri2	pr6|108
015023  aa  7 00106 3521 00	epp2 	pr7|70		disk_info_ptr
015024  aa  6 00156 2521 00	spri2	pr6|110
015025  aa  6 00116 3521 00	epp2 	pr6|78
015026  aa  6 00160 2521 00	spri2	pr6|112
015027  aa  5 00075 3521 00	epp2 	pr5|61		disk_data.devx
015030  aa  6 00162 2521 00	spri2	pr6|114
015031  aa  5 00067 3521 00	epp2 	pr5|55		disk_data.max_buff_size
015032  aa  6 00164 2521 00	spri2	pr6|116
015033  aa  5 00132 3521 00	epp2 	pr5|90		disk_data.time_int
015034  aa  6 00166 2521 00	spri2	pr6|118
015035  aa  7 00200 3521 00	epp2 	pr7|128		rcp_state
015036  aa  6 00170 2521 00	spri2	pr6|120
015037  aa  7 00157 3521 00	epp2 	pr7|111		code
015040  aa  6 00172 2521 00	spri2	pr6|122
015041  aa   763413 3520 04	epp2 	-6389,ic		000454 = 514000000044
015042  aa  6 00174 2521 00	spri2	pr6|124
015043  aa   763456 3520 04	epp2 	-6354,ic		000521 = 464000000000
015044  aa  6 00176 2521 00	spri2	pr6|126
015045  aa   763443 3520 04	epp2 	-6365,ic		000510 = 524000000000
015046  aa  6 00200 2521 00	spri2	pr6|128
015047  aa   763445 3520 04	epp2 	-6363,ic		000514 = 404000000021
015050  aa  6 00202 2521 00	spri2	pr6|130
015051  aa  6 00210 2521 00	spri2	pr6|136
015052  aa   763341 3520 04	epp2 	-6431,ic		000413 = 404000000023
015053  aa  6 00204 2521 00	spri2	pr6|132
015054  aa   763340 3520 04	epp2 	-6432,ic		000414 = 410000000107
015055  aa  6 00206 2521 00	spri2	pr6|134
015056  aa   763442 3520 04	epp2 	-6366,ic		000520 = 404000000043
015057  aa  6 00212 2521 00	spri2	pr6|138
015060  aa  6 00152 6211 00	eax1 	pr6|106
015061  aa   040000 4310 07	fld  	16384,dl
015062  aa  6 00044 3701 20	epp4 	pr6|36,*
015063  la  4 00170 3521 20	epp2 	pr4|120,*		rcp_$check_attach
015064  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2744
	if code ^= 0 then return;

015065  aa  6 00040 3735 20	epp7 	pr6|32,*
015066  aa  7 00157 2361 00	ldq  	pr7|111		code
015067  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2746
	do while (rcp_state ^= COMPLETE);

015070  aa  6 00040 3735 20	epp7 	pr6|32,*
015071  aa  7 00200 2361 00	ldq  	pr7|128		rcp_state
015072  aa   000127 6000 04	tze  	87,ic		015221
						STATEMENT 1 ON LINE 2747
	     on cleanup call detach;

015073  aa   000007 7260 07	lxl6 	7,dl
015074  aa   763432 3520 04	epp2 	-6374,ic		000526 = 143154145141
015075  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
015076  aa   000004 7100 04	tra  	4,ic		015102
015077  aa     000100000000
015100  aa   000011 7100 04	tra  	9,ic		015111
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 2747
	     on cleanup call detach;

015101  da     000755200000
015102  aa   000140 6270 00	eax7 	96
015103  aa  7 00034 3521 20	epp2 	pr7|28,*
015104  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
015105  aa     000000000000
015106  aa     000000000000
015107  aa   000235 6700 04	tsp4 	157,ic		015344
015110  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 2748
	     call ipc_$block (addr (wait_list), addr (event_info), code);

015111  aa  6 00040 3735 20	epp7 	pr6|32,*
015112  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015113  aa  5 00070 3735 00	epp7 	pr5|56		disk_data.wait_list
015114  aa  6 00214 6535 00	spri7	pr6|140
015115  aa  6 00040 3535 20	epp3 	pr6|32,*
015116  aa  3 00116 3535 00	epp3 	pr3|78		event_info
015117  aa  6 00216 2535 00	spri3	pr6|142
015120  aa  6 00214 3521 00	epp2 	pr6|140
015121  aa  6 00110 2521 00	spri2	pr6|72
015122  aa  6 00216 3521 00	epp2 	pr6|142
015123  aa  6 00112 2521 00	spri2	pr6|74
015124  aa  6 00040 3515 20	epp1 	pr6|32,*
015125  aa  1 00157 3521 00	epp2 	pr1|111		code
015126  aa  6 00114 2521 00	spri2	pr6|76
015127  aa  6 00106 6211 00	eax1 	pr6|70
015130  aa   014000 4310 07	fld  	6144,dl
015131  aa  6 00044 3701 20	epp4 	pr6|36,*
015132  la  4 00136 3521 20	epp2 	pr4|94,*		ipc_$block
015133  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2750
	     revert cleanup;

015134  aa  6 00104 4501 00	stz  	pr6|68
						STATEMENT 1 ON LINE 2751
	     if code ^= 0 then return;

015135  aa  6 00040 3735 20	epp7 	pr6|32,*
015136  aa  7 00157 2361 00	ldq  	pr7|111		code
015137  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2752
	     call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, time_int, rcp_state, code);

015140  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015141  aa  5 00066 3521 00	epp2 	pr5|54		disk_data.rcp_id
015142  aa  6 00154 2521 00	spri2	pr6|108
015143  aa  7 00106 3521 00	epp2 	pr7|70		disk_info_ptr
015144  aa  6 00156 2521 00	spri2	pr6|110
015145  aa  6 00116 3521 00	epp2 	pr6|78
015146  aa  6 00160 2521 00	spri2	pr6|112
015147  aa  5 00075 3521 00	epp2 	pr5|61		disk_data.devx
015150  aa  6 00162 2521 00	spri2	pr6|114
015151  aa  5 00067 3521 00	epp2 	pr5|55		disk_data.max_buff_size
015152  aa  6 00164 2521 00	spri2	pr6|116
015153  aa  5 00132 3521 00	epp2 	pr5|90		disk_data.time_int
015154  aa  6 00166 2521 00	spri2	pr6|118
015155  aa  7 00200 3521 00	epp2 	pr7|128		rcp_state
015156  aa  6 00170 2521 00	spri2	pr6|120
015157  aa  7 00157 3521 00	epp2 	pr7|111		code
015160  aa  6 00172 2521 00	spri2	pr6|122
015161  aa   763273 3520 04	epp2 	-6469,ic		000454 = 514000000044
015162  aa  6 00174 2521 00	spri2	pr6|124
015163  aa   763336 3520 04	epp2 	-6434,ic		000521 = 464000000000
015164  aa  6 00176 2521 00	spri2	pr6|126
015165  aa   763323 3520 04	epp2 	-6445,ic		000510 = 524000000000
015166  aa  6 00200 2521 00	spri2	pr6|128
015167  aa   763325 3520 04	epp2 	-6443,ic		000514 = 404000000021
015170  aa  6 00202 2521 00	spri2	pr6|130
015171  aa  6 00210 2521 00	spri2	pr6|136
015172  aa   763221 3520 04	epp2 	-6511,ic		000413 = 404000000023
015173  aa  6 00204 2521 00	spri2	pr6|132
015174  aa   763220 3520 04	epp2 	-6512,ic		000414 = 410000000107
015175  aa  6 00206 2521 00	spri2	pr6|134
015176  aa   763322 3520 04	epp2 	-6446,ic		000520 = 404000000043
015177  aa  6 00212 2521 00	spri2	pr6|138
015200  aa  6 00152 6211 00	eax1 	pr6|106
015201  aa   040000 4310 07	fld  	16384,dl
015202  aa  6 00044 3701 20	epp4 	pr6|36,*
015203  la  4 00170 3521 20	epp2 	pr4|120,*		rcp_$check_attach
015204  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2753
	     if code ^= 0 then return;

015205  aa  6 00040 3735 20	epp7 	pr6|32,*
015206  aa  7 00157 2361 00	ldq  	pr7|111		code
015207  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2754
	     if rcp_state < COMPLETE | rcp_state >= LONG_WAIT
		then do;

015210  aa  7 00200 2361 00	ldq  	pr7|128		rcp_state
015211  aa   000003 6040 04	tmi  	3,ic		015214
015212  aa   000002 1160 07	cmpq 	2,dl
015213  aa   777655 6040 04	tmi  	-83,ic		015070
						STATEMENT 1 ON LINE 2756
		     code = error_table_$action_not_performed;

015214  aa  6 00044 3701 20	epp4 	pr6|36,*
015215  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$action_not_performed
015216  aa  7 00157 7561 00	stq  	pr7|111		code
						STATEMENT 1 ON LINE 2758
		     return;

015217  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2759
		end;

						STATEMENT 1 ON LINE 2760
	     end;

015220  aa   777650 7100 04	tra  	-88,ic		015070
						STATEMENT 1 ON LINE 2762
	if drive = NOT_SET
	     then do;

015221  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015222  aa  5 00076 2361 00	ldq  	pr5|62		disk_data.drive
015223  aa   002546 1160 04	cmpq 	1382,ic		017771 = 777777777777
015224  aa   000011 6010 04	tnz  	9,ic		015235
						STATEMENT 1 ON LINE 2764
		drive_number.sign = "+";

015225  aa   053000 2350 03	lda  	22016,du
015226  aa  7 00301 5511 40	stba 	pr7|193,40	drive_number.sign
						STATEMENT 1 ON LINE 2765
		drive_number.number = substr (disk_info.device_name, 6, 2);

015227  aa  7 00106 3535 20	epp3 	pr7|70,*		disk_info_ptr
015230  aa  3 00005 2351 00	lda  	pr3|5		disk_info.device_name
015231  aa  7 00301 5511 30	stba 	pr7|193,30	drive_number.number
						STATEMENT 1 ON LINE 2766
		drive = drive_dec;

015232  aa  000 100 305 500	dtb  	(pr),(pr)
015233  aa  7 00301 01 0003	desc9ls	pr7|193,3,0	drive_dec
015234  aa  5 00076 00 0004	desc9a	pr5|62,4		disk_data.drive
						STATEMENT 1 ON LINE 2767
	     end;

						STATEMENT 1 ON LINE 2769
	buf_len = min (max (divide (sze, 4, 17, 0), 1024), max_buff_size);

015235  aa  5 00054 2361 00	ldq  	pr5|44		disk_data.sze
015236  aa   000004 5060 07	div  	4,dl
015237  aa   002000 1160 07	cmpq 	1024,dl
015240  aa   000002 6050 04	tpl  	2,ic		015242
015241  aa   002000 2360 07	ldq  	1024,dl
015242  aa  5 00067 1161 00	cmpq 	pr5|55		disk_data.max_buff_size
015243  aa   000002 6040 04	tmi  	2,ic		015245
015244  aa  5 00067 2361 00	ldq  	pr5|55		disk_data.max_buff_size
015245  aa  5 00127 7561 00	stq  	pr5|87		disk_data.buf_len
						STATEMENT 1 ON LINE 2771
	call ioi_$workspace (devx, buf_ptr, buf_len, code);

015246  aa  5 00075 3521 00	epp2 	pr5|61		disk_data.devx
015247  aa  6 00122 2521 00	spri2	pr6|82
015250  aa  5 00124 3521 00	epp2 	pr5|84		disk_data.buf_ptr
015251  aa  6 00124 2521 00	spri2	pr6|84
015252  aa  5 00127 3521 00	epp2 	pr5|87		disk_data.buf_len
015253  aa  6 00126 2521 00	spri2	pr6|86
015254  aa  7 00157 3521 00	epp2 	pr7|111		code
015255  aa  6 00130 2521 00	spri2	pr6|88
015256  aa  6 00120 6211 00	eax1 	pr6|80
015257  aa   020000 4310 07	fld  	8192,dl
015260  aa  6 00044 3701 20	epp4 	pr6|36,*
015261  la  4 00116 3521 20	epp2 	pr4|78,*		ioi_$workspace
015262  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2773
	if code ^= 0 then return;

015263  aa  6 00040 3735 20	epp7 	pr6|32,*
015264  aa  7 00157 2361 00	ldq  	pr7|111		code
015265  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2774
	data_len = buf_len - overhead;

015266  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015267  aa  5 00127 2361 00	ldq  	pr5|87		disk_data.buf_len
015270  aa   000300 1760 07	sbq  	192,dl
015271  aa  5 00130 7561 00	stq  	pr5|88		disk_data.data_len
						STATEMENT 1 ON LINE 2776
	call ioi_$set_status (devx, fixed (rel (addr (istat))), 1, code);

015272  aa  5 00124 3535 20	epp3 	pr5|84,*		disk_data.buf_ptr
015273  aa  3 00125 3515 00	epp1 	pr3|85		buffer.istat
015274  aa  1 00000 6351 00	eaa  	pr1|0
015275  aa   000066 7730 00	lrl  	54
015276  aa  6 00116 7561 00	stq  	pr6|78
015277  aa   000001 2360 07	ldq  	1,dl
015300  aa  6 00117 7561 00	stq  	pr6|79
015301  aa  5 00075 3521 00	epp2 	pr5|61		disk_data.devx
015302  aa  6 00122 2521 00	spri2	pr6|82
015303  aa  6 00116 3521 00	epp2 	pr6|78
015304  aa  6 00124 2521 00	spri2	pr6|84
015305  aa  6 00117 3521 00	epp2 	pr6|79
015306  aa  6 00126 2521 00	spri2	pr6|86
015307  aa  7 00157 3521 00	epp2 	pr7|111		code
015310  aa  6 00130 2521 00	spri2	pr6|88
015311  aa  6 00120 6211 00	eax1 	pr6|80
015312  aa   020000 4310 07	fld  	8192,dl
015313  aa  6 00044 3701 20	epp4 	pr6|36,*
015314  la  4 00140 3521 20	epp2 	pr4|96,*		ioi_$set_status
015315  aa  6 00216 2515 00	spri1	pr6|142
015316  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2778
	if code ^= 0 then return;

015317  aa  6 00040 3735 20	epp7 	pr6|32,*
015320  aa  7 00157 2361 00	ldq  	pr7|111		code
015321  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2780
	call ioi_$timeout (devx, (time_int), code);

015322  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015323  aa  5 00132 2371 00	ldaq 	pr5|90		disk_data.time_int
015324  aa  6 00214 7571 00	staq 	pr6|140
015325  aa  5 00075 3521 00	epp2 	pr5|61		disk_data.devx
015326  aa  6 00110 2521 00	spri2	pr6|72
015327  aa  6 00214 3521 00	epp2 	pr6|140
015330  aa  6 00112 2521 00	spri2	pr6|74
015331  aa  7 00157 3521 00	epp2 	pr7|111		code
015332  aa  6 00114 2521 00	spri2	pr6|76
015333  aa  6 00106 6211 00	eax1 	pr6|70
015334  aa   014000 4310 07	fld  	6144,dl
015335  aa  6 00044 3701 20	epp4 	pr6|36,*
015336  la  4 00114 3521 20	epp2 	pr4|76,*		ioi_$timeout
015337  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2781
	if code ^= 0 then return;

015340  aa  6 00040 3735 20	epp7 	pr6|32,*
015341  aa  7 00157 2361 00	ldq  	pr7|111		code
015342  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2789
     end mount;

015343  aa  0 00631 7101 00	tra  	pr0|409		return_mac
BEGIN PROCEDURE detach
ENTRY TO detach                                             STATEMENT 1 ON LINE 2783
detach:
     proc;

015344  aa  6 00100 6501 00	spri4	pr6|64
						STATEMENT 1 ON LINE 2785
	call rcp_$detach (rcp_id, "0"b, (0), "", (0));

015345  aa   000000 2350 07	lda  	0,dl
015346  aa  6 00106 7551 00	sta  	pr6|70
015347  aa  6 00107 4501 00	stz  	pr6|71
015350  aa  6 00111 4501 00	stz  	pr6|73
015351  aa  6 00040 3735 20	epp7 	pr6|32,*
015352  aa  7 00040 3735 20	epp7 	pr7|32,*
015353  aa  7 00136 3715 20	epp5 	pr7|94,*		disk_ptr
015354  aa  5 00066 3521 00	epp2 	pr5|54		disk_data.rcp_id
015355  aa  6 00114 2521 00	spri2	pr6|76
015356  aa  6 00106 3521 00	epp2 	pr6|70
015357  aa  6 00116 2521 00	spri2	pr6|78
015360  aa  6 00107 3521 00	epp2 	pr6|71
015361  aa  6 00120 2521 00	spri2	pr6|80
015362  aa  6 00110 3521 00	epp2 	pr6|72
015363  aa  6 00122 2521 00	spri2	pr6|82
015364  aa  6 00111 3521 00	epp2 	pr6|73
015365  aa  6 00124 2521 00	spri2	pr6|84
015366  aa   763066 3520 04	epp2 	-6602,ic		000454 = 514000000044
015367  aa  6 00126 2521 00	spri2	pr6|86
015370  aa   763125 3520 04	epp2 	-6571,ic		000515 = 514000000001
015371  aa  6 00130 2521 00	spri2	pr6|88
015372  aa   763122 3520 04	epp2 	-6574,ic		000514 = 404000000021
015373  aa  6 00132 2521 00	spri2	pr6|90
015374  aa   763114 3520 04	epp2 	-6580,ic		000510 = 524000000000
015375  aa  6 00134 2521 00	spri2	pr6|92
015376  aa   763122 3520 04	epp2 	-6574,ic		000520 = 404000000043
015377  aa  6 00136 2521 00	spri2	pr6|94
015400  aa  6 00112 6211 00	eax1 	pr6|74
015401  aa   024000 4310 07	fld  	10240,dl
015402  aa  6 00044 3701 20	epp4 	pr6|36,*
015403  la  4 00172 3521 20	epp2 	pr4|122,*		rcp_$detach
015404  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2786
	return;

015405  aa  6 00100 6101 00	rtcd 	pr6|64
						STATEMENT 1 ON LINE 2787
     end detach;

  END PROCEDURE detach
  END PROCEDURE mount
BEGIN PROCEDURE cond_hdlr
ENTRY TO cond_hdlr                                          STATEMENT 1 ON LINE 2795
cond_hdlr:
     proc (mc_ptr, cond_name, wc_mc_ptr, info_ptr, cont_sw);

015406  da     000763200000
015407  aa   000140 6270 00	eax7 	96
015410  aa  7 00034 3521 20	epp2 	pr7|28,*
015411  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
015412  aa     000012000000
015413  aa     000000000000
015414  aa  6 00042 3735 20	epp7 	pr6|34,*
015415  aa  7 00002 2361 20	ldq  	pr7|2,*
015416  aa   000002 6040 04	tmi  	2,ic		015420
015417  aa   777777 3760 07	anq  	262143,dl
015420  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
015421  aa  6 00100 7561 00	stq  	pr6|64
						STATEMENT 1 ON LINE 2808
	if masked
	     then do;

015422  aa  6 00040 3715 20	epp5 	pr6|32,*
015423  aa  5 00277 2351 00	lda  	pr5|191		mask.masked
015424  aa   000001 3150 07	cana 	1,dl
015425  aa   000027 6000 04	tze  	23,ic		015454
						STATEMENT 1 ON LINE 2810
		tp_info.version = 0;

015426  aa  5 00126 4501 00	stz  	pr5|86		tp_info.version
						STATEMENT 1 ON LINE 2811
		tp_info.code = error_table_$termination_requested;

015427  la  4 00074 2361 20	ldq  	pr4|60,*		error_table_$termination_requested
015430  aa  5 00127 7561 00	stq  	pr5|87		tp_info.code
						STATEMENT 1 ON LINE 2813
		call terminate_process_ ("fatal_error", addr (tp_info));

015431  aa   763172 2350 04	lda  	-6534,ic		000623 = 146141164141
015432  aa   763172 2360 04	ldq  	-6534,ic		000624 = 154137145162
015433  aa  6 00102 7571 00	staq 	pr6|66
015434  aa   763171 2350 04	lda  	-6535,ic		000625 = 162157162000
015435  aa  6 00104 7551 00	sta  	pr6|68
015436  aa  5 00126 3535 00	epp3 	pr5|86		tp_info
015437  aa  6 00106 2535 00	spri3	pr6|70
015440  aa  6 00102 3521 00	epp2 	pr6|66
015441  aa  6 00112 2521 00	spri2	pr6|74
015442  aa  6 00106 3521 00	epp2 	pr6|70
015443  aa  6 00114 2521 00	spri2	pr6|76
015444  aa   762746 3520 04	epp2 	-6682,ic		000412 = 524000000013
015445  aa  6 00116 2521 00	spri2	pr6|78
015446  aa   763053 3520 04	epp2 	-6613,ic		000521 = 464000000000
015447  aa  6 00120 2521 00	spri2	pr6|80
015450  aa  6 00110 6211 00	eax1 	pr6|72
015451  aa   010000 4310 07	fld  	4096,dl
015452  la  4 00164 3521 20	epp2 	pr4|116,*		terminate_process_
015453  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2815
	     end;

						STATEMENT 1 ON LINE 2817
	if cond_name ^= "cleanup" then cont_sw = "1"b;

015454  aa  6 00032 3735 20	epp7 	pr6|26,*
015455  aa  7 00004 3715 20	epp5 	pr7|4,*
015456  aa  6 00100 2351 00	lda  	pr6|64
015457  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
015460  aa  5 00000 00 0005	desc9a	pr5|0,al		cond_name
015461  aa   763047 00 0007	desc9a	-6617,7		000526 = 143154145141
015462  aa   000003 6000 04	tze  	3,ic		015465
015463  aa   400000 2350 03	lda  	131072,du
015464  aa  7 00012 7551 20	sta  	pr7|10,*		cont_sw
						STATEMENT 1 ON LINE 2819
     end cond_hdlr;

015465  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE cond_hdlr
BEGIN PROCEDURE cksum
ENTRY TO cksum                                              STATEMENT 1 ON LINE 2824
cksum:
     proc returns (bit (6));

015466  aa  6 00562 6501 00	spri4	pr6|370
015467  aa  6 00564 2521 00	spri2	pr6|372
						STATEMENT 1 ON LINE 2832
	ckchar = "0"b;

015470  aa  6 00570 4501 00	stz  	pr6|376		ckchar
						STATEMENT 1 ON LINE 2833
	do i = 1 to 30;

015471  aa   000001 2360 07	ldq  	1,dl
015472  aa  6 00172 7561 00	stq  	pr6|122		i
015473  aa   000000 0110 03	nop  	0,du
015474  aa  6 00172 2361 00	ldq  	pr6|122		i
015475  aa   000036 1160 07	cmpq 	30,dl
015476  aa   000012 6054 04	tpnz 	10,ic		015510
						STATEMENT 1 ON LINE 2834
	     ckchar = bool (ckchar, fmtsum (i), "0110"b);

015477  aa   000006 4020 07	mpy  	6,dl
015500  aa  6 00154 3735 20	epp7 	pr6|108,*		fmdp
015501  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
015502  aa  7 77777 63 0006	descb	pr7|-1(30),6	fmtsum
015503  aa  6 00056 00 0044	descb	pr6|46,36
015504  aa  6 00056 2351 00	lda  	pr6|46
015505  aa  6 00570 6551 00	ersa 	pr6|376		ckchar
						STATEMENT 1 ON LINE 2835
	     end;

015506  aa  6 00172 0541 00	aos  	pr6|122		i
015507  aa   777765 7100 04	tra  	-11,ic		015474
						STATEMENT 1 ON LINE 2836
	return (ckchar);

015510  aa  6 00564 3735 20	epp7 	pr6|372,*
015511  aa  7 00002 3715 20	epp5 	pr7|2,*
015512  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
015513  aa  6 00570 00 0006	descb	pr6|376,6		ckchar
015514  aa  5 00000 00 0006	descb	pr5|0,6
015515  aa  6 00562 6101 00	rtcd 	pr6|370
						STATEMENT 1 ON LINE 2837
     end cksum;

  END PROCEDURE cksum
BEGIN PROCEDURE io_call_order
ENTRY TO io_call_order                                      STATEMENT 1 ON LINE 2842
io_call_order:
     proc;

015516  aa  6 00572 6501 00	spri4	pr6|378
						STATEMENT 1 ON LINE 2865
	io_call_infop = a_info_ptr;

015517  aa  6 00032 3735 20	epp7 	pr6|26,*
015520  aa  7 00006 3715 20	epp5 	pr7|6,*		a_info_ptr
015521  aa  5 00000 3715 20	epp5 	pr5|0,*		a_info_ptr
015522  aa  6 00760 6515 00	spri5	pr6|496		io_call_infop
						STATEMENT 1 ON LINE 2866
	if io_call_info.order_name = "setsize"
	     then do;

015523  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
015524  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
015525  aa   763053 00 0007	desc9a	-6613,7		000576 = 163145164163
015526  aa   000153 6010 04	tnz  	107,ic		015701
						STATEMENT 1 ON LINE 2868
		if io_call_info.nargs ^> 0
		     then do;

015527  aa  5 00042 2361 00	ldq  	pr5|34		io_call_info.nargs
015530  aa   000027 6054 04	tpnz 	23,ic		015557
						STATEMENT 1 ON LINE 2870
			call io_call_info.error (error_table_$noarg, io_call_info.caller_name, "New size.");

015531  aa   763067 2370 04	ldaq 	-6601,ic		000620 = 116145167040 163151172145
015532  aa  6 01650 7571 00	staq 	pr6|936
015533  aa   056000 2350 03	lda  	23552,du
015534  aa  6 01652 7551 00	sta  	pr6|938
015535  aa  6 00044 3701 20	epp4 	pr6|36,*
015536  la  4 00056 3521 20	epp2 	pr4|46,*		error_table_$noarg
015537  aa  6 01656 2521 00	spri2	pr6|942
015540  aa  5 00001 3521 00	epp2 	pr5|1		io_call_info.caller_name
015541  aa  6 01660 2521 00	spri2	pr6|944
015542  aa  6 01650 3521 00	epp2 	pr6|936
015543  aa  6 01662 2521 00	spri2	pr6|946
015544  aa   762754 3520 04	epp2 	-6676,ic		000520 = 404000000043
015545  aa  6 01666 2521 00	spri2	pr6|950
015546  aa   762710 3520 04	epp2 	-6712,ic		000456 = 524000000040
015547  aa  6 01670 2521 00	spri2	pr6|952
015550  aa   762641 3520 04	epp2 	-6751,ic		000411 = 524000000011
015551  aa  6 01672 2521 00	spri2	pr6|954
015552  aa  6 01654 6211 00	eax1 	pr6|940
015553  aa   014000 4310 07	fld  	6144,dl
015554  aa  5 00026 3521 00	epp2 	pr5|22		io_call_info.error
015555  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2871
			return;

015556  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2872
		     end;

						STATEMENT 1 ON LINE 2873
		setsize = cv_dec_check_ ((io_call_info.args (1)), code);

015557  aa  5 00044 2361 00	ldq  	pr5|36		io_call_info.args
015560  aa   524000 2760 03	orq  	174080,du
015561  aa  6 01653 7561 00	stq  	pr6|939
015562  aa  5 00044 2361 00	ldq  	pr5|36		io_call_info.args
015563  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
015564  aa  6 01656 2521 00	spri2	pr6|942
015565  aa  5 00044 2351 00	lda  	pr5|36		io_call_info.args
015566  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
015567  aa  5 00045 00 0005	desc9a	pr5|37,al		io_call_info.args
015570  aa  2 00000 00 0006	desc9a	pr2|0,ql
015571  aa  6 00157 3521 00	epp2 	pr6|111		code
015572  aa  6 01660 2521 00	spri2	pr6|944
015573  aa  6 00614 3521 00	epp2 	pr6|396		setsize
015574  aa  6 01662 2521 00	spri2	pr6|946
015575  aa  6 01653 3521 00	epp2 	pr6|939
015576  aa  6 01664 2521 00	spri2	pr6|948
015577  aa   762721 3520 04	epp2 	-6703,ic		000520 = 404000000043
015600  aa  6 01666 2521 00	spri2	pr6|950
015601  aa  6 01670 2521 00	spri2	pr6|952
015602  aa  6 01654 6211 00	eax1 	pr6|940
015603  aa   014000 4310 07	fld  	6144,dl
015604  aa  6 00044 3701 20	epp4 	pr6|36,*
015605  la  4 00132 3521 20	epp2 	pr4|90,*		cv_dec_check_
015606  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2874
		if code ^= 0
		     then do;

015607  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
015610  aa  6 00157 2361 00	ldq  	pr6|111		code
015611  aa   000037 6000 04	tze  	31,ic		015650
						STATEMENT 1 ON LINE 2876
			call io_call_info
			     .error (0, io_call_info.caller_name, "Invalid size: ^a.", io_call_info.args (1));

015612  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
015613  aa  7 00043 2361 00	ldq  	pr7|35		io_call_info.max_arglen
015614  aa   530000 2760 03	orq  	176128,du
015615  aa  6 01653 7561 00	stq  	pr6|939
015616  aa  6 01676 4501 00	stz  	pr6|958
015617  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
015620  aa   763130 00 0024	desc9a	-6568,20		000747 = 111156166141
015621  aa  6 01654 00 0024	desc9a	pr6|940,20
015622  aa  6 01676 3521 00	epp2 	pr6|958
015623  aa  6 01702 2521 00	spri2	pr6|962
015624  aa  7 00001 3521 00	epp2 	pr7|1		io_call_info.caller_name
015625  aa  6 01704 2521 00	spri2	pr6|964
015626  aa  6 01654 3521 00	epp2 	pr6|940
015627  aa  6 01706 2521 00	spri2	pr6|966
015630  aa  7 00045 3521 00	epp2 	pr7|37		io_call_info.args
015631  aa  6 01710 2521 00	spri2	pr6|968
015632  aa   762654 3520 04	epp2 	-6740,ic		000506 = 404000000005
015633  aa  6 01714 2521 00	spri2	pr6|972
015634  aa   762622 3520 04	epp2 	-6766,ic		000456 = 524000000040
015635  aa  6 01716 2521 00	spri2	pr6|974
015636  aa   762600 3520 04	epp2 	-6784,ic		000436 = 524000000021
015637  aa  6 01720 2521 00	spri2	pr6|976
015640  aa  6 01653 3521 00	epp2 	pr6|939
015641  aa  6 01722 2521 00	spri2	pr6|978
015642  aa  6 01700 6211 00	eax1 	pr6|960
015643  aa   020000 4310 07	fld  	8192,dl
015644  aa  7 00026 3521 00	epp2 	pr7|22		io_call_info.error
015645  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2878
			code = 0;

015646  aa  6 00157 4501 00	stz  	pr6|111		code
						STATEMENT 1 ON LINE 2879
			return;

015647  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2880
		     end;

						STATEMENT 1 ON LINE 2881
		call iox_$control (iocb_ptr, "setsize", addr (setsize), code);

015650  aa   762726 2370 04	ldaq 	-6698,ic		000576 = 163145164163 151172145000
015651  aa  6 01674 7571 00	staq 	pr6|956
015652  aa  6 00614 3735 00	epp7 	pr6|396		setsize
015653  aa  6 01724 6535 00	spri7	pr6|980
015654  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
015655  aa  6 01702 2521 00	spri2	pr6|962
015656  aa  6 01674 3521 00	epp2 	pr6|956
015657  aa  6 01704 2521 00	spri2	pr6|964
015660  aa  6 01724 3521 00	epp2 	pr6|980
015661  aa  6 01706 2521 00	spri2	pr6|966
015662  aa  6 00157 3521 00	epp2 	pr6|111		code
015663  aa  6 01710 2521 00	spri2	pr6|968
015664  aa   762635 3520 04	epp2 	-6755,ic		000521 = 464000000000
015665  aa  6 01712 2521 00	spri2	pr6|970
015666  aa  6 01716 2521 00	spri2	pr6|974
015667  aa   762520 3520 04	epp2 	-6832,ic		000407 = 524000000007
015670  aa  6 01714 2521 00	spri2	pr6|972
015671  aa   762627 3520 04	epp2 	-6761,ic		000520 = 404000000043
015672  aa  6 01720 2521 00	spri2	pr6|976
015673  aa  6 01700 6211 00	eax1 	pr6|960
015674  aa   020000 4310 07	fld  	8192,dl
015675  aa  6 00044 3701 20	epp4 	pr6|36,*
015676  la  4 00174 3521 20	epp2 	pr4|124,*		iox_$control
015677  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2882
		return;

015700  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2883
	     end;

						STATEMENT 1 ON LINE 2884
	else if io_call_info.order_name = "changepack"
	     then do;

015701  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
015702  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
015703  aa   762747 00 0012	desc9a	-6681,10		000650 = 143150141156
015704  aa   000074 6010 04	tnz  	60,ic		016000
						STATEMENT 1 ON LINE 2886
		if io_call_info.nargs ^> 0
		     then do;

015705  aa  5 00042 2361 00	ldq  	pr5|34		io_call_info.nargs
015706  aa   000027 6054 04	tpnz 	23,ic		015735
						STATEMENT 1 ON LINE 2888
			call io_call_info.error (error_table_$noarg, io_call_info.caller_name, "New pack name.");

015707  aa   762773 2370 04	ldaq 	-6661,ic		000702 = 116145167040 160141143153
015710  aa  6 01654 7571 00	staq 	pr6|940
015711  aa   762773 2370 04	ldaq 	-6661,ic		000704 = 040156141155 145056000000
015712  aa  6 01656 7571 00	staq 	pr6|942
015713  aa  6 00044 3701 20	epp4 	pr6|36,*
015714  la  4 00056 3521 20	epp2 	pr4|46,*		error_table_$noarg
015715  aa  6 01702 2521 00	spri2	pr6|962
015716  aa  5 00001 3521 00	epp2 	pr5|1		io_call_info.caller_name
015717  aa  6 01704 2521 00	spri2	pr6|964
015720  aa  6 01654 3521 00	epp2 	pr6|940
015721  aa  6 01706 2521 00	spri2	pr6|966
015722  aa   762576 3520 04	epp2 	-6786,ic		000520 = 404000000043
015723  aa  6 01712 2521 00	spri2	pr6|970
015724  aa   762532 3520 04	epp2 	-6822,ic		000456 = 524000000040
015725  aa  6 01714 2521 00	spri2	pr6|972
015726  aa   762460 3520 04	epp2 	-6864,ic		000406 = 524000000016
015727  aa  6 01716 2521 00	spri2	pr6|974
015730  aa  6 01700 6211 00	eax1 	pr6|960
015731  aa   014000 4310 07	fld  	6144,dl
015732  aa  5 00026 3521 00	epp2 	pr5|22		io_call_info.error
015733  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2889
			return;

015734  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2890
		     end;

						STATEMENT 1 ON LINE 2891
		changepack = io_call_info.args (1);

015735  aa  5 00044 2361 00	ldq  	pr5|36		io_call_info.args
015736  aa   000040 1160 07	cmpq 	32,dl
015737  aa   000002 6040 04	tmi  	2,ic		015741
015740  aa   000040 2360 07	ldq  	32,dl
015741  aa  6 00600 7561 00	stq  	pr6|384		changepack
015742  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
015743  aa  5 00045 00 0006	desc9a	pr5|37,ql		io_call_info.args
015744  aa  6 00601 00 0006	desc9a	pr6|385,ql	changepack
						STATEMENT 1 ON LINE 2892
		call iox_$control (iocb_ptr, "changepack", addr (changepack), code);

015745  aa   762703 2370 04	ldaq 	-6717,ic		000650 = 143150141156 147145160141
015746  aa  6 01650 7571 00	staq 	pr6|936
015747  aa   143153 2350 03	lda  	50795,du
015750  aa  6 01652 7551 00	sta  	pr6|938
015751  aa  6 00600 3535 00	epp3 	pr6|384		changepack
015752  aa  6 01724 2535 00	spri3	pr6|980
015753  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
015754  aa  6 01702 2521 00	spri2	pr6|962
015755  aa  6 01650 3521 00	epp2 	pr6|936
015756  aa  6 01704 2521 00	spri2	pr6|964
015757  aa  6 01724 3521 00	epp2 	pr6|980
015760  aa  6 01706 2521 00	spri2	pr6|966
015761  aa  6 00157 3521 00	epp2 	pr6|111		code
015762  aa  6 01710 2521 00	spri2	pr6|968
015763  aa   762536 3520 04	epp2 	-6818,ic		000521 = 464000000000
015764  aa  6 01712 2521 00	spri2	pr6|970
015765  aa  6 01716 2521 00	spri2	pr6|974
015766  aa   762467 3520 04	epp2 	-6857,ic		000455 = 524000000012
015767  aa  6 01714 2521 00	spri2	pr6|972
015770  aa   762530 3520 04	epp2 	-6824,ic		000520 = 404000000043
015771  aa  6 01720 2521 00	spri2	pr6|976
015772  aa  6 01700 6211 00	eax1 	pr6|960
015773  aa   020000 4310 07	fld  	8192,dl
015774  aa  6 00044 3701 20	epp4 	pr6|36,*
015775  la  4 00174 3521 20	epp2 	pr4|124,*		iox_$control
015776  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2893
		return;

015777  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2894
	     end;

						STATEMENT 1 ON LINE 2895
	else if io_call_info.order_name = "getbounds"
	     then do;

016000  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
016001  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
016002  aa   762653 00 0011	desc9a	-6741,9		000653 = 147145164142
016003  aa   000066 6010 04	tnz  	54,ic		016071
						STATEMENT 1 ON LINE 2897
		call iox_$control (iocb_ptr, "getbounds", addr (getbounds), code);

016004  aa   762647 2350 04	lda  	-6745,ic		000653 = 147145164142
016005  aa   762647 2360 04	ldq  	-6745,ic		000654 = 157165156144
016006  aa  6 01650 7571 00	staq 	pr6|936
016007  aa   163000 2350 03	lda  	58880,du
016010  aa  6 01652 7551 00	sta  	pr6|938
016011  aa  6 00612 3535 00	epp3 	pr6|394		getbounds
016012  aa  6 01724 2535 00	spri3	pr6|980
016013  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
016014  aa  6 01702 2521 00	spri2	pr6|962
016015  aa  6 01650 3521 00	epp2 	pr6|936
016016  aa  6 01704 2521 00	spri2	pr6|964
016017  aa  6 01724 3521 00	epp2 	pr6|980
016020  aa  6 01706 2521 00	spri2	pr6|966
016021  aa  6 00157 3521 00	epp2 	pr6|111		code
016022  aa  6 01710 2521 00	spri2	pr6|968
016023  aa   762476 3520 04	epp2 	-6850,ic		000521 = 464000000000
016024  aa  6 01712 2521 00	spri2	pr6|970
016025  aa  6 01716 2521 00	spri2	pr6|974
016026  aa   762363 3520 04	epp2 	-6925,ic		000411 = 524000000011
016027  aa  6 01714 2521 00	spri2	pr6|972
016030  aa   762470 3520 04	epp2 	-6856,ic		000520 = 404000000043
016031  aa  6 01720 2521 00	spri2	pr6|976
016032  aa  6 01700 6211 00	eax1 	pr6|960
016033  aa   020000 4310 07	fld  	8192,dl
016034  aa  6 00044 3701 20	epp4 	pr6|36,*
016035  la  4 00174 3521 20	epp2 	pr4|124,*		iox_$control
016036  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2898
		if code = 0
		     then do;

016037  aa  6 00157 2361 00	ldq  	pr6|111		code
016040  aa   000030 6010 04	tnz  	24,ic		016070
						STATEMENT 1 ON LINE 2900
			call io_call_info
			     .
			     report ("^a: Sectors available are ^d:^d", io_call_info.caller_name, getbounds.low,
			     getbounds.high);

016041  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016042  aa   763051 00 0040	desc9a	-6615,32		001112 = 136141072040
016043  aa  6 01654 00 0040	desc9a	pr6|940,32
016044  aa  6 01654 3521 00	epp2 	pr6|940
016045  aa  6 01702 2521 00	spri2	pr6|962
016046  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016047  aa  7 00001 3521 00	epp2 	pr7|1		io_call_info.caller_name
016050  aa  6 01704 2521 00	spri2	pr6|964
016051  aa  6 00612 3521 00	epp2 	pr6|394		getbounds.low
016052  aa  6 01706 2521 00	spri2	pr6|966
016053  aa  6 00613 3521 00	epp2 	pr6|395		getbounds.high
016054  aa  6 01710 2521 00	spri2	pr6|968
016055  aa   762407 3520 04	epp2 	-6905,ic		000464 = 524000000037
016056  aa  6 01714 2521 00	spri2	pr6|972
016057  aa   762377 3520 04	epp2 	-6913,ic		000456 = 524000000040
016060  aa  6 01716 2521 00	spri2	pr6|974
016061  aa   762437 3520 04	epp2 	-6881,ic		000520 = 404000000043
016062  aa  6 01720 2521 00	spri2	pr6|976
016063  aa  6 01722 2521 00	spri2	pr6|978
016064  aa  6 01700 6211 00	eax1 	pr6|960
016065  aa   020000 4310 07	fld  	8192,dl
016066  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016067  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2904
		     end;

						STATEMENT 1 ON LINE 2905
		return;

016070  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2906
	     end;

						STATEMENT 1 ON LINE 2907
	else if io_call_info.order_name = "device_info"
	     then do;

016071  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
016072  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
016073  aa   762551 00 0013	desc9a	-6807,11		000642 = 144145166151
016074  aa   000177 6010 04	tnz  	127,ic		016273
						STATEMENT 1 ON LINE 2909
		call iox_$control (iocb_ptr, "device_info", addr (device_info_table), code);

016075  aa   762545 2370 04	ldaq 	-6811,ic		000642 = 144145166151 143145137151
016076  aa  6 01650 7571 00	staq 	pr6|936
016077  aa   762545 2350 04	lda  	-6811,ic		000644 = 156146157000
016100  aa  6 01652 7551 00	sta  	pr6|938
016101  aa  6 00615 3535 00	epp3 	pr6|397		device_info_table
016102  aa  6 01724 2535 00	spri3	pr6|980
016103  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
016104  aa  6 01702 2521 00	spri2	pr6|962
016105  aa  6 01650 3521 00	epp2 	pr6|936
016106  aa  6 01704 2521 00	spri2	pr6|964
016107  aa  6 01724 3521 00	epp2 	pr6|980
016110  aa  6 01706 2521 00	spri2	pr6|966
016111  aa  6 00157 3521 00	epp2 	pr6|111		code
016112  aa  6 01710 2521 00	spri2	pr6|968
016113  aa   762406 3520 04	epp2 	-6906,ic		000521 = 464000000000
016114  aa  6 01712 2521 00	spri2	pr6|970
016115  aa  6 01716 2521 00	spri2	pr6|974
016116  aa   762274 3520 04	epp2 	-6980,ic		000412 = 524000000013
016117  aa  6 01714 2521 00	spri2	pr6|972
016120  aa   762400 3520 04	epp2 	-6912,ic		000520 = 404000000043
016121  aa  6 01720 2521 00	spri2	pr6|976
016122  aa  6 01700 6211 00	eax1 	pr6|960
016123  aa   020000 4310 07	fld  	8192,dl
016124  aa  6 00044 3701 20	epp4 	pr6|36,*
016125  la  4 00174 3521 20	epp2 	pr4|124,*		iox_$control
016126  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2910
		if code = 0
		     then do;

016127  aa  6 00157 2361 00	ldq  	pr6|111		code
016130  aa   000142 6010 04	tnz  	98,ic		016272
						STATEMENT 1 ON LINE 2912
			call io_call_info
			     .
			     report ("Device Characteristics:^/^/device type:^-^-^a^/device name:^-^-^a",
			     device_info_table.dev_type, device_info_table.device_name);

016131  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016132  aa   763655 00 0104	desc9a	-6227,68		002006 = 104145166151
016133  aa  6 01700 00 0104	desc9a	pr6|960,68
016134  aa  6 01700 3521 00	epp2 	pr6|960
016135  aa  6 01656 2521 00	spri2	pr6|942
016136  aa  6 00615 3521 00	epp2 	pr6|397		device_info_table.dev_type
016137  aa  6 01660 2521 00	spri2	pr6|944
016140  aa  6 00616 3521 00	epp2 	pr6|398		device_info_table.device_name
016141  aa  6 01662 2521 00	spri2	pr6|946
016142  aa   762243 3520 04	epp2 	-7005,ic		000405 = 524000000101
016143  aa  6 01666 2521 00	spri2	pr6|950
016144  aa   762332 3520 04	epp2 	-6950,ic		000476 = 524000000004
016145  aa  6 01670 2521 00	spri2	pr6|952
016146  aa   762267 3520 04	epp2 	-6985,ic		000435 = 524000000010
016147  aa  6 01672 2521 00	spri2	pr6|954
016150  aa  6 01654 6211 00	eax1 	pr6|940
016151  aa   014000 4310 07	fld  	6144,dl
016152  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016153  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016154  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2916
			call io_call_info
			     .
			     report ("sectors per device:^-^-^d^/cylinders per device:^-^d",
			     device_info_table.sect_per_dev, device_info_table.cyl_per_dev);

016155  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016156  aa   763373 00 0064	desc9a	-6405,52		001550 = 163145143164
016157  aa  6 01654 00 0064	desc9a	pr6|940,52
016160  aa  6 01654 3521 00	epp2 	pr6|940
016161  aa  6 01702 2521 00	spri2	pr6|962
016162  aa  6 00620 3521 00	epp2 	pr6|400		device_info_table.sect_per_dev
016163  aa  6 01704 2521 00	spri2	pr6|964
016164  aa  6 00621 3521 00	epp2 	pr6|401		device_info_table.cyl_per_dev
016165  aa  6 01706 2521 00	spri2	pr6|966
016166  aa   762216 3520 04	epp2 	-7026,ic		000404 = 524000000064
016167  aa  6 01712 2521 00	spri2	pr6|970
016170  aa   762330 3520 04	epp2 	-6952,ic		000520 = 404000000043
016171  aa  6 01714 2521 00	spri2	pr6|972
016172  aa   762322 3520 04	epp2 	-6958,ic		000514 = 404000000021
016173  aa  6 01716 2521 00	spri2	pr6|974
016174  aa  6 01700 6211 00	eax1 	pr6|960
016175  aa   014000 4310 07	fld  	6144,dl
016176  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016177  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016200  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2920
			call io_call_info
			     .
			     report ("sectors per cylinder:^-^d^/sectors per track:^-^-^d",
			     device_info_table.sect_per_cyl, device_info_table.sect_per_track);

016201  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016202  aa   763332 00 0064	desc9a	-6438,52		001533 = 163145143164
016203  aa  6 01654 00 0064	desc9a	pr6|940,52
016204  aa  6 01654 3521 00	epp2 	pr6|940
016205  aa  6 01702 2521 00	spri2	pr6|962
016206  aa  6 00622 3521 00	epp2 	pr6|402		device_info_table.sect_per_cyl
016207  aa  6 01704 2521 00	spri2	pr6|964
016210  aa  6 00623 3521 00	epp2 	pr6|403		device_info_table.sect_per_track
016211  aa  6 01706 2521 00	spri2	pr6|966
016212  aa   762171 3520 04	epp2 	-7047,ic		000403 = 524000000063
016213  aa  6 01712 2521 00	spri2	pr6|970
016214  aa   762300 3520 04	epp2 	-6976,ic		000514 = 404000000021
016215  aa  6 01714 2521 00	spri2	pr6|972
016216  aa  6 01716 2521 00	spri2	pr6|974
016217  aa  6 01700 6211 00	eax1 	pr6|960
016220  aa   014000 4310 07	fld  	6144,dl
016221  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016222  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016223  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2924
			call io_call_info
			     .
			     report ("number of label sectors:^-^d^/number of alternate sectors:^-^d",
			     device_info_table.num_label_sect, device_info_table.num_alt_sect);

016224  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016225  aa   763522 00 0100	desc9a	-6318,64		001746 = 156165155142
016226  aa  6 01654 00 0100	desc9a	pr6|940,64
016227  aa  6 01654 3521 00	epp2 	pr6|940
016230  aa  6 01702 2521 00	spri2	pr6|962
016231  aa  6 00624 3521 00	epp2 	pr6|404		device_info_table.num_label_sect
016232  aa  6 01704 2521 00	spri2	pr6|964
016233  aa  6 00625 3521 00	epp2 	pr6|405		device_info_table.num_alt_sect
016234  aa  6 01706 2521 00	spri2	pr6|966
016235  aa   762145 3520 04	epp2 	-7067,ic		000402 = 524000000076
016236  aa  6 01712 2521 00	spri2	pr6|970
016237  aa   762255 3520 04	epp2 	-6995,ic		000514 = 404000000021
016240  aa  6 01714 2521 00	spri2	pr6|972
016241  aa  6 01716 2521 00	spri2	pr6|974
016242  aa  6 01700 6211 00	eax1 	pr6|960
016243  aa   014000 4310 07	fld  	6144,dl
016244  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016245  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016246  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2928
			call io_call_info.report ("sector size (words):^-^d", device_info_table.sect_size);

016247  aa   762565 2370 04	ldaq 	-6795,ic		001034 = 163145143164 157162040163
016250  aa  6 01654 7571 00	staq 	pr6|940
016251  aa   762565 2370 04	ldaq 	-6795,ic		001036 = 151172145040 050167157162
016252  aa  6 01656 7571 00	staq 	pr6|942
016253  aa   762565 2370 04	ldaq 	-6795,ic		001040 = 144163051072 136055136144
016254  aa  6 01660 7571 00	staq 	pr6|944
016255  aa  6 01654 3521 00	epp2 	pr6|940
016256  aa  6 01702 2521 00	spri2	pr6|962
016257  aa  6 00626 3521 00	epp2 	pr6|406		device_info_table.sect_size
016260  aa  6 01704 2521 00	spri2	pr6|964
016261  aa   762120 3520 04	epp2 	-7088,ic		000401 = 524000000030
016262  aa  6 01710 2521 00	spri2	pr6|968
016263  aa   762115 3520 04	epp2 	-7091,ic		000400 = 404000000014
016264  aa  6 01712 2521 00	spri2	pr6|970
016265  aa  6 01700 6211 00	eax1 	pr6|960
016266  aa   010000 4310 07	fld  	4096,dl
016267  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016270  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016271  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2929
		     end;

						STATEMENT 1 ON LINE 2930
		return;

016272  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2931
	     end;

						STATEMENT 1 ON LINE 2933
	else if io_call_info.order_name = "read_track_header"
	     then do;

016273  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
016274  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
016275  aa   762473 00 0021	desc9a	-6853,17		000766 = 162145141144
016276  aa   000126 6010 04	tnz  	86,ic		016424
						STATEMENT 1 ON LINE 2935
		track_header_data.version = thi_version_1;

016277  aa   000001 2360 07	ldq  	1,dl
016300  aa  6 00627 7561 00	stq  	pr6|407		track_header_data.version
						STATEMENT 1 ON LINE 2936
		call iox_$control (iocb_ptr, "read_track_header", addr (track_header_data), code);

016301  aa   762465 2370 04	ldaq 	-6859,ic		000766 = 162145141144 137164162141
016302  aa  6 01654 7571 00	staq 	pr6|940
016303  aa   762465 2370 04	ldaq 	-6859,ic		000770 = 143153137150 145141144145
016304  aa  6 01656 7571 00	staq 	pr6|942
016305  aa   162000 2350 03	lda  	58368,du
016306  aa  6 01660 7551 00	sta  	pr6|944
016307  aa  6 00627 3535 00	epp3 	pr6|407		track_header_data
016310  aa  6 01724 2535 00	spri3	pr6|980
016311  aa  6 00140 3521 00	epp2 	pr6|96		iocb_ptr
016312  aa  6 01702 2521 00	spri2	pr6|962
016313  aa  6 01654 3521 00	epp2 	pr6|940
016314  aa  6 01704 2521 00	spri2	pr6|964
016315  aa  6 01724 3521 00	epp2 	pr6|980
016316  aa  6 01706 2521 00	spri2	pr6|966
016317  aa  6 00157 3521 00	epp2 	pr6|111		code
016320  aa  6 01710 2521 00	spri2	pr6|968
016321  aa   762200 3520 04	epp2 	-7040,ic		000521 = 464000000000
016322  aa  6 01712 2521 00	spri2	pr6|970
016323  aa  6 01716 2521 00	spri2	pr6|974
016324  aa   762112 3520 04	epp2 	-7094,ic		000436 = 524000000021
016325  aa  6 01714 2521 00	spri2	pr6|972
016326  aa   762172 3520 04	epp2 	-7046,ic		000520 = 404000000043
016327  aa  6 01720 2521 00	spri2	pr6|976
016330  aa  6 01700 6211 00	eax1 	pr6|960
016331  aa   020000 4310 07	fld  	8192,dl
016332  aa  6 00044 3701 20	epp4 	pr6|36,*
016333  la  4 00174 3521 20	epp2 	pr4|124,*		iox_$control
016334  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2937
		if code = 0
		     then if io_call_info.nargs > 0
			     then if io_call_info.args (1) = "-hex"
				     then call print_track_header_info (addr (track_header_data),
					     io_call_info.report, "1"b);

016335  aa  6 00157 2361 00	ldq  	pr6|111		code
016336  aa   000065 6010 04	tnz  	53,ic		016423
016337  aa  6 00760 3735 20	epp7 	pr6|496,*		io_call_infop
016340  aa  7 00042 2361 00	ldq  	pr7|34		io_call_info.nargs
016341  aa   000044 6044 04	tmoz 	36,ic		016405
016342  aa  7 00044 2351 00	lda  	pr7|36		io_call_info.args
016343  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
016344  aa  7 00045 00 0005	desc9a	pr7|37,al		io_call_info.args
016345  aa   762034 00 0004	desc9a	-7140,4		000377 = 055150145170
016346  aa   000020 6010 04	tnz  	16,ic		016366
016347  aa  6 00627 3715 00	epp5 	pr6|407		track_header_data
016350  aa  6 01724 6515 00	spri5	pr6|980
016351  aa   400000 2350 03	lda  	131072,du
016352  aa  6 01653 7551 00	sta  	pr6|939
016353  aa  6 01724 3521 00	epp2 	pr6|980
016354  aa  6 01656 2521 00	spri2	pr6|942
016355  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016356  aa  6 01660 2521 00	spri2	pr6|944
016357  aa  6 01653 3521 00	epp2 	pr6|939
016360  aa  6 01662 2521 00	spri2	pr6|946
016361  aa  6 01654 3521 00	epp2 	pr6|940
016362  aa   014000 4310 07	fld  	6144,dl
016363  aa  2 00000 7571 00	staq 	pr2|0
016364  aa   000110 6700 04	tsp4 	72,ic		016474
016365  aa   000036 7100 04	tra  	30,ic		016423
						STATEMENT 1 ON LINE 2942
				     else call print_track_header_info (addr (track_header_data),
					     io_call_info.report, "0"b);

016366  aa  6 00627 3715 00	epp5 	pr6|407		track_header_data
016367  aa  6 01724 6515 00	spri5	pr6|980
016370  aa   000000 2350 07	lda  	0,dl
016371  aa  6 01653 7551 00	sta  	pr6|939
016372  aa  6 01724 3521 00	epp2 	pr6|980
016373  aa  6 01656 2521 00	spri2	pr6|942
016374  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016375  aa  6 01660 2521 00	spri2	pr6|944
016376  aa  6 01653 3521 00	epp2 	pr6|939
016377  aa  6 01662 2521 00	spri2	pr6|946
016400  aa  6 01654 3521 00	epp2 	pr6|940
016401  aa   014000 4310 07	fld  	6144,dl
016402  aa  2 00000 7571 00	staq 	pr2|0
016403  aa   000071 6700 04	tsp4 	57,ic		016474
016404  aa   000017 7100 04	tra  	15,ic		016423
						STATEMENT 1 ON LINE 2944
			     else call print_track_header_info (addr (track_header_data), io_call_info.report, "0"b)
				     ;

016405  aa  6 00627 3715 00	epp5 	pr6|407		track_header_data
016406  aa  6 01724 6515 00	spri5	pr6|980
016407  aa   000000 2350 07	lda  	0,dl
016410  aa  6 01653 7551 00	sta  	pr6|939
016411  aa  6 01724 3521 00	epp2 	pr6|980
016412  aa  6 01656 2521 00	spri2	pr6|942
016413  aa  7 00022 3521 00	epp2 	pr7|18		io_call_info.report
016414  aa  6 01660 2521 00	spri2	pr6|944
016415  aa  6 01653 3521 00	epp2 	pr6|939
016416  aa  6 01662 2521 00	spri2	pr6|946
016417  aa  6 01654 3521 00	epp2 	pr6|940
016420  aa   014000 4310 07	fld  	6144,dl
016421  aa  2 00000 7571 00	staq 	pr2|0
016422  aa   000052 6700 04	tsp4 	42,ic		016474
						STATEMENT 1 ON LINE 2946
		return;

016423  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2947
	     end;

						STATEMENT 1 ON LINE 2948
	else if io_call_info.order_name = "format_trk" | io_call_info.order_name = "rd_trk_header"
	     | io_call_info.order_name = "read_track_header"
	     then do;

016424  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
016425  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
016426  aa   762213 00 0012	desc9a	-7029,10		000637 = 146157162155
016427  aa   000011 6000 04	tze  	9,ic		016440
016430  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
016431  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
016432  aa   762266 00 0015	desc9a	-6986,13		000716 = 162144137164
016433  aa   000005 6000 04	tze  	5,ic		016440
016434  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
016435  aa  5 00011 00 0040	desc9a	pr5|9,32		io_call_info.order_name
016436  aa   762332 00 0021	desc9a	-6950,17		000766 = 162145141144
016437  aa   000031 6010 04	tnz  	25,ic		016470
						STATEMENT 1 ON LINE 2951
		call io_call_info
		     .
		     error (0, io_call_info.caller_name, "The ^a control order is not supported by io_call",
		     io_call_info.order_name);

016440  aa  6 01653 4501 00	stz  	pr6|939
016441  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016442  aa   762746 00 0060	desc9a	-6682,48		001407 = 124150145040
016443  aa  6 01654 00 0060	desc9a	pr6|940,48
016444  aa  6 01653 3521 00	epp2 	pr6|939
016445  aa  6 01702 2521 00	spri2	pr6|962
016446  aa  5 00001 3521 00	epp2 	pr5|1		io_call_info.caller_name
016447  aa  6 01704 2521 00	spri2	pr6|964
016450  aa  6 01654 3521 00	epp2 	pr6|940
016451  aa  6 01706 2521 00	spri2	pr6|966
016452  aa  5 00011 3521 00	epp2 	pr5|9		io_call_info.order_name
016453  aa  6 01710 2521 00	spri2	pr6|968
016454  aa   762032 3520 04	epp2 	-7142,ic		000506 = 404000000005
016455  aa  6 01714 2521 00	spri2	pr6|972
016456  aa   762000 3520 04	epp2 	-7168,ic		000456 = 524000000040
016457  aa  6 01716 2521 00	spri2	pr6|974
016460  aa  6 01722 2521 00	spri2	pr6|978
016461  aa   762022 3520 04	epp2 	-7150,ic		000503 = 524000000060
016462  aa  6 01720 2521 00	spri2	pr6|976
016463  aa  6 01700 6211 00	eax1 	pr6|960
016464  aa   020000 4310 07	fld  	8192,dl
016465  aa  5 00026 3521 00	epp2 	pr5|22		io_call_info.error
016466  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2955
		return;

016467  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2956
	     end;

						STATEMENT 1 ON LINE 2958
	else code = error_table_$no_operation;

016470  aa  6 00044 3701 20	epp4 	pr6|36,*
016471  la  4 00052 2361 20	ldq  	pr4|42,*		error_table_$no_operation
016472  aa  6 00157 7561 00	stq  	pr6|111		code
						STATEMENT 1 ON LINE 2959
	return;

016473  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 2961
     end io_call_order;

  END PROCEDURE io_call_order
BEGIN PROCEDURE print_track_header_info
ENTRY TO print_track_header_info                            STATEMENT 1 ON LINE 2963
print_track_header_info:
     proc (thip, report, all_sw);

016474  aa  6 00762 6501 00	spri4	pr6|498
016475  aa  6 00764 2521 00	spri2	pr6|500
						STATEMENT 1 ON LINE 2971
016476  aa  6 00770 4501 00	stz  	pr6|504		header_dumped
						STATEMENT 1 ON LINE 2978
	call report ("^/position=(^d/^d)  ti=^2b^[  alternate=(^d/^d)^;^2s^]  tskip=^d,^d,^d  cf=^a",
	     thip -> thi.c0.cyl_lower + thip -> thi.c0.cyl_upper * 256, thip -> thi.c0.head, bit (thip -> thi.c0.ti),
	     (thip -> thi.c0.alt_cyl_lower + thip -> thi.c0.alt_cyl_upper + thip -> thi.c0.alt_head ^= 0),
	     thip -> thi.c0.alt_cyl_lower + thip -> thi.c0.alt_cyl_upper * 256, thip -> thi.c0.alt_head,
	     thip -> thi.c0.t_skip.distance, cond_flag (thip -> thi.c0.cf));

016477  aa   000034 7270 07	lxl7 	28,dl
016500  aa  2 00002 3735 20	epp7 	pr2|2,*		thip
016501  aa  7 00000 3735 20	epp7 	pr7|0,*		thip
016502  aa  7 00012 3521 00	epp2 	pr7|10		thi.cf
016503  aa  2 00000 5035 17	abd  	pr2|0,7
016504  aa  6 01730 2521 00	spri2	pr6|984
016505  aa  6 01742 3521 00	epp2 	pr6|994
016506  aa  6 01732 2521 00	spri2	pr6|986
016507  aa   761662 3520 04	epp2 	-7246,ic		000371 = 516000000010
016510  aa  6 01736 2521 00	spri2	pr6|990
016511  aa  6 01744 3521 00	epp2 	pr6|996
016512  aa  6 01740 2521 00	spri2	pr6|992
016513  aa  6 01726 6211 00	eax1 	pr6|982
016514  aa   010000 4310 07	fld  	4096,dl
016515  aa   000504 3520 04	epp2 	324,ic		017221 = 000360627000
016516  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
016517  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016520  aa   763310 00 0120	desc9a	-6456,80		002027 = 136057160157
016521  aa  6 01746 00 0120	desc9a	pr6|998,80
016522  aa  6 00764 3735 20	epp7 	pr6|500,*
016523  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
016524  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
016525  aa  5 00007 2351 00	lda  	pr5|7		thi.cyl_upper
016526  aa   000020 7350 00	als  	16
016527  aa   000106 7730 00	lrl  	70
016530  aa   000010 7360 00	qls  	8
016531  aa  6 01745 7561 00	stq  	pr6|997
016532  aa  5 00007 2351 00	lda  	pr5|7		thi.cyl_lower
016533  aa   000010 7350 00	als  	8
016534  aa   000100 7730 00	lrl  	64
016535  aa  6 01745 0761 00	adq  	pr6|997
016536  aa  6 01745 7561 00	stq  	pr6|997
016537  aa  5 00007 2351 00	lda  	pr5|7		thi.ti
016540  aa   000006 7350 00	als  	6
016541  aa   000106 7730 00	lrl  	70
016542  aa   000106 7370 00	lls  	70
016543  aa  6 01772 7551 00	sta  	pr6|1018
016544  aa  5 00011 2351 00	lda  	pr5|9		thi.alt_head
016545  aa   000002 7350 00	als  	2
016546  aa   000102 7730 00	lrl  	66
016547  aa  6 01773 7561 00	stq  	pr6|1019		thi.alt_head
016550  aa  5 00011 2351 00	lda  	pr5|9		thi.alt_cyl_upper
016551  aa   000106 7730 00	lrl  	70
016552  aa  6 01774 7561 00	stq  	pr6|1020		thi.alt_cyl_upper
016553  aa  5 00010 2361 00	ldq  	pr5|8		thi.alt_cyl_lower
016554  aa  0 00420 3771 00	anaq 	pr0|272		= 000000000000 000000000377
016555  aa  6 01775 7561 00	stq  	pr6|1021		thi.alt_cyl_lower
016556  aa  6 01774 0761 00	adq  	pr6|1020		thi.alt_cyl_upper
016557  aa  6 01773 0761 00	adq  	pr6|1019		thi.alt_head
016560  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
016561  aa  6 01773 7551 00	sta  	pr6|1019
016562  aa  6 01774 2361 00	ldq  	pr6|1020		thi.alt_cyl_upper
016563  aa   000010 7360 00	qls  	8
016564  aa  6 01775 0761 00	adq  	pr6|1021		thi.alt_cyl_lower
016565  aa  6 01775 7561 00	stq  	pr6|1021
016566  aa  6 01746 3521 00	epp2 	pr6|998
016567  aa  6 02000 2521 00	spri2	pr6|1024
016570  aa  6 01745 3521 00	epp2 	pr6|997
016571  aa  6 02002 2521 00	spri2	pr6|1026
016572  aa   000022 7270 07	lxl7 	18,dl
016573  aa  5 00007 3521 00	epp2 	pr5|7		thi.head
016574  aa  2 00000 5035 17	abd  	pr2|0,7
016575  aa  6 02004 2521 00	spri2	pr6|1028
016576  aa  6 01772 3521 00	epp2 	pr6|1018
016577  aa  6 02006 2521 00	spri2	pr6|1030
016600  aa  6 01773 3521 00	epp2 	pr6|1019
016601  aa  6 02010 2521 00	spri2	pr6|1032
016602  aa  6 01775 3521 00	epp2 	pr6|1021
016603  aa  6 02012 2521 00	spri2	pr6|1034
016604  aa   000002 7260 07	lxl6 	2,dl
016605  aa  5 00011 3521 00	epp2 	pr5|9		thi.alt_head
016606  aa  2 00000 5035 16	abd  	pr2|0,6
016607  aa  6 02014 2521 00	spri2	pr6|1036
016610  aa   000020 7250 07	lxl5 	16,dl
016611  aa  5 00011 3521 00	epp2 	pr5|9		thi.distance
016612  aa  2 00000 5035 15	abd  	pr2|0,5
016613  aa  6 02016 2521 00	spri2	pr6|1038
016614  aa  6 01742 3521 20	epp2 	pr6|994,*
016615  aa  6 02020 2521 00	spri2	pr6|1040
016616  aa   761557 3520 04	epp2 	-7313,ic		000375 = 524000000115
016617  aa  6 02024 2521 00	spri2	pr6|1044
016620  aa   761554 3520 04	epp2 	-7316,ic		000374 = 404000000017
016621  aa  6 02026 2521 00	spri2	pr6|1046
016622  aa  6 02036 2521 00	spri2	pr6|1054
016623  aa   761550 3520 04	epp2 	-7320,ic		000373 = 606000000006
016624  aa  6 02030 2521 00	spri2	pr6|1048
016625  aa  6 02040 2521 00	spri2	pr6|1056
016626  aa   761544 3520 04	epp2 	-7324,ic		000372 = 514000000002
016627  aa  6 02032 2521 00	spri2	pr6|1050
016630  aa   761665 3520 04	epp2 	-7243,ic		000515 = 514000000001
016631  aa  6 02034 2521 00	spri2	pr6|1052
016632  aa   762044 3520 04	epp2 	-7132,ic		000676 = 606100000010
016633  aa  6 02042 2521 00	spri2	pr6|1058
016634  aa  6 01744 3521 00	epp2 	pr6|996
016635  aa  6 02044 2521 00	spri2	pr6|1060
016636  aa  6 01776 6211 00	eax1 	pr6|1022
016637  aa   044000 4310 07	fld  	18432,dl
016640  aa  7 00004 3521 20	epp2 	pr7|4,*		report
016641  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2983
	call report (
	     "physical sector size = ^[512^;64^] words.^[Format of this disk by Honeywell has ^[not ^]completed.^;^s^]",
	     thip -> thi.c0.large_records, thip -> thi.c0.honeywell_formatted, ^(thip -> thi.c0.format_complete));

016642  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
016643  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016644  aa   763240 00 0150	desc9a	-6496,104		002103 = 160150171163
016645  aa  6 01776 00 0150	desc9a	pr6|1022,104
016646  aa  6 00764 3735 20	epp7 	pr6|500,*
016647  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
016650  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
016651  aa  5 00007 2351 00	lda  	pr5|7		thi.format_complete
016652  aa   000002 7350 00	als  	2
016653  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
016654  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
016655  aa  6 01744 7551 00	sta  	pr6|996
016656  aa  6 01776 3521 00	epp2 	pr6|1022
016657  aa  6 01750 2521 00	spri2	pr6|1000
016660  aa  5 00007 3521 00	epp2 	pr5|7		thi.large_records
016661  aa  6 01752 2521 00	spri2	pr6|1002
016662  aa   000001 7270 07	lxl7 	1,dl
016663  aa  5 00007 3521 00	epp2 	pr5|7		thi.honeywell_formatted
016664  aa  2 00000 5035 17	abd  	pr2|0,7
016665  aa  6 01754 2521 00	spri2	pr6|1004
016666  aa  6 01744 3521 00	epp2 	pr6|996
016667  aa  6 01756 2521 00	spri2	pr6|1006
016670  aa   761500 3520 04	epp2 	-7360,ic		000370 = 524000000150
016671  aa  6 01762 2521 00	spri2	pr6|1010
016672  aa   761533 3520 04	epp2 	-7333,ic		000425 = 516000000001
016673  aa  6 01764 2521 00	spri2	pr6|1012
016674  aa  6 01766 2521 00	spri2	pr6|1014
016675  aa   761620 3520 04	epp2 	-7280,ic		000515 = 514000000001
016676  aa  6 01770 2521 00	spri2	pr6|1016
016677  aa  6 01746 6211 00	eax1 	pr6|998
016700  aa   020000 4310 07	fld  	8192,dl
016701  aa  7 00004 3521 20	epp2 	pr7|4,*		report
016702  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2986
	if thip -> thi.c0.log_track then call report ("*** This is a log track. ***");

016703  aa  6 00764 3735 20	epp7 	pr6|500,*
016704  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
016705  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
016706  aa  5 00007 2351 00	lda  	pr5|7		thi.log_track
016707  aa   010000 3150 03	cana 	4096,du
016710  aa   000014 6000 04	tze  	12,ic		016724
016711  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
016712  aa   762154 00 0034	desc9a	-7060,28		001065 = 052052052040
016713  aa  6 01726 00 0034	desc9a	pr6|982,28
016714  aa  6 01726 3521 00	epp2 	pr6|982
016715  aa  6 01750 2521 00	spri2	pr6|1000
016716  aa   761451 3520 04	epp2 	-7383,ic		000367 = 524000000034
016717  aa  6 01754 2521 00	spri2	pr6|1004
016720  aa  6 01746 6211 00	eax1 	pr6|998
016721  aa   004000 4310 07	fld  	2048,dl
016722  aa  7 00004 3521 20	epp2 	pr7|4,*		report
016723  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2987
	call report ("^/skip1^5xskip2^5xcf^/");

016724  aa   762074 2370 04	ldaq 	-7108,ic		001020 = 136057163153 151160061136
016725  aa  6 01726 7571 00	staq 	pr6|982
016726  aa   762074 2370 04	ldaq 	-7108,ic		001022 = 065170163153 151160062136
016727  aa  6 01730 7571 00	staq 	pr6|984
016730  aa   762074 2370 04	ldaq 	-7108,ic		001024 = 065170143146 136057000000
016731  aa  6 01732 7571 00	staq 	pr6|986
016732  aa  6 01726 3521 00	epp2 	pr6|982
016733  aa  6 01750 2521 00	spri2	pr6|1000
016734  aa   761432 3520 04	epp2 	-7398,ic		000366 = 524000000026
016735  aa  6 01754 2521 00	spri2	pr6|1004
016736  aa  6 01746 6211 00	eax1 	pr6|998
016737  aa   004000 4310 07	fld  	2048,dl
016740  aa  6 00764 3735 20	epp7 	pr6|500,*
016741  aa  7 00004 3521 20	epp2 	pr7|4,*		report
016742  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2988
	call report ("^8a^2x^8a^2x^a", skip_mess (thip -> thi.c0.skip (1)), skip_mess (thip -> thi.c0.skip (2)),
	     cond_flag (thip -> thi.c0.cf));

016743  aa  6 00764 3735 20	epp7 	pr6|500,*
016744  aa   000034 7270 07	lxl7 	28,dl
016745  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
016746  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
016747  aa  5 00012 3521 00	epp2 	pr5|10		thi.cf
016750  aa  2 00000 5035 17	abd  	pr2|0,7
016751  aa  6 01730 2521 00	spri2	pr6|984
016752  aa  6 01742 3521 00	epp2 	pr6|994
016753  aa  6 01732 2521 00	spri2	pr6|986
016754  aa   761415 3520 04	epp2 	-7411,ic		000371 = 516000000010
016755  aa  6 01736 2521 00	spri2	pr6|990
016756  aa  6 01744 3521 00	epp2 	pr6|996
016757  aa  6 01740 2521 00	spri2	pr6|992
016760  aa  6 01726 6211 00	eax1 	pr6|982
016761  aa   010000 4310 07	fld  	4096,dl
016762  aa   000237 3520 04	epp2 	159,ic		017221 = 000360627000
016763  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
016764  aa   761706 2370 04	ldaq 	-7226,ic		000672 = 136070141136 062170136070
016765  aa  6 01726 7571 00	staq 	pr6|982
016766  aa   761706 2370 04	ldaq 	-7226,ic		000674 = 141136062170 136141000000
016767  aa  6 01730 7571 00	staq 	pr6|984
016770  aa  6 00764 3735 20	epp7 	pr6|500,*
016771  aa   000040 7270 07	lxl7 	32,dl
016772  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
016773  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
016774  aa  5 00007 3521 00	epp2 	pr5|7		thi.skip
016775  aa  2 00000 5035 17	abd  	pr2|0,7
016776  aa  6 01750 2521 00	spri2	pr6|1000
016777  aa  6 02046 3521 00	epp2 	pr6|1062
017000  aa  6 01752 2521 00	spri2	pr6|1002
017001  aa  6 01746 3521 00	epp2 	pr6|998
017002  aa   010000 4310 07	fld  	4096,dl
017003  aa  2 00000 7571 00	staq 	pr2|0
017004  aa   000356 6700 04	tsp4 	238,ic		017362
017005  aa  6 00764 3735 20	epp7 	pr6|500,*
017006  aa   000014 7270 07	lxl7 	12,dl
017007  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
017010  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
017011  aa  5 00010 3521 00	epp2 	pr5|8		thi.skip
017012  aa  2 00000 5035 17	abd  	pr2|0,7
017013  aa  6 01750 2521 00	spri2	pr6|1000
017014  aa  6 02050 3521 00	epp2 	pr6|1064
017015  aa  6 01752 2521 00	spri2	pr6|1002
017016  aa  6 01746 3521 00	epp2 	pr6|998
017017  aa   010000 4310 07	fld  	4096,dl
017020  aa  2 00000 7571 00	staq 	pr2|0
017021  aa   000341 6700 04	tsp4 	225,ic		017362
017022  aa  6 01726 3521 00	epp2 	pr6|982
017023  aa  6 01750 2521 00	spri2	pr6|1000
017024  aa  6 02046 3521 00	epp2 	pr6|1062
017025  aa  6 01752 2521 00	spri2	pr6|1002
017026  aa  6 02050 3521 00	epp2 	pr6|1064
017027  aa  6 01754 2521 00	spri2	pr6|1004
017030  aa  6 01742 3521 20	epp2 	pr6|994,*
017031  aa  6 01756 2521 00	spri2	pr6|1006
017032  aa   761354 3520 04	epp2 	-7444,ic		000406 = 524000000016
017033  aa  6 01762 2521 00	spri2	pr6|1010
017034  aa   761401 3520 04	epp2 	-7423,ic		000435 = 524000000010
017035  aa  6 01764 2521 00	spri2	pr6|1012
017036  aa  6 01766 2521 00	spri2	pr6|1014
017037  aa  6 01744 3521 00	epp2 	pr6|996
017040  aa  6 01770 2521 00	spri2	pr6|1016
017041  aa  6 01746 6211 00	eax1 	pr6|998
017042  aa   020000 4310 07	fld  	8192,dl
017043  aa  6 00764 3735 20	epp7 	pr6|500,*
017044  aa  7 00004 3521 20	epp2 	pr7|4,*		report
017045  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2990
	if dev_type = msu0500devt then last_sector = 40;

017046  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
017047  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
017050  aa  7 00074 2361 00	ldq  	pr7|60		disk_data.dev_type
017051  aa   000002 1160 07	cmpq 	2,dl
017052  aa   000004 6010 04	tnz  	4,ic		017056
017053  aa   000050 2360 07	ldq  	40,dl
017054  aa  6 00772 7561 00	stq  	pr6|506		last_sector
017055  aa   000007 7100 04	tra  	7,ic		017064
						STATEMENT 1 ON LINE 2991
	else if dev_type = msu0501devt then last_sector = 8;

017056  aa   000007 1160 07	cmpq 	7,dl
017057  aa   000004 6010 04	tnz  	4,ic		017063
017060  aa   000010 2360 07	ldq  	8,dl
017061  aa  6 00772 7561 00	stq  	pr6|506		last_sector
017062  aa   000002 7100 04	tra  	2,ic		017064
						STATEMENT 1 ON LINE 2992
	else last_sector = 0;

017063  aa  6 00772 4501 00	stz  	pr6|506		last_sector
						STATEMENT 1 ON LINE 2993
	do i = 1 to last_sector - 1;

017064  aa  6 00772 2361 00	ldq  	pr6|506		last_sector
017065  aa   000001 1760 07	sbq  	1,dl
017066  aa  6 00773 7561 00	stq  	pr6|507
017067  aa   000001 2360 07	ldq  	1,dl
017070  aa  6 00771 7561 00	stq  	pr6|505		i
017071  aa   000000 0110 03	nop  	0,du
017072  aa  6 00771 2361 00	ldq  	pr6|505		i
017073  aa  6 00773 1161 00	cmpq 	pr6|507
017074  aa   000114 6054 04	tpnz 	76,ic		017210
						STATEMENT 1 ON LINE 2994
	     call report ("^8a^2x^8a^2x^a", skip_mess (thip -> thi.c (i).skip (1)),
		skip_mess (thip -> thi.c (i).skip (2)), cond_flag (thip -> thi.c (i).cf));

017075  aa   000001 7360 00	qls  	1
017076  aa  6 00764 3735 20	epp7 	pr6|500,*
017077  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
017100  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
017101  aa  5 00012 3521 06	epp2 	pr5|10,ql		thi.cf
017102  aa   000034 7270 07	lxl7 	28,dl
017103  aa  2 00000 5035 17	abd  	pr2|0,7
017104  aa  6 01730 2521 00	spri2	pr6|984
017105  aa  6 01742 3521 00	epp2 	pr6|994
017106  aa  6 01732 2521 00	spri2	pr6|986
017107  aa   761262 3520 04	epp2 	-7502,ic		000371 = 516000000010
017110  aa  6 01736 2521 00	spri2	pr6|990
017111  aa  6 01744 3521 00	epp2 	pr6|996
017112  aa  6 01740 2521 00	spri2	pr6|992
017113  aa  6 01726 6211 00	eax1 	pr6|982
017114  aa   010000 4310 07	fld  	4096,dl
017115  aa   000104 3520 04	epp2 	68,ic		017221 = 000360627000
017116  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
017117  aa   761553 2370 04	ldaq 	-7317,ic		000672 = 136070141136 062170136070
017120  aa  6 01726 7571 00	staq 	pr6|982
017121  aa   761553 2370 04	ldaq 	-7317,ic		000674 = 141136062170 136141000000
017122  aa  6 01730 7571 00	staq 	pr6|984
017123  aa  6 00771 2361 00	ldq  	pr6|505		i
017124  aa   000110 4020 07	mpy  	72,dl
017125  aa  6 00764 3735 20	epp7 	pr6|500,*
017126  aa   000040 6270 06	eax7 	32,ql
017127  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
017130  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
017131  aa  5 00011 3521 00	epp2 	pr5|9		thi.skip
017132  aa  2 00000 5035 17	abd  	pr2|0,7
017133  aa  6 01750 2521 00	spri2	pr6|1000
017134  aa  6 02050 3521 00	epp2 	pr6|1064
017135  aa  6 01752 2521 00	spri2	pr6|1002
017136  aa  6 01746 3521 00	epp2 	pr6|998
017137  aa   010000 4310 07	fld  	4096,dl
017140  aa  2 00000 7571 00	staq 	pr2|0
017141  aa   000221 6700 04	tsp4 	145,ic		017362
017142  aa  6 00771 2361 00	ldq  	pr6|505		i
017143  aa   000110 4020 07	mpy  	72,dl
017144  aa  6 00764 3735 20	epp7 	pr6|500,*
017145  aa   000014 6270 06	eax7 	12,ql
017146  aa  7 00002 3715 20	epp5 	pr7|2,*		thip
017147  aa  5 00000 3715 20	epp5 	pr5|0,*		thip
017150  aa  5 00012 3521 00	epp2 	pr5|10		thi.skip
017151  aa  2 00000 5035 17	abd  	pr2|0,7
017152  aa  6 01750 2521 00	spri2	pr6|1000
017153  aa  6 02046 3521 00	epp2 	pr6|1062
017154  aa  6 01752 2521 00	spri2	pr6|1002
017155  aa  6 01746 3521 00	epp2 	pr6|998
017156  aa   010000 4310 07	fld  	4096,dl
017157  aa  2 00000 7571 00	staq 	pr2|0
017160  aa   000202 6700 04	tsp4 	130,ic		017362
017161  aa  6 01726 3521 00	epp2 	pr6|982
017162  aa  6 01750 2521 00	spri2	pr6|1000
017163  aa  6 02050 3521 00	epp2 	pr6|1064
017164  aa  6 01752 2521 00	spri2	pr6|1002
017165  aa  6 02046 3521 00	epp2 	pr6|1062
017166  aa  6 01754 2521 00	spri2	pr6|1004
017167  aa  6 01742 3521 20	epp2 	pr6|994,*
017170  aa  6 01756 2521 00	spri2	pr6|1006
017171  aa   761215 3520 04	epp2 	-7539,ic		000406 = 524000000016
017172  aa  6 01762 2521 00	spri2	pr6|1010
017173  aa   761242 3520 04	epp2 	-7518,ic		000435 = 524000000010
017174  aa  6 01764 2521 00	spri2	pr6|1012
017175  aa  6 01766 2521 00	spri2	pr6|1014
017176  aa  6 01744 3521 00	epp2 	pr6|996
017177  aa  6 01770 2521 00	spri2	pr6|1016
017200  aa  6 01746 6211 00	eax1 	pr6|998
017201  aa   020000 4310 07	fld  	8192,dl
017202  aa  6 00764 3735 20	epp7 	pr6|500,*
017203  aa  7 00004 3521 20	epp2 	pr7|4,*		report
017204  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 2996
	     end;

017205  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
017206  aa  6 00771 0541 00	aos  	pr6|505		i
017207  aa   777663 7100 04	tra  	-77,ic		017072
						STATEMENT 1 ON LINE 2998
	if all_sw					/* dump it in hex also */
	     then call dump_header ();

017210  aa  6 00764 3735 20	epp7 	pr6|500,*
017211  aa  7 00006 3715 20	epp5 	pr7|6,*
017212  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
017213  aa  5 00000 00 0001	descb	pr5|0,1		all_sw
017214  aa   000000 00 0000	descb	0,0
017215  aa   000002 6000 04	tze  	2,ic		017217
017216  aa   000074 6700 04	tsp4 	60,ic		017312
						STATEMENT 1 ON LINE 3001
	return;

017217  aa  6 00762 6101 00	rtcd 	pr6|498
						STATEMENT 1 ON LINE 3061
     end print_track_header_info;

BEGIN PROCEDURE cond_flag
ENTRY TO cond_flag                                          STATEMENT 1 ON LINE 3004
cond_flag:
     proc (cf) returns (char (*));

017220  da     000771220000
017221  aa   000360 6270 00	eax7 	240
017222  aa  7 00034 3521 20	epp2 	pr7|28,*
017223  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
017224  aa     000004000000
017225  aa     000000000000
						STATEMENT 1 ON LINE 3011
	if cf = "0011100"b then return ("No Error");

017226  aa  6 00032 3735 20	epp7 	pr6|26,*
017227  aa  7 00002 3715 20	epp5 	pr7|2,*
017230  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
017231  aa  5 00000 00 0010	descb	pr5|0,8		cf
017232  aa  6 00100 00 0044	descb	pr6|64,36		cf
017233  aa  6 00100 2351 00	lda  	pr6|64		cf
017234  aa   160000 1150 03	cmpa 	57344,du
017235  aa   000011 6010 04	tnz  	9,ic		017246
017236  aa   000010 2360 07	ldq  	8,dl
017237  aa  6 00042 3535 20	epp3 	pr6|34,*
017240  aa   526000 2760 03	orq  	175104,du
017241  aa  3 00002 7561 20	stq  	pr3|2,*
017242  aa   000010 2360 07	ldq  	8,dl
017243  aa   000000 7200 07	lxl0 	0,dl
017244  aa   761260 3520 04	epp2 	-7504,ic		000524 = 116157040105
017245  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 3012
	else if cf = "00111001"b then return ("EDAC Error - Corrected");

017246  aa   162000 1150 03	cmpa 	58368,du
017247  aa   000011 6010 04	tnz  	9,ic		017260
017250  aa   000026 2360 07	ldq  	22,dl
017251  aa  6 00042 3535 20	epp3 	pr6|34,*
017252  aa   526000 2760 03	orq  	175104,du
017253  aa  3 00002 7561 20	stq  	pr3|2,*
017254  aa   000026 2360 07	ldq  	22,dl
017255  aa   000000 7200 07	lxl0 	0,dl
017256  aa   761534 3520 04	epp2 	-7332,ic		001012 = 105104101103
017257  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 3013
	else if cf = "00111010"b then return ("EDAC Error - Uncorrectable");

017260  aa   164000 1150 03	cmpa 	59392,du
017261  aa   000011 6010 04	tnz  	9,ic		017272
017262  aa   000032 2360 07	ldq  	26,dl
017263  aa  6 00042 3535 20	epp3 	pr6|34,*
017264  aa   526000 2760 03	orq  	175104,du
017265  aa  3 00002 7561 20	stq  	pr3|2,*
017266  aa   000032 2360 07	ldq  	26,dl
017267  aa   000000 7200 07	lxl0 	0,dl
017270  aa   761566 3520 04	epp2 	-7306,ic		001056 = 105104101103
017271  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 3014
	else return (char (cf));

017272  aa   000010 2360 07	ldq  	8,dl
017273  aa  6 00042 3535 20	epp3 	pr6|34,*
017274  aa   526000 2760 03	orq  	175104,du
017275  aa  3 00002 7561 20	stq  	pr3|2,*
017276  aa  6 00100 3535 00	epp3 	pr6|64		cf
017277  aa   000010 2360 07	ldq  	8,dl
017300  aa   000047 7270 07	lxl7 	39,dl
017301  aa  6 00102 3515 00	epp1 	pr6|66
017302  aa   000010 2350 07	lda  	8,dl
017303  aa   000052 7260 07	lxl6 	42,dl
017304  aa  6 00104 3715 00	epp5 	pr6|68
017305  aa  0 01257 7001 00	tsx0 	pr0|687		any_to_any_truncate_
017306  aa   000010 2360 07	ldq  	8,dl
017307  aa   000000 7200 07	lxl0 	0,dl
017310  aa  6 00102 3521 00	epp2 	pr6|66
017311  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 3017
     end cond_flag;

  END PROCEDURE cond_flag
BEGIN PROCEDURE dump_header
ENTRY TO dump_header                                        STATEMENT 1 ON LINE 3020
dump_header:
     proc ();

017312  aa  6 00774 6501 00	spri4	pr6|508
						STATEMENT 1 ON LINE 3024
	if header_dumped then return;

017313  aa  6 00770 2351 00	lda  	pr6|504		header_dumped
017314  aa   000002 6000 04	tze  	2,ic		017316
017315  aa  6 00774 6101 00	rtcd 	pr6|508
						STATEMENT 1 ON LINE 3026
	call report ("^(^/^4(^9.4b^2x^)^)", header_array);

017316  aa   761046 2360 04	ldq  	-7642,ic		000364 = 516100000044
017317  aa  6 02052 7561 00	stq  	pr6|1066
017320  aa   000001 2360 07	ldq  	1,dl
017321  aa  6 02053 7561 00	stq  	pr6|1067
017322  aa  6 00136 3735 20	epp7 	pr6|94,*		disk_ptr
017323  aa  7 00074 7271 00	lxl7 	pr7|60		disk_data.dev_type
017324  ta   000015 2360 17	ldq  	13,7
017325  aa  6 02054 7561 00	stq  	pr6|1068
017326  aa   000044 2360 07	ldq  	36,dl
017327  aa  6 02055 7561 00	stq  	pr6|1069
017330  aa   761412 2370 04	ldaq 	-7414,ic		000742 = 136050136057 136064050136
017331  aa  6 02056 7571 00	staq 	pr6|1070
017332  aa   761412 2370 04	ldaq 	-7414,ic		000744 = 071056064142 136062170136
017333  aa  6 02060 7571 00	staq 	pr6|1072
017334  aa   761412 2350 04	lda  	-7414,ic		000746 = 051136051000
017335  aa  6 02062 7551 00	sta  	pr6|1074
017336  aa  6 00764 3715 20	epp5 	pr6|500,*
017337  aa  5 00002 3521 20	epp2 	pr5|2,*		thip
017340  aa  2 00000 3521 20	epp2 	pr2|0,*		thip
017341  aa   000001 0520 03	adwp2	1,du
017342  aa  6 02100 2521 00	spri2	pr6|1088
017343  aa  6 02056 3521 00	epp2 	pr6|1070
017344  aa  6 02066 2521 00	spri2	pr6|1078
017345  aa  6 02100 3521 20	epp2 	pr6|1088,*	header_array
017346  aa  6 02070 2521 00	spri2	pr6|1080
017347  aa   761104 3520 04	epp2 	-7612,ic		000453 = 524000000023
017350  aa  6 02074 2521 00	spri2	pr6|1084
017351  aa  6 02052 3521 00	epp2 	pr6|1066
017352  aa  6 02076 2521 00	spri2	pr6|1086
017353  aa  6 02064 6211 00	eax1 	pr6|1076
017354  aa   010000 4310 07	fld  	4096,dl
017355  aa  5 00004 3521 20	epp2 	pr5|4,*		report
017356  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 3028
	header_dumped = "1"b;

017357  aa   400000 2350 03	lda  	131072,du
017360  aa  6 00770 7551 00	sta  	pr6|504		header_dumped
						STATEMENT 1 ON LINE 3030
	return;

017361  aa  6 00774 6101 00	rtcd 	pr6|508
						STATEMENT 1 ON LINE 3033
     end dump_header;

  END PROCEDURE dump_header
BEGIN PROCEDURE skip_mess
ENTRY TO skip_mess                                          STATEMENT 1 ON LINE 3036
skip_mess:
     proc (skip) returns (char (8));

017362  aa  6 01002 6501 00	spri4	pr6|514
017363  aa  6 01004 2521 00	spri2	pr6|516
						STATEMENT 1 ON LINE 3042
017364  aa   000040 2350 03	lda  	32,du
017365  aa  6 01011 5511 20	stba 	pr6|521,20	retval.space
						STATEMENT 1 ON LINE 3048
	if ^skip.used then return ("none  ");

017366  aa  2 00002 3735 20	epp7 	pr2|2,*
017367  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
017370  aa  7 00000 00 0001	descb	pr7|0,1		skip.used
017371  aa   000000 00 0000	descb	0,0
017372  aa   000006 6010 04	tnz  	6,ic		017400
017373  aa  2 00004 3715 20	epp5 	pr2|4,*
017374  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
017375  aa   761126 00 0010	desc9a	-7594,8		000522 = 156157156145
017376  aa  5 00000 00 0010	desc9a	pr5|0,8
017377  aa  6 01002 6101 00	rtcd 	pr6|514
						STATEMENT 1 ON LINE 3050
	if skip.gap_following_count then type = "FC";

017400  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
017401  aa  7 00000 01 0001	descb	pr7|0(1),1	skip.gap_following_count
017402  aa   000000 00 0000	descb	0,0
017403  aa   000004 6000 04	tze  	4,ic		017407
017404  aa   106103 2350 07	lda  	35907,dl
017405  aa  6 01011 5511 14	stba 	pr6|521,14	retval.type
017406  aa   000012 7100 04	tra  	10,ic		017420
						STATEMENT 1 ON LINE 3051
	else if skip.gap_following_data then type = "FD";

017407  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
017410  aa  7 00000 02 0001	descb	pr7|0(2),1	skip.gap_following_data
017411  aa   000000 00 0000	descb	0,0
017412  aa   000004 6000 04	tze  	4,ic		017416
017413  aa   106104 2350 07	lda  	35908,dl
017414  aa  6 01011 5511 14	stba 	pr6|521,14	retval.type
017415  aa   000003 7100 04	tra  	3,ic		017420
						STATEMENT 1 ON LINE 3052
	else type = "ID";

017416  aa   111104 2350 07	lda  	37444,dl
017417  aa  6 01011 5511 14	stba 	pr6|521,14	retval.type
						STATEMENT 1 ON LINE 3053
	disp = skip.displacement;

017420  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
017421  aa  7 00000 04 0014	descb	pr7|0(4),12	skip.displacement
017422  aa  6 00056 00 0044	descb	pr6|46,36
017423  aa  6 00056 2351 00	lda  	pr6|46
017424  aa   000074 7730 00	lrl  	60
017425  aa  6 02104 7561 00	stq  	pr6|1092		skip.displacement
017426  aa  000 100 301 500	btd  	(pr),(pr)
017427  aa  6 02104 00 0004	desc9a	pr6|1092,4	skip.displacement
017430  aa  6 02102 01 0006	desc9ls	pr6|1090,6,0
017431  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
017432  aa  6 02102 01 0006	desc9ls	pr6|1090,6,0
017433  aa   000011 00 0003	desc9a	9,3		017442 = 104070321000
017434  aa  6 01010 00 0005	desc9a	pr6|520,5		retval.disp
						STATEMENT 1 ON LINE 3055
	return (string (retval));

017435  aa  2 00004 3715 20	epp5 	pr2|4,*
017436  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
017437  aa  6 01010 00 0010	desc9a	pr6|520,8
017440  aa  5 00000 00 0010	desc9a	pr5|0,8
017441  aa  6 01002 6101 00	rtcd 	pr6|514
						STATEMENT 1 ON LINE 3058
     end skip_mess;

  END PROCEDURE skip_mess
  END PROCEDURE print_track_header_info
  END PROCEDURE rdisk_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
