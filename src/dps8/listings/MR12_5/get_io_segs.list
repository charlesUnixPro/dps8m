	COMPILATION LISTING OF SEGMENT get_io_segs
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0957.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
       10 get_io_segs:
       11      procedure;
       12 
       13 /* GET_IO_SEGS - Compute Sizes for Wired I/O Databases.
       14*   coded 1/25/77 by Noel I. Morris
       15*   Modified by C. Hornig for paged IOM November 1980
       16*   Modified by J. Bongiovanni for stock_seg, February 1982
       17*   Modified March 1982 by C. Hornig for more paged IOM
       18*   Modified BIM 10/82 (and CAH) -- use hbound instead of -1
       19*   Modified 12/83 by Chris Jones to allow chnl cards for tapes as well as disks
       20*   Modified BIM 83-12-15 for demise of FNP cards.
       21*   Modified 1/84 by Chris Jones to add ites to ioi_data and to add
       22*   io_config_data and allow it to run in user ring for debugging.
       23*   Modified 3/84 by T. Oke for system wide free queue PARM DSKQ n.
       24*   Added limit variables min_per_drive and max_per_drive (5 and 200).
       25*   Added two warning messages.
       26*   Modified 9/84 by Keith Loepere to choose good free_q_size for bce.
       27*   Modified 9/84 by Chris Jones to set disk_channel_count correctly, and to correct documentation and messages.
       28*   Modified 11/84 by Paul Farley to make room in ioi_data for MCAs.
       29*   Modified 06/85 by Paul Farley to make room for FIPS controllers in io_config_data.
       30**/
       31 
       32 /****^  HISTORY COMMENTS:
       33*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
       34*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
       35*     Add support for MCA
       36*     and FIPS controllers.
       37*  2) change(86-01-09,Fawcett), approve(86-04-11,MCR7383),
       38*     audit(86-05-29,GDixon), install(86-07-17,MR12.0-1097):
       39*     Add support for subvolumes that increase the size of pvt and stock_seg.
       40*                                                   END HISTORY COMMENTS */
       41 
       42 dcl	disk_subsystems	   fixed bin;		/* number of disk subsystems */
       43 dcl	dev_idx		   fixed bin;
       44 dcl	physical_volumes	   fixed bin;		/* number of storage system devices */
       45 dcl	disk_channel_count	   fixed bin;		/* number of disk channels */
       46 dcl	disk_drives	   fixed bin;		/* number of disk drives (including device 0) */
       47 dcl	fptr		   ptr;			/* pointer to free_q parm */
       48 dcl	1 dskq_parm	   aligned based (fptr),
       49 	  2 name		   char (4),
       50 	  2 size		   fixed bin;
       51 dcl	free_q_size	   fixed bin;		/* number of free queue entries */
       52 dcl	imus		   fixed bin;		/* number of IMU's */
       53 dcl	controllers	   fixed bin;		/* number of MPCs and IPCs */
       54 dcl	seg_size		   fixed bin (19);		/* size of segment */
       55 dcl	subsystem_type	   char (4) aligned;
       56 dcl	tsdw		   fixed bin (71);		/* temporary SDW */
       57 dcl	i		   fixed bin;
       58 
       59 dcl	config_$find	   entry (char (4) aligned, ptr);
       60 dcl	config_$find_2	   entry (char (4) aligned, char (4) aligned, ptr);
       61 dcl	config_$find_parm	   entry (char (*), ptr);
       62 
       63 dcl	get_ring_		   entry () returns (fixed bin (3));
       64 dcl	get_main		   entry (ptr, fixed bin (19), fixed bin (71));
       65 dcl	ioa_		   entry () options (variable);
       66 dcl	syserr		   entry options (variable);
       67 
       68 dcl	min_per_drive	   fixed bin init (5) int static options (constant);
       69 dcl	max_per_drive	   fixed bin init (200) int static options (constant);
       70 dcl	ME		   char (32) init ("get_io_segs:") int static options (constant);
       71 dcl	SYSERR_CONTROL_STRING  char (64) int static options (constant)
       72 			   init ("^a Missing ndrives field on config card prph ^a.");
       73 dcl	SYSERR_QUEUE_STRING_1  char (50) int static options (constant)
       74 			   init ("^a DSKQ ^i. < ^i. per drive, forcing DSKQ ^i.");
       75 dcl	SYSERR_QUEUE_STRING_2  char (50) int static options (constant)
       76 			   init ("^a DSKQ ^i. > ^i. per drive, forcing DSKQ ^i.");
       77 
       78 dcl	(addr, bin, hbound, lbound, max, min, null, ptr, rel, size, substr, wordno)
       79 			   builtin;
       80 
       81 /* Count how many of everything there are */
       82 
       83 	ioi_subsystems, disk_subsystems, ioi_channels, ioi_devices, physical_volumes, disk_drives, ioi_multiplexers,
       84 	     imus, controllers, disk_channel_count = 0;
       85 
       86 /* * * * * * * * * PRPH cards * * * * * * * * * */
       87 
       88 	prph_cardp = null ();
       89 	call config_$find (PRPH_CARD_WORD, prph_cardp);	/* Search for PRPH cards. */
       90 	do while (prph_cardp ^= null ());
       91 	     ioi_subsystems = ioi_subsystems + 1;	/* Count an I/O subsystem. */
       92 
       93 	     subsystem_type = substr (prph_card.name, 1, 3);
       94 	     if /* case */ (subsystem_type = "tap") | (subsystem_type = "dsk") then do;
       95 /**** NOTE THE ASSUMPTION THAT prph dsk AND prph tap CARDS ARE "like" ONE ANOTHER ****/
       96 		prph_dsk_cardp = prph_cardp;
       97 		prph_tap_cardp = prph_cardp;		/* do both for crossref purposes */
       98 		if subsystem_type = "dsk" then do;
       99 		     disk_subsystems = disk_subsystems + 1;
      100 		     disk_channel_count = disk_channel_count + prph_dsk_card.nchan;
      101 		end;
      102 		ioi_channels = ioi_channels + prph_tap_card.nchan;
      103 						/* count number of channels. */
      104 		chnl_cardp = null ();
      105 		call config_$find_2 (CHNL_CARD_WORD, prph_card.name, chnl_cardp);
      106 		if chnl_cardp ^= null () then
      107 		     do i = 1 to 3;			/* Count additional channels. */
      108 		     if chnl_card.nchan (i) > 0 then do;
      109 			ioi_channels = ioi_channels + chnl_card.nchan (i);
      110 			if subsystem_type = "dsk" then
      111 			     disk_channel_count = disk_channel_count + chnl_card.nchan (i);
      112 		     end;
      113 		end;
      114 		ioi_devices = ioi_devices + 1;	/* Count drives plus controller. */
      115 		do i = lbound (prph_tap_card.group, 1) to hbound (prph_tap_card.group, 1)
      116 		     while (prph_tap_card.group (i).model ^= -1);
      117 						/* count drives. */
      118 		     if prph_tap_card.group (i).ndrives = -1 then
      119 			if get_ring_ () = 0 then
      120 			     call syserr (CRASH, SYSERR_CONTROL_STRING, ME, prph_card.name);
      121 			else do;
      122 			     call ioa_ (SYSERR_CONTROL_STRING, ME, prph_card.name);
      123 			     return;
      124 			end;
      125 
      126 		     if subsystem_type = "dsk" then
      127 			disk_drives = disk_drives + prph_dsk_card.group (i).ndrives;
      128 		     if prph_tap_card.group (i).model ^= 0 then do;
      129 			ioi_devices = ioi_devices + prph_tap_card.group (i).ndrives;
      130 			if subsystem_type = "dsk" then do;
      131 			     do dev_idx = 1 to hbound (MODEL, 1)
      132 				while (prph_tap_card.group (i).model ^= MODEL (dev_idx));
      133 			     end;
      134 			     dev_idx = MODELX (dev_idx);
      135 			     if number_of_sv (dev_idx) = 0 then
      136 				physical_volumes = physical_volumes + prph_dsk_card.group (i).ndrives;
      137 			     else physical_volumes =
      138 				     physical_volumes
      139 				     + (prph_dsk_card.group (i).ndrives * number_of_sv (dev_idx));
      140 			end;
      141 		     end;
      142 		end;
      143 	     end;
      144 
      145 	     else do;				/* Other peripherals. */
      146 		ioi_channels = ioi_channels + 1;
      147 		ioi_devices = ioi_devices + 1;
      148 	     end;
      149 	     call config_$find (PRPH_CARD_WORD, prph_cardp);
      150 						/* Search for PRPH cards. */
      151 	end;
      152 
      153 /* * * * * * * * * * MPC cards * * * * * * * * * */
      154 
      155 	mpc_cardp = null ();
      156 	call config_$find (MPC_CARD_WORD, mpc_cardp);
      157 
      158 	do while (mpc_cardp ^= null ());
      159 	     controllers = controllers + 1;
      160 
      161 	     call config_$find (MPC_CARD_WORD, mpc_cardp);
      162 	end;
      163 
      164 /* * * * * * * * * * IPC FIPS cards * * * * * * * * * */
      165 
      166 	ipc_cardp = null ();
      167 	call config_$find (IPC_CARD_WORD, ipc_cardp);
      168 
      169 	do while (ipc_cardp ^= null ());
      170 	     if ipc_card.type = IPC_FIPS then
      171 		controllers = controllers + 1;
      172 
      173 	     call config_$find (IPC_CARD_WORD, ipc_cardp);
      174 	end;
      175 
      176 /* * * * * * * * * * IOM cards * * * * * * * * * */
      177 
      178 	iom_cardp = null ();
      179 	call config_$find (IOM_CARD_WORD, iom_cardp);
      180 
      181 	do while (iom_cardp ^= null ());
      182 	     ioi_multiplexers = ioi_multiplexers + 1;
      183 	     if (iom_card.model = "iioc") | (iom_card.model = "imu") then
      184 		imus = imus + 1;
      185 
      186 	     call config_$find (IOM_CARD_WORD, iom_cardp);
      187 	end;
      188 
      189 /* * * * * * * * * * Allow for MCA in the IMUs * * * * * * * * * */
      190 
      191 	ioi_subsystems = ioi_subsystems + imus;
      192 	ioi_channels = ioi_channels + imus;
      193 	ioi_devices = ioi_devices + imus;
      194 
      195 /* * * * * * * * * * STOK card * * * * * * * * * */
      196 
      197 	stok_cardp = null ();
      198 	call config_$find (STOK_CARD_WORD, stok_cardp);
      199 	if stok_cardp = null () then
      200 	     n_in_record_stock = DEFAULT_N_IN_RECORD_STOCK;
      201 	else if stok_card.type_word.n_fields < 1 then
      202 	     n_in_record_stock = DEFAULT_N_IN_RECORD_STOCK;
      203 	else if stok_card.n_record_stock_entries <= 0 then
      204 	     n_in_record_stock = DEFAULT_N_IN_RECORD_STOCK;
      205 	else n_in_record_stock = stok_card.n_record_stock_entries;
      206 	if stok_cardp = null () then
      207 	     n_in_vtoce_stock = DEFAULT_N_IN_VTOCE_STOCK;
      208 	else if stok_card.type_word.n_fields < 2 then
      209 	     n_in_vtoce_stock = DEFAULT_N_IN_VTOCE_STOCK;
      210 	else if stok_card.n_vtoce_stock_entries <= 0 then
      211 	     n_in_vtoce_stock = DEFAULT_N_IN_VTOCE_STOCK;
      212 	else n_in_vtoce_stock = stok_card.n_vtoce_stock_entries;
      213 	n_volmap_pages = 3;
      214 
      215 /* * * * * * * * * * PARM DSKQ card * * * * * * * * * */
      216 
      217 	if sys_info$collection_1_phase = SERVICE_INITIALIZATION then do;
      218 	     free_q_size = 20 * physical_volumes;	/* set default */
      219 
      220 	     call config_$find_parm ("dskq", fptr);	/* get ptr to dskq parameter */
      221 	     if fptr ^= null () then do;
      222 		free_q_size =
      223 		     min (max (dskq_parm.size, min_per_drive * physical_volumes), max_per_drive * physical_volumes);
      224 		if dskq_parm.size < (min_per_drive * physical_volumes) then
      225 		     call syserr (ANNOUNCE, SYSERR_QUEUE_STRING_1, ME, dskq_parm.size, min_per_drive, free_q_size);
      226 		else if dskq_parm.size > max_per_drive * physical_volumes then
      227 		     call syserr (ANNOUNCE, SYSERR_QUEUE_STRING_2, ME, dskq_parm.size, max_per_drive, free_q_size);
      228 	     end;
      229 	end;
      230 	else free_q_size = 64;			/* Don't let queue be large enough to grab all of bce's memory. */
      231 
      232 /* Now allocate the databases */
      233 
      234 /* * * * * * * * * * PVT * * * * * * * * * */
      235 
      236 	pvtp = addr (pvt$);				/* Get pointer to PVT. */
      237 	seg_size = bin (rel (addr (pvt.array))) + physical_volumes * size (pvte);
      238 						/* Compute required size of PVT. */
      239 	call install_segment (pvtp, seg_size, tsdw);
      240 	pvt.max_n_entries = physical_volumes;		/* for init_pvt */
      241 
      242 
      243 /* * * * * * * * * * STOCK_SEG * * * * * * * * * */
      244 
      245 	stock_segp = addr (stock_seg$);
      246 	seg_size = size (stock_seg) + physical_volumes * (size (record_stock) + size (vtoce_stock));
      247 	call install_segment (stock_segp, seg_size, tsdw);
      248 	stock_seg.record_stock_entries = n_in_record_stock;
      249 	stock_seg.vtoce_stock_entries = n_in_vtoce_stock;
      250 	stock_seg.record_stock_size = size (record_stock);
      251 	stock_seg.vtoce_stock_size = size (vtoce_stock);
      252 	stock_seg.n_stock_entries = physical_volumes;
      253 
      254 /* * * * * * * * * * DISK_SEG * * * * * * * * * */
      255 
      256 	disksp = addr (disk_seg$);			/* Get pointer to disk database segment. */
      257 	seg_size =
      258 	     size (disk_data) + free_q_size * size (quentry) + disk_subsystems * size (disktab)
      259 	     + disk_drives * size (devtab) + disk_channel_count * size (chantab);
      260 						/* Compute required size of disk_seg. */
      261 
      262 	call install_segment (disksp, seg_size, tsdw);
      263 	disk_data.free_q_size = free_q_size;
      264 
      265 /* * * * * * * * * * IO_CONFIG_DATA * * * * * * * * * */
      266 
      267 	io_config_data_ptr = addr (io_config_data$);
      268 	io_config_device_table_ptr, io_config_channel_table_ptr, io_config_controller_table_ptr,
      269 	     io_config_iom_table_ptr = io_config_data_ptr;/* base all of these so wordno gives the right answer */
      270 
      271 	begin;
      272 
      273 dcl	(device_table_length, channel_table_length, controller_table_length, iom_table_length, io_config_tables_length)
      274 			   fixed bin (19);
      275 
      276 	     device_table_length =
      277 		wordno (addr (device_table.device_entry)) + size (device_entry_template) * ioi_devices;
      278 	     channel_table_length =
      279 		wordno (addr (channel_table.channel_entry)) + size (channel_entry_template) * ioi_channels;
      280 	     controller_table_length =
      281 		wordno (addr (controller_table.controller_entry)) + size (controller_entry_template) * controllers;
      282 	     iom_table_length = wordno (addr (iom_table.iom_entry)) + size (iom_entry_template) * ioi_multiplexers;
      283 	     io_config_tables_length =
      284 		device_table_length + channel_table_length + controller_table_length + iom_table_length;
      285 	     seg_size = wordno (addr (io_config_data.tables)) + io_config_tables_length;
      286 	     call install_segment (io_config_data_ptr, seg_size, tsdw);
      287 
      288 	     io_config_data.tables_length = io_config_tables_length;
      289 	     io_config_data.device_table_offset = wordno (addr (io_config_data.tables));
      290 	     io_config_data.channel_table_offset = io_config_data.device_table_offset + device_table_length;
      291 	     io_config_data.controller_table_offset = io_config_data.channel_table_offset + channel_table_length;
      292 	     io_config_data.iom_table_offset = io_config_data.controller_table_offset + controller_table_length;
      293 
      294 	     io_config_device_table_ptr = ptr (io_config_data_ptr, io_config_data.device_table_offset);
      295 	     io_config_channel_table_ptr = ptr (io_config_data_ptr, io_config_data.channel_table_offset);
      296 	     io_config_controller_table_ptr = ptr (io_config_data_ptr, io_config_data.controller_table_offset);
      297 	     io_config_iom_table_ptr = ptr (io_config_data_ptr, io_config_data.iom_table_offset);
      298 
      299 	     device_table.n_devices = ioi_devices;
      300 	     channel_table.n_channels = ioi_channels;
      301 	     controller_table.n_controllers = controllers;
      302 	     iom_table.n_ioms = ioi_multiplexers;
      303 	end;
      304 
      305 /* * * * * * * * * * IOI_DATA * * * * * * * * * */
      306 
      307 	idp = addr (ioi_data$);			/* Get pointer to IOI data. */
      308 	call install_segment (idp, size (ioi_data), tsdw);/* Make a wired segment. */
      309 
      310 	ioi_data.ngt = ioi_subsystems;		/* Fill in real database. */
      311 	ioi_data.nct = ioi_channels;
      312 	ioi_data.ndt = ioi_devices;
      313 	ioi_data.nit = ioi_multiplexers;
      314 
      315 /* * * * * * * * * * IOM_DATA * * * * * * * * * */
      316 
      317 	iom_data_ptr = addr (iom_data$);		/* Get pointer to IOM data. */
      318 	n_devices = ioi_channels + ioi_multiplexers * 2 + imus;
      319 						/* Compute number of channels needed */
      320 	seg_size = size (iom_data);			/* Compute required length of iom_data. */
      321 
      322 	call install_segment (iom_data_ptr, seg_size, tsdw);
      323 
      324 	iom_data.n_devices = n_devices;		/* Remember this value. */
      325 
      326 	return;
      327 
      328 install_segment:
      329      proc (segptr, seglen, sdw);
      330 
      331 dcl	segptr		   ptr;
      332 dcl	seglen		   fixed bin (19);
      333 dcl	sdw		   fixed bin (71);
      334 
      335 
      336 dcl	pmut$swap_sdw	   entry (ptr, ptr);
      337 
      338 	if get_ring_ () ^= 0 then
      339 	     return;				/* already available */
      340 
      341 	call get_main (segptr, seglen, sdw);
      342 	call pmut$swap_sdw (segptr, addr (sdw));
      343 
      344      end install_segment;
      345 
      346 /* format: off */
  1     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  1     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  1     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  1     4 
  1     5 /* This include file has an ALM version.  Keep 'em in sync! */
  1     6 
  1     7 dcl (
  1     8 
  1     9 /* The following constants define the message action codes.  This indicates
  1    10*how a message is to be handled.  */
  1    11 
  1    12      SYSERR_CRASH_SYSTEM	init (1),			
  1    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  1    14 
  1    15      SYSERR_TERMINATE_PROCESS	init (2),
  1    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  1    17 
  1    18      SYSERR_PRINT_WITH_ALARM	init (3),
  1    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  1    20 
  1    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  1    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  1    23 
  1    24      SYSERR_LOG_OR_PRINT	init (4),
  1    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  1    26 
  1    27      SYSERR_LOG_OR_DISCARD	init (5),
  1    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  1    29 
  1    30 
  1    31 /* The following constants are added to the normal severities to indicate
  1    32*different sorting classes of messages.  */
  1    33 
  1    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  1    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  1    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  1    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  1    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  1    39 	) fixed bin internal static options (constant);
  1    40 
  1    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      347  
  2     1 /* BEGIN INCLUDE FILE ... config_chnl_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  2     2 
  2     3 dcl  chnl_cardp ptr;				/* Pointer to a CHNL card. */
  2     4 
  2     5 dcl 1 chnl_card based (chnl_cardp) aligned,		/* CHNL card declaration */
  2     6     2 word char (4),				/* "chnl" */
  2     7     2 name char (4),				/* subsystem name */
  2     8     2 group (3),					/* Channel groups for this subsystem -- 9 fields total */
  2     9       3 iom fixed bin (3),				/* IOM number */
  2    10       3 chan fixed bin (8),				/* channel number */
  2    11       3 nchan fixed bin,				/* number of channels */
  2    12 
  2    13     2 pad (4) bit (36) aligned,			/* pad to 15 fields */
  2    14 
  2    15     2 type_word aligned,
  2    16       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  2    17       3 pad1 bit (4) unaligned,
  2    18       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  2    19 
  2    20 dcl 1 chnl_card_array aligned based (chnl_cardp),		/* Overlay for channel group array */
  2    21     2 pad1 (2) bit (36) aligned,
  2    22     2 group (min (3, divide (max (0, (chnl_card.n_fields - 1)), 3, 17, 0))),
  2    23       3 iom fixed bin (3),				/* IOM number */
  2    24       3 chan fixed bin (8),				/* Channel number. */
  2    25       3 nchan fixed bin;				/* Number of logical channels on this channel. */
  2    26 
  2    27 dcl  CHNL_CARD_WORD char (4) aligned internal static options (constant) init ("chnl");
  2    28 
  2    29 /* END INCLUDE FILE ... config_chnl_card.incl.pl1 */
      348  
  3     1 /* BEGIN INCLUDE FILE ... config_deck.incl.pl1 ... 11/13/80, W. Olin Sibert */
  3     2 
  3     3 dcl (configp, cardp) pointer;
  3     4 dcl  config_n_cards fixed bin;			/* Number of cards used in config */
  3     5 dcl  config_max_cards fixed bin;			/* Max number of cards in config */
  3     6 
  3     7 dcl  config_deck$ fixed bin external static;
  3     8 
  3     9 dcl 1 config_deck aligned based (configp),
  3    10     2 cards (config_n_cards) aligned like config_card,
  3    11     2 pad_cards (config_max_cards - config_n_cards) aligned like config_card;
  3    12 
  3    13 dcl 1 config_card aligned based (cardp),
  3    14     2 word char (4) aligned,
  3    15     2 data_field (14) bit (36) aligned,
  3    16     2 type_word aligned like config_card_type_word;
  3    17 
  3    18 dcl 1 config_card_type_word aligned based,
  3    19     2 field_type (14) bit (2) unaligned,
  3    20     2 pad1 bit (4) unaligned,
  3    21     2 n_fields fixed bin (4) unsigned unaligned;
  3    22 
  3    23 dcl (CONFIG_DECIMAL_TYPE	init ("11"b),
  3    24      CONFIG_OCTAL_TYPE	init ("00"b),
  3    25      CONFIG_SINGLE_CHAR_TYPE	init ("01"b),
  3    26      CONFIG_STRING_TYPE	init ("10"b)) bit (2) aligned static options (constant);
  3    27 
  3    28 dcl  ZERO_CARD_WORD char (4) aligned internal static options (constant) init ("    ");
  3    29 dcl  FREE_CARD_WORD char (4) aligned internal static options (constant) init ("ÿÿÿÿ");
  3    30 
  3    31 dcl  VALID_CARD_WORD_CHARACTERS char (38) internal static options (constant) init
  3    32     ("abcdefghijklmnopqrstuvwxyz0123456789_.");		/* lowercase letters, digits, period and underscore */
  3    33 
  3    34 dcl  EMPTY_FIELD bit (36) aligned internal static options (constant) init ("777777777777"b3);
  3    35 
  3    36 /* END INCLUDE FILE config_deck.incl.pl1 */
      349  
  4     1 /* BEGIN INCLUDE FILE ... config_iom_card.incl.pl1 ... 11/37/80 W. Olin Sibert */
  4     2 
  4     3 dcl  iom_cardp pointer;				/* pointer to IOM card */
  4     4 
  4     5 dcl 1 iom_card aligned based (iom_cardp),		/* IOM card declaration */
  4     6     2 word char (4),				/* "iom" */
  4     7     2 tag fixed bin (3),				/* One more than IOM tag set in maintenance panel switches */
  4     8     2 port fixed bin (3),				/* Controller port to which IOM is connected */
  4     9     2 model char (4),				/* IOM model number: "iomb", "nsa", "iioc" */
  4    10     2 state char (4),				/* State: "on" or "off" */
  4    11 
  4    12     2 pad (10) bit (36) aligned,			/* Pad to 15 fields */
  4    13 
  4    14     2 type_word aligned,
  4    15       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  4    16       3 pad1 bit (4) unaligned,
  4    17       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  4    18 
  4    19 dcl  IOM_CARD_WORD char (4) aligned internal static options (constant) init ("iom");
  4    20 
  4    21 /* END INCLUDE FILE ... config_iom_card.incl.pl1 */
      350  
  5     1 /* BEGIN INCLUDE FILE ... config_ipc_card.incl.pl1 ... */
  5     2 /****^  HISTORY COMMENTS:
  5     3*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  5     4*     audit(86-03-08,CLJones), install(86-03-21,MR12.0-1033):
  5     5*     Create IPC card.
  5     6*                                                   END HISTORY COMMENTS */
  5     7 
  5     8 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  5     9 
  5    10 dcl	ipc_cardp		   ptr;                      /* card pointer */
  5    11 
  5    12 dcl	1 ipc_card	   aligned based (ipc_cardp),
  5    13 	  2 word		   char (4),		/* "ipc" */
  5    14 	  2 type		   char (4),		/* Type of this IPC - e.g., "fips" */
  5    15 	  2 iom		   fixed bin (3),		/* IOM number */
  5    16 	  2 chan		   fixed bin (8),		/* Channel number. */
  5    17 	  2 nchan		   fixed bin,		/* Number of logical channels on this channel. */
  5    18 	  2 pad (10) bit (36) aligned,			/* Pad to 15 fields */
  5    19 	  2 type_word	   aligned,
  5    20 	    3 field_type	   (14) bit (2) unaligned,	/* type of each field; see config_deck.incl.pl1 */
  5    21 	    3 pad1	   bit (4) unaligned,
  5    22 	    3 n_fields	   fixed bin (4) unsigned unaligned;
  5    23 						/* number of fields used on card */
  5    24 
  5    25 dcl	IPC_CARD_WORD	   char (4) aligned internal static options (constant) init ("ipc");
  5    26 dcl	IPC_FIPS		   char (4) aligned internal static options (constant) init ("fips");
  5    27 
  5    28 /* END INCLUDE FILE ... config_ipc_card.incl.pl1 */
      351  
  6     1 /* BEGIN INCLUDE FILE ... config_mpc_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  6     2 
  6     3 dcl  mpc_cardp ptr;					/* Pointer to an MPC card. */
  6     4 
  6     5 dcl 1 mpc_card aligned based (mpc_cardp),
  6     6     2 word char (4),				/* "mpc" */
  6     7     2 name char (4),				/* Name of this MPC - e.g., "mspa" */
  6     8     2 model fixed bin,				/* Model of this MPC - e.g., 601. */
  6     9     2 port (4),					/* Per port information. 12 fields total */
  6    10       3 iom fixed bin (3),				/* IOM number */
  6    11       3 chan fixed bin (8),				/* Channel number. */
  6    12       3 nchan fixed bin,				/* Number of logical channels on this channel. */
  6    13 
  6    14     2 type_word aligned,
  6    15       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  6    16       3 pad1 bit (4) unaligned,
  6    17       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  6    18 
  6    19 dcl 1 mpc_card_array aligned based (mpc_cardp),		/* Overlay for MPC port array */
  6    20     2 pad1 (3) bit (36) aligned,
  6    21     2 port (divide (max (0, (mpc_card.n_fields - 2)), 3, 17, 0)),
  6    22       3 iom fixed bin (3),				/* IOM number */
  6    23       3 chan fixed bin (8),				/* Channel number. */
  6    24       3 nchan fixed bin;				/* Number of logical channels on this channel. */
  6    25 
  6    26 dcl  MPC_CARD_WORD char (4) aligned internal static options (constant) init ("mpc");
  6    27 
  6    28 /* END INCLUDE FILE ... config_mpc_card.incl.pl1 */
      352  
  7     1 /* BEGIN INCLUDE FILE ... config_prph_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  7     2 
  7     3 dcl  prph_cardp ptr;				/* Pointer to a PRPH card. */
  7     4 
  7     5 dcl 1 prph_card based (prph_cardp) aligned,		/* PRPH card declaration */
  7     6     2 word char (4),				/* "prph" */
  7     7     2 name char (4),				/* subsystem name */
  7     8     2 iom fixed bin (3),				/* IOM number */
  7     9     2 chan fixed bin (8),				/* channel number */
  7    10     2 model fixed bin,				/* model number */
  7    11     2 state char (4),                                       /* ON/OFF state */
  7    12     2 pad (9) bit (36) aligned,			/* pad to 15 fields */
  7    13 
  7    14     2 type_word aligned,
  7    15       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  7    16       3 pad1 bit (4) unaligned,
  7    17       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  7    18 
  7    19 dcl  PRPH_CARD_WORD char (4) aligned internal static options (constant) init ("prph");
  7    20 
  7    21 /* END INCLUDE FILE ... config_prph_card.incl.pl1 */
      353  
  8     1 /* BEGIN INCLUDE FILE ... config_prph_dsk_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  8     2 
  8     3 dcl  prph_dsk_cardp ptr;				/* Pointer to a PRPH DSKx card. */
  8     4 
  8     5 dcl 1 prph_dsk_card based (prph_dsk_cardp) aligned,	/* PRPH DSKx card declaration */
  8     6     2 word char (4),				/* "prph" */
  8     7     2 name char (4),				/* "dskX" */
  8     8     2 iom fixed bin (3),				/* IOM number */
  8     9     2 chan fixed bin (8),				/* channel number */
  8    10     2 nchan fixed bin,				/* number of channels */
  8    11 
  8    12     2 group (5),
  8    13       3 model fixed bin,				/* model number */
  8    14       3 ndrives fixed bin,				/* number of drives */
  8    15 
  8    16     2 type_word aligned,
  8    17       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  8    18       3 pad1 bit (4) unaligned,
  8    19       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  8    20 
  8    21 dcl 1 prph_dsk_card_array aligned based (prph_dsk_cardp),	/* Overlay for drive group array */
  8    22     2 pad1 (5) bit (36) aligned,
  8    23     2 group (divide (max (0, (prph_dsk_card.n_fields - 4)), 2, 17, 0)),
  8    24       3 model fixed bin,				/* model number */
  8    25       3 ndrives fixed bin;				/* number of drives */
  8    26 
  8    27 /* END INCLUDE FILE ... config_prph_dsk_card.incl.pl1 */
      354  
  9     1 /* BEGIN INCLUDE FILE ... config_prph_tap_card.incl.pl1 */
  9     2 
  9     3 dcl  prph_tap_cardp ptr;				/* Pointer to a PRPH TAPx card. */
  9     4 
  9     5 dcl 1 prph_tap_card based (prph_tap_cardp) aligned,	/* PRPH TAPx card declaration */
  9     6     2 word char (4),				/* "prph" */
  9     7     2 name char (4),				/* "tapX" */
  9     8     2 iom fixed bin (3),				/* IOM number */
  9     9     2 chan fixed bin (8),				/* channel number */
  9    10     2 nchan fixed bin,				/* number of channels */
  9    11 
  9    12     2 group (5),
  9    13       3 model fixed bin,				/* model number */
  9    14       3 ndrives fixed bin,				/* number of drives */
  9    15 
  9    16     2 type_word aligned,
  9    17       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  9    18       3 pad1 bit (4) unaligned,
  9    19       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  9    20 
  9    21 dcl 1 prph_tap_card_array aligned based (prph_tap_cardp),	/* Overlay for drive group array */
  9    22     2 pad1 (5) bit (36) aligned,
  9    23     2 group (divide (max (0, (prph_tap_card.n_fields - 4)), 2, 17, 0)),
  9    24       3 model fixed bin,				/* model number */
  9    25       3 ndrives fixed bin;				/* number of drives */
  9    26 
  9    27 /* END INCLUDE FILE ... config_prph_tap_card.incl.pl1 */
      355  
 10     1 /*  START OF:	config_stok_card.incl.pl1	February 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10     2 
 10     3 dcl  stok_cardp ptr;					/* Pointer to s STOK card */
 10     4 
 10     5 dcl 1 stok_card based (stok_cardp) aligned,		/* STOK card declaration */
 10     6     2 word char (4),				/* "stok" */
 10     7     2 n_record_stock_entries fixed bin,			/* Number of record stock entries */
 10     8     2 n_vtoce_stock_entries fixed bin,			/* Number of VTOCE stock entries */
 10     9 
 10    10     2 pad (12) bit (36) aligned,			/* pad to 15 fields */
 10    11 
 10    12     2 type_word aligned,				
 10    13       3 field_type (14) bit (2) unal,			/* type of each field; see config_deck.incl.pl1 */
 10    14       3 pad1 bit (4) unaligned,
 10    15       3 n_fields fixed bin (4) unsigned unaligned;
 10    16 	
 10    17 dcl  STOK_CARD_WORD char (4) aligned internal static options (constant) init ("stok");
 10    18 	
 10    19 
 10    20 /*  END OF:	config_stok_card.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      356  
 11     1 /* Begin include file ...... dskdcl.incl.pl1 */
 11     2 
 11     3 /****^  HISTORY COMMENTS:
 11     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
 11     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
 11     6*     Support for FIPS dev 0.
 11     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
 11     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
 11     9*     Added reconnect_announce_time to chantab to allow announcement of
 11    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
 11    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
 11    12*                                                   END HISTORY COMMENTS */
 11    13 
 11    14 /* Structures used by the Disk DIM */
 11    15 
 11    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
 11    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
 11    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
 11    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
 11    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
 11    21 
 11    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
 11    23 
 11    24 dcl  disk_seg$ ext;					/* disk data segment */
 11    25 
 11    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
 11    27      diskp ptr,					/* pointer to disk DIM info structure */
 11    28      optp ptr,					/* pointer to opt_info */
 11    29      sysp ptr;					/* pointer to sys_info */
 11    30 
 11    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
 11    32        2 subsystems fixed bin,			/* number of subsystems */
 11    33        2 free_offset bit (18),			/* offset of first unused location in segment */
 11    34        2 status_mask bit (36),			/* mask for checking for disk error */
 11    35        2 lock bit (36) unal,				/* disk_data lock */
 11    36        2 free_q like qht,				/* head/tail offsets */
 11    37        2 free_q_size fixed bin,			/* length of queue */
 11    38        2 array (32),				/* per subsystem info */
 11    39          (
 11    40          3 offset bit (18),				/* location of data for this subsystem */
 11    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
 11    42          3 name char (4)
 11    43          ) unal,					/* name of subsystem */
 11    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
 11    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
 11    46        2 pad bit (36),				/* double word align */
 11    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
 11    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
 11    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
 11    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
 11    51 
 11    52 
 11    53 /* The following system table is used to hold the maximum queue loading
 11    54*   permitted system-wide for each IO type.  From the current loading and
 11    55*   the maximum loading a multiplier fraction is calculated.  These combine
 11    56*   to produce the final optimization multiplier to derive a Logcial Seek
 11    57*   from a Physical Seek. */
 11    58 
 11    59 dcl  1 sys_info aligned based (sysp),
 11    60        3 depth float bin (27),			/* current load */
 11    61        3 max_depth float bin (27),			/* max permissible */
 11    62        3 fraction float bin (27),			/* load fraction */
 11    63        3 depth_map bit (18) unaligned,			/* which depth counter */
 11    64        3 pad bit (18) unaligned;
 11    65 
 11    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
 11    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
 11    68*   dctl's use. */
 11    69 
 11    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
 11    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
 11    72 
 11    73 
 11    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
 11    75        2 lock bit (36) unal,				/* data base lock */
 11    76        2 nchan fixed bin,				/* number of disk channels */
 11    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
 11    78        2 last_dev fixed bin unal,			/* highest disk drive number */
 11    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
 11    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
 11    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
 11    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
 11    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
 11    84        2 dev_index fixed bin (17) unal,			/* current device to check */
 11    85        2 errors fixed bin,				/* error count */
 11    86        2 ferrors fixed bin,				/* fatal error count */
 11    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
 11    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
 11    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
 11    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
 11    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
 11    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
 11    93 
 11    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
 11    95 
 11    96 
 11    97 dcl  qp ptr,					/* pointer to queue entry */
 11    98      cp ptr;					/* pointer to channel information table */
 11    99 
 11   100 
 11   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
 11   102*   expansion space.  They will always be positive and upper bits can be
 11   103*   stolen for other fields.
 11   104*
 11   105*   Entries are forward and back linked to permit easy chasing and removal. */
 11   106 
 11   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
 11   108 						/* WORD 1 */
 11   109        2 next bit (18) unaligned,			/* forward link */
 11   110        2 prev bit (18) unaligned,			/* back link */
 11   111 						/* WORD 2 */
 11   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
 11   113        2 used bit (1) unaligned,			/* entry in use */
 11   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
 11   115        2 pad bit (6) unaligned,			/* future expansion */
 11   116        2 coreadd bit (24) unaligned,			/* main memory address */
 11   117 						/* WORD 3 */
 11   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
 11   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
 11   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
 11   121        2 pad2 bit (5) unaligned,
 11   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
 11   123 						/* WORD 4 */
 11   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
 11   125        2 pad3 bit (9) unaligned,
 11   126        2 sector bit (21) unaligned,			/* device sector desired */
 11   127 						/* WORDS 5&6 */
 11   128        2 time fixed bin (71);				/* clock at queue */
 11   129 
 11   130 
 11   131 
 11   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
 11   133        2 chx fixed bin (35),				/* io_manager channel index */
 11   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
 11   135        2 statusp ptr,				/* pointer to hardware status word */
 11   136        2 chanid char (8),				/* channel name */
 11   137        (
 11   138        2 pad0 bit (18),
 11   139        2 in_use bit (1),				/* non-zero if channel being used */
 11   140        2 active bit (1),				/* non-zero if channel active */
 11   141        2 rsr bit (1),				/* non-zero if RSR in progress */
 11   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
 11   143        2 inop bit (1),				/* non-zero if channel inoperative */
 11   144        2 broken bit (1),				/* non-zero if channel broken */
 11   145        2 action_code bit (2),				/* saved from status */
 11   146        2 pad1 bit (10)
 11   147        ) unal,
 11   148        (
 11   149        2 qrp bit (18),				/* rel ptr to queue entry */
 11   150        2 pad2 bit (3),
 11   151        2 command bit (6),				/* peripheral command */
 11   152        2 erct fixed bin (8)
 11   153        ) unal,					/* error retry count */
 11   154        2 select_data,				/* data passed to IOM on select */
 11   155          (
 11   156          3 limit bit (12),				/* limit on number of sectors */
 11   157          3 mbz bit (3),
 11   158          3 sector bit (21)
 11   159          ) unaligned,				/* sector address */
 11   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
 11   161        2 connect_time fixed bin (52),			/* time of last connect */
 11   162        2 connects fixed bin,				/* count of connects performed */
 11   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
 11   164        2 rstdcw bit (36),				/* restore command */
 11   165        2 scdcw bit (36),				/* select command */
 11   166        2 sddcw bit (36),				/* select data xfer */
 11   167        2 dcdcw bit (36),				/* command to read or write */
 11   168        2 dddcw bit (36),				/* data xfer DCW */
 11   169        2 dscdcw bit (36),				/* RSR command */
 11   170        2 dsddcw bit (36),				/* RSR data xfer */
 11   171        2 rssdcw bit (36),				/* RSS command */
 11   172        2 status bit (36) aligned,			/* saved status */
 11   173 						/* Lossage counters for interrupt loss. */
 11   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
 11   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
 11   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
 11   177        2 status_from_run fixed bin (35);		/* status missed til run called */
 11   178 
 11   179 dcl  1 qht aligned based,				/* queue head/tail structure */
 11   180        2 sum fixed bin (35),				/* sum of depths */
 11   181        2 count fixed bin (35),			/* allocs */
 11   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
 11   183        2 depth fixed bin (17) unaligned,		/* current depth */
 11   184        2 head bit (18) unaligned,			/* queue head */
 11   185        2 tail bit (18) unaligned;			/* queue tail */
 11   186 
 11   187 dcl  dp ptr,					/* pointer to device information table */
 11   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
 11   189 
 11   190 dcl  1 devtab based (dp) aligned,			/* device information table */
 11   191        (
 11   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
 11   193        2 inop bit (1),				/* device inoperative */
 11   194        2 was_broken bit (1),				/* device previously broken */
 11   195        2 broken bit (1),				/* device down */
 11   196        2 abandoned bit (1),				/* device lost and gone forever */
 11   197        2 forward bit (1),				/* moving low->high */
 11   198        2 pad bit (10),
 11   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
 11   200        2 pdi unsigned fixed bin (6)
 11   201        ) unal,					/* primary device index */
 11   202        2 cylinder fixed bin (35),			/* current cylinder position */
 11   203        2 comb fixed bin (35),				/* number of combs */
 11   204        2 pad1 fixed bin (35),
 11   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
 11   206        2 wq like qht,				/* work queue */
 11   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
 11   208        2 opt_info (0:6) like opt_info;			/* optimizer */
 11   209 
 11   210 
 11   211 /* Optimizing table for device. Must be even multiple words long. */
 11   212 /* Slope and intercept define a straight line of y = intercept - slope*x
 11   213*   Multiplier is calculated from this and current system loading.
 11   214*
 11   215*   sys_info is the offset to the relevant system queue loading fraction. */
 11   216 
 11   217 dcl  1 opt_info aligned based (optp),
 11   218        3 multiplier float bin (27),			/* depth mult */
 11   219        3 slope float bin (27),			/* slope of line */
 11   220        3 intercept float bin (27),			/* Y intercept */
 11   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
 11   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
 11   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
 11   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
 11   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
 11   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
 11   227 
 11   228 
 11   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
 11   230        (
 11   231        2 sx fixed bin (11),				/* structure index */
 11   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
 11   233        2 unused_sect_per_cyl fixed bin (11)
 11   234        ) unal;					/* # of unused sectors at end of cylinder */
 11   235 
 11   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
 11   237        2 count fixed bin,				/* total number of attempts */
 11   238        2 waits fixed bin,				/* number of attempts which required waiting */
 11   239        2 wait_time fixed bin (52);			/* total time spent waiting */
 11   240 
 11   241 dcl  (
 11   242      RST_LISTX init (1),				/* listx for restore */
 11   243      SC_LISTX init (2),				/* listx for select */
 11   244      DSC_LISTX init (6),				/* listx for RSR */
 11   245      RSS_LISTX init (8)
 11   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
 11   247 
 11   248 /* IO types defined.  Value is also index of write_map to determine if
 11   249*   the IO type is a read or a write. */
 11   250 
 11   251 dcl  (
 11   252      PAGE_READ init (0),
 11   253      PAGE_WRITE init (1),
 11   254      VTOC_READ init (2),
 11   255      VTOC_WRITE init (3),
 11   256      TEST init (4),
 11   257      BOOTLOAD_READ init (5),
 11   258      BOOTLOAD_WRITE init (6),
 11   259      MAX_IO_TYPE init (6)
 11   260      ) fixed bin (4) static options (constant);
 11   261 
 11   262 dcl  IO_TYPE (0:6) char (16)
 11   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
 11   264 	static options (constant);
 11   265 
 11   266 /* Map indexed by IO type to determine if operation is a read or write. */
 11   267 
 11   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
 11   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
 11   270 
 11   271 /* Map indexed by IO type to determine if operation is a sector IO. */
 11   272 
 11   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
 11   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
 11   275 
 11   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
 11   277 
 11   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
 11   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
 11   280 
 11   281 /* End of include file ...... dskdcl.incl.pl1 */
      357  
 12     1 /*  START OF:	io_config.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12     2 
 12     3 /* Structures for overlaying the io_config data segment. */
 12     4 /* Written February 1984 by Chris Jones as part of IOM reconfiguration project. */
 12     5 
 12     6 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 12     7 
 12     8 dcl	io_config_data$	   external;
 12     9 
 12    10 dcl	io_config_data_ptr	   ptr;
 12    11 dcl	io_config_device_table_ptr
 12    12 			   ptr;
 12    13 dcl	io_config_channel_table_ptr
 12    14 			   ptr;
 12    15 dcl	io_config_controller_table_ptr
 12    16 			   ptr;
 12    17 dcl	io_config_iom_table_ptr
 12    18 			   ptr;
 12    19 
 12    20 dcl	tables_length	   fixed bin (19);
 12    21 
 12    22 dcl	1 io_config_data	   aligned based (io_config_data_ptr),
 12    23 	  2 version	   char (8),
 12    24 	  2 tables_length	   fixed bin (19) unsigned,
 12    25 	  2 device_table_offset
 12    26 			   fixed bin (18) uns unal,
 12    27 	  2 channel_table_offset
 12    28 			   fixed bin (18) uns unal,
 12    29 	  2 controller_table_offset
 12    30 			   fixed bin (18) uns unal,
 12    31 	  2 iom_table_offset   fixed bin (18) uns unal,
 12    32 	  2 p_clock	   fixed bin (35),
 12    33 	  2 pad		   (2) bit (36),		/* pad to 0 mod 8 boundary */
 12    34 	  2 tables	   (0 refer (io_config_data.tables_length)) bit (36);
 12    35 
 12    36 dcl	1 device_table	   aligned based (io_config_device_table_ptr),
 12    37 	  2 version	   char (8),
 12    38 	  2 n_devices	   fixed bin,
 12    39 	  2 pad		   bit (36),		/* pad to even word boundary */
 12    40 	  2 device_entry	   (0 refer (device_table.n_devices)) like device_entry_template;
 12    41 
 12    42 dcl	1 device_entry_template
 12    43 			   aligned based,
 12    44 	  2 name		   char (32) unaligned,
 12    45 	  2 comment	   char (32) unaligned,
 12    46 	  2 flags,
 12    47 	  ( 3 configured,				/* set => not deleted */
 12    48 	    3 assigned				/* set => in use (by a user or ring 0) */
 12    49 	    )		   bit (1) unaligned,
 12    50 	  2 pad		   bit (36),		/* pad to even word boundary */
 12    51 	  2 pchan_idx	   (8) fixed bin;		/* indexes into channel_table */
 12    52 
 12    53 dcl	1 channel_table	   aligned based (io_config_channel_table_ptr),
 12    54 	  2 version	   char (8),
 12    55 	  2 n_channels	   fixed bin,
 12    56 	  2 pad		   bit (36),		/* pad to even word boundary */
 12    57 	  2 channel_entry	   (0 refer (channel_table.n_channels)) aligned like channel_entry_template;
 12    58 
 12    59 dcl	1 channel_entry_template
 12    60 			   aligned based,
 12    61 	  2 name		   char (8),		/* e.g. "A31" */
 12    62 	  2 comment	   char (32) unaligned,
 12    63 	  2 flags,
 12    64 	  ( 3 configured,				/* set => available for assignment */
 12    65 	    3 assigned				/* set => currently assigned */
 12    66 	    )		   bit (1) unaligned,
 12    67 	  2 controller_idx	   fixed bin,		/* index into controller table (if on MPC) */
 12    68 	  2 iom_idx	   fixed bin,		/* index into iom_table */
 12    69 	  2 base_channel_idx   fixed bin;		/* index into channel table */
 12    70 
 12    71 dcl	1 controller_table	   aligned based (io_config_controller_table_ptr),
 12    72 	  2 version	   char (8) aligned,
 12    73 	  2 n_controllers	   fixed bin,
 12    74 	  2 pad		   bit (36),		/* pad to even word boundary */
 12    75 	  2 controller_entry   (0 refer (controller_table.n_controllers)) like controller_entry_template;
 12    76 
 12    77 dcl	1 controller_entry_template
 12    78 			   aligned based,
 12    79 	  2 name		   char (8),		/* e.g. "mspa" */
 12    80 	  2 comment	   char (32) unaligned,
 12    81 	  2 flags,
 12    82 	  ( 3 configured,				/* set => not deleted */
 12    83 	    3 assigned				/* set => one process has whole controller */
 12    84 	    )		   bit (1) unaligned,
 12    85 	  2 pad		   bit (36);		/* pad to even word boundary */
 12    86 
 12    87 dcl	1 iom_table	   aligned based (io_config_iom_table_ptr),
 12    88 	  2 version	   char (8),
 12    89 	  2 n_ioms	   fixed bin,
 12    90 	  2 pad		   bit (36),		/* pad to even word boundary */
 12    91 	  2 iom_entry	   (0 refer (iom_table.n_ioms)) like iom_entry_template;
 12    92 
 12    93 dcl	1 iom_entry_template   aligned based,
 12    94 	  2 name		   char (8),
 12    95 	  2 comment	   char (32) unaligned,
 12    96 	  2 flags,
 12    97 	  ( 3 configured				/* set => not deleted */
 12    98 	    )		   bit (1) unaligned,
 12    99 	  2 n_configured_channels
 12   100 			   fixed bin;
 12   101 
 12   102 dcl	IO_CONFIG_DATA_VERSION_1
 12   103 			   char (8) aligned static options (constant) init ("IOCD_01");
 12   104 dcl	IO_CONFIG_DEVICE_TABLE_VERSION_1
 12   105 			   char (8) aligned static options (constant) init ("DEVT_01");
 12   106 dcl	IO_CONFIG_CHANNEL_TABLE_VERSION_1
 12   107 			   char (8) aligned static options (constant) init ("CHANT_01");
 12   108 dcl	IO_CONFIG_CONTROLLER_TABLE_VERSION_1
 12   109 			   char (8) aligned static options (constant) init ("CTLRT_01");
 12   110 dcl	IO_CONFIG_IOM_TABLE_VERSION_1
 12   111 			   char (8) aligned static options (constant) init ("IOMT_01");
 12   112 
 12   113 /*  END OF:	io_config.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      358  
 13     1 /* Begin include file ...... ioi_data.incl.pl1 */
 13     2 
 13     3 
 13     4 /****^  HISTORY COMMENTS:
 13     5*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
 13     6*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
 13     7*     Support for FIPS and
 13     8*     IMU.
 13     9*  2) change(86-05-16,Kissel), approve(86-07-30,MCR7461), audit(86-07-31,Coren),
 13    10*     install(86-08-19,MR12.0-1120):
 13    11*     Changed the value of IOI_DEFAULT_MAX_BOUND from 4096 to 1024.  This
 13    12*     corrects a problem when RCP tries to set the maximum workspace size if it
 13    13*     is less than 4096.  Since ioi_ (actually grab_aste) touched all the pages
 13    14*     at assignment time, the current length is 4, and trying to set the max
 13    15*     length to less than 4 (e.g. because the max unprivileged workspace size in
 13    16*     RCP for a special device is 1) returns an error.
 13    17*                                                   END HISTORY COMMENTS */
 13    18 
 13    19 /* Rewritten May 1982 by C. Hornig for new ioi_ */
 13    20 /* Rewrite finished March 1983 by Chris Jones */
 13    21 /* Extended for reconfiguration April 1983 by Chris Jones. */
 13    22 /* Modified November 1983 by Chris Jones to separate items in the dte protected by different locks. */
 13    23 /* Modified January 1984 by Chris Jones to add ite's. */
 13    24 /* Modified Feb 1984 by Rich Fawcett to add ipc and fips */
 13    25 /* Modified Sept 1985 by Paul Farley to add controller flag to dte. */
 13    26 
 13    27 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 13    28 
 13    29 dcl	idp		   ptr;			/* pointer to IOI data structure */
 13    30 dcl	gtep		   ptr;			/* pointer to channel/device group entry */
 13    31 dcl	ctep		   ptr;			/* pointer to channel table entry */
 13    32 dcl	dtep		   ptr;			/* pointer to wired device table entry */
 13    33 dcl	itep		   ptr;			/* pointer to I/O multiplexer entry */
 13    34 
 13    35 dcl	(ioi_subsystems, ioi_devices, ioi_channels, ioi_multiplexers)
 13    36 			   fixed bin;
 13    37 dcl	ioi_data$		   external;		/* IOI data segment */
 13    38 
 13    39 
 13    40 dcl	1 ioi_data	   based (idp) aligned,	/* I/O Interfacer data structure */
 13    41 	  2 ngt		   fixed bin,		/* number of groups */
 13    42 	  2 nct		   fixed bin,		/* number of channels */
 13    43 	  2 ndt		   fixed bin,		/* number of devices */
 13    44 	  2 nit		   fixed bin,		/* number of IOMs */
 13    45 	  2 spurious_interrupts
 13    46 			   fixed bin (35),		/* interrupts with no status */
 13    47 	  2 reconfig_lock	   like lock,		/* lock for reconfiguring devices, channels, etc. */
 13    48 	  2 flags,
 13    49 	    3 setup	   bit (1) unal,		/* "1"b => ioi_init has run */
 13    50 	    3 pad1	   bit (35) unal,
 13    51 	  2 rss_idcw	   bit (36),		/* reset status IDCW */
 13    52 	  2 pad2		   (6) fixed bin (35),	/* pad to 16 words */
 13    53 	  2 dt		   (ioi_devices refer (ioi_data.ndt)) like dte aligned,
 13    54 						/* device table */
 13    55 	  2 gt		   (ioi_subsystems refer (ioi_data.ngt)) like gte aligned,
 13    56 						/* channel/device group table */
 13    57 	  2 ct		   (ioi_channels refer (ioi_data.nct)) like cte aligned,
 13    58 						/* channel table */
 13    59 	  2 it		   (ioi_multiplexers refer (ioi_data.nit)) like ite aligned;
 13    60 						/* multiplexer table */
 14     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
 14     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
 14     3*   encourages name conflicts.
 14     4*   USE HC_FAST_LOCK INSTEAD!
 14     5**/
 14     6 
 14     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
 14     8 
 14     9 /* format: style3 */
 14    10 
 14    11 declare	lock_ptr		pointer;
 14    12 declare	1 lock		aligned based (lock_ptr),
 14    13 	  2 pid		bit (36) aligned,		/* holder of lock */
 14    14 	  2 event		bit (36) aligned,		/* event associated with lock */
 14    15 	  2 flags		aligned,
 14    16 	    3 notify_sw	bit (1) unaligned,
 14    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
 14    18 
 14    19 /* End include file hc_lock.incl.pl1 */
 13    61 
 13    62 
 13    63 dcl	1 ite		   based (itep) aligned,	/* I/O multiplexer table entry */
 13    64 	  2 model		   char (4),		/* which flavor we are */
 13    65 	  2 flags,
 13    66 	  ( 3 deleting	   bit (1),
 13    67 	    3 deleted	   bit (1)
 13    68 	    )		   unaligned,
 13    69 	  2 pad1		   bit (16) unaligned,
 13    70 	  2 iom_table_idx	   fixed bin (17) unaligned,
 13    71 	  2 tag		   fixed bin (3),
 13    72 	  2 pad2		   (5) bit (36);
 13    73 
 13    74 dcl	1 gte		   based (gtep) aligned,	/* channel/device group table entry */
 13    75 	  2 lock		   bit (36),		/* (0) loop lock */
 13    76 	  2 name		   char (4),		/* (1) subsystem name */
 13    77 	  2 dtep		   bit (18) unaligned,	/* (2) rel ptr to device just serviced */
 13    78 	  2 ctep		   bit (18) unaligned,	/* (2) rel ptr to thread of channel table entries */
 13    79 	  2 detailed_status_cmd
 13    80 			   bit (6) unal,		/* (3) idcw command to read detailed status */
 13    81 	  2 flags		   unaligned,		/* (3) */
 13    82 	    3 psia	   bit (1),		/* "1"b if channel is PSIA */
 13    83 	    3 suspend_devices  bit (1),		/* "1"b if device I/O suspended */
 13    84 	    3 dual_controller  bit (1),		/* "1"b if dual controller subsystem (disk only) */
 13    85 	    3 ascii_dtst	   bit (1),		/* "1"b if detailed status sent in ASCII mode */
 13    86 	    3 mplex	   bit (1),		/* "1"b if channels are multiplexed among devices */
 13    87 	    3 ipc		   bit (1),		/* "1"b if devices are on an IMU */
 13    88 	    3 fips	   bit (1),		/* "1"b if devices start at zero */
 13    89 	    3 pad		   bit (23),
 13    90 	  2 n_devices	   fixed bin,		/* (4) number of devices in device table thread */
 13    91 	  2 pending_connects   fixed bin,		/* (5) count of pending connect requests */
 13    92 	  2 io_log_info_index  fixed bin,		/* (6) index into io_log_status_info table */
 13    93 	  2 disk_data_subsystem_idx
 13    94 			   fixed bin;		/* (7) index into disk_data.array for disks */
 13    95 
 13    96 dcl	1 cte		   based (ctep) aligned,	/* channel table entry */
 13    97 	  2 next_ctep	   bit (18) unaligned,	/* (0) rel ptr to next channel table entry */
 13    98 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
 13    99 	  2 flags1	   unaligned,		/* (1) */
 13   100 	    3 ioi_use	   bit (1),		/* "1"b if channel currently being used */
 13   101 	    3 connected	   bit (1),		/* "1"b if channel is connected */
 13   102 	    3 toss_status	   bit (1),		/* "1"b if status is to be ignored */
 13   103 	    3 quiescing	   bit (1),		/* "1"b if the channel is just finishing what it's doing */
 13   104 	    3 direct	   bit (1),		/* "1"b if this is a direct channel */
 13   105 	    3 pad1	   bit (4),
 13   106 	  2 disktab_ctx	   fixed bin (9) uns unal,	/* (1) index into disktab.chantab for this channel */
 13   107 	  2 cur_dtep	   bit (18) unaligned,	/* (1) current device table entry */
 13   108 	  2 chanid	   char (8),		/* (2) io_manager's name for channel */
 13   109 	  2 statusp	   ptr unal,		/* (4) pointer to first word of status */
 13   110 	  2 chx		   fixed bin (35),		/* (5) channel index for io_manager */
 13   111 	  2 time_limit	   fixed bin (71),		/* (6) connect time limit */
 13   112 	  2 saved_status	   unaligned,		/* (8) status repository while reading detailed status */
 13   113 	    3 word1	   bit (36),
 13   114 	    3 word2	   bit (36),
 13   115 	    3 word4	   bit (36),
 13   116 	    3 next_lpw_offset  bit (18),
 13   117 	    3 command	   bit (6),
 13   118 	  2 pad3		   bit (12) unaligned,	/* (11) */
 13   119 	  2 base_ctep	   bit (18) unaligned,	/* (12) rel ptr to base logical chan. of physical chan. */
 13   120 	  2 itep		   bit (18) unaligned,	/* (12) rel ptr to itep */
 13   121 	  2 flags2	   unaligned,		/* (13) */
 13   122 	    3 deleting	   bit (1),		/* "1"b if attempting to delete this channel */
 13   123 	    3 deleted	   bit (1),		/* "1"b if channel deleted */
 13   124 	  2 pad4		   bit (16) unaligned,	/* (13) */
 13   125 	  2 channel_table_idx  fixed bin (17) unaligned,
 13   126 	  2 pad5		   (2) bit (36);		/* (14) pad to 8 word boundary */
 13   127 
 13   128 dcl	1 dte		   based (dtep) aligned,	/* wired device table entry */
 13   129 	  2 next_dtep	   bit (18) unaligned,	/* (0) rel ptr to next entry in thread */
 13   130 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
 13   131 	  2 cur_ctep	   bit (18) unaligned,	/* (1) rel ptr to channel in use */
 13   132 	  2 flags1	   unaligned,		/* (1) flags protected by gte lock */
 13   133 	    3 connected	   bit (1),		/* "1"b if device has a channel */
 13   134 	    3 log_status_cnt   bit (1),		/* "1"b if count in log_status is valid */
 13   135 	    3 reading_detailed_status
 13   136 			   bit (1),		/* "1"b if read of detailed device status in progress */
 13   137 	    3 pad1	   bit (15),
 13   138 	  2 channel_required   char (8),		/* (2) channel name of required channel */
 13   139 	  2 ev_chn	   fixed bin (71),		/* (4) event ID for status wakeups */
 13   140 	  2 workspace_ptr	   ptr,			/* (6) workspace pointer */
 13   141 	  2 workspace_astep	   ptr,			/* (8) workspace ASTE ptr */
 13   142 	  2 workspace_sdw	   fixed bin (71),		/* (10) SDW of workspace segment */
 13   143 	  2 ptp		   ptr,			/* (12) device page table */
 13   144 	  2 max_bound	   fixed bin (19),		/* (14) largest allowable bound of workspace segment */
 13   145 	  2 bound		   fixed bin (19),		/* (15) bound of workspace */
 13   146 	  2 process_id	   bit (36),		/* (16) ID of process owning device */
 13   147 	  2 ring		   fixed bin (3),		/* (17) highest ring allowed to access device */
 13   148 	  2 device	   bit (6) unal,		/* (18) device code */
 13   149 	  2 flags2	   unal,			/* (18) constant or protected by dte lock */
 13   150 	    3 priv	   bit (1),		/* "1"b if privileged user */
 13   151 	    3 in_use	   bit (1),		/* "1"b if device is to be used */
 13   152 	    3 deleting	   bit (1),		/* "1"b if trying to delete this device */
 13   153 	    3 deleted	   bit (1),		/* "1"b if this device is deleted */
 13   154 	    3 suspended	   bit (1),		/* "1"b if device isn't to be used temporarily */
 13   155 	    3 workspace_wired  bit (1),		/* "1"b if workspace is wired */
 13   156               3 direct           bit (1),                   /* "1"b if device is connected to a direct channel */
 13   157 	    3 controller	   bit (1),		/* "1"b if dte for the devices controller */
 13   158 	    3 pad2	   bit (4),
 13   159 	  2 device_table_idx   fixed bin (17) unaligned,
 13   160 	  2 listx		   uns fixed bin (18) unal,	/* (19) DCW list index for connect */
 13   161 	  2 idcw_listx	   uns fixed bin (18) unal,	/* (19) DCW list index of IDCW */
 13   162 	  2 timeout	   fixed bin (35),		/* (20) time limit for I/O completion (usec) */
 13   163 	  2 max_timeout	   fixed bin (35),		/* (21) maximum allowable timeout grace time (usec) */
 13   164 	  2 unwire_time	   fixed bin (71),		/* (22) when to unwire the workspace */
 13   165 	  2 pcw		   bit (36),		/* (24) peripheral control word (PCW) */
 13   166 	  2 status_control,				/* (25) */
 13   167 	    3 status_offset	   fixed bin (18) unsigned unaligned,
 13   168 						/* offset of status queue in user workspace */
 13   169 	    3 status_entries   fixed bin (9) unsigned unaligned,
 13   170 						/* number of entries in status queue */
 13   171 	    3 status_entry_idx fixed bin (9) unsigned unaligned,
 13   172 						/* next entry to be used */
 13   173 	  2 idcw		   bit (36),		/* (26) instruction DCW (KEEP ON EVEN WORD BOUNDARY) */
 13   174 	  2 tdcw		   bit (36),		/* (27) transfer DCW to remainder of list */
 13   175 	  2 special_status	   bit (36),		/* (28) special interrupt status */
 13   176 	  2 lock		   like lock,		/* (29) wait lock */
 13   177 	  2 log_status,				/* (32) */
 13   178 	  ( 3 level	   fixed bin (3) unsigned,
 13   179 	    3 time_out	   bit (1),
 13   180 	    3 type	   bit (2),
 13   181 	    3 command	   bit (6),
 13   182 	    3 count	   fixed bin (6) unsigned,
 13   183 	    3 channel	   bit (18),
 13   184 	    3 status	   bit (36)
 13   185 	    )		   unaligned,
 13   186 	  2 ptx		   fixed bin,		/* (34) index of page table */
 13   187 	  2 active	   bit (1),		/* (35) "1"b if device running or to run */
 13   188 	  2 special_interrupt  bit (1),		/* (36) "1"b if special interrupt received */
 13   189 	  2 detailed_status_valid
 13   190 			   bit (1),		/* (37) "1"b if detailed status read sucessfully */
 13   191 	  2 last_log_time	   fixed bin (71),		/* (38) when status was last logged */
 13   192 	  2 detailed_status	   (8) bit (36),		/* (40) (buffer for reading most recent detailed status */
 13   193 	  2 log_detailed_status
 13   194 			   (8) bit (36);		/* (48) copy of last detailed status logged */
 13   195 
 13   196 /**** Defaults for various I/O parameters */
 13   197 
 13   198 dcl	IOI_DEFAULT_MAX_BOUND  fixed bin (19) static options (constant) init (1024);
 13   199 dcl	IOI_DEFAULT_MAX_TIMEOUT
 13   200 			   fixed bin (35) static options (constant) init (30000000);
 13   201 dcl	IOI_DEFAULT_TIMEOUT	   fixed bin (35) static options (constant) init (30000000);
 13   202 
 13   203 dcl	IO_STATUS_ERROR_MASK   bit (36) static options (constant) init ("370000770000"b3);
 13   204 
 13   205 dcl	IO_CHANNEL_LOCK_TEMPLATE
 13   206 			   char (2) int static options (constant) init ("ch");
 13   207 dcl	IOI_DEVICE_LOCK_EVENT_TEMPLATE
 13   208 			   char (2) static options (constant) init ("dv");
 13   209 
 13   210 /* End of include file ...... ioi_data.incl.pl1 */
      359  
 15     1 /* Begin include file ...... iom_data.incl.pl1
 15     2*   First written in August 1971 by R F Mabee.
 15     3*   Modified for paged IOM November 1980 by C. Hornig.
 15     4*   More IIOC changes by C. Hornig, June 1982.
 15     5*   Modified for channel reconfiguration by Chris Jones, January 1984.
 15     6*   Modified to remove support of non-paged IOMs by Chris Jones, August 1984.
 15     7*   Modified to add IMW read protocol flags by M. Pandolf, January 1985.
 15     8**/
 15     9 
 15    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 15    11 dcl	iom_data$		   external;
 15    12 dcl	iom_mailbox$	   external;
 15    13 
 15    14 dcl	n_devices		   fixed bin;
 15    15 dcl	iom_data_ptr	   ptr;
 15    16 
 15    17 dcl	1 iom_data	   based (iom_data_ptr) aligned,
 15    18 	  2 n_devices	   fixed bin,		/* (0) Maximum number of channels. */
 15    19 	  2 stop_lpw	   bit (36),		/* (1) LPW pointing to stop_dcw. */
 15    20 	  2 stop_dcw	   bit (36),		/* (2) DCW to stop channel, probably storing bad status. */
 15    21 	  2 stop_scw	   bit (36),		/* (3) SCW for same */
 15    22 	  2 imw_lock	   fixed bin (35),		/* (4) Essentially a lock for iom switch checking: */
 15    23 						/* 1  : OK to poll IMW */
 15    24 						/* 0  : lock in transition */
 15    25 						/* -1 : DONT poll IMW */
 15    26 	  2 n_intr_procs fixed bin (35),		/* (5) Number of processors in interrupt handler */
 15    27 	  2 pad1		   (2) bit (36),
 15    28 	  2 stop_status	   bit (72),		/* (10) All unused channels store status here. */
 15    29 	  2 rfh1		   (6) bit (36),		/* can't use this */
 15    30 	  2 stop_ext_status	   bit (8 * 36),		/* (20) Unused channels' extended status */
 15    31 	  2 pad3		   (5) bit (36),
 15    32 	  2 invalid_interrupts fixed bin (35),		/* (35) interrupts on unused channels */
 15    33 	  2 null_interrupts	   fixed bin (35),		/* (36) spurious interrupts */
 15    34 	  2 multiple_interrupts
 15    35 			   fixed bin (35),		/* (37) several interrupts at a time */
 15    36 	  2 per_iom	   (4) like per_iom,	/* (40) for each IOM */
 15    37 	  2 per_device	   (n_devices refer (iom_data.n_devices)) like per_device;
 15    38 						/* (240) Data for assigned channels. */
 15    39 
 15    40 dcl	1 per_iom		   aligned based,
 15    41 	  2 lock		   bit (36),		/* (40) connect mailbox lock */
 15    42 	  2 flags,				/* (41) */
 15    43 	    3 configured	   bit (1) unal,		/* is configured */
 15    44 	    3 on_line	   bit (1) unal,		/* is ON */
 15    45 	    3 pad1	   bit (34) unal,
 15    46 	  2 model		   char (4),		/* (42) what kind of IOM */
 15    47 	  2 port		   fixed bin (3),		/* (43) SC port */
 15    48 	  2 connect_time	   fixed bin (71),		/* (44) time of last connect */
 15    49 	  2 connect_lpw	   bit (36),		/* (46) LPW for connect channel */
 15    50 	  2 cow		   bit (36),		/* (47) Connect Operand Word */
 15    51 	  2 special_chx	   fixed bin (35),		/* (50) chx of special status channel */
 15    52 	  2 fault_chx	   fixed bin (35),		/* (51) chx of system fault channel */
 15    53 	  2 pad2		   (4) bit (36),
 15    54 	  2 abandoned_connects fixed bin (35),		/* (56) times we couldn't get IOM to listen at all */
 15    55 	  2 reconnects	   fixed bin (35),		/* (57) times a connect was lost */
 15    56 	  2 chantab	   (0:63) uns fixed bin (9) unal;
 15    57 						/* (60) packed devtab indices */
 15    58 
 15    59 dcl	1 per_device	   aligned based,
 15    60 	  2 status	   bit (72),		/* (0) Status for channel is stored here. */
 15    61 	  2 rfh1		   (6) bit (36),
 15    62 	  2 ext_status	   bit (8 * 36),		/* (10) extended status stored by IIOC */
 15    63 	  2 iom		   uns fixed bin (3),	/* (20) IOM# (1-4) */
 15    64 	  2 channel	   uns fixed bin (6),	/* (21) channel # */
 15    65 	  2 handler	   entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 15    66 						/* (22) Interrupt handler for device. */
 15    67 	  2 flags,				/* (26) */
 15    68 	    3 in_use	   bit (1) unal,		/* assigned */
 15    69 	    3 queue_status	   bit (1) unal,		/* maintain status queue */
 15    70 	    3 on_line	   bit (1) unal,		/* can be assigned */
 15    71 	  2 index		   fixed bin (35),		/* (27) Channel identification index. */
 15    72 	  2 pcw		   bit (72),		/* (30) Peripheral Control Word */
 15    73 	  2 lpw		   bit (72),		/* (32) List Pointer Word */
 15    74 	  2 scw		   bit (36),		/* (34) Status Control Word */
 15    75 	  2 pad1		   fixed bin (35),
 15    76 	  2 status_queue_ptr   ptr,			/* (36) Status queue */
 15    77 	  2 connect_time	   fixed bin (71),		/* (40) time of last connect */
 15    78 	  2 connects	   fixed bin (71),		/* (42) Total connects */
 15    79 	  2 interrupts	   fixed bin (71),		/* (44) Total number of interrupts for this channel. */
 15    80 	  2 interrupt_time	   fixed bin (71);		/* (46) Total interrupt time for this channel. */
 15    81 
 15    82 dcl	iom_mailbox_seg_ptr	   ptr;
 15    83 dcl	1 iom_mailbox_seg	   aligned based (iom_mailbox_seg_ptr),
 15    84 	  2 imw_array	   (0:31) bit (32),		/* Indexed by interrupt cell number. One bit for each channel. */
 15    85 	  2 system_fault	   (4) aligned like status_queue,
 15    86 						/* system faults store here (12 words/IOM) */
 15    87 	  2 special_status	   (4) aligned like status_queue,
 15    88 						/* special status words here (12 words/IOM) */
 15    89 	  2 iom_mailbox	   (4) like iom_mailbox;	/* Used to communicate with the IOM. */
 15    90 
 15    91 dcl	status_queue_ptr	   ptr;
 15    92 dcl	1 status_queue	   aligned based (status_queue_ptr),
 15    93 	  2 status	   (12) bit (36);
 15    94 
 15    95 dcl	1 iom_mailbox	   aligned based,
 15    96 	  2 channel_mailbox	   (0:63) like channel_mailbox;
 15    97 
 15    98 dcl	1 channel_mailbox	   aligned based,
 15    99 	  2 lpw		   bit (72),		/* List pointer word. Points to DCW list. */
 15   100 	  2 scw		   bit (36),		/* Status control word. Points to channel_table.status. */
 15   101 	  2 dcw		   bit (36);		/* Data control word. Primarily scratch space for IOM. */
 15   102 
 15   103 /* Defined channel numbers. */
 15   104 
 15   105 dcl	(
 15   106 	system_fault_channel   init (1),		/* Stores system fault words using LPW and DCW. */
 15   107 	connect_channel	   init (2),		/* Starts other channels using LPW pointing to PCW. */
 15   108 	special_status_channel init (6)		/* Stores special status using LPW and DCW. */
 15   109 	)		   fixed bin (6) static options (constant);
 15   110 
 15   111 /* End of include file ..... iom_data.incl.pl1 */
      360  
 16     1 /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
 16     2 
 16     3 
 16     4 /* The physical volume table (PVT) is a wired-down table.
 16     5*   It has one entry for each spindle present, be it for
 16     6*   Storage System or "I/O" use.
 16     7**/
 16     8 
 16     9      dcl	   pvt$		      ext,
 16    10 	   pvtp		      ptr;
 16    11 
 16    12 
 16    13      dcl	   1 pvt		      based (pvtp) aligned,
 16    14 
 16    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
 16    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
 16    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
 16    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
 16    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
 16    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
 16    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
 16    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
 16    23 
 16    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
 16    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
 16    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
 16    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
 16    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
 16    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
 16    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
 16    31 
 16    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
 16    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
 16    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
 16    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 16    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 16    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
 16    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
 16    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
 16    40 
 16    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
 16    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
 16    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
 16    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
 16    45 
 16    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
 16    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
 16    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
 16    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
 16    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
 16    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
 16    52 	     2 pad (2) bit (36) aligned,
 16    53 
 16    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
 16    55 
 16    56 
 16    57 
 16    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
      361  
 17     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 17     2 
 17     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
 17     4 
 17     5 /****^  HISTORY COMMENTS:
 17     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
 17     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 17     8*     Add the support for subvolumes
 17     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
 17    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 17    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
 17    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 17    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 17    14*     Added inconsistent_dbm bit for determining the status of volume
 17    15*     dumper bit maps.
 17    16*                                                   END HISTORY COMMENTS */
 17    17 
 17    18      dcl	   pvt$array	      aligned external;
 17    19      dcl	   pvt$max_n_entries      fixed bin external;
 17    20 
 17    21      dcl	   pvt_arrayp	      ptr;
 17    22      dcl	   pvtep		      ptr;
 17    23 
 17    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
 17    25 
 17    26      dcl	   1 pvte		      based (pvtep) aligned,
 17    27 
 17    28 	     2 pvid	      bit (36),		/* physical volume ID */
 17    29 
 17    30 	     2 lvid	      bit (36),		/* logical volume ID */
 17    31 
 17    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
 17    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
 17    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
 17    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
 17    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
 17    37 	     2 pad3	      bit (2) unaligned,
 17    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
 17    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
 17    40 
 17    41 
 17    42 
 17    43 	     2 devname	      char (4),		/* device name */
 17    44 
 17    45 	     (2 device_type	      fixed bin (8),	/* device type */
 17    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
 17    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
 17    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
 17    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
 17    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
 17    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
 17    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
 17    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
 17    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
 17    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
 17    56 	     2 scav_check_address
 17    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
 17    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
 17    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
 17    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
 17    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
 17    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
 17    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
 17    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
 17    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
 17    66 
 17    67 
 17    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
 17    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
 17    70 
 17    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
 17    72 
 17    73 	     2 nleft	      fixed bin (17),	/* number of records left */
 17    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
 17    75 
 17    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
 17    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
 17    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
 17    79 	     2 records_per_cyl    fixed bin,
 17    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
 17    81 	     2 sv_name            char (2) aligned,
 17    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
 17    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
 17    84 
 17    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
 17    86 	     2 pad2	      bit (18) unaligned,
 17    87 
 17    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
 17    89 
 17    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
 17    91 
 17    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
 17    93 
 17    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
 17    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
 17    96 
 17    97 
 17    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
 17    99 
 17   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
 17   101 
 17   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
 17   103 
 17   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
 17   105 
 17   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
 17   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
 17   108 
 17   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
 17   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
 17   111 
 17   112 
 17   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
 17   114 	   VOLMAP_ASYNC_READ      init (1),
 17   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
 17   116 
 17   117 
 17   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      362  
 18     1 /*  START OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 18     2 
 18     3      dcl	   stock_segp	      ptr;
 18     4      dcl	   record_stockp	      ptr;
 18     5      dcl	   vtoce_stockp	      ptr;
 18     6      dcl	   stock_seg$	      ext;
 18     7 
 18     8      dcl	   n_in_record_stock      fixed bin;
 18     9      dcl	   n_volmap_pages	      fixed bin;
 18    10      dcl	   n_in_vtoce_stock	      fixed bin;
 18    11 
 18    12 
 18    13      dcl	   1 stock_seg	      aligned based (stock_segp),
 18    14 
 18    15 	     2 meters	      aligned like rsmeters,
 18    16 
 18    17 	     2 record_stock_entries fixed bin,		/* Number of entries in a record stock */
 18    18 	     2 vtoce_stock_entries fixed bin,		/* Number of entries in a VTOCE stock */
 18    19 	     2 record_stock_size  fixed bin,		/* Size of a record stock in words */
 18    20 	     2 vtoce_stock_size   fixed bin,		/* Size of a VTOCE stock in words */
 18    21 	     2 n_stock_entries    fixed bin,		/* Number of stocks of each type */
 18    22 	     2 record_stock_arrayp ptr,		/* Record stock region */
 18    23 	     2 vtoce_stock_arrayp ptr;		/* VTOCE stock region */
 18    24 
 18    25 
 18    26      dcl	   1 record_stock	      aligned based (record_stockp),
 18    27 
 18    28 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
 18    29 
 18    30 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number of addresses in stock */
 18    31 	     2 n_volmap_pages     fixed bin (18) uns unal,/* Number of pages in Volume Map */
 18    32 
 18    33 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number addresses currently free */
 18    34 	     2 n_os_in_stock      fixed bin (18) uns unal,/* Number addresses currently out-of-service */
 18    35 
 18    36 	     2 low_threshold      fixed bin (18) uns unal,/* Low threshold for withdrawing from volmap */
 18    37 	     2 high_threshold     fixed bin (18) uns unal,/* High threshold for depositing to volmap */
 18    38 
 18    39 	     2 target	      fixed bin (18) uns unal,/* Target for stock */
 18    40 	     2 stock_offset	      bit (18) unal,	/* Offset of stock in this structure */
 18    41 
 18    42 	     2 n_words_in_stock   fixed bin (18) uns unal,/* Number of words = Number of entries / 2 */
 18    43 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
 18    44 
 18    45 	     2 old_volmap_page    (3) aligned,		/* N_OLD_VOLMAP_PAGES (cif) */
 18    46 	       3 last	      fixed bin (18) uns unal,/* Roving pointer */
 18    47 	       3 pad	      bit (18) unal,
 18    48 
 18    49 	     2 volmap_page	      (n_volmap_pages refer (record_stock.n_volmap_pages)) aligned,
 18    50 	       3 n_free	      fixed bin (18) uns unal,/* Number free records in this volmap page */
 18    51 	       3 baseadd	      fixed bin (17) unal,	/* First record address described by this page */
 18    52 
 18    53 	     2 stock	      (n_in_record_stock refer (record_stock.n_in_stock)) bit (18) unal; /* Stock array of addresses */
 18    54 						/* bit 0 ON => out-of-service */
 18    55 
 18    56 
 18    57      dcl	   1 vtoce_stock	      aligned based (vtoce_stockp),
 18    58 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
 18    59 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number indices in stock */
 18    60 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number indices currently free */
 18    61 	     2 target	      fixed bin (18) uns unal,/* Target when withdrawing/depositing */
 18    62 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
 18    63 	     2 stock	      (n_in_vtoce_stock refer (vtoce_stock.n_in_stock)) fixed bin (17) unal; /* Stock array of VTOCE indices */
 18    64 
 18    65 
 18    66      dcl	   1 rsmeters	      aligned based,
 18    67 
 18    68 	     2 async_read_calls   fixed bin (35),	/* Number of asynchronous read attempts */
 18    69 	     2 async_page_reads   fixed bin (35),	/* Number of times page read was required */
 18    70 	     2 async_post_io_calls fixed bin (35),	/* Number of times read or write posted */
 18    71 	     2 deposit_calls      fixed bin (35),	/* Number of times deposit called */
 18    72 	     2 async_post_io_time fixed bin (71),	/* CPU time posting I/Os (interrupt side) */
 18    73 	     2 deposit_time	      fixed bin (71),	/* CPU time in deposit (call side) */
 18    74 	     2 low_thresh_detected fixed bin (35),	/* Number of times stock below low threshold */
 18    75 	     2 high_thresh_detected fixed bin (35),	/* Number of times stock above high threshold */
 18    76 	     2 low_thresh_fails   fixed bin (35),	/* Number of times no records in volmap */
 18    77 	     2 withdraw_stock_steps fixed bin (35),	/* Number steps thru stock in withdraw */
 18    78 	     2 withdraw_stock_losses fixed bin (35),	/* Number lockless losses */
 18    79 	     2 n_withdraw_attempt fixed bin (35),	/* Number attempts to withdraw a page */
 18    80 	     2 n_withdraw_range   fixed bin (35),	/* Number attempts to withdraw within range */
 18    81 	     2 n_pages_withdraw_stock fixed bin (35),	/* Number pages withdrawn from stock */
 18    82 	     2 n_pages_withdraw_async fixed bin (35),	/* Number pages withdrawn from volmap */
 18    83 	     2 n_v_withdraw_attempts fixed bin (35),	/* Number attempts to withdraw from volmap */
 18    84 	     2 withdraw_volmap_steps fixed bin (35),	/* Number steps thru volmap in withdraw */
 18    85 	     2 deposit_stock_steps fixed bin (35),	/* Number steps thru stock in deposit */
 18    86 	     2 deposit_stock_losses fixed bin (35),	/* Number lockless losses */
 18    87 	     2 n_deposit_attempt  fixed bin (35),	/* Number attempts to deposit a page */
 18    88 	     2 n_pages_deposit_stock fixed bin (35),	/* Number pages deposited to stock */
 18    89 	     2 n_pages_deposit_volmap fixed bin (35),	/* Number pages deposited to volmap */
 18    90 	     2 n_v_deposit_attempts fixed bin (35),	/* Number attempts to deposit to volmap */
 18    91 	     2 reset_os_calls     fixed bin (35),	/* Number calls to reset_os */
 18    92 	     2 reset_os_losses    fixed bin (35),	/* Number lockless losses */
 18    93 	     2 withdraw_calls     fixed bin (35),	/* Number calls to withdraw */
 18    94 	     2 withdraw_time      fixed bin (71),	/* CPU time in withdraw (page-fault) */
 18    95 	     2 pc_deposit_time    fixed bin (71),	/* CPU time in pc_deposit */
 18    96 	     2 pc_deposit_calls   fixed bin (35),	/* Number calls to pc_deposit */
 18    97 	     2 pc_deposit_pages   fixed bin (35),	/* Number pages deposited by pc_deposit */
 18    98 	     2 get_free_vtoce_calls fixed bin (35),	/* Number calls to get_free_vtoce */
 18    99 	     2 return_free_vtoce_call fixed bin (35),	/* Number calls to return_free_vtoce */
 18   100 	     2 deposit_vstock_calls fixed bin (35),	/* Number attempts to deposit to vtoce stock */
 18   101 	     2 deposit_vstock_fails fixed bin (35),	/* Number times deposit failed */
 18   102 	     2 withdraw_vstock_calls fixed bin (35),	/* Number attempts to withdraw from vtoce stock */
 18   103 	     2 withdraw_vstock_fails fixed bin (35),	/* Number times withdraw failed */
 18   104 	     2 deposit_vtoc_map fixed bin (35),		/* Number times vtoce deposited to map */
 18   105 	     2 withdraw_check_scav fixed bin (35),	/* Number times withdraw checked an address for scavenge */
 18   106 	     2 withdraw_conflict fixed bin (35),	/* Number times conflict found */
 18   107 	     2 pad (11)	      fixed bin (35);
 18   108 	
 18   109 
 18   110      dcl	   N_OLD_VOLMAP_PAGES     fixed bin init (3) int static options (constant);
 18   111      dcl	   DEFAULT_N_IN_RECORD_STOCK fixed bin init (104) int static options (constant);
 18   112      dcl	   DEFAULT_N_IN_VTOCE_STOCK fixed bin init (10) int static options (constant);
 18   113 
 18   114 
 18   115 /*  END OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      363  
 19     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
 19     2*
 19     3*   Values for the "access mode" argument so often used in hardcore
 19     4*   James R. Davis 26 Jan 81  MCR 4844
 19     5*   Added constants for SM access 4/28/82 Jay Pattin
 19     6*   Added text strings 03/19/85 Chris Jones
 19     7**/
 19     8 
 19     9 
 19    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 19    11 dcl	(
 19    12 	N_ACCESS		   init ("000"b),
 19    13 	R_ACCESS		   init ("100"b),
 19    14 	E_ACCESS		   init ("010"b),
 19    15 	W_ACCESS		   init ("001"b),
 19    16 	RE_ACCESS		   init ("110"b),
 19    17 	REW_ACCESS	   init ("111"b),
 19    18 	RW_ACCESS		   init ("101"b),
 19    19 	S_ACCESS		   init ("100"b),
 19    20 	M_ACCESS		   init ("010"b),
 19    21 	A_ACCESS		   init ("001"b),
 19    22 	SA_ACCESS		   init ("101"b),
 19    23 	SM_ACCESS		   init ("110"b),
 19    24 	SMA_ACCESS	   init ("111"b)
 19    25 	)		   bit (3) internal static options (constant);
 19    26 
 19    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
 19    28*   2) divide (bin_value, 2) to come up with an index into the array. */
 19    29 
 19    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
 19    31 			   static options (constant);
 19    32 
 19    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
 19    34 			   static options (constant);
 19    35 
 19    36 dcl	(
 19    37 	N_ACCESS_BIN	   init (00000b),
 19    38 	R_ACCESS_BIN	   init (01000b),
 19    39 	E_ACCESS_BIN	   init (00100b),
 19    40 	W_ACCESS_BIN	   init (00010b),
 19    41 	RW_ACCESS_BIN	   init (01010b),
 19    42 	RE_ACCESS_BIN	   init (01100b),
 19    43 	REW_ACCESS_BIN	   init (01110b),
 19    44 	S_ACCESS_BIN	   init (01000b),
 19    45 	M_ACCESS_BIN	   init (00010b),
 19    46 	A_ACCESS_BIN	   init (00001b),
 19    47 	SA_ACCESS_BIN	   init (01001b),
 19    48 	SM_ACCESS_BIN	   init (01010b),
 19    49 	SMA_ACCESS_BIN	   init (01011b)
 19    50 	)		   fixed bin (5) internal static options (constant);
 19    51 
 19    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      364 
 20     1 /* BEGIN include file collection_1_phases.incl.pl1 */
 20     2 
 20     3 /* Symbolic names for the various collection1 phases.
 20     4*Keith Loepere, October 1983. */
 20     5 
 20     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 20     7 
 20     8 dcl  sys_info$collection_1_phase	        fixed bin external static;
 20     9 
 20    10 dcl  EARLY_INITIALIZATION		        fixed bin init (1) static options (constant);  /* phase to find the config deck */
 20    11 dcl  BOOT_INITIALIZATION		        fixed bin init (2) static options (constant);  /* phase to setup up crash handler, bce */
 20    12 dcl  SERVICE_INITIALIZATION		        fixed bin init (3) static options (constant);  /* phase to set up for service */
 20    13 
 20    14 /* These first 3 (EARLY, BOOT and SERVICE) must be 1, 2, 3 in that order so
 20    15*programs can simply tell apart the booting phases from all others (crash or
 20    16*recovery type phases). */
 20    17 
 20    18 dcl  CRASH_INITIALIZATION		        fixed bin init (4) static options (constant);  /* phase to set up bce after crash/shut down */
 20    19 dcl  RE_EARLY_INITIALIZATION		        fixed bin init (5) static options (constant);  /* retry boot initialization given safe config to a new early level */
 20    20 dcl  BCE_CRASH_INITIALIZATION		        fixed bin init (6) static options (constant);  /* retry boot initialization to give a new boot level given a crash of bce */
 20    21 dcl  SHUT_INITIALIZATION		        fixed bin init (7) static options (constant);  /* same as boot but don't load new disk mpcs */
 20    22 
 20    23 dcl  COLLECTION_1_PHASE_NAMES		        (7) char (16) unal static options (constant) init
 20    24 				        ("early", "boot", "service", "crash", "re_early", "bce_crash", "shut");
 20    25 
 20    26 /* END include file collection_1_phases.incl.pl1 */
      365 
 21     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
 21     2 
 21     3 /****^  HISTORY COMMENTS:
 21     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
 21     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
 21     6*     Add support for FIPS
 21     7*     3380.
 21     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
 21     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
 21    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
 21    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
 21    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
 21    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
 21    14*                                                   END HISTORY COMMENTS */
 21    15 
 21    16 /* Modified 5/19/76 by N. I. Morris */
 21    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
 21    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
 21    19 /* Modified '82 by BIM for needs_alt_part */
 21    20 /* Modified 4/84 by Chris Jones for FIPS disks */
 21    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
 21    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
 21    23*   volmap and record stock can be expanded. */
 21    24 
 21    25 /*
 21    26********************************************************************************
 21    27**							        *
 21    28**                           WARNING:                                          *
 21    29**							        *
 21    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
 21    31**   type is added.						        *
 21    32**							        *
 21    33**   There are other include files that contain arrays indexed by the device   *
 21    34**   index obtained by references to MODELX or MODELN in this include file.    *
 21    35**   These must be modified when a new device type is added:		        *
 21    36**   disk_pack.incl.pl1					        *
 21    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
 21    38**							        *
 21    39********************************************************************************
 21    40**/
 21    41 
 21    42 
 21    43 dcl (maxdevt init (9),				/* maximum legal devt */
 21    44      bulkdevt init (1),				/* bulk store devt */
 21    45      msu0500devt init (2),				/* MSU0500 device type */
 21    46      msu0451devt init (3),				/* MSU0451 device type */
 21    47      msu0450devt init (3),				/* MSU0450 device type */
 21    48      msu0400devt init (4),				/* MSU0400 device type */
 21    49      dsu191devt init (4),				/* DSU191 device type */
 21    50      dsu190devt init (5),				/* DSU190 device type */
 21    51      dsu181devt init (6),				/* DSU181 device type */
 21    52      msu0501devt init (7),				/* MSU0501 device type */
 21    53      fips3380devt init (8),				/* 3380D FIPS device type */
 21    54      fips3381devt init (9)				/* 3380E FIPS device type */
 21    55      ) fixed bin (4) static options (constant);
 21    56 
 21    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
 21    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
 21    59 
 21    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
 21    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
 21    62 
 21    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
 21    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
 21    65 
 21    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
 21    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
 21    68 
 21    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
 21    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
 21    71 
 21    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
 21    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
 21    74 
 21    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
 21    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
 21    77 
 21    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
 21    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
 21    80 
 21    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
 21    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
 21    83 
 21    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
 21    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
 21    86 
 21    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
 21    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
 21    89 
 21    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
 21    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
 21    92 
 21    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
 21    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
 21    95 
 21    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
 21    97      ("abc");
 21    98 
 21    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
 21   100      init ("a","b","c");
 21   101 
 21   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
 21   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
 21   104 
 21   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
 21   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
 21   107 
 21   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
 21   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
 21   110 
 21   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
 21   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
 21   113 
 21   114 
 21   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
 21   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
 21   117 
 21   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
 21   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
 21   120 
 21   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
 21   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
 21   123 
 21   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
 21   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
 21   126 
 21   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
 21   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
 21   129 
 21   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
 21   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
 21   132 
 21   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
 21   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
 21   135 
 21   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
 21   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
 21   138 
 21   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
 21   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
 21   141 
 22     1 /* Begin fs_dev_types_sector.incl.pl1 */
 22     2 
 22     3 
 22     4 /****^  HISTORY COMMENTS:
 22     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
 22     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
 22     7*     Add the sector differance for devices that do 64 word IO and devices that
 22     8*     do 512 word IO.
 22     9*                                                   END HISTORY COMMENTS */
 22    10 
 22    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
 22    12*	 need all the data in fs_dev_types. This is also included in
 22    13*	 fs_dev_types.incl.pl1  */
 22    14 
 22    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
 22    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
 22    17 
 22    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
 22    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
 22    20 
 22    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
 22    22  /* table of # of sectors per record on each device */
 22    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
 22    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
 22    25 
 22    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
 22    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
 22    28 	
 22    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
 22    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
 22    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
 22    32 
 22    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
 22    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
 22    35 
 22    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
 22    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
 22    38 
 22    39 /* End fs_dev_types_sector.incl.pl1 */
 22    40 
 21   142 
 21   143 
 21   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      366 
      367 /* format: on */
      368 
      369 /* BEGIN MESSAGE DOCUMENTATION
      370*
      371*   Message:
      372*   get_io_segs: Missing ndrives field on config card prph NAME.
      373*
      374*   S:	$crash
      375*
      376*   T:	$init
      377*
      378*   M:	The prph card for the NAME subsystem is missing an ndrives field.
      379*
      380*   A:	$config
      381*
      382*
      383*   Message:
      384*   get_io_segs: DSKQ mmm. < xxx. per drive, forcing DSKQ nnn.
      385*
      386*   S:	$beep
      387*
      388*   T:	$init
      389*
      390*   M:	The dskq card specifies less than 5 queue entries per configured
      391*   drive.  This is considered too few for efficient operation and is
      392*   forced to 5 entries per drive.
      393*
      394*   A:	$config
      395*
      396*
      397*   Message:
      398*   get_io_segs: DSKQ mmm. > xxx. per drive, forcing DSKQ nnn.
      399*   S:	$beep
      400*
      401*   T:	$init
      402*
      403*   M:	The dskq card specifies an excess of queue entries beyond that
      404*   reasonably required for efficient operation.  The free queue will be
      405*   limited to 100 entries per drive.
      406*
      407*   A:	$config
      408*
      409*
      410*   END MESSAGE DOCUMENTATION */
      411 
      412      end get_io_segs;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0815.8  get_io_segs.pl1                   >spec>install>1112>get_io_segs.pl1
347          1    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
348          2    05/08/81  1853.6  config_chnl_card.incl.pl1         >ldd>include>config_chnl_card.incl.pl1
349          3    05/08/81  1853.6  config_deck.incl.pl1              >ldd>include>config_deck.incl.pl1
350          4    05/08/81  1853.6  config_iom_card.incl.pl1          >ldd>include>config_iom_card.incl.pl1
351          5    03/27/86  1120.0  config_ipc_card.incl.pl1          >ldd>include>config_ipc_card.incl.pl1
352          6    05/08/81  1853.6  config_mpc_card.incl.pl1          >ldd>include>config_mpc_card.incl.pl1
353          7    10/31/84  1315.5  config_prph_card.incl.pl1         >ldd>include>config_prph_card.incl.pl1
354          8    05/08/81  1853.7  config_prph_dsk_card.incl.pl1     >ldd>include>config_prph_dsk_card.incl.pl1
355          9    11/08/82  1005.8  config_prph_tap_card.incl.pl1     >ldd>include>config_prph_tap_card.incl.pl1
356         10    05/27/82  1525.6  config_stok_card.incl.pl1         >ldd>include>config_stok_card.incl.pl1
357         11    08/11/88  2011.5  dskdcl.incl.pl1                   >ldd>include>dskdcl.incl.pl1
358         12    07/11/84  0937.3  io_config_data.incl.pl1           >ldd>include>io_config_data.incl.pl1
359         13    09/02/86  1552.9  ioi_data.incl.pl1                 >ldd>include>ioi_data.incl.pl1
13-61       14    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
360         15    04/11/85  1452.4  iom_data.incl.pl1                 >ldd>include>iom_data.incl.pl1
361         16    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
362         17    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
363         18    10/25/82  1015.6  stock_seg.incl.pl1                >ldd>include>stock_seg.incl.pl1
364         19    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
365         20    07/11/84  0937.3  collection_1_phases.incl.pl1      >ldd>include>collection_1_phases.incl.pl1
366         21    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
21-142      22    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000150 constant        fixed bin(17,0)          initial dcl 1-7 set ref 224* 226*
CHNL_CARD_WORD                  000047 constant        char(4)                  initial dcl 2-27 set ref 105*
CRASH                           000152 constant        fixed bin(17,0)          initial dcl 1-7 set ref 118*
DEFAULT_N_IN_RECORD_STOCK              constant        fixed bin(17,0)          initial dcl 18-111 ref 199 201 203
DEFAULT_N_IN_VTOCE_STOCK               constant        fixed bin(17,0)          initial dcl 18-112 ref 206 208 210
IOM_CARD_WORD                   000046 constant        char(4)                  initial dcl 4-19 set ref 179* 186*
IPC_CARD_WORD                   000045 constant        char(4)                  initial dcl 5-25 set ref 167* 173*
IPC_FIPS                        000044 constant        char(4)                  initial dcl 5-26 ref 170
ME                              000122 constant        char(32)                 initial packed unaligned dcl 70 set ref 118* 122*
                                                                                  224* 226*
MODEL                           000025 constant        fixed bin(17,0)          initial array dcl 21-57 ref 131 131
MODELX                          000011 constant        fixed bin(17,0)          initial array dcl 21-60 ref 134
MPC_CARD_WORD                   000043 constant        char(4)                  initial dcl 6-26 set ref 156* 161*
PRPH_CARD_WORD                  000042 constant        char(4)                  initial dcl 7-19 set ref 89* 149*
SERVICE_INITIALIZATION                 constant        fixed bin(17,0)          initial dcl 20-12 ref 217
STOK_CARD_WORD                  000041 constant        char(4)                  initial dcl 10-17 set ref 198*
SYSERR_CONTROL_STRING           000102 constant        char(64)                 initial packed unaligned dcl 71 set ref 118* 122*
SYSERR_QUEUE_STRING_1           000065 constant        char(50)                 initial packed unaligned dcl 73 set ref 224*
SYSERR_QUEUE_STRING_2           000050 constant        char(50)                 initial packed unaligned dcl 75 set ref 226*
addr                                                   builtin function         dcl 78 ref 236 237 245 256 267 276 278 280 282 285
                                                                                  289 307 317 342 342
array                    50            based           fixed bin(71,0)          level 2 dcl 16-13 set ref 237
bin                                                    builtin function         dcl 78 ref 237
channel_entry             4            based           structure                array level 2 dcl 12-53 set ref 278
channel_entry_template                 based           structure                level 1 dcl 12-59 ref 278
channel_mailbox                        based           structure                level 1 dcl 15-98
channel_table                          based           structure                level 1 dcl 12-53
channel_table_length            000204 automatic       fixed bin(19,0)          dcl 273 set ref 278* 283 291
channel_table_offset      3(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 12-22
                                                                                  set ref 290* 291 295
chantab                                based           structure                level 1 dcl 11-132 ref 257
chnl_card                              based           structure                level 1 dcl 2-5
chnl_cardp                      000122 automatic       pointer                  dcl 2-3 set ref 104* 105* 106 108 109 110
config_$find                    000010 constant        entry                    external dcl 59 ref 89 149 156 161 167 173 179 186
                                                                                  198
config_$find_2                  000012 constant        entry                    external dcl 60 ref 105
config_$find_parm               000014 constant        entry                    external dcl 61 ref 220
config_card                            based           structure                level 1 dcl 3-13
config_card_type_word                  based           structure                level 1 dcl 3-18
controller_entry          4            based           structure                array level 2 dcl 12-71 set ref 280
controller_entry_template              based           structure                level 1 dcl 12-77 ref 280
controller_table                       based           structure                level 1 dcl 12-71
controller_table_length         000205 automatic       fixed bin(19,0)          dcl 273 set ref 280* 283 292
controller_table_offset
                          4            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 12-22
                                                                                  set ref 291* 292 296
controllers                     000112 automatic       fixed bin(17,0)          dcl 53 set ref 83* 159* 159 170* 170 280 301
cp                                     automatic       pointer                  dcl 11-97 ref 257
cte                                    based           structure                level 1 dcl 13-96
dev_idx                         000101 automatic       fixed bin(17,0)          dcl 43 set ref 131* 131* 134* 134 135 137
device_entry              4            based           structure                array level 2 dcl 12-36 set ref 276
device_entry_template                  based           structure                level 1 dcl 12-42 ref 276
device_table                           based           structure                level 1 dcl 12-36
device_table_length             000203 automatic       fixed bin(19,0)          dcl 273 set ref 276* 283 290
device_table_offset       3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 12-22
                                                                                  set ref 289* 290 294
devtab                                 based           structure                level 1 dcl 11-190 ref 257
disk_channel_count              000103 automatic       fixed bin(17,0)          dcl 45 set ref 83* 100* 100 110* 110 257
disk_data                              based           structure                level 1 dcl 11-31 set ref 257
disk_drives                     000104 automatic       fixed bin(17,0)          dcl 46 set ref 83* 126* 126 257
disk_lock_meters                       based           structure                level 1 dcl 11-236
disk_seg$                       000026 external static fixed bin(17,0)          dcl 11-24 set ref 256
disk_subsystems                 000100 automatic       fixed bin(17,0)          dcl 42 set ref 83* 99* 99 257
diskp                                  automatic       pointer                  dcl 11-26 ref 257
disksp                          000142 automatic       pointer                  dcl 11-26 set ref 256* 257 262* 263
disktab                                based           structure                level 1 dcl 11-74 ref 257
dp                                     automatic       pointer                  dcl 11-187 ref 257
dskq_parm                              based           structure                level 1 dcl 48
dte                                    based           structure                level 1 dcl 13-128
fptr                            000106 automatic       pointer                  dcl 47 set ref 220* 221 222 224 224 226 226
free_q_size              10            based           fixed bin(17,0)          level 2 in structure "disk_data" dcl 11-31
                                                                                  in procedure "get_io_segs" set ref 263*
free_q_size                     000110 automatic       fixed bin(17,0)          dcl 51 in procedure "get_io_segs" set ref 218* 222*
                                                                                  224* 226* 230* 257 263
get_main                        000020 constant        entry                    external dcl 64 ref 341
get_ring_                       000016 constant        entry                    external dcl 63 ref 118 338
group                     5            based           structure                array level 2 in structure "prph_dsk_card" dcl 8-5
                                                                                  in procedure "get_io_segs"
group                     2            based           structure                array level 2 in structure "chnl_card" dcl 2-5
                                                                                  in procedure "get_io_segs"
group                     5            based           structure                array level 2 in structure "prph_tap_card" dcl 9-5
                                                                                  in procedure "get_io_segs" ref 115 115
gte                                    based           structure                level 1 dcl 13-74
hbound                                                 builtin function         dcl 78 ref 115 131
i                               000120 automatic       fixed bin(17,0)          dcl 57 set ref 106* 108 109 110* 115* 115* 118 126
                                                                                  128 129 131 135 137*
idp                             000156 automatic       pointer                  dcl 13-29 set ref 307* 308* 308 308 310 311 312 313
imus                            000111 automatic       fixed bin(17,0)          dcl 52 set ref 83* 183* 183 191 192 193 318
io_config_channel_table_ptr     000150 automatic       pointer                  dcl 12-13 set ref 268* 278 295* 300
io_config_controller_table_ptr  000152 automatic       pointer                  dcl 12-15 set ref 268* 280 296* 301
io_config_data                         based           structure                level 1 dcl 12-22
io_config_data$                 000030 external static fixed bin(17,0)          dcl 12-8 set ref 267
io_config_data_ptr              000144 automatic       pointer                  dcl 12-10 set ref 267* 268 285 286* 288 289 289 290
                                                                                  290 291 291 292 292 294 294 295 295 296 296 297
                                                                                  297
io_config_device_table_ptr      000146 automatic       pointer                  dcl 12-11 set ref 268* 276 294* 299
io_config_iom_table_ptr         000154 automatic       pointer                  dcl 12-17 set ref 268* 282 297* 302
io_config_tables_length         000207 automatic       fixed bin(19,0)          dcl 273 set ref 283* 285 288
ioa_                            000022 constant        entry                    external dcl 65 ref 122
ioi_channels                    000162 automatic       fixed bin(17,0)          dcl 13-35 set ref 83* 102* 102 109* 109 146* 146
                                                                                  192* 192 278 300 308 308 311 318
ioi_data                               based           structure                level 1 dcl 13-40 set ref 308 308
ioi_data$                       000032 external static fixed bin(17,0)          dcl 13-37 set ref 307
ioi_devices                     000161 automatic       fixed bin(17,0)          dcl 13-35 set ref 83* 114* 114 129* 129 147* 147
                                                                                  193* 193 276 299 308 308 312
ioi_multiplexers                000163 automatic       fixed bin(17,0)          dcl 13-35 set ref 83* 182* 182 282 302 308 308 313
                                                                                  318
ioi_subsystems                  000160 automatic       fixed bin(17,0)          dcl 13-35 set ref 83* 91* 91 191* 191 308 308 310
iom_card                               based           structure                level 1 dcl 4-5
iom_cardp                       000124 automatic       pointer                  dcl 4-3 set ref 178* 179* 181 183 183 186*
iom_data                               based           structure                level 1 dcl 15-17 set ref 320
iom_data$                       000034 external static fixed bin(17,0)          dcl 15-11 set ref 317
iom_data_ptr                    000166 automatic       pointer                  dcl 15-15 set ref 317* 320 322* 324
iom_entry                 4            based           structure                array level 2 dcl 12-87 set ref 282
iom_entry_template                     based           structure                level 1 dcl 12-93 ref 282
iom_mailbox                            based           structure                level 1 dcl 15-95
iom_table                              based           structure                level 1 dcl 12-87
iom_table_length                000206 automatic       fixed bin(19,0)          dcl 273 set ref 282* 283
iom_table_offset          4(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 12-22
                                                                                  set ref 292* 297
ipc_card                               based           structure                level 1 dcl 5-12
ipc_cardp                       000126 automatic       pointer                  dcl 5-10 set ref 166* 167* 169 170 173*
ite                                    based           structure                level 1 dcl 13-63
lbound                                                 builtin function         dcl 78 ref 115
lock                                   based           structure                level 1 dcl 14-12
max                                                    builtin function         dcl 78 ref 222
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 16-13 set ref 240*
max_per_drive                   000132 constant        fixed bin(17,0)          initial dcl 69 set ref 222 226 226*
min                                                    builtin function         dcl 78 ref 222
min_per_drive                   000151 constant        fixed bin(17,0)          initial dcl 68 set ref 222 224 224*
model                     3            based           char(4)                  level 2 in structure "iom_card" dcl 4-5 in procedure
                                                                                  "get_io_segs" ref 183 183
model                     5            based           fixed bin(17,0)          array level 3 in structure "prph_tap_card" dcl 9-5
                                                                                  in procedure "get_io_segs" ref 115 128 131
mpc_cardp                       000130 automatic       pointer                  dcl 6-3 set ref 155* 156* 158 161*
n_channels                2            based           fixed bin(17,0)          level 2 dcl 12-53 set ref 300*
n_controllers             2            based           fixed bin(17,0)          level 2 dcl 12-71 set ref 301*
n_devices                 2            based           fixed bin(17,0)          level 2 in structure "device_table" dcl 12-36
                                                                                  in procedure "get_io_segs" set ref 299*
n_devices                       000164 automatic       fixed bin(17,0)          dcl 15-14 in procedure "get_io_segs" set ref 318*
                                                                                  320 324
n_devices                              based           fixed bin(17,0)          level 2 in structure "iom_data" dcl 15-17
                                                                                  in procedure "get_io_segs" set ref 324*
n_fields                 17(32)        based           fixed bin(4,0)           level 3 packed packed unsigned unaligned dcl 10-5
                                                                                  ref 201 208
n_in_record_stock               000174 automatic       fixed bin(17,0)          dcl 18-8 set ref 199* 201* 203* 205* 246 248 250
n_in_vtoce_stock                000176 automatic       fixed bin(17,0)          dcl 18-10 set ref 206* 208* 210* 212* 246 249 251
n_ioms                    2            based           fixed bin(17,0)          level 2 dcl 12-87 set ref 302*
n_record_stock_entries
                          1            based           fixed bin(17,0)          level 2 dcl 10-5 ref 203 205
n_stock_entries          72            based           fixed bin(17,0)          level 2 dcl 18-13 set ref 252*
n_volmap_pages                  000175 automatic       fixed bin(17,0)          dcl 18-9 set ref 213* 246 250
n_vtoce_stock_entries
                          2            based           fixed bin(17,0)          level 2 dcl 10-5 ref 210 212
name                      1            based           char(4)                  level 2 dcl 7-5 set ref 93 105* 118* 122*
nchan                     4            based           fixed bin(17,0)          level 2 in structure "prph_dsk_card" dcl 8-5
                                                                                  in procedure "get_io_segs" ref 100
nchan                     4            based           fixed bin(17,0)          array level 3 in structure "chnl_card" dcl 2-5
                                                                                  in procedure "get_io_segs" ref 108 109 110
nchan                     4            based           fixed bin(17,0)          level 2 in structure "prph_tap_card" dcl 9-5
                                                                                  in procedure "get_io_segs" ref 102
nct                       1            based           fixed bin(17,0)          level 2 dcl 13-40 set ref 311*
ndrives                   6            based           fixed bin(17,0)          array level 3 in structure "prph_dsk_card" dcl 8-5
                                                                                  in procedure "get_io_segs" ref 126 135 137
ndrives                   6            based           fixed bin(17,0)          array level 3 in structure "prph_tap_card" dcl 9-5
                                                                                  in procedure "get_io_segs" ref 118 129
ndt                       2            based           fixed bin(17,0)          level 2 dcl 13-40 set ref 312*
ngt                                    based           fixed bin(17,0)          level 2 dcl 13-40 set ref 310*
nit                       3            based           fixed bin(17,0)          level 2 dcl 13-40 set ref 313*
null                                                   builtin function         dcl 78 ref 88 90 104 106 155 158 166 169 178 181 197
                                                                                  199 206 221
number_of_sv                    000000 constant        fixed bin(17,0)          initial array dcl 21-93 ref 135 137
opt_info                               based           structure                level 1 dcl 11-217
per_device                             based           structure                level 1 dcl 15-59
per_iom                                based           structure                level 1 dcl 15-40
physical_volumes                000102 automatic       fixed bin(17,0)          dcl 44 set ref 83* 135* 135 137* 137 218 222 222 224
                                                                                  226 237 240 246 252
pmut$swap_sdw                   000044 constant        entry                    external dcl 336 ref 342
prph_card                              based           structure                level 1 dcl 7-5
prph_cardp                      000132 automatic       pointer                  dcl 7-3 set ref 88* 89* 90 93 96 97 105 118 122 149*
prph_dsk_card                          based           structure                level 1 dcl 8-5
prph_dsk_cardp                  000134 automatic       pointer                  dcl 8-3 set ref 96* 100 126 135 137
prph_tap_card                          based           structure                level 1 dcl 9-5
prph_tap_cardp                  000136 automatic       pointer                  dcl 9-3 set ref 97* 102 115 115 115 118 128 129 131
ptr                                                    builtin function         dcl 78 ref 294 295 296 297
pvt                                    based           structure                level 1 dcl 16-13
pvt$                            000036 external static fixed bin(17,0)          dcl 16-9 set ref 236
pvte                                   based           structure                level 1 dcl 17-26 ref 237
pvtep                                  automatic       pointer                  dcl 17-22 ref 237
pvtp                            000170 automatic       pointer                  dcl 16-9 set ref 236* 237 239* 240
qht                                    based           structure                level 1 dcl 11-179
qp                                     automatic       pointer                  dcl 11-97 ref 257
quentry                                based           structure                level 1 dcl 11-107 ref 257
record_stock                           based           structure                level 1 dcl 18-26 ref 246 250
record_stock_entries     66            based           fixed bin(17,0)          level 2 dcl 18-13 set ref 248*
record_stock_size        70            based           fixed bin(17,0)          level 2 dcl 18-13 set ref 250*
record_stockp                          automatic       pointer                  dcl 18-4 ref 246 250
rel                                                    builtin function         dcl 78 ref 237
rsmeters                               based           structure                level 1 dcl 18-66
sdw                                    parameter       fixed bin(71,0)          dcl 333 set ref 328 341* 342 342
seek_command                    000200 automatic       bit(6)                   initial array packed unaligned dcl 21-84 set ref
                                                                                  21-84* 21-84* 21-84* 21-84* 21-84* 21-84* 21-84*
                                                                                  21-84* 21-84*
seg_size                        000113 automatic       fixed bin(19,0)          dcl 54 set ref 237* 239* 246* 247* 257* 262* 285*
                                                                                  286* 320* 322*
seglen                                 parameter       fixed bin(19,0)          dcl 332 set ref 328 341*
segptr                                 parameter       pointer                  dcl 331 set ref 328 341* 342*
size                      1            based           fixed bin(17,0)          level 2 in structure "dskq_parm" dcl 48 in procedure
                                                                                  "get_io_segs" set ref 222 224 224* 226 226*
size                                                   builtin function         dcl 78 in procedure "get_io_segs" ref 237 246 246
                                                                                  246 250 251 257 257 257 257 257 276 278 280 282
                                                                                  308 308 320
status_queue                           based           structure                level 1 dcl 15-92
stock_seg                              based           structure                level 1 dcl 18-13 set ref 246
stock_seg$                      000040 external static fixed bin(17,0)          dcl 18-6 set ref 245
stock_segp                      000172 automatic       pointer                  dcl 18-3 set ref 245* 246 247* 248 249 250 251 252
stok_card                              based           structure                level 1 dcl 10-5
stok_cardp                      000140 automatic       pointer                  dcl 10-3 set ref 197* 198* 199 201 203 205 206 208
                                                                                  210 212
substr                                                 builtin function         dcl 78 ref 93
subsystem_type                  000114 automatic       char(4)                  dcl 55 set ref 93* 94 94 98 110 126 130
sys_info                               based           structure                level 1 dcl 11-59
sys_info$collection_1_phase     000042 external static fixed bin(17,0)          dcl 20-8 ref 217
syserr                          000024 constant        entry                    external dcl 66 ref 118 224 226
tables                   10            based           bit(36)                  array level 2 dcl 12-22 set ref 285 289
tables_length             2            based           fixed bin(19,0)          level 2 unsigned dcl 12-22 set ref 288*
tsdw                            000116 automatic       fixed bin(71,0)          dcl 56 set ref 239* 247* 262* 286* 308* 322*
type                      1            based           char(4)                  level 2 dcl 5-12 ref 170
type_word                17            based           structure                level 2 dcl 10-5
vtoce_stock                            based           structure                level 1 dcl 18-57 ref 246 251
vtoce_stock_entries      67            based           fixed bin(17,0)          level 2 dcl 18-13 set ref 249*
vtoce_stock_size         71            based           fixed bin(17,0)          level 2 dcl 18-13 set ref 251*
vtoce_stockp                           automatic       pointer                  dcl 18-5 ref 246 251
wordno                                                 builtin function         dcl 78 ref 276 278 280 282 285 289

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
BCE_CRASH_INITIALIZATION               internal static fixed bin(17,0)          initial dcl 20-20
BEEP                                   internal static fixed bin(17,0)          initial dcl 1-7
BOOTLOAD_READ                          internal static fixed bin(4,0)           initial dcl 11-251
BOOTLOAD_WRITE                         internal static fixed bin(4,0)           initial dcl 11-251
BOOT_INITIALIZATION                    internal static fixed bin(17,0)          initial dcl 20-11
COLLECTION_1_PHASE_NAMES               internal static char(16)                 initial array packed unaligned dcl 20-23
CONFIG_DECIMAL_TYPE                    internal static bit(2)                   initial dcl 3-23
CONFIG_OCTAL_TYPE                      internal static bit(2)                   initial dcl 3-23
CONFIG_SINGLE_CHAR_TYPE                internal static bit(2)                   initial dcl 3-23
CONFIG_STRING_TYPE                     internal static bit(2)                   initial dcl 3-23
CRASH_INITIALIZATION                   internal static fixed bin(17,0)          initial dcl 20-18
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 19-33
DSC_LISTX                              internal static fixed bin(12,0)          initial dcl 11-241
EARLY_INITIALIZATION                   internal static fixed bin(17,0)          initial dcl 20-10
EMPTY_FIELD                            internal static bit(36)                  initial dcl 3-34
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
FREE_CARD_WORD                         internal static char(4)                  initial dcl 3-29
IOI_DEFAULT_MAX_BOUND                  internal static fixed bin(19,0)          initial dcl 13-198
IOI_DEFAULT_MAX_TIMEOUT                internal static fixed bin(35,0)          initial dcl 13-199
IOI_DEFAULT_TIMEOUT                    internal static fixed bin(35,0)          initial dcl 13-201
IOI_DEVICE_LOCK_EVENT_TEMPLATE         internal static char(2)                  initial packed unaligned dcl 13-207
IO_CHANNEL_LOCK_TEMPLATE               internal static char(2)                  initial packed unaligned dcl 13-205
IO_CONFIG_CHANNEL_TABLE_VERSION_1      internal static char(8)                  initial dcl 12-106
IO_CONFIG_CONTROLLER_TABLE_VERSION_1   internal static char(8)                  initial dcl 12-108
IO_CONFIG_DATA_VERSION_1               internal static char(8)                  initial dcl 12-102
IO_CONFIG_DEVICE_TABLE_VERSION_1       internal static char(8)                  initial dcl 12-104
IO_CONFIG_IOM_TABLE_VERSION_1          internal static char(8)                  initial dcl 12-110
IO_STATUS_ERROR_MASK                   internal static bit(36)                  initial packed unaligned dcl 13-203
IO_TYPE                                internal static char(16)                 initial array packed unaligned dcl 11-262
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 1-7
LOG                                    internal static fixed bin(17,0)          initial dcl 1-7
MAX_IO_TYPE                            internal static fixed bin(4,0)           initial dcl 11-251
MODELN                                 internal static fixed bin(17,0)          initial array dcl 21-63
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
N_OLD_VOLMAP_PAGES                     internal static fixed bin(17,0)          initial dcl 18-110
PAGE_READ                              internal static fixed bin(4,0)           initial dcl 11-251
PAGE_WRITE                             internal static fixed bin(4,0)           initial dcl 11-251
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 19-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 19-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 19-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 19-36
RE_EARLY_INITIALIZATION                internal static fixed bin(17,0)          initial dcl 20-19
RSS_LISTX                              internal static fixed bin(12,0)          initial dcl 11-241
RST_LISTX                              internal static fixed bin(12,0)          initial dcl 11-241
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 19-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 19-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 19-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 19-36
SC_LISTX                               internal static fixed bin(12,0)          initial dcl 11-241
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 19-30
SHUT_INITIALIZATION                    internal static fixed bin(17,0)          initial dcl 20-21
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 19-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 19-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 19-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 19-36
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 1-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 1-7
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 1-7
TEST                                   internal static fixed bin(4,0)           initial dcl 11-251
VALID_CARD_WORD_CHARACTERS             internal static char(38)                 initial packed unaligned dcl 3-31
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 17-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 17-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 17-113
VTOC_READ                              internal static fixed bin(4,0)           initial dcl 11-251
VTOC_WRITE                             internal static fixed bin(4,0)           initial dcl 11-251
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 19-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 19-36
ZERO_CARD_WORD                         internal static char(4)                  initial dcl 3-28
bootload_map                           defined         bit(1)                   array packed unaligned dcl 11-279
bootload_mapping                       internal static bit(7)                   initial packed unaligned dcl 11-278
bulkdevt                               internal static fixed bin(4,0)           initial dcl 21-43
cardp                                  automatic       pointer                  dcl 3-3
chnl_card_array                        based           structure                level 1 dcl 2-20
config_deck                            based           structure                level 1 dcl 3-9
config_deck$                           external static fixed bin(17,0)          dcl 3-7
config_max_cards                       automatic       fixed bin(17,0)          dcl 3-5
config_n_cards                         automatic       fixed bin(17,0)          dcl 3-4
configp                                automatic       pointer                  dcl 3-3
connect_channel                        internal static fixed bin(6,0)           initial dcl 15-105
ctep                                   automatic       pointer                  dcl 13-31
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 21-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 21-105
dev_time                               internal static float bin(27)            initial array dcl 21-139
device_names                           internal static char(4)                  initial array dcl 21-66
disk_channel_table                     based           structure                array level 1 dcl 11-94
dskdcl_chans_per_subsys                internal static fixed bin(17,0)          initial dcl 11-70
dskdcl_chans_per_subsys_shift          internal static fixed bin(17,0)          initial dcl 11-71
dsu181devt                             internal static fixed bin(4,0)           initial dcl 21-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 21-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 21-43
dtep                                   automatic       pointer                  dcl 13-32
fips3380devt                           internal static fixed bin(4,0)           initial dcl 21-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 21-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 21-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 21-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 21-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 21-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 21-124
gtep                                   automatic       pointer                  dcl 13-30
iom_mailbox$                           external static fixed bin(17,0)          dcl 15-12
iom_mailbox_seg                        based           structure                level 1 dcl 15-83
iom_mailbox_seg_ptr                    automatic       pointer                  dcl 15-82
itep                                   automatic       pointer                  dcl 13-33
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 21-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 21-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 21-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 21-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 21-121
lock_ptr                               automatic       pointer                  dcl 14-11
maxdevt                                internal static fixed bin(4,0)           initial dcl 21-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 21-75
mpc_card                               based           structure                level 1 dcl 6-5
mpc_card_array                         based           structure                level 1 dcl 6-19
msu0400devt                            internal static fixed bin(4,0)           initial dcl 21-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 21-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 21-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 21-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 21-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 21-81
optp                                   automatic       pointer                  dcl 11-26
prph_dsk_card_array                    based           structure                level 1 dcl 8-21
prph_tap_card_array                    based           structure                level 1 dcl 9-21
pvt$array                              external static fixed bin(17,0)          dcl 17-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 17-19
pvt_array                              based           structure                array level 1 dcl 17-24
pvt_arrayp                             automatic       pointer                  dcl 17-21
pvtdi                                  based           structure                level 1 dcl 11-229
pvtdip                                 automatic       pointer                  dcl 11-187
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 21-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 21-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 21-90
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 22-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 22-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 22-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 22-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 22-26
sector_map                             defined         bit(1)                   array packed unaligned dcl 11-274
sector_mapping                         internal static bit(7)                   initial packed unaligned dcl 11-273
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 21-78
special_status_channel                 internal static fixed bin(6,0)           initial dcl 15-105
status_queue_ptr                       automatic       pointer                  dcl 15-91
sysp                                   automatic       pointer                  dcl 11-26
system_fault_channel                   internal static fixed bin(6,0)           initial dcl 15-105
tables_length                          automatic       fixed bin(19,0)          dcl 12-20
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 21-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 21-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 21-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 22-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 22-36
write_map                              defined         bit(1)                   array packed unaligned dcl 11-269
write_mapping                          internal static bit(7)                   initial packed unaligned dcl 11-268

NAMES DECLARED BY EXPLICIT CONTEXT.
get_io_segs                     000157 constant        entry                    external dcl 10
install_segment                 001606 constant        entry                    internal dcl 328 ref 239 247 262 286 308 322

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2122        2170    1737        2132
Length      3032    1737        46         626     162           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_io_segs                         240 external procedure  is an external procedure.  
begin block on line 271                 begin block         shares stack frame of external procedure get_io_segs.  
install_segment                         internal procedure  shares stack frame of external procedure get_io_segs.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_io_segs              000100 disk_subsystems             get_io_segs
                         000101 dev_idx                     get_io_segs
                         000102 physical_volumes            get_io_segs
                         000103 disk_channel_count          get_io_segs
                         000104 disk_drives                 get_io_segs
                         000106 fptr                        get_io_segs
                         000110 free_q_size                 get_io_segs
                         000111 imus                        get_io_segs
                         000112 controllers                 get_io_segs
                         000113 seg_size                    get_io_segs
                         000114 subsystem_type              get_io_segs
                         000116 tsdw                        get_io_segs
                         000120 i                           get_io_segs
                         000122 chnl_cardp                  get_io_segs
                         000124 iom_cardp                   get_io_segs
                         000126 ipc_cardp                   get_io_segs
                         000130 mpc_cardp                   get_io_segs
                         000132 prph_cardp                  get_io_segs
                         000134 prph_dsk_cardp              get_io_segs
                         000136 prph_tap_cardp              get_io_segs
                         000140 stok_cardp                  get_io_segs
                         000142 disksp                      get_io_segs
                         000144 io_config_data_ptr          get_io_segs
                         000146 io_config_device_table_ptr  get_io_segs
                         000150 io_config_channel_table_ptr get_io_segs
                         000152 io_config_controller_table_ptr
                                                            get_io_segs
                         000154 io_config_iom_table_ptr     get_io_segs
                         000156 idp                         get_io_segs
                         000160 ioi_subsystems              get_io_segs
                         000161 ioi_devices                 get_io_segs
                         000162 ioi_channels                get_io_segs
                         000163 ioi_multiplexers            get_io_segs
                         000164 n_devices                   get_io_segs
                         000166 iom_data_ptr                get_io_segs
                         000170 pvtp                        get_io_segs
                         000172 stock_segp                  get_io_segs
                         000174 n_in_record_stock           get_io_segs
                         000175 n_volmap_pages              get_io_segs
                         000176 n_in_vtoce_stock            get_io_segs
                         000200 seek_command                get_io_segs
                         000203 device_table_length         begin block on line 271
                         000204 channel_table_length        begin block on line 271
                         000205 controller_table_length     begin block on line 271
                         000206 iom_table_length            begin block on line 271
                         000207 io_config_tables_length     begin block on line 271

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
config_$find                  config_$find_2                config_$find_parm             get_main
get_ring_                     ioa_                          pmut$swap_sdw                 syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
disk_seg$                     io_config_data$               ioi_data$                     iom_data$
pvt$                          stock_seg$                    sys_info$collection_1_phase




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000156   21   84 000164        83 000253        88 000265        89 000267        90 000277        91 000304
     93 000305        94 000312        96 000324        97 000325        98 000326        99 000333       100 000334
    102 000337       104 000342       105 000344       106 000357       108 000371       109 000376       110 000377
    113 000407       114 000411       115 000412       118 000425       122 000471       123 000513       126 000514
    128 000525       129 000531       130 000533       131 000540       133 000554       134 000556       135 000561
    137 000571       142 000603       143 000605       146 000606       147 000607       149 000610       151 000621
    155 000622       156 000624       158 000635       159 000642       161 000643       162 000654       166 000655
    167 000657       169 000670       170 000674       173 000701       174 000712       178 000713       179 000715
    181 000726       182 000732       183 000733       186 000745       187 000756       191 000757       192 000761
    193 000762       197 000763       198 000765       199 000776       201 001005       203 001015       205 001022
    206 001023       208 001032       210 001042       212 001047       213 001050       217 001052       218 001056
    220 001061       221 001077       222 001103       224 001121       226 001157       229 001213       230 001214
    236 001216       237 001221       239 001231       240 001234       245 001237       246 001242       247 001265
    248 001267       249 001272       250 001274       251 001306       252 001314       256 001316       257 001321
    262 001343       263 001345       267 001350       268 001353       276 001357       278 001370       280 001401
    282 001412       283 001423       285 001430       286 001437       288 001445       289 001450       290 001455
    291 001461       292 001464       294 001470       295 001475       296 001502       297 001507       299 001514
    300 001517       301 001522       302 001525       307 001527       308 001532       310 001556       311 001560
    312 001563       313 001565       317 001567       318 001572       320 001576       322 001601       324 001603
    326 001605       328 001606       338 001610       341 001622       342 001636       344 001652


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
