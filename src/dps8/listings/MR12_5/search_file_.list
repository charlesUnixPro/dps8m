	COMPILATION LISTING OF SEGMENT search_file_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-06-29_1715.63_Thu_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: off */
       13 
       14 /* search_file_ ... qedx utility procedure to search addressed portion of buffer with specified regular expression */
       15 
       16 /*	This procedure parses a regular expression and stores an executable version of same in its internal storage.
       17*   A regular expression can contain up to 132 characters and up to 20 subexpressions as defined below.
       18*   Certain special cases are recognized and optimized. The follow subexpressions are currently supported:
       19*
       20*   Type	Meaning
       21*
       22*   0	The first string search of the regular expression.
       23*   1	The first string search of the regular expression has an initial newline. Anchor search to the
       24*	beginning of a line.
       25*   2	A string search following a dot-star subexpression.
       26*   3	A string search following a star or dot subexpression.
       27*   4	A star subexpression.
       28*   5	A dot subexpression. */
       29 
       30 /*	The following non-standard error codes are returned by search_file_:
       31*   1	Search failed.
       32*   2	Invalid syntax in a regular expression. (A message is always printed.)
       33**/
       34 
       35 /* Initial coding by R. C. Daley,  August 1970 */
       36 /* Recoded in V2 PL/I by D. S. Levin, August 1974 */
       37 /* Modified for gapped buffer first line detection by T. Oke 80-07-14. */
       38 /* Changes merged and edited 03/03/82 S. Herbst */
       39 /* Fixed argument reference bug 11/03/82 S. Herbst */
       40 /* Added $silent 11/12/82 S. Herbst */
       41 /* Modified: January 1983 by G. Palter to make reentrant and always return standard codes for $silent entrypoint */
       42 
       43 /* format: on,style4,delnl,insnl,ifthenstmt,ifthen */
       44 
       45 /* Previous compatability entry point for mail system use */
       46 
       47 search_file_:
       48      proc (atp, ati, atl, afp, afi, afe, ami, ame, acode);
       49 
       50 dcl  atp ptr,					/* Pointer to string containing regular expression. */
       51      ati fixed bin (21),				/* Index of first character of regular expression. */
       52      atl fixed bin (21),				/* Length of regular expression. */
       53      afp ptr,					/* Pointer to buffer file to be searched. */
       54      afi fixed bin (21),				/* Index of first character to be searched. */
       55      afe fixed bin (21),				/* Index of last character to be searched. */
       56      ami fixed bin (21),				/* Index of first character of string matched (Output). */
       57      ame fixed bin (21),				/* Index of last character of string matched (Output). */
       58      alb fixed bin (21),				/* start of lower buffer */
       59      aft fixed bin (21),				/* start of upper buffer */
       60      acode fixed bin (35),				/* Error status code (Output) */
       61      P_qid_ptr pointer parameter;			/* -> qedx internal data */
       62 
       63 dcl  (tp, fp) ptr,					/* Automatic storage. */
       64      silent_sw bit (1),				/* ON for search_file_$silent */
       65      (lb, ft, ti, tl, te, fi, fe, j) fixed bin (21),
       66      match_start (20) fixed bin (21),			/* Index of first character of match. */
       67      reentry_point (20) fixed bin (21),			/* Restart or reentry stack. Reenter if element ^= 0. */
       68      (i, l, type, st, last_string, last_star) fixed bin;
       69 
       70 dcl  1 rd aligned based (rd_ptr),			/* completely describes a regular expression */
       71        2 reg_info (20),
       72          3 search_char char (1) unal,
       73          3 len fixed bin (8) unaligned,
       74          3 start fixed bin (8) unaligned,
       75          3 search_type fixed bin (8) unaligned,
       76        2 regl fixed binary (21),			/* length of the regular expression */
       77        2 omit_newline bit (1) aligned,			/* differentiates between $ and \cNL */
       78        2 reg character (132);				/* string accumulator */
       79 dcl  rd_ptr pointer;
       80 
       81 dcl  1 external_rd static aligned like rd;		/* for use by non-qedx entrypoints */
       82 dcl  first_call bit (1) aligned static initial ("1"b);	/* ... so non-qedx entrypoints can initialize above */
       83 
       84 dcl						/* Constants. */
       85      special_char char (5) aligned internal static initial (".*\$"),
       86 						/* 5th character is \c. */
       87      nl char (1) aligned internal static initial ("
       88 ");
       89 
       90 dcl  exp char (te) based aligned;
       91 dcl  text char (fe) based aligned;
       92 
       93 dcl  error_table_$nomatch fixed binary (35) external;
       94 dcl  error_table_$regexp_invalid_star fixed bin (35) ext;
       95 dcl  error_table_$regexp_too_complex fixed bin (35) ext;
       96 dcl  error_table_$regexp_too_long fixed bin (35) ext;
       97 dcl  error_table_$regexp_undefined fixed bin (35) ext;
       98 
       99 dcl  ioa_ entry options (variable);
      100 
      101 dcl  (hbound, index, length, search, substr, unspec, verify) builtin;
      102 
      103 	silent_sw = "0"b;				/* normal entry point prints error messages */
      104 	go to RETAINED_COMMON;
      105 
      106 silent:
      107      entry (atp, ati, atl, afp, afi, afe, ami, ame, acode);
      108 
      109 	silent_sw = "1"b;
      110 
      111 RETAINED_COMMON:
      112 	lb = afe;					/* presets lb and ft for single buffer */
      113 	ft = lb + 1;				/* first section full, second section empty */
      114 
      115 	rd_ptr = addr (external_rd);			/* use non-qedx saved expression (if any) */
      116 	if first_call then do;			/* ... need to initialize the expression */
      117 	     first_call = "0"b;
      118 	     rd.regl = 0;				/* ... no initial saved expression */
      119 	end;
      120 	go to COMMON;
      121 
      122 
      123 /* qedx only */
      124 
      125 qx_search_file_:
      126      entry (P_qid_ptr, atp, ati, atl, afp, afi, afe, ami, ame, alb, aft, acode);
      127 
      128 
      129 	silent_sw = "0"b;				/* qedx relies on this entrypoint to print error messages */
      130 	lb = alb;
      131 	ft = aft;
      132 
      133 	qid_ptr = P_qid_ptr;			/* get saved regular expression (if any) */
      134 	rd_ptr = qid.regexp_data_ptr;
      135 
      136 COMMON:
      137 	tp = atp;					/* Pointer to string containing regular expression. */
      138 	ti = ati;					/* Index of first character of regular expression. */
      139 	tl = atl;					/* Length of regular expression. */
      140 	fp = afp;					/* Pointer to buffer area to be searched. */
      141 	fi = afi;					/* Index of first character of area to be searched. */
      142 	fe = afe;					/* Index of last character of area to be searched. */
      143 
      144 	if tl = 0					/* Check for null regular expression "//". */
      145 	then if rd.regl > 0				/* "//" given, use previous regular expression if any. */
      146 	     then go to match;
      147 	     else do;
      148 		if silent_sw then
      149 		     acode = error_table_$regexp_undefined;
      150 		else call ioa_ ("// undefined in regular expression.");
      151 						/* Error, // and no previous regular expression. */
      152 fatal:
      153 		rd.regl = 0;			/* No previous regular expression. */
      154 		if ^silent_sw then acode = 2;		/* Fatal error. Cannot be retried. */
      155 		return;
      156 	     end;
      157 	te = ti + tl - 1;				/* Get index of last character of regular expression. */
      158 	st = 1;					/* Initialize string accumulator length to zero. */
      159 	l = 0;					/* Initialize sub-expression string length to zero. */
      160 	type = 0;					/* Assume simple expression until we know otherwise. */
      161 
      162 	if substr (tp -> exp, ti, 1) = "^"		/* Anchor to the beginning of line? */
      163 	then do;					/* Yes, make first character a newline. */
      164 	     type = 1;				/* String must begin at newline. */
      165 	     ti = ti + 1;				/* Get next character. */
      166 	     substr (rd.reg, 1, 1) = nl;		/* First character is a newline. */
      167 	     st = st + 1;				/* Length does not include newline. */
      168 	end;
      169 
      170 	rd.regl = 0;				/* Initialize to no subexpressions. */
      171 	last_string = 0;				/* Index to immediately previous string search. */
      172 	last_star = 0;				/* Index to immediately previous star subexpression. */
      173 	rd.omit_newline = "0"b;			/* No "$" found. Do not shorten matched string. */
      174 
      175 parse_expression:					/* Parse the regular expression, forming subexpressions. */
      176 	tl = te - ti + 1;				/* Get the length of the remainder of the RE. */
      177 	if tl <= 0 then goto expression_parsed;		/* No more regular expr. Go execute what we have. */
      178 	i = search (substr (tp -> exp, ti, tl), special_char) - 1;
      179 						/* Find first special character. */
      180 	if i < 0 then i = tl;			/* None found. Get number of remaining characters. */
      181 	if i > 0					/* If count is nonzero, add those characters to string. */
      182 	then do;
      183 	     if st + l + i > length (rd.reg) then go to long_string;
      184 						/* Can't store all those characters. */
      185 	     substr (rd.reg, st + l, i) = substr (tp -> exp, ti, i);
      186 						/* Add the characters to the string. */
      187 	     l = l + i;				/* Bump the string length. */
      188 	     ti = ti + i;				/* Skip those characters in the regular expression. */
      189 	     if ti > te then go to expression_parsed;	/* If no special characters then done parsing. */
      190 	end;
      191 
      192 	go to special_case (index (special_char, substr (tp -> exp, ti, 1)));
      193 						/* Go to appropriate routine. */
      194 
      195 special_case (1):					/* Period or dot. */
      196 	call end_sub_expression;			/* Previous string search must be terminated. */
      197 	i = 0;					/* Initialize to only one occurance of dot. */
      198 	tl = te - ti + 1;				/* Get the length of the remainder of the RE. */
      199 	if tl - 1 > 0 then i = verify (substr (tp -> exp, ti + 1, tl - 1), ".");
      200 						/* Count all following dots. */
      201 	if i = 0 then i = tl;			/* This equals the total number of dots. */
      202 	ti = ti + i;				/* Skip over all the dots. */
      203 	if ti <= te then
      204 	     if substr (tp -> exp, ti, 1) = "*"		/* Last dot is part of ".*". */
      205 	     then do;
      206 		type = 2;				/* Indicates next string search is preceeded by ".*". */
      207 		ti = ti + 1;			/* Skip over "*". */
      208 		i = i - 1;			/* Reduce dot count by one. */
      209 	     end;
      210 	if i > 0 then call builder (5, i);		/* Dot subexpression. Dot-star stored by end_sub_expression */
      211 	if type ^= 2 then type = 3;			/* No dot-star, just a normal string search. */
      212 	go to parse_expression;			/* Continue. */
      213 
      214 special_case (2):					/* Asterisk or star. */
      215 	if l = 0					/* No character precedes the star. */
      216 	then do;
      217 	     if silent_sw then
      218 		acode = error_table_$regexp_invalid_star;
      219 	     else call ioa_ ("Invalid use of * in regular expression.");
      220 	     go to fatal;
      221 	end;
      222 	l = l - 1;				/* The character must be removed from previous string. */
      223 	ti = ti + 1;				/* Skip the star. */
      224 	call end_sub_expression;			/* Build search subexpression for previous string. */
      225 	if type = 2 then go to parse_expression;	/* Do not build if star preceded by dot-star. */
      226 	if rd.regl > 0 & rd.regl = last_star		/* Do not build if previous subexpression is identical. */
      227 	then if rd.reg_info (last_star).search_char = substr (rd.reg, st, 1) then go to parse_expression;
      228 	call builder (4, 0);			/* A star subexpression. */
      229 	last_star = rd.regl;			/* This is now the most recent star subexpression. */
      230 	rd.reg_info (last_star).search_char = substr (rd.reg, st, 1);
      231 						/* Store character for star subexpression. */
      232 	type = 3;					/* No dot-star, just a normal string search. */
      233 	go to parse_expression;			/* Continue the parse. */
      234 
      235 special_case (3):					/* Backslash. Could be part of \c or \C. */
      236 	if ti = te then go to store_char;		/* Obviously no character follows it. */
      237 	if substr (tp -> exp, ti + 1, 1) ^= "c" & substr (tp -> exp, ti + 1, 1) ^= "C" then go to store_char;
      238 	ti = ti + 1;				/* Found "\c" or "\C". Skip the backslash. */
      239 
      240 special_case (5):					/* Backslash-c as single character. */
      241 	ti = ti + 1;				/* Skip the "\c", or skip "c" from above. */
      242 
      243 store_char:					/* Add a single character to the string being created. */
      244 	if st + l = length (rd.reg)			/* Check for string overflow. */
      245 	then do;
      246 
      247 long_string:					/* Expression has too many characters. */
      248 	     if silent_sw then
      249 		acode = error_table_$regexp_too_long;
      250 	     else call ioa_ ("Regular expression is too long.");
      251 	     go to fatal;
      252 	end;
      253 	substr (rd.reg, st + l, 1) = substr (tp -> exp, ti, 1);
      254 						/* Add the character. */
      255 	ti = ti + 1;				/* Continue scan with next character. */
      256 	l = l + 1;				/* Bump string length. */
      257 	go to parse_expression;			/* Continue parse. */
      258 
      259 special_case (4):					/* Dollar sign or end of line anchor. */
      260 	if ti ^= te then go to store_char;		/* Special meaning only at end of expression. */
      261 	rd.omit_newline = "1"b;			/* Found a "$". Omit newline at end of string. */
      262 	if st + l = length (rd.reg) then go to long_string;
      263 						/* No room. */
      264 	substr (rd.reg, st + l, 1) = nl;		/* Store a newline to provide the anchor. */
      265 	l = l + 1;				/* Adjust string length. */
      266 	ti = ti + 1;				/* Now we are done. */
      267 
      268 /* End of parsing loop. */
      269 
      270 expression_parsed:
      271 	call end_sub_expression;			/* Create final search subexpression, if any. */
      272 	if type = 2 then call builder (2, 0);		/* Dot-star is last subexpression of RE. */
      273 
      274 match:
      275 	if fe = 0 | fi > fe then go to fail;		/* Search fails on empty buffer. */
      276 	do i = 1 to rd.regl;			/* Reset the reentry stack to no reentry points. */
      277 	     reentry_point (i) = 0;
      278 	end;
      279 
      280 restart_search:					/* Match the entire regular expression. */
      281 	match_start (1) = fi;			/* Assume expression is anchored. */
      282 	i = 1;					/* Initialize to first subexpression. */
      283 	st = 1;					/* Start at the beginning of the string accumulator. */
      284 	te = fi - 1;				/* Initialize to zero length string. */
      285 
      286 search_loop:
      287 	tl = fe - fi + 1;				/* Get length of remainder of the text buffer. */
      288 	l = rd.reg_info (i).len;			/* Get length field. */
      289 	go to string_search (rd.reg_info (i).search_type);/* Execute the subexpression. */
      290 
      291 string_search (0):					/* Initial search without initial newline. */
      292 	if l > tl then go to fail;			/* Not enough characters to satisfy the match. */
      293 	j = index (substr (fp -> text, fi, tl), substr (rd.reg, 1, l)) - 1;
      294 						/* Find occurance of the string. */
      295 	if j < 0 then go to fail;			/* Not there. Search fails. */
      296 	st = st + l;				/* Skip over string in accumulator. */
      297 	go to found_first_match;			/* Go save all information about first match. */
      298 
      299 string_search (1):					/* Initial search with initial newline. */
      300 	if fi > 1 & (lb > 0 | fi ^= ft) then do;	/* not first line of buffer */
      301 	     if (lb > 0 & fi = ft) then do;		/* pointers will be valid for check */
      302 		if substr (fp -> text, lb, 1) = nl then goto nl_found;
      303 						/* nl end of first section */
      304 	     end;
      305 	     else if substr (fp -> text, fi - 1, 1) = nl then goto nl_found;
      306 						/* nl is previous char */
      307 	     j = index (substr (fp -> text, fi, tl), nl); /* Search for newline. */
      308 	     if j = 0 then go to fail;		/* No more lines. Search fails. */
      309 	     fi = fi + j;				/* Go to first character after newline. */
      310 	     tl = tl - j;				/* Reduce the buffer length. */
      311 	     if tl <= 0 then go to fail;		/* That newline was the last character in buffer. */
      312 	end;
      313 nl_found:
      314 	st = st + l + 1;				/* Point to next string. Skip this string and newline. */
      315 	j = 0;					/* Offset if string matches the current line. */
      316 	if l = 0 then go to found_first_match;		/* Just had to find the beginning of a line. */
      317 	if l > tl then go to fail;			/* Not enough characters to satisfy the match. */
      318 	if substr (fp -> text, fi, l) ^= substr (rd.reg, 2, l)
      319 						/* Check this line but omit newline. */
      320 	then do;					/* Not in current line. Search remainder of buffer. */
      321 	     j = index (substr (fp -> text, fi, tl), substr (rd.reg, 1, l + 1));
      322 						/* Include the newline in the search. */
      323 	     if j = 0 then go to fail;		/* Not found in buffer. Search fails. */
      324 	end;
      325 
      326 found_first_match:
      327 	match_start (1) = fi + j;			/* This is first search. The match starts here. */
      328 	go to found_field;				/* Get next subexpression. */
      329 
      330 string_search (2):					/* Dot-star string search. Match as few characters as possible. */
      331 	if l = 0					/* If length is zero, then RE ends with ".*". */
      332 	then do;					/* Treat like ".*$". */
      333 	     te = fi + index (substr (fp -> text, fi, tl), nl) - 2;
      334 						/* Find end of the current line, without newline. */
      335 	     if te < fi - 1 then te = fe;		/* No newline, take the rest of the buffer. */
      336 	     go to next_field;			/* Pretend there is something next. */
      337 	end;
      338 	if l > tl then go to fail_reset;		/* Must have enough characters for the match. */
      339 	j = index (substr (fp -> text, fi, tl), substr (rd.reg, st, l)) - 1;
      340 						/* Find a match. */
      341 	if j < 0 then go to fail_reset;		/* None found. Could be someone else's fault. */
      342 	te = 0;					/* If offset is zero, there is no newline. */
      343 	if j > 0 then te = index (substr (fp -> text, fi, j), nl);
      344 						/* Dot does not match a newline. */
      345 	if te > 0					/* At least one intervening newline. */
      346 	then do;					/* Advance one line and try again. */
      347 	     fi = fi + te;				/* Point to next line. */
      348 	     reentry_point (i) = 0;			/* Remove from stack until needed. */
      349 	     go to restart_search;			/* Try to match entire RE. */
      350 	end;
      351 	reentry_point (i) = fi + j + 1;		/* Stack a reentry point if future subexpression fails. */
      352 	st = st + l;				/* Advance string offset pointer. */
      353 	go to found_field;				/* Tell everyone we found something. */
      354 
      355 string_search (3):					/* Search subexpression. Match string at current buffer position. */
      356 	if l > tl then go to fail_retry;		/* Cannot match if not enough characters. */
      357 	j = 0;					/* Offset if the following is a match. */
      358 	if substr (fp -> text, fi, l) ^= substr (rd.reg, st, l) then go to fail_retry;
      359 						/* Do they match? */
      360 	st = st + l;				/* Skip over string in accumulator. */
      361 	go to found_field;				/* Get next subexpression. */
      362 
      363 string_search (4):					/* Star subexpression. Match as many of a particular character as possible. */
      364 	reentry_point (i) = 0;			/* Assume a match on zero length string. */
      365 	if tl <= 0 then go to next_field;		/* Match a zero length string. */
      366 	match_start (i) = fi;			/* Match starts at current buffer position. */
      367 	l = verify (substr (fp -> text, fi, tl), rd.reg_info (i).search_char) - 1;
      368 						/* Count the occurances. */
      369 	if l < 0 then l = tl;			/* Rest of buffer is a match. */
      370 	if l = 0 then go to next_field;		/* Matches a zero length string. */
      371 	reentry_point (i) = fi + l - 1;		/* Restart point matches one fewer characters. */
      372 	j = 0;					/* String offset for the match. */
      373 	go to found_field;
      374 
      375 string_search (5):					/* Dots. */
      376 	if tl < l then go to fail_retry;		/* Must have enough characters. */
      377 	j = 0;					/* Offset. */
      378 	if index (substr (fp -> text, fi, l), nl) ^= 0	/* Dot does not match a newline. */
      379 	then go to fail_retry;			/* Dot does not match a newline. */
      380 
      381 found_field:					/* Code to store a match. */
      382 	fi = fi + j + l;				/* Next search will begin immediately after match. */
      383 	te = fi - 1;				/* Address of last matched character. */
      384 
      385 next_field:					/* Get next subexpression. */
      386 	i = i + 1;				/* Bump subexpression counter. */
      387 	if i <= rd.regl then go to search_loop;		/* Execute next subexpression or match SUCCEEDS! */
      388 	if rd.omit_newline				/* If last char is "$", do not match final newline. */
      389 	then te = te - 1;				/* Match the line without the newline character. */
      390 	ami = match_start (1);			/* Return index of first character matched. */
      391 	ame = te;					/* Return index of last character matched. */
      392 	acode = 0;
      393 	return;
      394 
      395 fail_reset:					/* A reentry point is no longer valid. Reset it. */
      396 	reentry_point (i) = 0;
      397 
      398 fail_retry:					/* A subexpression failed.  Iterate if possible. */
      399 	i = i - 1;				/* Try previous subexpression. */
      400 	if i <= 0 then do;
      401 	     match_start (1) = match_start (1) + 1;	/* Restart one character further in. */
      402 	     if match_start (1) > fe			/* Search fails on empty buffer. */
      403 	     then do;
      404 fail:						/* Regular expression cannot be matched. */
      405 		if silent_sw then
      406 		     acode = error_table_$nomatch;	/* always return standard codes for search_file_$silent */
      407 		else acode = 1;
      408 		return;
      409 	     end;
      410 	     fi = match_start (1);			/* Get new starting offset. */
      411 	     go to restart_search;
      412 	end;
      413 	fi = reentry_point (i);			/* Pick up a potential restart point. */
      414 	if fi = 0 then go to fail_retry;		/* Must be a useful restart point. */
      415 	st = rd.reg_info (i).start;			/* It's OK.  Reset the string accumulator offset. */
      416 	if rd.reg_info (i).search_type = 2 then go to search_loop;
      417 						/* It's ".*". Go find next occurrence of string. */
      418 	if reentry_point (i) < match_start (i) then go to fail_reset;
      419 						/* It's "a*". No restart if no a's matched. */
      420 	reentry_point (i) = reentry_point (i) - 1;	/* Decrement number of a's matched. */
      421 	go to next_field;
      422 
      423 /* Initializes qedx per-invocation regular expression data */
      424 
      425 init:
      426      entry (P_qid_ptr);
      427 
      428 	qid_ptr = P_qid_ptr;
      429 
      430 	allocate rd in (editor_area) set (rd_ptr);
      431 	rd.regl = 0;				/* no saved regular expression yet */
      432 
      433 	qid.regexp_data_ptr = rd_ptr;
      434 
      435 	return;
      436 
      437 
      438 /* Terminates qedx per-invocation regular expression data */
      439 
      440 cleanup:
      441      entry (P_qid_ptr);
      442 
      443 	qid_ptr = P_qid_ptr;
      444 
      445 	if qid.regexp_data_ptr ^= null () then do;
      446 	     free qid.regexp_data_ptr -> rd in (editor_area);
      447 	     qid.regexp_data_ptr = null ();
      448 	end;
      449 
      450 	return;
      451 
      452 /* Creates current search subexpression */
      453 
      454 end_sub_expression:
      455      procedure ();
      456 
      457 dcl  (dot_count, ir) fixed bin;
      458 
      459 	if l > 0 | type = 1				/* If current search string subexpression outstanding. */
      460 	then do;
      461 	     if type = 2				/* A string search preceded by ".*". */
      462 	     then do;
      463 		dot_count = 0;			/* initialize to no dots. */
      464 		do ir = rd.regl to last_string + 1 by -1;
      465 						/* Scan the RE. */
      466 		     if rd.reg_info (ir).search_type = 5/* A dot subexpressionn. */
      467 		     then dot_count = dot_count + rd.reg_info (ir).len;
      468 						/* Add in its count. */
      469 		     else if rd.reg_info (ir).search_type ^= 4
      470 						/* A star subexpression. */
      471 		     then go to done_dot_star;
      472 		     rd.regl = rd.regl - 1;		/* Remove dot or star subexpression from RE. */
      473 		end;
      474 done_dot_star:
      475 		if dot_count > 0 then call builder (5, dot_count);
      476 						/* Build dot subexpression if necessary. */
      477 		last_star = 0;			/* Forget about those star subexpressions. */
      478 	     end;
      479 	     if last_string = rd.regl - 1 & last_star = rd.regl
      480 						/* Optimize ab*b to abb*. Also b*b to bb*. */
      481 	     then do;
      482 		ir = verify (substr (rd.reg, st, l), rd.reg_info (last_star).search_char) - 1;
      483 		if ir < 0 then ir = l;		/* Entire string matches the character. */
      484 		if ir > 0				/* Move the matches to the previous string. */
      485 		then do;
      486 		     if last_string = 0		/* Oops, there was really no previous string. */
      487 		     then do;			/* Guess we'll have to make one. */
      488 			last_string = 1;		/* String search is first subexpression. */
      489 			unspec (rd.reg_info (2)) = unspec (rd.reg_info (1));
      490 						/* Copy star subexpression. */
      491 			last_star = last_star + 1;	/* Remember that. */
      492 			rd.reg_info (2).start = ir + 1;
      493 						/* Set the correct accumulator offset. */
      494 			rd.reg_info (1).search_type = 0;
      495 						/* First subexpression is a string search. */
      496 			rd.regl = 2;		/* Now there are two subexpressions. */
      497 		     end;
      498 		     rd.reg_info (last_string).len = rd.reg_info (last_string).len + ir;
      499 						/* Add to previous string length. */
      500 		     st = st + ir;			/* Bump offset pointer. */
      501 		     l = l - ir;			/* Reduce string length. */
      502 		     if l = 0 then return;		/* String is eliminated. */
      503 		end;
      504 	     end;
      505 	     call builder (type, l);			/* Any type of search string subexpression. */
      506 	     type = 3;				/* Set to 3 in case it was 0, 1, or 2. */
      507 	     last_string = rd.regl;			/* Remember position of last string. */
      508 	     st = st + l;				/* Bump accumulator offset. */
      509 	     l = 0;				/* Initialize string length to zero. */
      510 	end;
      511 
      512 	return;
      513 
      514      end end_sub_expression;
      515 
      516 /* Creates any subexpression */
      517 
      518 builder:
      519      procedure (id, size);
      520 
      521 dcl  (id, size) fixed bin;
      522 
      523 	if rd.regl = hbound (rd.reg_info, 1)		/* Insure we have not exceeded the stack. */
      524 	then do;
      525 	     if silent_sw then
      526 		acode = error_table_$regexp_too_complex;
      527 	     else call ioa_ ("Regular expression is too complex.");
      528 	     go to fatal;
      529 	end;
      530 	rd.regl = rd.regl + 1;			/* Bump stack size. */
      531 	rd.reg_info (rd.regl).search_type = id;		/* Store type of subexpression. */
      532 	rd.reg_info (rd.regl).len = size;		/* Store length of the subexpression. */
      533 	rd.reg_info (rd.regl).start = st;		/* Store accumulator offset. */
      534 
      535 	return;
      536 
      537      end builder;
      538 
  1     1 /* BEGIN INCLUDE FILE ... qedx_internal_data.incl.pl1 */
  1     2 /* Created:  January 1983 by G. Palter */
  1     3 
  1     4 /* Data used by a single invocation of qedx or qedx_ */
  1     5 
  1     6 dcl 1 qid aligned based (qid_ptr),
  1     7       2 editor_name character (72) unaligned,		/* name of the editor (eg: "send_mail (qedx)") */
  1     8       2 editor_area_ptr pointer,			/* -> area used to allocate data */
  1     9       2 qedx_info_ptr pointer,			/* -> caller's definition of this qedx invocation */
  1    10       2 edx_util_data_ptr pointer,			/* -> data used by edx_util_ */
  1    11       2 regexp_data_ptr pointer,			/* -> data used by qx_search_file_ */
  1    12       2 flags,
  1    13         3 no_rw_path bit (1) unaligned,
  1    14         3 query_if_modified bit (1) unaligned,
  1    15         3 pad bit (34) unaligned,
  1    16       2 b0 like b,					/* buffer 0 */
  1    17       2 tw like b;					/* typewriter buffer */
  1    18 
  1    19 dcl  qid_ptr pointer;
  1    20 
  1    21 dcl  editor_area area based (qid.editor_area_ptr);
  1    22 
  1    23 
  1    24 /* Description of an element of the buffer recursion stack */
  1    25 
  1    26 dcl 1 sv based aligned,
  1    27       2 prev pointer,				/* pointer to previous element in stack */
  1    28       2 bp pointer,					/* pointer to control block for this element */
  1    29       2 (ti, te) fixed binary (21);			/* saved copies of buffer read indexes */
  1    30 
  1    31 /* Description of a single qedx buffer:  Buffers are managed in two sections, a top and a bottom.  The gap between the
  1    32*   sections is the end of the current line, and permits easy insertion and deletion of text, without extraineous data
  1    33*   movement.
  1    34*
  1    35*   An empty section is indicated when the pointers are out-of-sequence.  For example for the bottom section if lb
  1    36*   (last_bottom) is < 1 then the bottom is empty.  If ft (first_top) is > (file_end) then the top is empty.
  1    37*
  1    38*   In addition only one temporary file is needed to support operations on the buffers
  1    39*
  1    40*   Line and range pointers:
  1    41*   li	- Start index of current line.
  1    42*   le	- End index of current line. Points to NL.
  1    43*
  1    44*   lli	- Start index of last line of range.
  1    45*   lle	- End index of last line of range. Points to NL.
  1    46*
  1    47*   fli	- Start index of first line of range.
  1    48*   fle	- End index of first line of range.
  1    49*
  1    50*   Gapped buffer standards:
  1    51*   1	- Start index of buffer.
  1    52*   ilb	- End index of first part of buffer.  Should point to NL.
  1    53*   ift	- Start index of second part of buffer.
  1    54*   ife	- End index of buffer.  Should be one of: 1024*4*4,  1024*4*16, 1024*4*64, or 1024*4*255;
  1    55*
  1    56*   Gapped standards permit the range to split across the gap, but a line of text cannot split across the gap.  Therefore
  1    57*   when the gap is moved one should also move li and le if they are in the moved section of buffer.
  1    58*
  1    59*   The gap, when processing insert, delete, change, substitute, is either immediately before, or immediately after the
  1    60*   range specified.  This is dependant upon the type of operation.  I/O such as writing and printing of buffer contents,
  1    61*   or searching and line indexing is done without moving the gap, and is done in sections as appropriate for the current
  1    62*   operational positioning and the current gap position */
  1    63 
  1    64 dcl 1 b based (bp) aligned,
  1    65       2 name character (16),				/* buffer name */
  1    66       2 next pointer,				/* pointer to next buffer control block (if any) */
  1    67       2 dp pointer,					/* pointer to beginning of buffer data */
  1    68       2 default_path character (256),			/* default output pathname for this buffer */
  1    69       2 lb fixed binary (21),				/* index of last character of bottom section */
  1    70       2 ft fixed binary (21),				/* index of first character of top section */
  1    71       2 de fixed binary (21),				/* index of last character in buffer */
  1    72       2 li fixed binary (21),				/* index of first character of current line */
  1    73       2 le fixed binary (21),				/* index of last character of current line */
  1    74       2 ti fixed binary (21),				/* index of next char. to be read from buffer */
  1    75       2 te fixed binary (21),				/* index of last char. of line being read from buffer */
  1    76       2 tw_sw bit (1),				/* typewriter buffer switch (OFF for normal buffers) */
  1    77       2 callers_idx fixed binary,			/* index in caller's qedx_info.buffers of this buffer */
  1    78       2 flags,
  1    79         3 modified bit (1) unaligned,			/* buffer has been modified since last write */
  1    80         3 default_was_region bit (1) unaligned,		/* default pathname was originally caller's region */
  1    81         3 default_is_region bit (1) unaligned,		/* default pathname is currently caller's region */
  1    82         3 default_locked bit (1) unaligned,		/* default pathname can not be changed by r/w requests */
  1    83         3 default_untrusted bit (1) unaligned,		/* buffer pathname is not trustworthy */
  1    84         3 pad bit (31) unaligned;
  1    85 
  1    86 dcl  bp pointer;
  1    87 
  1    88 /* END INCLUDE FILE ... qedx_internal_data.incl.pl1 */
      539 
      540 
      541      end search_file_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/29/00  1715.6  search_file_.pl1                  >udd>sm>ds>w>ml>search_file_.pl1
539          1    05/04/83  1217.9  qedx_internal_data.incl.pl1       >ldd>incl>qedx_internal_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_qid_ptr                              parameter       pointer                  dcl 50 ref 125 133 425 428 440 443
acode                                  parameter       fixed bin(35,0)          dcl 50 set ref 47 106 125 148* 154* 217* 247* 392*
                                                                                  404* 407* 525*
afe                                    parameter       fixed bin(21,0)          dcl 50 ref 47 106 111 125 142
afi                                    parameter       fixed bin(21,0)          dcl 50 ref 47 106 125 141
afp                                    parameter       pointer                  dcl 50 ref 47 106 125 140
aft                                    parameter       fixed bin(21,0)          dcl 50 ref 125 131
alb                                    parameter       fixed bin(21,0)          dcl 50 ref 125 130
ame                                    parameter       fixed bin(21,0)          dcl 50 set ref 47 106 125 391*
ami                                    parameter       fixed bin(21,0)          dcl 50 set ref 47 106 125 390*
ati                                    parameter       fixed bin(21,0)          dcl 50 ref 47 106 125 138
atl                                    parameter       fixed bin(21,0)          dcl 50 ref 47 106 125 139
atp                                    parameter       pointer                  dcl 50 ref 47 106 125 136
b                                      based           structure                level 1 dcl 1-64
dot_count                       000232 automatic       fixed bin(17,0)          dcl 457 set ref 463* 466* 466 474 474*
editor_area                            based           area(1024)               dcl 1-21 ref 430 446
editor_area_ptr          22            based           pointer                  level 2 dcl 1-6 ref 430 446
error_table_$nomatch            000100 external static fixed bin(35,0)          dcl 93 ref 404
error_table_$regexp_invalid_star
                                000102 external static fixed bin(35,0)          dcl 94 ref 217
error_table_$regexp_too_complex 000104 external static fixed bin(35,0)          dcl 95 ref 525
error_table_$regexp_too_long    000106 external static fixed bin(35,0)          dcl 96 ref 247
error_table_$regexp_undefined   000110 external static fixed bin(35,0)          dcl 97 ref 148
exp                                    based           char                     dcl 90 ref 162 178 185 192 199 203 237 237 253
external_rd                     000010 internal static structure                level 1 dcl 81 set ref 115
fe                              000113 automatic       fixed bin(21,0)          dcl 63 set ref 142* 274 274 286 293 302 305 307 318
                                                                                  321 333 335 339 343 358 367 378 402
fi                              000112 automatic       fixed bin(21,0)          dcl 63 set ref 141* 274 280 284 286 293 299 299 301
                                                                                  305 307 309* 309 318 321 326 333 333 335 339 343
                                                                                  347* 347 351 358 366 367 371 378 381* 381 383 410*
                                                                                  413* 414
first_call                      000077 internal static bit(1)                   initial dcl 82 set ref 116 117*
fp                              000102 automatic       pointer                  dcl 63 set ref 140* 293 302 305 307 318 321 333 339
                                                                                  343 358 367 378
ft                              000106 automatic       fixed bin(21,0)          dcl 63 set ref 113* 131* 299 301
hbound                                                 builtin function         dcl 101 ref 523
i                               000165 automatic       fixed bin(17,0)          dcl 63 set ref 178* 180 180* 181 183 185 185 187 188
                                                                                  197* 199* 201 201* 202 208* 208 210 210* 276* 277*
                                                                                  282* 288 289 348 351 363 366 367 371 385* 385 387
                                                                                  395 398* 398 400 413 415 416 418 418 420 420
id                                     parameter       fixed bin(17,0)          dcl 521 ref 518 531
index                                                  builtin function         dcl 101 ref 192 293 307 321 333 339 343 378
ioa_                            000112 constant        entry                    external dcl 99 ref 150 219 250 527
ir                              000233 automatic       fixed bin(17,0)          dcl 457 set ref 464* 466 466 469* 482* 483 483* 484
                                                                                  492 498 500 501
j                               000114 automatic       fixed bin(21,0)          dcl 63 set ref 293* 295 307* 308 309 310 315* 321*
                                                                                  323 326 339* 341 343 343 351 357* 372* 377* 381
l                               000166 automatic       fixed bin(17,0)          dcl 63 set ref 159* 183 185 187* 187 214 222* 222
                                                                                  243 253 256* 256 262 264 265* 265 288* 291 293 296
                                                                                  313 316 317 318 318 321 330 338 339 352 355 358
                                                                                  358 360 367* 369 369* 370 371 375 378 381 459 482
                                                                                  483 501* 501 502 505* 508 509*
last_star                       000172 automatic       fixed bin(17,0)          dcl 63 set ref 172* 226 226 229* 230 477* 479 482
                                                                                  491* 491
last_string                     000171 automatic       fixed bin(17,0)          dcl 63 set ref 171* 464 479 486 488* 498 498 507*
lb                              000105 automatic       fixed bin(21,0)          dcl 63 set ref 111* 113 130* 299 301 302
len                       0(09)        based           fixed bin(8,0)           array level 3 packed packed unaligned dcl 70 set ref
                                                                                  288 466 498* 498 532*
length                                                 builtin function         dcl 101 ref 183 243 262
match_start                     000115 automatic       fixed bin(21,0)          array dcl 63 set ref 280* 326* 366* 390 401* 401 402
                                                                                  410 418
nl                              002156 constant        char(1)                  initial dcl 84 ref 166 264 302 305 307 333 343 378
omit_newline             25            based           bit(1)                   level 2 dcl 70 set ref 173* 261* 388
qid                                    based           structure                level 1 dcl 1-6
qid_ptr                         000176 automatic       pointer                  dcl 1-19 set ref 133* 134 428* 430 433 443* 445 446
                                                                                  446 447
rd                                     based           structure                level 1 dcl 70 set ref 430 446
rd_ptr                          000174 automatic       pointer                  dcl 79 set ref 115* 118 134* 144 152 166 170 173 183
                                                                                  185 226 226 226 226 229 230 230 243 253 261 262
                                                                                  264 276 288 289 293 318 321 339 358 367 387 388
                                                                                  415 416 430* 431 433 464 466 466 469 472 472 479
                                                                                  479 482 482 489 489 492 494 496 498 498 507 523
                                                                                  523 530 530 531 531 532 532 533 533
reentry_point                   000141 automatic       fixed bin(21,0)          array dcl 63 set ref 277* 348* 351* 363* 371* 395*
                                                                                  413 418 420* 420
reg                      26            based           char(132)                level 2 dcl 70 set ref 166* 183 185* 226 230 243
                                                                                  253* 262 264* 293 318 321 339 358 482
reg_info                               based           structure                array level 2 dcl 70 set ref 489* 489 523
regexp_data_ptr          30            based           pointer                  level 2 dcl 1-6 set ref 134 433* 445 446 447*
regl                     24            based           fixed bin(21,0)          level 2 dcl 70 set ref 118* 144 152* 170* 226 226
                                                                                  229 276 387 431* 464 472* 472 479 479 496* 507 523
                                                                                  530* 530 531 532 533
search                                                 builtin function         dcl 101 ref 178
search_char                            based           char(1)                  array level 3 packed packed unaligned dcl 70 set ref
                                                                                  226 230* 367 482
search_type               0(27)        based           fixed bin(8,0)           array level 3 packed packed unaligned dcl 70 set ref
                                                                                  289 416 466 469 494* 531*
silent_sw                       000104 automatic       bit(1)                   packed unaligned dcl 63 set ref 103* 109* 129* 148
                                                                                  154 217 247 404 525
size                                   parameter       fixed bin(17,0)          dcl 521 ref 518 532
special_char                    000014 constant        char(5)                  initial dcl 84 ref 178 192
st                              000170 automatic       fixed bin(17,0)          dcl 63 set ref 158* 167* 167 183 185 226 230 243 253
                                                                                  262 264 283* 296* 296 313* 313 339 352* 352 358
                                                                                  360* 360 415* 482 500* 500 508* 508 533
start                     0(18)        based           fixed bin(8,0)           array level 3 packed packed unaligned dcl 70 set ref
                                                                                  415 492* 533*
substr                                                 builtin function         dcl 101 set ref 162 166* 178 185* 185 192 199 203
                                                                                  226 230 237 237 253* 253 264* 293 293 302 305 307
                                                                                  318 318 321 321 333 339 339 343 358 358 367 378
                                                                                  482
te                              000111 automatic       fixed bin(21,0)          dcl 63 set ref 157* 162 175 178 185 189 192 198 199
                                                                                  203 203 235 237 237 253 259 284* 333* 335 335*
                                                                                  342* 343* 345 347 383* 388* 388 391
text                                   based           char                     dcl 91 ref 293 302 305 307 318 321 333 339 343 358
                                                                                  367 378
ti                              000107 automatic       fixed bin(21,0)          dcl 63 set ref 138* 157 162 165* 165 175 178 185
                                                                                  188* 188 189 192 198 199 202* 202 203 203 207* 207
                                                                                  223* 223 235 237 237 238* 238 240* 240 253 255*
                                                                                  255 259 266* 266
tl                              000110 automatic       fixed bin(21,0)          dcl 63 set ref 139* 144 157 175* 177 178 180 198*
                                                                                  199 199 201 286* 291 293 307 310* 310 311 317 321
                                                                                  333 338 339 355 365 367 369 375
tp                              000100 automatic       pointer                  dcl 63 set ref 136* 162 178 185 192 199 203 237 237
                                                                                  253
type                            000167 automatic       fixed bin(17,0)          dcl 63 set ref 160* 164* 206* 211 211* 225 232* 272
                                                                                  459 461 505* 506*
unspec                                                 builtin function         dcl 101 set ref 489* 489
verify                                                 builtin function         dcl 101 ref 199 367 482

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
bp                                     automatic       pointer                  dcl 1-86
sv                                     based           structure                level 1 dcl 1-26

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000261 constant        label                    dcl 136 ref 120
RETAINED_COMMON                 000171 constant        label                    dcl 111 ref 104
builder                         001650 constant        entry                    internal dcl 518 ref 210 228 272 474 505
cleanup                         001447 constant        entry                    external dcl 440
done_dot_star                   001541 constant        label                    dcl 474 ref 469
end_sub_expression              001472 constant        entry                    internal dcl 454 ref 195 224 270
expression_parsed               000717 constant        label                    dcl 270 ref 177 189
fail                            001360 constant        label                    dcl 404 ref 274 291 295 308 311 317 323
fail_reset                      001346 constant        label                    dcl 395 ref 338 341 418
fail_retry                      001350 constant        label                    dcl 398 ref 355 358 375 378 414
fatal                           000326 constant        label                    dcl 152 ref 220 251 528
found_field                     001321 constant        label                    dcl 381 ref 328 353 361 373
found_first_match               001127 constant        label                    dcl 326 ref 297 316
init                            001422 constant        entry                    external dcl 425
long_string                     000640 constant        label                    dcl 247 ref 183 262
match                           000730 constant        label                    dcl 274 ref 144
next_field                      001327 constant        label                    dcl 385 ref 336 365 370 421
nl_found                        001074 constant        label                    dcl 313 ref 302 305
parse_expression                000364 constant        label                    dcl 175 ref 212 225 226 233 257
qx_search_file_                 000216 constant        entry                    external dcl 125
restart_search                  000750 constant        label                    dcl 280 ref 349 411
search_file_                    000103 constant        entry                    external dcl 47
search_loop                     000760 constant        label                    dcl 286 ref 387 416
silent                          000137 constant        entry                    external dcl 106
special_case                    000000 constant        label                    array(5) dcl 195 ref 192
store_char                      000634 constant        label                    dcl 243 ref 235 237 259
string_search                   000005 constant        label                    array(0:5) dcl 291 ref 289

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 115
null                                                   builtin function         ref 445 447

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2312        2426    2161        2322
Length      2632    2161       114         170     130          70

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
search_file_                        208 external procedure  is an external procedure.  
end_sub_expression                      internal procedure  shares stack frame of external procedure search_file_.  
builder                                 internal procedure  shares stack frame of external procedure search_file_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 external_rd                 search_file_
000077 first_call                  search_file_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
search_file_             000100 tp                          search_file_
                         000102 fp                          search_file_
                         000104 silent_sw                   search_file_
                         000105 lb                          search_file_
                         000106 ft                          search_file_
                         000107 ti                          search_file_
                         000110 tl                          search_file_
                         000111 te                          search_file_
                         000112 fi                          search_file_
                         000113 fe                          search_file_
                         000114 j                           search_file_
                         000115 match_start                 search_file_
                         000141 reentry_point               search_file_
                         000165 i                           search_file_
                         000166 l                           search_file_
                         000167 type                        search_file_
                         000170 st                          search_file_
                         000171 last_string                 search_file_
                         000172 last_star                   search_file_
                         000174 rd_ptr                      search_file_
                         000176 qid_ptr                     search_file_
                         000232 dot_count                   end_sub_expression
                         000233 ir                          end_sub_expression

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   return_mac          ext_entry           set_chars_eis       index_chars_eis
verify_eis          op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$nomatch          error_table_$regexp_invalid_star
error_table_$regexp_too_complex                             error_table_$regexp_too_long  error_table_$regexp_undefined


CONSTANTS
001720  aa     000004000000
001721  aa     000000000000
001722  aa     600000000041
001723  aa     000167000000
001724  aa     600000000041
001725  aa     000166000000

001726  aa     000004000000
001727  aa     000000000000
001730  aa     600000000041
001731  aa     000277000000
001732  aa     600000000041
001733  aa     000232000000

001734  aa     000004000000
001735  aa     000000000000
001736  aa     600000000041
001737  aa     000276000000
001740  aa     600000000041
001741  aa     000255000000

001742  aa     000004000000
001743  aa     000000000000
001744  aa     600000000041
001745  aa     000255000000
001746  aa     600000000041
001747  aa     000276000000

001750  aa     000004000000
001751  aa     000000000000
001752  aa     600000000041
001753  aa     000255000000
001754  aa     600000000041
001755  aa     000165000000

001756  aa  000 000 000 000	    
001757  aa  000 000 000 000	    
001760  aa  000 000 000 000	    
001761  aa  000 000 000 000	    
001762  aa  000 000 000 000	    
001763  aa  000 000 000 000	    
001764  aa  000 777 000 000	   
001765  aa  000 000 000 000	    
001766  aa  000 000 000 000	    
001767  aa  777 000 000 000	   
001770  aa  000 000 777 000	   
001771  aa  000 000 777 000	   
001772  aa  000 000 000 000	    
001773  aa  000 000 000 000	    
001774  aa  000 000 000 000	    
001775  aa  000 000 000 000	    
001776  aa  000 000 000 000	    
001777  aa  000 000 000 000	    
002000  aa  000 000 000 000	    
002001  aa  000 000 000 000	    
002002  aa  000 000 000 000	    
002003  aa  000 000 000 000	    
002004  aa  000 000 000 000	    
002005  aa  777 000 000 000	   
002006  aa  000 000 000 000	    
002007  aa  000 000 000 000	    
002010  aa  000 000 000 000	    
002011  aa  000 000 000 000	    
002012  aa  000 000 000 000	    
002013  aa  000 000 000 000	    
002014  aa  000 000 000 000	    
002015  aa  000 000 000 000	    
002016  aa  000 000 000 000	    
002017  aa  000 000 000 000	    
002020  aa  000 000 000 000	    
002021  aa  000 000 000 000	    
002022  aa  000 000 000 000	    
002023  aa  000 000 000 000	    
002024  aa  000 000 000 000	    
002025  aa  000 000 000 000	    
002026  aa  000 000 000 000	    
002027  aa  000 000 000 000	    
002030  aa  000 000 000 000	    
002031  aa  000 000 000 000	    
002032  aa  000 000 000 000	    
002033  aa  000 000 000 000	    
002034  aa  000 000 000 000	    
002035  aa  000 000 000 000	    
002036  aa  000 000 000 000	    
002037  aa  000 000 000 000	    
002040  aa  000 000 000 000	    
002041  aa  000 000 000 000	    
002042  aa  000 000 000 000	    
002043  aa  000 000 000 000	    
002044  aa  000 000 000 000	    
002045  aa  000 000 000 000	    
002046  aa  000 000 000 000	    
002047  aa  000 000 000 000	    
002050  aa  000 000 000 000	    
002051  aa  000 000 000 000	    
002052  aa  000 000 000 000	    
002053  aa  000 000 000 000	    
002054  aa  000 000 000 000	    
002055  aa  000 000 000 000	    
002056  aa  000 000 000 000	    
002057  aa  000 000 000 000	    
002060  aa  000 000 000 000	    
002061  aa  000 000 000 000	    
002062  aa  000 000 000 000	    
002063  aa  000 000 000 000	    
002064  aa  000 000 000 000	    
002065  aa  000 000 000 000	    
002066  aa  000 000 000 000	    
002067  aa  000 000 000 000	    
002070  aa  000 000 000 000	    
002071  aa  000 000 000 000	    
002072  aa  000 000 000 000	    
002073  aa  000 000 000 000	    
002074  aa  000 000 000 000	    
002075  aa  000 000 000 000	    
002076  aa  000 000 000 000	    
002077  aa  000 000 000 000	    
002100  aa  000 000 000 000	    
002101  aa  000 000 000 000	    
002102  aa  000 000 000 000	    
002103  aa  000 000 000 000	    
002104  aa  000 000 000 000	    
002105  aa  000 000 000 000	    
002106  aa  000 000 000 000	    
002107  aa  000 000 000 000	    
002110  aa  000 000 000 000	    
002111  aa  000 000 000 000	    
002112  aa  000 000 000 000	    
002113  aa  000 000 000 000	    
002114  aa  000 000 000 000	    
002115  aa  000 000 000 000	    
002116  aa  000 000 000 000	    
002117  aa  000 000 000 000	    
002120  aa  000 000 000 000	    
002121  aa  000 000 000 000	    
002122  aa  000 000 000 000	    
002123  aa  000 000 000 000	    
002124  aa  000 000 000 000	    
002125  aa  000 000 000 000	    
002126  aa  000 000 000 000	    
002127  aa  000 000 000 000	    
002130  aa  000 000 000 000	    
002131  aa  000 000 000 000	    
002132  aa  000 000 000 000	    
002133  aa  000 000 000 000	    
002134  aa  000 000 000 000	    
002135  aa  000 000 000 000	    
002136  aa  000 000 000 000	    
002137  aa  000 000 000 000	    
002140  aa  000 000 000 000	    
002141  aa  000 000 000 000	    
002142  aa  000 000 000 000	    
002143  aa  000 000 000 000	    
002144  aa  000 000 000 000	    
002145  aa  000 000 000 000	    
002146  aa  000 000 000 000	    
002147  aa  000 000 000 000	    
002150  aa  000 000 000 000	    
002151  aa  000 000 000 000	    
002152  aa  000 000 000 000	    
002153  aa  000 000 000 000	    
002154  aa  000 000 000 000	    
002155  aa  000 000 000 000	    

002156  aa  012 000 000 000	


000014  aa  056 052 134 044	.*\$
000015  aa  031 000 000 000	

000016  aa     524000000042

000017  aa     404000000021

000020  aa     524000000037

000021  aa     524000000047

002157  aa  052 000 000 000	*

002160  aa  136 000 000 000	^

000022  aa     524000000043

000023  aa     404000000043

000024  aa     404000000025

000025  aa     464000000000

000026  aa     077777000043
000027  aa     000001000000

000030  aa  122 145 147 165	Regu
000031  aa  154 141 162 040	lar 
000032  aa  145 170 160 162	expr
000033  aa  145 163 163 151	essi
000034  aa  157 156 040 151	on i
000035  aa  163 040 164 157	s to
000036  aa  157 040 154 157	o lo
000037  aa  156 147 056 000	ng.

000040  aa  122 145 147 165	Regu
000041  aa  154 141 162 040	lar 
000042  aa  145 170 160 162	expr
000043  aa  145 163 163 151	essi
000044  aa  157 156 040 151	on i
000045  aa  163 040 164 157	s to
000046  aa  157 040 143 157	o co
000047  aa  155 160 154 145	mple
000050  aa  170 056 000 000	x.

000051  aa  057 057 040 165	// u
000052  aa  156 144 145 146	ndef
000053  aa  151 156 145 144	ined
000054  aa  040 151 156 040	 in 
000055  aa  162 145 147 165	regu
000056  aa  154 141 162 040	lar 
000057  aa  145 170 160 162	expr
000060  aa  145 163 163 151	essi
000061  aa  157 156 056 000	on.

000062  aa  111 156 166 141	Inva
000063  aa  154 151 144 040	lid 
000064  aa  165 163 145 040	use 
000065  aa  157 146 040 052	of *
000066  aa  040 151 156 040	 in 
000067  aa  162 145 147 165	regu
000070  aa  154 141 162 040	lar 
000071  aa  145 170 160 162	expr
000072  aa  145 163 163 151	essi
000073  aa  157 156 056 000	on.

LABEL ARRAYS
000000  aa   000444 7100 04	tra  	292,ic		000444
000001  aa   000526 7100 04	tra  	342,ic		000527
000002  aa   000615 7100 04	tra  	397,ic		000617
000003  aa   000673 7100 04	tra  	443,ic		000676
000004  aa   000627 7100 04	tra  	407,ic		000633

000005  aa   000771 7100 04	tra  	505,ic		000776
000006  aa   001013 7100 04	tra  	523,ic		001021
000007  aa   001124 7100 04	tra  	596,ic		001133
000010  aa   001224 7100 04	tra  	660,ic		001234
000011  aa   001240 7100 04	tra  	672,ic		001251
000012  aa   001267 7100 04	tra  	695,ic		001301

BEGIN PROCEDURE search_file_
ENTRY TO search_file_                                       STATEMENT 1 ON LINE 47
search_file_:
     proc (atp, ati, atl, afp, afi, afe, ami, ame, acode);

000074  at     000011000025
000075  tt     000024000024
000076  tt     000025000024
000077  tt     000024000024
000100  tt     000024000023
000101  ta     000074000000
000102  da     000076300000
000103  aa   000320 6270 00	eax7 	208
000104  aa  7 00034 3521 20	epp2 	pr7|28,*
000105  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000106  aa     000022000000
000107  aa     000000000000
000110  aa  6 00032 3735 20	epp7 	pr6|26,*
000111  aa  7 00002 3715 20	epp5 	pr7|2,*
000112  aa  6 00200 6515 00	spri5	pr6|128
000113  aa  7 00004 3535 20	epp3 	pr7|4,*
000114  aa  6 00202 2535 00	spri3	pr6|130
000115  aa  7 00006 3515 20	epp1 	pr7|6,*
000116  aa  6 00204 2515 00	spri1	pr6|132
000117  aa  7 00010 3715 20	epp5 	pr7|8,*
000120  aa  6 00206 6515 00	spri5	pr6|134
000121  aa  7 00012 3535 20	epp3 	pr7|10,*
000122  aa  6 00210 2535 00	spri3	pr6|136
000123  aa  7 00014 3515 20	epp1 	pr7|12,*
000124  aa  6 00212 2515 00	spri1	pr6|138
000125  aa  7 00016 3715 20	epp5 	pr7|14,*
000126  aa  6 00214 6515 00	spri5	pr6|140
000127  aa  7 00020 3535 20	epp3 	pr7|16,*
000130  aa  6 00216 2535 00	spri3	pr6|142
000131  aa  7 00022 3515 20	epp1 	pr7|18,*
000132  aa  6 00220 2515 00	spri1	pr6|144
						STATEMENT 1 ON LINE 103
	silent_sw = "0"b;

000133  aa  6 00104 4501 00	stz  	pr6|68		silent_sw
						STATEMENT 1 ON LINE 104
	go to RETAINED_COMMON;

000134  aa   000035 7100 04	tra  	29,ic		000171
ENTRY TO silent                                             STATEMENT 1 ON LINE 106
silent:
     entry (atp, ati, atl, afp, afi, afe, ami, ame, acode);

000135  ta     000074000000
000136  da     000103300000
000137  aa   000320 6270 00	eax7 	208
000140  aa  7 00034 3521 20	epp2 	pr7|28,*
000141  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000142  aa     000022000000
000143  aa     000000000000
000144  aa  6 00032 3735 20	epp7 	pr6|26,*
000145  aa  7 00002 3715 20	epp5 	pr7|2,*
000146  aa  6 00200 6515 00	spri5	pr6|128
000147  aa  7 00004 3535 20	epp3 	pr7|4,*
000150  aa  6 00202 2535 00	spri3	pr6|130
000151  aa  7 00006 3515 20	epp1 	pr7|6,*
000152  aa  6 00204 2515 00	spri1	pr6|132
000153  aa  7 00010 3715 20	epp5 	pr7|8,*
000154  aa  6 00206 6515 00	spri5	pr6|134
000155  aa  7 00012 3535 20	epp3 	pr7|10,*
000156  aa  6 00210 2535 00	spri3	pr6|136
000157  aa  7 00014 3515 20	epp1 	pr7|12,*
000160  aa  6 00212 2515 00	spri1	pr6|138
000161  aa  7 00016 3715 20	epp5 	pr7|14,*
000162  aa  6 00214 6515 00	spri5	pr6|140
000163  aa  7 00020 3535 20	epp3 	pr7|16,*
000164  aa  6 00216 2535 00	spri3	pr6|142
000165  aa  7 00022 3515 20	epp1 	pr7|18,*
000166  aa  6 00220 2515 00	spri1	pr6|144
						STATEMENT 1 ON LINE 109
	silent_sw = "1"b;

000167  aa   400000 2350 03	lda  	131072,du
000170  aa  6 00104 7551 00	sta  	pr6|68		silent_sw
						STATEMENT 1 ON LINE 111
RETAINED_COMMON:
	lb = afe;

000171  aa  6 00212 2361 20	ldq  	pr6|138,*		afe
000172  aa  6 00105 7561 00	stq  	pr6|69		lb
						STATEMENT 1 ON LINE 113
	ft = lb + 1;

000173  aa   000001 0760 07	adq  	1,dl
000174  aa  6 00106 7561 00	stq  	pr6|70		ft
						STATEMENT 1 ON LINE 115
	rd_ptr = addr (external_rd);

000175  aa  6 00044 3701 20	epp4 	pr6|36,*
000176  ia  4 00010 3735 00	epp7 	pr4|8		external_rd
000177  aa  6 00174 6535 00	spri7	pr6|124		rd_ptr
						STATEMENT 1 ON LINE 116
	if first_call then do;

000200  ia  4 00077 2351 00	lda  	pr4|63		first_call
000201  aa   000060 6000 04	tze  	48,ic		000261
						STATEMENT 1 ON LINE 117
	     first_call = "0"b;

000202  ia  4 00077 4501 00	stz  	pr4|63		first_call
						STATEMENT 1 ON LINE 118
	     rd.regl = 0;

000203  aa  7 00024 4501 00	stz  	pr7|20		rd.regl
						STATEMENT 1 ON LINE 119
	end;

						STATEMENT 1 ON LINE 120
	go to COMMON;

000204  aa   000055 7100 04	tra  	45,ic		000261
ENTRY TO qx_search_file_                                    STATEMENT 1 ON LINE 125
qx_search_file_:
     entry (P_qid_ptr, atp, ati, atl, afp, afi, afe, ami, ame, alb, aft, acode);

000205  at     000014000025
000206  tt     000025000024
000207  tt     000024000025
000210  tt     000024000024
000211  tt     000024000024
000212  tt     000024000024
000213  ta     000023000000
000214  ta     000205000000
000215  da     000112300000
000216  aa   000320 6270 00	eax7 	208
000217  aa  7 00034 3521 20	epp2 	pr7|28,*
000220  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000221  aa     000030000000
000222  aa     000000000000
000223  aa  6 00032 3735 20	epp7 	pr6|26,*
000224  aa  7 00004 3715 20	epp5 	pr7|4,*
000225  aa  6 00200 6515 00	spri5	pr6|128
000226  aa  7 00006 3535 20	epp3 	pr7|6,*
000227  aa  6 00202 2535 00	spri3	pr6|130
000230  aa  7 00010 3515 20	epp1 	pr7|8,*
000231  aa  6 00204 2515 00	spri1	pr6|132
000232  aa  7 00012 3715 20	epp5 	pr7|10,*
000233  aa  6 00206 6515 00	spri5	pr6|134
000234  aa  7 00014 3535 20	epp3 	pr7|12,*
000235  aa  6 00210 2535 00	spri3	pr6|136
000236  aa  7 00016 3515 20	epp1 	pr7|14,*
000237  aa  6 00212 2515 00	spri1	pr6|138
000240  aa  7 00020 3715 20	epp5 	pr7|16,*
000241  aa  6 00214 6515 00	spri5	pr6|140
000242  aa  7 00022 3535 20	epp3 	pr7|18,*
000243  aa  6 00216 2535 00	spri3	pr6|142
000244  aa  7 00030 3515 20	epp1 	pr7|24,*
000245  aa  6 00220 2515 00	spri1	pr6|144
						STATEMENT 1 ON LINE 129
	silent_sw = "0"b;

000246  aa  6 00104 4501 00	stz  	pr6|68		silent_sw
						STATEMENT 1 ON LINE 130
	lb = alb;

000247  aa  6 00032 3735 20	epp7 	pr6|26,*
000250  aa  7 00024 2361 20	ldq  	pr7|20,*		alb
000251  aa  6 00105 7561 00	stq  	pr6|69		lb
						STATEMENT 1 ON LINE 131
	ft = aft;

000252  aa  7 00026 2361 20	ldq  	pr7|22,*		aft
000253  aa  6 00106 7561 00	stq  	pr6|70		ft
						STATEMENT 1 ON LINE 133
	qid_ptr = P_qid_ptr;

000254  aa  7 00002 3715 20	epp5 	pr7|2,*		P_qid_ptr
000255  aa  5 00000 3715 20	epp5 	pr5|0,*		P_qid_ptr
000256  aa  6 00176 6515 00	spri5	pr6|126		qid_ptr
						STATEMENT 1 ON LINE 134
	rd_ptr = qid.regexp_data_ptr;

000257  aa  5 00030 3535 20	epp3 	pr5|24,*		qid.regexp_data_ptr
000260  aa  6 00174 2535 00	spri3	pr6|124		rd_ptr
						STATEMENT 1 ON LINE 136
COMMON:
	tp = atp;

000261  aa  6 00200 3735 20	epp7 	pr6|128,*		atp
000262  aa  7 00000 3735 20	epp7 	pr7|0,*		atp
000263  aa  6 00100 6535 00	spri7	pr6|64		tp
						STATEMENT 1 ON LINE 138
	ti = ati;

000264  aa  6 00202 2361 20	ldq  	pr6|130,*		ati
000265  aa  6 00107 7561 00	stq  	pr6|71		ti
						STATEMENT 1 ON LINE 139
	tl = atl;

000266  aa  6 00204 2361 20	ldq  	pr6|132,*		atl
000267  aa  6 00110 7561 00	stq  	pr6|72		tl
						STATEMENT 1 ON LINE 140
	fp = afp;

000270  aa  6 00206 3715 20	epp5 	pr6|134,*		afp
000271  aa  5 00000 3715 20	epp5 	pr5|0,*		afp
000272  aa  6 00102 6515 00	spri5	pr6|66		fp
						STATEMENT 1 ON LINE 141
	fi = afi;

000273  aa  6 00210 2361 20	ldq  	pr6|136,*		afi
000274  aa  6 00112 7561 00	stq  	pr6|74		fi
						STATEMENT 1 ON LINE 142
	fe = afe;

000275  aa  6 00212 2361 20	ldq  	pr6|138,*		afe
000276  aa  6 00113 7561 00	stq  	pr6|75		fe
						STATEMENT 1 ON LINE 144
	if tl = 0					/* Check for null regular expression "//". */
	then if rd.regl > 0				/* "//" given, use previous regular expression if any. */
	     then go to match;

000277  aa  6 00110 2361 00	ldq  	pr6|72		tl
000300  aa   000035 6010 04	tnz  	29,ic		000335
000301  aa  6 00174 3535 20	epp3 	pr6|124,*		rd_ptr
000302  aa  3 00024 2361 00	ldq  	pr3|20		rd.regl
000303  aa   000425 6054 04	tpnz 	277,ic		000730
						STATEMENT 1 ON LINE 147
	     else do;

						STATEMENT 1 ON LINE 148
		if silent_sw then
		     acode = error_table_$regexp_undefined;

000304  aa  6 00104 2351 00	lda  	pr6|68		silent_sw
000305  aa   000005 6000 04	tze  	5,ic		000312
000306  aa  6 00044 3701 20	epp4 	pr6|36,*
000307  la  4 00110 2361 20	ldq  	pr4|72,*		error_table_$regexp_undefined
000310  aa  6 00220 7561 20	stq  	pr6|144,*		acode
000311  aa   000015 7100 04	tra  	13,ic		000326
						STATEMENT 1 ON LINE 150
		else call ioa_ ("// undefined in regular expression.");

000312  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000313  aa   777537 00 0044	desc9a	-161,36		000051 = 057057040165
000314  aa  6 00244 00 0044	desc9a	pr6|164,36
000315  aa  6 00244 3521 00	epp2 	pr6|164
000316  aa  6 00260 2521 00	spri2	pr6|176
000317  aa   777503 3520 04	epp2 	-189,ic		000022 = 524000000043
000320  aa  6 00262 2521 00	spri2	pr6|178
000321  aa  6 00256 6211 00	eax1 	pr6|174
000322  aa   004000 4310 07	fld  	2048,dl
000323  aa  6 00044 3701 20	epp4 	pr6|36,*
000324  la  4 00112 3521 20	epp2 	pr4|74,*		ioa_
000325  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 152
fatal:
		rd.regl = 0;

000326  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
000327  aa  7 00024 4501 00	stz  	pr7|20		rd.regl
						STATEMENT 1 ON LINE 154
		if ^silent_sw then acode = 2;

000330  aa  6 00104 2351 00	lda  	pr6|68		silent_sw
000331  aa   000003 6010 04	tnz  	3,ic		000334
000332  aa   000002 2360 07	ldq  	2,dl
000333  aa  6 00220 7561 20	stq  	pr6|144,*		acode
						STATEMENT 1 ON LINE 155
		return;

000334  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 156
	     end;

						STATEMENT 1 ON LINE 157
	te = ti + tl - 1;

000335  aa  6 00107 0761 00	adq  	pr6|71		ti
000336  aa   000001 1760 07	sbq  	1,dl
000337  aa  6 00111 7561 00	stq  	pr6|73		te
						STATEMENT 1 ON LINE 158
	st = 1;

000340  aa   000001 2360 07	ldq  	1,dl
000341  aa  6 00170 7561 00	stq  	pr6|120		st
						STATEMENT 1 ON LINE 159
	l = 0;

000342  aa  6 00166 4501 00	stz  	pr6|118		l
						STATEMENT 1 ON LINE 160
	type = 0;

000343  aa  6 00167 4501 00	stz  	pr6|119		type
						STATEMENT 1 ON LINE 162
	if substr (tp -> exp, ti, 1) = "^"		/* Anchor to the beginning of line? */
	then do;

000344  aa  6 00107 2351 00	lda  	pr6|71		ti
000345  aa  040 004 106 505	cmpc 	(pr,al),(ic),fill(040)
000346  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	exp
000347  aa   001613 00 0001	desc9a	907,1		002160 = 136000000000
000350  aa   000007 6010 04	tnz  	7,ic		000357
						STATEMENT 1 ON LINE 164
	     type = 1;

000351  aa  6 00167 7561 00	stq  	pr6|119		type
						STATEMENT 1 ON LINE 165
	     ti = ti + 1;

000352  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 166
	     substr (rd.reg, 1, 1) = nl;

000353  aa   012000 2350 03	lda  	5120,du
000354  aa  6 00174 3535 20	epp3 	pr6|124,*		rd_ptr
000355  aa  3 00026 5511 40	stba 	pr3|22,40		rd.reg
						STATEMENT 1 ON LINE 167
	     st = st + 1;

000356  aa  6 00170 0541 00	aos  	pr6|120		st
						STATEMENT 1 ON LINE 168
	end;

						STATEMENT 1 ON LINE 170
	rd.regl = 0;

000357  aa  6 00174 3535 20	epp3 	pr6|124,*		rd_ptr
000360  aa  3 00024 4501 00	stz  	pr3|20		rd.regl
						STATEMENT 1 ON LINE 171
	last_string = 0;

000361  aa  6 00171 4501 00	stz  	pr6|121		last_string
						STATEMENT 1 ON LINE 172
	last_star = 0;

000362  aa  6 00172 4501 00	stz  	pr6|122		last_star
						STATEMENT 1 ON LINE 173
	rd.omit_newline = "0"b;

000363  aa  3 00025 4501 00	stz  	pr3|21		rd.omit_newline
						STATEMENT 1 ON LINE 175
parse_expression:					/* Parse the regular expression, forming subexpressions. */
	tl = te - ti + 1;

000364  aa  6 00111 2361 00	ldq  	pr6|73		te
000365  aa  6 00107 1761 00	sbq  	pr6|71		ti
000366  aa   000001 0760 07	adq  	1,dl
000367  aa  6 00110 7561 00	stq  	pr6|72		tl
						STATEMENT 1 ON LINE 177
	if tl <= 0 then goto expression_parsed;

000370  aa   000327 6044 04	tmoz 	215,ic		000717
						STATEMENT 1 ON LINE 178
	i = search (substr (tp -> exp, ti, tl), special_char) - 1;

000371  aa  6 00107 2351 00	lda  	pr6|71		ti
000372  aa  6 00100 3735 20	epp7 	pr6|64,*		tp
000373  aa  000 000 164 545	tct  	(pr,rl,al)
000374  aa  7 77777 60 0006	desc9a	pr7|-1(3),ql	exp
000375  aa   001363 0000 04	arg  	755,ic		001756 = 000000000000
000376  aa  6 00056 0001 00	arg  	pr6|46
000377  aa  6 00056 2361 00	ldq  	pr6|46
000400  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000401  aa   000002 6070 04	ttf  	2,ic		000403
000402  aa   000001 3360 07	lcq  	1,dl
000403  aa  6 00165 7561 00	stq  	pr6|117		i
						STATEMENT 1 ON LINE 180
	if i < 0 then i = tl;

000404  aa   000003 6050 04	tpl  	3,ic		000407
000405  aa  6 00110 2361 00	ldq  	pr6|72		tl
000406  aa  6 00165 7561 00	stq  	pr6|117		i
						STATEMENT 1 ON LINE 181
	if i > 0					/* If count is nonzero, add those characters to string. */
	then do;

000407  aa   000023 6044 04	tmoz 	19,ic		000432
						STATEMENT 1 ON LINE 183
	     if st + l + i > length (rd.reg) then go to long_string;

000410  aa  6 00170 2361 00	ldq  	pr6|120		st
000411  aa  6 00166 0761 00	adq  	pr6|118		l
000412  aa  6 00165 0761 00	adq  	pr6|117		i
000413  aa   000204 1160 07	cmpq 	132,dl
000414  aa   000224 6054 04	tpnz 	148,ic		000640
						STATEMENT 1 ON LINE 185
	     substr (rd.reg, st + l, i) = substr (tp -> exp, ti, i);

000415  aa  6 00170 2361 00	ldq  	pr6|120		st
000416  aa  6 00166 0761 00	adq  	pr6|118		l
000417  aa  6 00174 3715 20	epp5 	pr6|124,*		rd_ptr
000420  aa  6 00165 7271 00	lxl7 	pr6|117		i
000421  aa  040 146 100 545	mlr  	(pr,rl,al),(pr,rl,ql),fill(040)
000422  aa  7 77777 60 0017	desc9a	pr7|-1(3),x7	exp
000423  aa  5 00025 60 0017	desc9a	pr5|21(3),x7	rd.reg
						STATEMENT 1 ON LINE 187
	     l = l + i;

000424  aa  6 00165 2361 00	ldq  	pr6|117		i
000425  aa  6 00166 0561 00	asq  	pr6|118		l
						STATEMENT 1 ON LINE 188
	     ti = ti + i;

000426  aa  6 00107 0561 00	asq  	pr6|71		ti
						STATEMENT 1 ON LINE 189
	     if ti > te then go to expression_parsed;

000427  aa  6 00107 2361 00	ldq  	pr6|71		ti
000430  aa  6 00111 1161 00	cmpq 	pr6|73		te
000431  aa   000266 6054 04	tpnz 	182,ic		000717
						STATEMENT 1 ON LINE 190
	end;

						STATEMENT 1 ON LINE 192
	go to special_case (index (special_char, substr (tp -> exp, ti, 1)));

000432  aa  6 00107 2351 00	lda  	pr6|71		ti
000433  aa  000 105 124 404	scm  	(ic),(pr,al),mask(000)
000434  aa   777361 00 0005	desc9a	-271,5		000014 = 056052134044
000435  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	exp
000436  aa  6 00056 0001 00	arg  	pr6|46
000437  aa  6 00056 2361 00	ldq  	pr6|46
000440  aa   000002 6070 04	ttf  	2,ic		000442
000441  aa   000001 3360 07	lcq  	1,dl
000442  aa   000001 0760 07	adq  	1,dl
000443  ta   777777 7100 06	tra  	-1,ql
						STATEMENT 1 ON LINE 195
special_case (1):					/* Period or dot. */
	call end_sub_expression;

000444  aa   001026 6700 04	tsp4 	534,ic		001472
						STATEMENT 1 ON LINE 197
	i = 0;

000445  aa  6 00165 4501 00	stz  	pr6|117		i
						STATEMENT 1 ON LINE 198
	tl = te - ti + 1;

000446  aa  6 00111 2361 00	ldq  	pr6|73		te
000447  aa  6 00107 1761 00	sbq  	pr6|71		ti
000450  aa   000001 0760 07	adq  	1,dl
000451  aa  6 00110 7561 00	stq  	pr6|72		tl
						STATEMENT 1 ON LINE 199
	if tl - 1 > 0 then i = verify (substr (tp -> exp, ti + 1, tl - 1), ".");

000452  aa   000001 1760 07	sbq  	1,dl
000453  aa  6 00255 7561 00	stq  	pr6|173
000454  aa   000015 6044 04	tmoz 	13,ic		000471
000455  aa  6 00107 2351 00	lda  	pr6|71		ti
000456  aa  6 00100 3735 20	epp7 	pr6|64,*		tp
000457  aa  000 000 164 545	tct  	(pr,rl,al)
000460  aa  7 00000 00 0006	desc9a	pr7|0,ql		exp
000461  aa  0 77202 0001 00	arg  	pr0|-382		= 777777777777
000462  aa  6 00056 0001 00	arg  	pr6|46
000463  aa  6 00056 2361 00	ldq  	pr6|46
000464  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000465  aa   000002 6070 04	ttf  	2,ic		000467
000466  aa   000001 3360 07	lcq  	1,dl
000467  aa   000001 0760 07	adq  	1,dl
000470  aa  6 00165 7561 00	stq  	pr6|117		i
						STATEMENT 1 ON LINE 201
	if i = 0 then i = tl;

000471  aa  6 00165 2361 00	ldq  	pr6|117		i
000472  aa   000003 6010 04	tnz  	3,ic		000475
000473  aa  6 00110 2361 00	ldq  	pr6|72		tl
000474  aa  6 00165 7561 00	stq  	pr6|117		i
						STATEMENT 1 ON LINE 202
	ti = ti + i;

000475  aa  6 00107 0561 00	asq  	pr6|71		ti
						STATEMENT 1 ON LINE 203
	if ti <= te then
	     if substr (tp -> exp, ti, 1) = "*"		/* Last dot is part of ".*". */
	     then do;

000476  aa  6 00107 2361 00	ldq  	pr6|71		ti
000477  aa  6 00111 1161 00	cmpq 	pr6|73		te
000500  aa   000013 6054 04	tpnz 	11,ic		000513
000501  aa  6 00100 3735 20	epp7 	pr6|64,*		tp
000502  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
000503  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	exp
000504  aa   001455 00 0001	desc9a	813,1		002157 = 052000000000
000505  aa   000006 6010 04	tnz  	6,ic		000513
						STATEMENT 1 ON LINE 206
		type = 2;

000506  aa   000002 2360 07	ldq  	2,dl
000507  aa  6 00167 7561 00	stq  	pr6|119		type
						STATEMENT 1 ON LINE 207
		ti = ti + 1;

000510  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 208
		i = i - 1;

000511  aa   000001 3360 07	lcq  	1,dl
000512  aa  6 00165 0561 00	asq  	pr6|117		i
						STATEMENT 1 ON LINE 209
	     end;

						STATEMENT 1 ON LINE 210
	if i > 0 then call builder (5, i);

000513  aa  6 00165 2361 00	ldq  	pr6|117		i
000514  aa   000005 6044 04	tmoz 	5,ic		000521
000515  aa   000005 2360 07	ldq  	5,dl
000516  aa  6 00255 7561 00	stq  	pr6|173
000517  aa   001231 3520 04	epp2 	665,ic		001750 = 000004000000
000520  aa   001130 6700 04	tsp4 	600,ic		001650
						STATEMENT 1 ON LINE 211
	if type ^= 2 then type = 3;

000521  aa  6 00167 2361 00	ldq  	pr6|119		type
000522  aa   000002 1160 07	cmpq 	2,dl
000523  aa   777641 6000 04	tze  	-95,ic		000364
000524  aa   000003 2360 07	ldq  	3,dl
000525  aa  6 00167 7561 00	stq  	pr6|119		type
						STATEMENT 1 ON LINE 212
	go to parse_expression;

000526  aa   777636 7100 04	tra  	-98,ic		000364
						STATEMENT 1 ON LINE 214
special_case (2):					/* Asterisk or star. */
	if l = 0					/* No character precedes the star. */
	then do;

000527  aa  6 00166 2361 00	ldq  	pr6|118		l
000530  aa   000024 6010 04	tnz  	20,ic		000554
						STATEMENT 1 ON LINE 217
	     if silent_sw then
		acode = error_table_$regexp_invalid_star;

000531  aa  6 00104 2351 00	lda  	pr6|68		silent_sw
000532  aa   000005 6000 04	tze  	5,ic		000537
000533  aa  6 00044 3701 20	epp4 	pr6|36,*
000534  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$regexp_invalid_star
000535  aa  6 00220 7561 20	stq  	pr6|144,*		acode
000536  aa   777570 7100 04	tra  	-136,ic		000326
						STATEMENT 1 ON LINE 219
	     else call ioa_ ("Invalid use of * in regular expression.");

000537  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000540  aa   777323 00 0050	desc9a	-301,40		000062 = 111156166141
000541  aa  6 00264 00 0050	desc9a	pr6|180,40
000542  aa  6 00264 3521 00	epp2 	pr6|180
000543  aa  6 00260 2521 00	spri2	pr6|176
000544  aa   777255 3520 04	epp2 	-339,ic		000021 = 524000000047
000545  aa  6 00262 2521 00	spri2	pr6|178
000546  aa  6 00256 6211 00	eax1 	pr6|174
000547  aa   004000 4310 07	fld  	2048,dl
000550  aa  6 00044 3701 20	epp4 	pr6|36,*
000551  la  4 00112 3521 20	epp2 	pr4|74,*		ioa_
000552  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 220
	     go to fatal;

000553  aa   777553 7100 04	tra  	-149,ic		000326
						STATEMENT 1 ON LINE 221
	end;

						STATEMENT 1 ON LINE 222
	l = l - 1;

000554  aa   000001 3360 07	lcq  	1,dl
000555  aa  6 00166 0561 00	asq  	pr6|118		l
						STATEMENT 1 ON LINE 223
	ti = ti + 1;

000556  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 224
	call end_sub_expression;

000557  aa   000713 6700 04	tsp4 	459,ic		001472
						STATEMENT 1 ON LINE 225
	if type = 2 then go to parse_expression;

000560  aa  6 00167 2361 00	ldq  	pr6|119		type
000561  aa   000002 1160 07	cmpq 	2,dl
000562  aa   777602 6000 04	tze  	-126,ic		000364
						STATEMENT 1 ON LINE 226
	if rd.regl > 0 & rd.regl = last_star		/* Do not build if previous subexpression is identical. */
	then if rd.reg_info (last_star).search_char = substr (rd.reg, st, 1) then go to parse_expression;

000563  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
000564  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
000565  aa   000012 6044 04	tmoz 	10,ic		000577
000566  aa  6 00172 1161 00	cmpq 	pr6|122		last_star
000567  aa   000010 6010 04	tnz  	8,ic		000577
000570  aa  6 00170 7271 00	lxl7 	pr6|120		st
000571  aa  6 00172 7261 00	lxl6 	pr6|122		last_star
000572  aa  7 77777 3715 16	epp5 	pr7|-1,6		rd.search_char
000573  aa  040 117 106 500	cmpc 	(pr),(pr,x7),fill(040)
000574  aa  5 00000 00 0001	desc9a	pr5|0,1		rd.search_char
000575  aa  7 00025 60 0001	desc9a	pr7|21(3),1	rd.reg
000576  aa   777566 6000 04	tze  	-138,ic		000364
						STATEMENT 1 ON LINE 228
	call builder (4, 0);

000577  aa   000004 2360 07	ldq  	4,dl
000600  aa  6 00255 7561 00	stq  	pr6|173
000601  aa  6 00276 4501 00	stz  	pr6|190
000602  aa   001140 3520 04	epp2 	608,ic		001742 = 000004000000
000603  aa   001045 6700 04	tsp4 	549,ic		001650
						STATEMENT 1 ON LINE 229
	last_star = rd.regl;

000604  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
000605  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
000606  aa  6 00172 7561 00	stq  	pr6|122		last_star
						STATEMENT 1 ON LINE 230
	rd.reg_info (last_star).search_char = substr (rd.reg, st, 1);

000607  aa  6 00170 7271 00	lxl7 	pr6|120		st
000610  aa  7 77777 3715 06	epp5 	pr7|-1,ql		rd.search_char
000611  aa  040 100 100 517	mlr  	(pr,x7),(pr),fill(040)
000612  aa  7 00025 60 0001	desc9a	pr7|21(3),1	rd.reg
000613  aa  5 00000 00 0001	desc9a	pr5|0,1		rd.search_char
						STATEMENT 1 ON LINE 232
	type = 3;

000614  aa   000003 2360 07	ldq  	3,dl
000615  aa  6 00167 7561 00	stq  	pr6|119		type
						STATEMENT 1 ON LINE 233
	go to parse_expression;

000616  aa   777546 7100 04	tra  	-154,ic		000364
						STATEMENT 1 ON LINE 235
special_case (3):					/* Backslash. Could be part of \c or \C. */
	if ti = te then go to store_char;

000617  aa  6 00107 2361 00	ldq  	pr6|71		ti
000620  aa  6 00111 1161 00	cmpq 	pr6|73		te
000621  aa   000013 6000 04	tze  	11,ic		000634
						STATEMENT 1 ON LINE 237
	if substr (tp -> exp, ti + 1, 1) ^= "c" & substr (tp -> exp, ti + 1, 1) ^= "C" then go to store_char;

000622  aa  000 100 100 505	mlr  	(pr,al),(pr),fill(000)
000623  aa  7 00000 00 0001	desc9a	pr7|0,1		exp
000624  aa  6 00276 00 0004	desc9a	pr6|190,4		exp
000625  aa  6 00276 2351 00	lda  	pr6|190		exp
000626  aa   143000 1150 03	cmpa 	50688,du
000627  aa   000003 6000 04	tze  	3,ic		000632
000630  aa   103000 1150 03	cmpa 	34304,du
000631  aa   000003 6010 04	tnz  	3,ic		000634
						STATEMENT 1 ON LINE 238
	ti = ti + 1;

000632  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 240
special_case (5):					/* Backslash-c as single character. */
	ti = ti + 1;

000633  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 243
store_char:					/* Add a single character to the string being created. */
	if st + l = length (rd.reg)			/* Check for string overflow. */
	then do;

000634  aa  6 00170 2361 00	ldq  	pr6|120		st
000635  aa  6 00166 0761 00	adq  	pr6|118		l
000636  aa   000204 1160 07	cmpq 	132,dl
000637  aa   000024 6010 04	tnz  	20,ic		000663
						STATEMENT 1 ON LINE 247
long_string:					/* Expression has too many characters. */
	     if silent_sw then
		acode = error_table_$regexp_too_long;

000640  aa  6 00104 2351 00	lda  	pr6|68		silent_sw
000641  aa   000005 6000 04	tze  	5,ic		000646
000642  aa  6 00044 3701 20	epp4 	pr6|36,*
000643  la  4 00106 2361 20	ldq  	pr4|70,*		error_table_$regexp_too_long
000644  aa  6 00220 7561 20	stq  	pr6|144,*		acode
000645  aa   777461 7100 04	tra  	-207,ic		000326
						STATEMENT 1 ON LINE 250
	     else call ioa_ ("Regular expression is too long.");

000646  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000647  aa   777162 00 0040	desc9a	-398,32		000030 = 122145147165
000650  aa  6 00244 00 0040	desc9a	pr6|164,32
000651  aa  6 00244 3521 00	epp2 	pr6|164
000652  aa  6 00260 2521 00	spri2	pr6|176
000653  aa   777145 3520 04	epp2 	-411,ic		000020 = 524000000037
000654  aa  6 00262 2521 00	spri2	pr6|178
000655  aa  6 00256 6211 00	eax1 	pr6|174
000656  aa   004000 4310 07	fld  	2048,dl
000657  aa  6 00044 3701 20	epp4 	pr6|36,*
000660  la  4 00112 3521 20	epp2 	pr4|74,*		ioa_
000661  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 251
	     go to fatal;

000662  aa   777444 7100 04	tra  	-220,ic		000326
						STATEMENT 1 ON LINE 252
	end;

						STATEMENT 1 ON LINE 253
	substr (rd.reg, st + l, 1) = substr (tp -> exp, ti, 1);

000663  aa  6 00170 2361 00	ldq  	pr6|120		st
000664  aa  6 00166 0761 00	adq  	pr6|118		l
000665  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
000666  aa  6 00107 2351 00	lda  	pr6|71		ti
000667  aa  6 00100 3715 20	epp5 	pr6|64,*		tp
000670  aa  040 106 100 505	mlr  	(pr,al),(pr,ql),fill(040)
000671  aa  5 77777 60 0001	desc9a	pr5|-1(3),1	exp
000672  aa  7 00025 60 0001	desc9a	pr7|21(3),1	rd.reg
						STATEMENT 1 ON LINE 255
	ti = ti + 1;

000673  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 256
	l = l + 1;

000674  aa  6 00166 0541 00	aos  	pr6|118		l
						STATEMENT 1 ON LINE 257
	go to parse_expression;

000675  aa   777467 7100 04	tra  	-201,ic		000364
						STATEMENT 1 ON LINE 259
special_case (4):					/* Dollar sign or end of line anchor. */
	if ti ^= te then go to store_char;

000676  aa  6 00107 2361 00	ldq  	pr6|71		ti
000677  aa  6 00111 1161 00	cmpq 	pr6|73		te
000700  aa   777734 6010 04	tnz  	-36,ic		000634
						STATEMENT 1 ON LINE 261
	rd.omit_newline = "1"b;

000701  aa   400000 2350 03	lda  	131072,du
000702  aa  6 00174 3715 20	epp5 	pr6|124,*		rd_ptr
000703  aa  5 00025 7551 00	sta  	pr5|21		rd.omit_newline
						STATEMENT 1 ON LINE 262
	if st + l = length (rd.reg) then go to long_string;

000704  aa  6 00170 2361 00	ldq  	pr6|120		st
000705  aa  6 00166 0761 00	adq  	pr6|118		l
000706  aa   000204 1160 07	cmpq 	132,dl
000707  aa   777731 6000 04	tze  	-39,ic		000640
						STATEMENT 1 ON LINE 264
	substr (rd.reg, st + l, 1) = nl;

000710  aa  6 00170 2361 00	ldq  	pr6|120		st
000711  aa  6 00166 0761 00	adq  	pr6|118		l
000712  aa  012 106 100 400	mlr  	(),(pr,ql),fill(012)
000713  aa   000000 00 0000	desc9a	0,0
000714  aa  5 00025 60 0001	desc9a	pr5|21(3),1	rd.reg
						STATEMENT 1 ON LINE 265
	l = l + 1;

000715  aa  6 00166 0541 00	aos  	pr6|118		l
						STATEMENT 1 ON LINE 266
	ti = ti + 1;

000716  aa  6 00107 0541 00	aos  	pr6|71		ti
						STATEMENT 1 ON LINE 270
expression_parsed:
	call end_sub_expression;

000717  aa   000553 6700 04	tsp4 	363,ic		001472
						STATEMENT 1 ON LINE 272
	if type = 2 then call builder (2, 0);

000720  aa  6 00167 2361 00	ldq  	pr6|119		type
000721  aa   000002 1160 07	cmpq 	2,dl
000722  aa   000006 6010 04	tnz  	6,ic		000730
000723  aa   000002 2360 07	ldq  	2,dl
000724  aa  6 00276 7561 00	stq  	pr6|190
000725  aa  6 00255 4501 00	stz  	pr6|173
000726  aa   001006 3520 04	epp2 	518,ic		001734 = 000004000000
000727  aa   000721 6700 04	tsp4 	465,ic		001650
						STATEMENT 1 ON LINE 274
match:
	if fe = 0 | fi > fe then go to fail;

000730  aa  6 00113 2361 00	ldq  	pr6|75		fe
000731  aa   000427 6000 04	tze  	279,ic		001360
000732  aa  6 00112 1161 00	cmpq 	pr6|74		fi
000733  aa   000425 6040 04	tmi  	277,ic		001360
						STATEMENT 1 ON LINE 276
	do i = 1 to rd.regl;

000734  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
000735  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
000736  aa  6 00222 7561 00	stq  	pr6|146
000737  aa   000001 2360 07	ldq  	1,dl
000740  aa  6 00165 7561 00	stq  	pr6|117		i
000741  aa   000000 0110 03	nop  	0,du
000742  aa  6 00165 2361 00	ldq  	pr6|117		i
000743  aa  6 00222 1161 00	cmpq 	pr6|146
000744  aa   000004 6054 04	tpnz 	4,ic		000750
						STATEMENT 1 ON LINE 277
	     reentry_point (i) = 0;

000745  aa  6 00140 4501 06	stz  	pr6|96,ql		reentry_point
						STATEMENT 1 ON LINE 278
	end;

000746  aa  6 00165 0541 00	aos  	pr6|117		i
000747  aa   777773 7100 04	tra  	-5,ic		000742
						STATEMENT 1 ON LINE 280
restart_search:					/* Match the entire regular expression. */
	match_start (1) = fi;

000750  aa  6 00112 2361 00	ldq  	pr6|74		fi
000751  aa  6 00115 7561 00	stq  	pr6|77		match_start
						STATEMENT 1 ON LINE 282
	i = 1;

000752  aa   000001 2360 07	ldq  	1,dl
000753  aa  6 00165 7561 00	stq  	pr6|117		i
						STATEMENT 1 ON LINE 283
	st = 1;

000754  aa  6 00170 7561 00	stq  	pr6|120		st
						STATEMENT 1 ON LINE 284
	te = fi - 1;

000755  aa  6 00112 2361 00	ldq  	pr6|74		fi
000756  aa   000001 1760 07	sbq  	1,dl
000757  aa  6 00111 7561 00	stq  	pr6|73		te
						STATEMENT 1 ON LINE 286
search_loop:
	tl = fe - fi + 1;

000760  aa  6 00113 2361 00	ldq  	pr6|75		fe
000761  aa  6 00112 1761 00	sbq  	pr6|74		fi
000762  aa   000001 0760 07	adq  	1,dl
000763  aa  6 00110 7561 00	stq  	pr6|72		tl
						STATEMENT 1 ON LINE 288
	l = rd.reg_info (i).len;

000764  aa  6 00165 7271 00	lxl7 	pr6|117		i
000765  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
000766  aa  7 77777 2351 17	lda  	pr7|-1,7		rd.len
000767  aa   000011 7350 00	als  	9
000770  aa   000077 7330 00	lrs  	63
000771  aa  6 00166 7561 00	stq  	pr6|118		l
						STATEMENT 1 ON LINE 289
	go to string_search (rd.reg_info (i).search_type);

000772  aa  7 77777 2351 17	lda  	pr7|-1,7		rd.search_type
000773  aa   000033 7350 00	als  	27
000774  aa   000077 7330 00	lrs  	63
000775  ta   000005 7100 06	tra  	5,ql
						STATEMENT 1 ON LINE 291
string_search (0):					/* Initial search without initial newline. */
	if l > tl then go to fail;

000776  aa  6 00166 2361 00	ldq  	pr6|118		l
000777  aa  6 00110 1161 00	cmpq 	pr6|72		tl
001000  aa   000360 6054 04	tpnz 	240,ic		001360
						STATEMENT 1 ON LINE 293
	j = index (substr (fp -> text, fi, tl), substr (rd.reg, 1, l)) - 1;

001001  aa  6 00110 2361 00	ldq  	pr6|72		tl
001002  aa  6 00112 2351 00	lda  	pr6|74		fi
001003  aa   000003 0750 07	ada  	3,dl
001004  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001005  aa  5 77777 3521 00	epp2 	pr5|-1		text
001006  aa  2 00000 5005 05	a9bd 	pr2|0,al
001007  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
001010  aa  6 00166 2361 00	ldq  	pr6|118		l
001011  aa  7 00026 3521 00	epp2 	pr7|22		rd.reg
001012  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
001013  aa   000001 1760 07	sbq  	1,dl
001014  aa  6 00114 7561 00	stq  	pr6|76		j
						STATEMENT 1 ON LINE 295
	if j < 0 then go to fail;

001015  aa   000343 6040 04	tmi  	227,ic		001360
						STATEMENT 1 ON LINE 296
	st = st + l;

001016  aa  6 00166 2361 00	ldq  	pr6|118		l
001017  aa  6 00170 0561 00	asq  	pr6|120		st
						STATEMENT 1 ON LINE 297
	go to found_first_match;

001020  aa   000107 7100 04	tra  	71,ic		001127
						STATEMENT 1 ON LINE 299
string_search (1):					/* Initial search with initial newline. */
	if fi > 1 & (lb > 0 | fi ^= ft) then do;

001021  aa  6 00105 2361 00	ldq  	pr6|69		lb
001022  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
001023  aa  6 00255 7551 00	sta  	pr6|173
001024  aa  6 00112 2361 00	ldq  	pr6|74		fi
001025  aa   000001 1160 07	cmpq 	1,dl
001026  aa   000046 6044 04	tmoz 	38,ic		001074
001027  aa  6 00255 2351 00	lda  	pr6|173
001030  aa   000003 6010 04	tnz  	3,ic		001033
001031  aa  6 00106 1161 00	cmpq 	pr6|70		ft
001032  aa   000042 6000 04	tze  	34,ic		001074
						STATEMENT 1 ON LINE 301
	     if (lb > 0 & fi = ft) then do;

001033  aa   400000 3150 03	cana 	131072,du
001034  aa   000012 6000 04	tze  	10,ic		001046
001035  aa  6 00106 1161 00	cmpq 	pr6|70		ft
001036  aa   000010 6010 04	tnz  	8,ic		001046
						STATEMENT 1 ON LINE 302
		if substr (fp -> text, lb, 1) = nl then goto nl_found;

001037  aa  6 00105 2361 00	ldq  	pr6|69		lb
001040  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001041  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
001042  aa  5 77777 60 0001	desc9a	pr5|-1(3),1	text
001043  aa   001115 00 0001	desc9a	589,1		002156 = 012000000000
001044  aa   000030 6000 04	tze  	24,ic		001074
						STATEMENT 1 ON LINE 304
	     end;

001045  aa   000006 7100 04	tra  	6,ic		001053
						STATEMENT 1 ON LINE 305
	     else if substr (fp -> text, fi - 1, 1) = nl then goto nl_found;

001046  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001047  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
001050  aa  5 77777 40 0001	desc9a	pr5|-1(2),1	text
001051  aa   001107 00 0001	desc9a	583,1		002156 = 012000000000
001052  aa   000022 6000 04	tze  	18,ic		001074
						STATEMENT 1 ON LINE 307
	     j = index (substr (fp -> text, fi, tl), nl);

001053  aa  6 00112 2361 00	ldq  	pr6|74		fi
001054  aa  6 00110 2351 00	lda  	pr6|72		tl
001055  aa  000 003 124 546	scm  	(pr,rl,ql),(du),mask(000)
001056  aa  5 77777 60 0005	desc9a	pr5|-1(3),al	text
001057  aa   012000 00 0001	desc9a	5120,1
001060  aa  6 00056 0001 00	arg  	pr6|46
001061  aa  6 00056 2361 00	ldq  	pr6|46
001062  aa   000002 6070 04	ttf  	2,ic		001064
001063  aa   000001 3360 07	lcq  	1,dl
001064  aa   000001 0760 07	adq  	1,dl
001065  aa  6 00114 7561 00	stq  	pr6|76		j
						STATEMENT 1 ON LINE 308
	     if j = 0 then go to fail;

001066  aa   000272 6000 04	tze  	186,ic		001360
						STATEMENT 1 ON LINE 309
	     fi = fi + j;

001067  aa  6 00112 0561 00	asq  	pr6|74		fi
						STATEMENT 1 ON LINE 310
	     tl = tl - j;

001070  aa  6 00114 3361 00	lcq  	pr6|76		j
001071  aa  6 00110 0561 00	asq  	pr6|72		tl
						STATEMENT 1 ON LINE 311
	     if tl <= 0 then go to fail;

001072  aa  6 00110 2361 00	ldq  	pr6|72		tl
001073  aa   000265 6044 04	tmoz 	181,ic		001360
						STATEMENT 1 ON LINE 312
	end;

						STATEMENT 1 ON LINE 313
nl_found:
	st = st + l + 1;

001074  aa  6 00170 2361 00	ldq  	pr6|120		st
001075  aa  6 00166 0761 00	adq  	pr6|118		l
001076  aa   000001 0760 07	adq  	1,dl
001077  aa  6 00170 7561 00	stq  	pr6|120		st
						STATEMENT 1 ON LINE 315
	j = 0;

001100  aa  6 00114 4501 00	stz  	pr6|76		j
						STATEMENT 1 ON LINE 316
	if l = 0 then go to found_first_match;

001101  aa  6 00166 2361 00	ldq  	pr6|118		l
001102  aa   000025 6000 04	tze  	21,ic		001127
						STATEMENT 1 ON LINE 317
	if l > tl then go to fail;

001103  aa  6 00110 1161 00	cmpq 	pr6|72		tl
001104  aa   000254 6054 04	tpnz 	172,ic		001360
						STATEMENT 1 ON LINE 318
	if substr (fp -> text, fi, l) ^= substr (rd.reg, 2, l)
						/* Check this line but omit newline. */
	then do;

001105  aa  6 00112 2351 00	lda  	pr6|74		fi
001106  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001107  aa  040 140 106 545	cmpc 	(pr,rl,al),(pr,rl),fill(040)
001110  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	text
001111  aa  7 00026 20 0006	desc9a	pr7|22(1),ql	rd.reg
001112  aa   000015 6000 04	tze  	13,ic		001127
						STATEMENT 1 ON LINE 321
	     j = index (substr (fp -> text, fi, tl), substr (rd.reg, 1, l + 1));

001113  aa   000001 0760 07	adq  	1,dl
001114  aa  6 00255 7561 00	stq  	pr6|173
001115  aa  6 00110 2361 00	ldq  	pr6|72		tl
001116  aa   000003 0750 07	ada  	3,dl
001117  aa  5 77777 3521 00	epp2 	pr5|-1		text
001120  aa  2 00000 5005 05	a9bd 	pr2|0,al
001121  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
001122  aa  6 00255 2361 00	ldq  	pr6|173
001123  aa  7 00026 3521 00	epp2 	pr7|22		rd.reg
001124  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
001125  aa  6 00114 7561 00	stq  	pr6|76		j
						STATEMENT 1 ON LINE 323
	     if j = 0 then go to fail;

001126  aa   000232 6000 04	tze  	154,ic		001360
						STATEMENT 1 ON LINE 324
	end;

						STATEMENT 1 ON LINE 326
found_first_match:
	match_start (1) = fi + j;

001127  aa  6 00112 2361 00	ldq  	pr6|74		fi
001130  aa  6 00114 0761 00	adq  	pr6|76		j
001131  aa  6 00115 7561 00	stq  	pr6|77		match_start
						STATEMENT 1 ON LINE 328
	go to found_field;

001132  aa   000167 7100 04	tra  	119,ic		001321
						STATEMENT 1 ON LINE 330
string_search (2):					/* Dot-star string search. Match as few characters as possible. */
	if l = 0					/* If length is zero, then RE ends with ".*". */
	then do;

001133  aa  6 00166 2361 00	ldq  	pr6|118		l
001134  aa   000026 6010 04	tnz  	22,ic		001162
						STATEMENT 1 ON LINE 333
	     te = fi + index (substr (fp -> text, fi, tl), nl) - 2;

001135  aa  6 00112 2351 00	lda  	pr6|74		fi
001136  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001137  aa  6 00110 2361 00	ldq  	pr6|72		tl
001140  aa  000 003 124 545	scm  	(pr,rl,al),(du),mask(000)
001141  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	text
001142  aa   012000 00 0001	desc9a	5120,1
001143  aa  6 00056 0001 00	arg  	pr6|46
001144  aa  6 00056 2361 00	ldq  	pr6|46
001145  aa   000002 6070 04	ttf  	2,ic		001147
001146  aa   000001 3360 07	lcq  	1,dl
001147  aa   000001 0760 07	adq  	1,dl
001150  aa  6 00112 0761 00	adq  	pr6|74		fi
001151  aa   000002 1760 07	sbq  	2,dl
001152  aa  6 00111 7561 00	stq  	pr6|73		te
						STATEMENT 1 ON LINE 335
	     if te < fi - 1 then te = fe;

001153  aa  6 00112 2361 00	ldq  	pr6|74		fi
001154  aa   000001 1760 07	sbq  	1,dl
001155  aa  6 00111 1161 00	cmpq 	pr6|73		te
001156  aa   000151 6044 04	tmoz 	105,ic		001327
001157  aa  6 00113 2361 00	ldq  	pr6|75		fe
001160  aa  6 00111 7561 00	stq  	pr6|73		te
						STATEMENT 1 ON LINE 336
	     go to next_field;

001161  aa   000146 7100 04	tra  	102,ic		001327
						STATEMENT 1 ON LINE 337
	end;

						STATEMENT 1 ON LINE 338
	if l > tl then go to fail_reset;

001162  aa  6 00110 1161 00	cmpq 	pr6|72		tl
001163  aa   000163 6054 04	tpnz 	115,ic		001346
						STATEMENT 1 ON LINE 339
	j = index (substr (fp -> text, fi, tl), substr (rd.reg, st, l)) - 1;

001164  aa  6 00110 2361 00	ldq  	pr6|72		tl
001165  aa  6 00112 2351 00	lda  	pr6|74		fi
001166  aa   000003 0750 07	ada  	3,dl
001167  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001170  aa  5 77777 3521 00	epp2 	pr5|-1		text
001171  aa  2 00000 5005 05	a9bd 	pr2|0,al
001172  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
001173  aa  6 00166 2361 00	ldq  	pr6|118		l
001174  aa  6 00170 7261 00	lxl6 	pr6|120		st
001175  aa   000003 6260 16	eax6 	3,6
001176  aa  7 00025 3521 00	epp2 	pr7|21		rd.reg
001177  aa  2 00000 5005 16	a9bd 	pr2|0,6
001200  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
001201  aa   000001 1760 07	sbq  	1,dl
001202  aa  6 00114 7561 00	stq  	pr6|76		j
						STATEMENT 1 ON LINE 341
	if j < 0 then go to fail_reset;

001203  aa   000143 6040 04	tmi  	99,ic		001346
						STATEMENT 1 ON LINE 342
	te = 0;

001204  aa  6 00111 4501 00	stz  	pr6|73		te
						STATEMENT 1 ON LINE 343
	if j > 0 then te = index (substr (fp -> text, fi, j), nl);

001205  aa   000013 6044 04	tmoz 	11,ic		001220
001206  aa  6 00112 2351 00	lda  	pr6|74		fi
001207  aa  000 003 124 545	scm  	(pr,rl,al),(du),mask(000)
001210  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	text
001211  aa   012000 00 0001	desc9a	5120,1
001212  aa  6 00056 0001 00	arg  	pr6|46
001213  aa  6 00056 2361 00	ldq  	pr6|46
001214  aa   000002 6070 04	ttf  	2,ic		001216
001215  aa   000001 3360 07	lcq  	1,dl
001216  aa   000001 0760 07	adq  	1,dl
001217  aa  6 00111 7561 00	stq  	pr6|73		te
						STATEMENT 1 ON LINE 345
	if te > 0					/* At least one intervening newline. */
	then do;

001220  aa  6 00111 2361 00	ldq  	pr6|73		te
001221  aa   000004 6044 04	tmoz 	4,ic		001225
						STATEMENT 1 ON LINE 347
	     fi = fi + te;

001222  aa  6 00112 0561 00	asq  	pr6|74		fi
						STATEMENT 1 ON LINE 348
	     reentry_point (i) = 0;

001223  aa  6 00140 4501 17	stz  	pr6|96,7		reentry_point
						STATEMENT 1 ON LINE 349
	     go to restart_search;

001224  aa   777524 7100 04	tra  	-172,ic		000750
						STATEMENT 1 ON LINE 350
	end;

						STATEMENT 1 ON LINE 351
	reentry_point (i) = fi + j + 1;

001225  aa  6 00112 2361 00	ldq  	pr6|74		fi
001226  aa  6 00114 0761 00	adq  	pr6|76		j
001227  aa   000001 0760 07	adq  	1,dl
001230  aa  6 00140 7561 17	stq  	pr6|96,7		reentry_point
						STATEMENT 1 ON LINE 352
	st = st + l;

001231  aa  6 00166 2361 00	ldq  	pr6|118		l
001232  aa  6 00170 0561 00	asq  	pr6|120		st
						STATEMENT 1 ON LINE 353
	go to found_field;

001233  aa   000066 7100 04	tra  	54,ic		001321
						STATEMENT 1 ON LINE 355
string_search (3):					/* Search subexpression. Match string at current buffer position. */
	if l > tl then go to fail_retry;

001234  aa  6 00166 2361 00	ldq  	pr6|118		l
001235  aa  6 00110 1161 00	cmpq 	pr6|72		tl
001236  aa   000112 6054 04	tpnz 	74,ic		001350
						STATEMENT 1 ON LINE 357
	j = 0;

001237  aa  6 00114 4501 00	stz  	pr6|76		j
						STATEMENT 1 ON LINE 358
	if substr (fp -> text, fi, l) ^= substr (rd.reg, st, l) then go to fail_retry;

001240  aa  6 00170 7261 00	lxl6 	pr6|120		st
001241  aa  6 00112 2351 00	lda  	pr6|74		fi
001242  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001243  aa  040 156 106 545	cmpc 	(pr,rl,al),(pr,rl,x6),fill(040)
001244  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	text
001245  aa  7 00025 60 0006	desc9a	pr7|21(3),ql	rd.reg
001246  aa   000102 6010 04	tnz  	66,ic		001350
						STATEMENT 1 ON LINE 360
	st = st + l;

001247  aa  6 00170 0561 00	asq  	pr6|120		st
						STATEMENT 1 ON LINE 361
	go to found_field;

001250  aa   000051 7100 04	tra  	41,ic		001321
						STATEMENT 1 ON LINE 363
string_search (4):					/* Star subexpression. Match as many of a particular character as possible. */
	reentry_point (i) = 0;

001251  aa  6 00140 4501 17	stz  	pr6|96,7		reentry_point
						STATEMENT 1 ON LINE 365
	if tl <= 0 then go to next_field;

001252  aa  6 00110 2361 00	ldq  	pr6|72		tl
001253  aa   000054 6044 04	tmoz 	44,ic		001327
						STATEMENT 1 ON LINE 366
	match_start (i) = fi;

001254  aa  6 00112 2361 00	ldq  	pr6|74		fi
001255  aa  6 00114 7561 17	stq  	pr6|76,7		match_start
						STATEMENT 1 ON LINE 367
	l = verify (substr (fp -> text, fi, tl), rd.reg_info (i).search_char) - 1;

001256  aa   000003 0760 07	adq  	3,dl
001257  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001260  aa  5 77777 3521 00	epp2 	pr5|-1		text
001261  aa  2 00000 5005 06	a9bd 	pr2|0,ql
001262  aa  6 00110 2361 00	ldq  	pr6|72		tl
001263  aa  7 77777 3515 17	epp1 	pr7|-1,7		rd.search_char
001264  aa   000001 2350 07	lda  	1,dl
001265  aa  0 01244 7001 00	tsx0 	pr0|676		verify_eis
001266  aa   000001 1760 07	sbq  	1,dl
001267  aa  6 00166 7561 00	stq  	pr6|118		l
						STATEMENT 1 ON LINE 369
	if l < 0 then l = tl;

001270  aa   000003 6050 04	tpl  	3,ic		001273
001271  aa  6 00110 2361 00	ldq  	pr6|72		tl
001272  aa  6 00166 7561 00	stq  	pr6|118		l
						STATEMENT 1 ON LINE 370
	if l = 0 then go to next_field;

001273  aa   000034 6000 04	tze  	28,ic		001327
						STATEMENT 1 ON LINE 371
	reentry_point (i) = fi + l - 1;

001274  aa  6 00112 0761 00	adq  	pr6|74		fi
001275  aa   000001 1760 07	sbq  	1,dl
001276  aa  6 00140 7561 17	stq  	pr6|96,7		reentry_point
						STATEMENT 1 ON LINE 372
	j = 0;

001277  aa  6 00114 4501 00	stz  	pr6|76		j
						STATEMENT 1 ON LINE 373
	go to found_field;

001300  aa   000021 7100 04	tra  	17,ic		001321
						STATEMENT 1 ON LINE 375
string_search (5):					/* Dots. */
	if tl < l then go to fail_retry;

001301  aa  6 00110 2361 00	ldq  	pr6|72		tl
001302  aa  6 00166 1161 00	cmpq 	pr6|118		l
001303  aa   000045 6040 04	tmi  	37,ic		001350
						STATEMENT 1 ON LINE 377
	j = 0;

001304  aa  6 00114 4501 00	stz  	pr6|76		j
						STATEMENT 1 ON LINE 378
	if index (substr (fp -> text, fi, l), nl) ^= 0	/* Dot does not match a newline. */
	then go to fail_retry;

001305  aa  6 00112 2351 00	lda  	pr6|74		fi
001306  aa  6 00102 3715 20	epp5 	pr6|66,*		fp
001307  aa  6 00166 7261 00	lxl6 	pr6|118		l
001310  aa  000 003 124 545	scm  	(pr,rl,al),(du),mask(000)
001311  aa  5 77777 60 0016	desc9a	pr5|-1(3),x6	text
001312  aa   012000 00 0001	desc9a	5120,1
001313  aa  6 00056 0001 00	arg  	pr6|46
001314  aa  6 00056 2361 00	ldq  	pr6|46
001315  aa   000002 6070 04	ttf  	2,ic		001317
001316  aa   000001 3360 07	lcq  	1,dl
001317  aa   000001 0760 07	adq  	1,dl
001320  aa   000030 6010 04	tnz  	24,ic		001350
						STATEMENT 1 ON LINE 381
found_field:					/* Code to store a match. */
	fi = fi + j + l;

001321  aa  6 00112 2361 00	ldq  	pr6|74		fi
001322  aa  6 00114 0761 00	adq  	pr6|76		j
001323  aa  6 00166 0761 00	adq  	pr6|118		l
001324  aa  6 00112 7561 00	stq  	pr6|74		fi
						STATEMENT 1 ON LINE 383
	te = fi - 1;

001325  aa   000001 1760 07	sbq  	1,dl
001326  aa  6 00111 7561 00	stq  	pr6|73		te
						STATEMENT 1 ON LINE 385
next_field:					/* Get next subexpression. */
	i = i + 1;

001327  aa  6 00165 0541 00	aos  	pr6|117		i
						STATEMENT 1 ON LINE 387
	if i <= rd.regl then go to search_loop;

001330  aa  6 00165 2361 00	ldq  	pr6|117		i
001331  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001332  aa  7 00024 1161 00	cmpq 	pr7|20		rd.regl
001333  aa   777425 6044 04	tmoz 	-235,ic		000760
						STATEMENT 1 ON LINE 388
	if rd.omit_newline				/* If last char is "$", do not match final newline. */
	then te = te - 1;

001334  aa  7 00025 2351 00	lda  	pr7|21		rd.omit_newline
001335  aa   000003 6000 04	tze  	3,ic		001340
001336  aa   000001 3360 07	lcq  	1,dl
001337  aa  6 00111 0561 00	asq  	pr6|73		te
						STATEMENT 1 ON LINE 390
	ami = match_start (1);

001340  aa  6 00115 2361 00	ldq  	pr6|77		match_start
001341  aa  6 00214 7561 20	stq  	pr6|140,*		ami
						STATEMENT 1 ON LINE 391
	ame = te;

001342  aa  6 00111 2361 00	ldq  	pr6|73		te
001343  aa  6 00216 7561 20	stq  	pr6|142,*		ame
						STATEMENT 1 ON LINE 392
	acode = 0;

001344  aa  6 00220 4501 20	stz  	pr6|144,*		acode
						STATEMENT 1 ON LINE 393
	return;

001345  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 395
fail_reset:					/* A reentry point is no longer valid. Reset it. */
	reentry_point (i) = 0;

001346  aa  6 00165 7271 00	lxl7 	pr6|117		i
001347  aa  6 00140 4501 17	stz  	pr6|96,7		reentry_point
						STATEMENT 1 ON LINE 398
fail_retry:					/* A subexpression failed.  Iterate if possible. */
	i = i - 1;

001350  aa   000001 3360 07	lcq  	1,dl
001351  aa  6 00165 0561 00	asq  	pr6|117		i
						STATEMENT 1 ON LINE 400
	if i <= 0 then do;

001352  aa  6 00165 2361 00	ldq  	pr6|117		i
001353  aa   000020 6054 04	tpnz 	16,ic		001373
						STATEMENT 1 ON LINE 401
	     match_start (1) = match_start (1) + 1;

001354  aa  6 00115 0541 00	aos  	pr6|77		match_start
						STATEMENT 1 ON LINE 402
	     if match_start (1) > fe			/* Search fails on empty buffer. */
	     then do;

001355  aa  6 00115 2361 00	ldq  	pr6|77		match_start
001356  aa  6 00113 1161 00	cmpq 	pr6|75		fe
001357  aa   000012 6044 04	tmoz 	10,ic		001371
						STATEMENT 1 ON LINE 404
fail:						/* Regular expression cannot be matched. */
		if silent_sw then
		     acode = error_table_$nomatch;

001360  aa  6 00104 2351 00	lda  	pr6|68		silent_sw
001361  aa   000005 6000 04	tze  	5,ic		001366
001362  aa  6 00044 3701 20	epp4 	pr6|36,*
001363  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$nomatch
001364  aa  6 00220 7561 20	stq  	pr6|144,*		acode
001365  aa   000003 7100 04	tra  	3,ic		001370
						STATEMENT 1 ON LINE 407
		else acode = 1;

001366  aa   000001 2360 07	ldq  	1,dl
001367  aa  6 00220 7561 20	stq  	pr6|144,*		acode
						STATEMENT 1 ON LINE 408
		return;

001370  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 409
	     end;

						STATEMENT 1 ON LINE 410
	     fi = match_start (1);

001371  aa  6 00112 7561 00	stq  	pr6|74		fi
						STATEMENT 1 ON LINE 411
	     go to restart_search;

001372  aa   777356 7100 04	tra  	-274,ic		000750
						STATEMENT 1 ON LINE 412
	end;

						STATEMENT 1 ON LINE 413
	fi = reentry_point (i);

001373  aa  6 00140 2361 06	ldq  	pr6|96,ql		reentry_point
001374  aa  6 00112 7561 00	stq  	pr6|74		fi
						STATEMENT 1 ON LINE 414
	if fi = 0 then go to fail_retry;

001375  aa   777753 6000 04	tze  	-21,ic		001350
						STATEMENT 1 ON LINE 415
	st = rd.reg_info (i).start;

001376  aa  6 00165 7271 00	lxl7 	pr6|117		i
001377  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001400  aa  7 77777 2351 17	lda  	pr7|-1,7		rd.start
001401  aa   000022 7350 00	als  	18
001402  aa   000077 7330 00	lrs  	63
001403  aa  6 00170 7561 00	stq  	pr6|120		st
						STATEMENT 1 ON LINE 416
	if rd.reg_info (i).search_type = 2 then go to search_loop;

001404  aa  7 77777 2351 17	lda  	pr7|-1,7		rd.search_type
001405  aa   000033 7350 00	als  	27
001406  aa   000077 7330 00	lrs  	63
001407  aa   000002 1160 07	cmpq 	2,dl
001410  aa   777350 6000 04	tze  	-280,ic		000760
						STATEMENT 1 ON LINE 418
	if reentry_point (i) < match_start (i) then go to fail_reset;

001411  aa  6 00140 2361 17	ldq  	pr6|96,7		reentry_point
001412  aa  6 00114 1161 17	cmpq 	pr6|76,7		match_start
001413  aa   777733 6040 04	tmi  	-37,ic		001346
						STATEMENT 1 ON LINE 420
	reentry_point (i) = reentry_point (i) - 1;

001414  aa   000001 3360 07	lcq  	1,dl
001415  aa  6 00140 0561 17	asq  	pr6|96,7		reentry_point
						STATEMENT 1 ON LINE 421
	go to next_field;

001416  aa   777711 7100 04	tra  	-55,ic		001327
ENTRY TO init                                               STATEMENT 1 ON LINE 425
init:
     entry (P_qid_ptr);

001417  at     000001000025
001420  ta     001417000000
001421  da     000117300000
001422  aa   000320 6270 00	eax7 	208
001423  aa  7 00034 3521 20	epp2 	pr7|28,*
001424  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001425  aa     000002000000
001426  aa     000000000000
						STATEMENT 1 ON LINE 428
	qid_ptr = P_qid_ptr;

001427  aa  6 00032 3735 20	epp7 	pr6|26,*
001430  aa  7 00002 3715 20	epp5 	pr7|2,*		P_qid_ptr
001431  aa  5 00000 3715 20	epp5 	pr5|0,*		P_qid_ptr
001432  aa  6 00176 6515 00	spri5	pr6|126		qid_ptr
						STATEMENT 1 ON LINE 430
	allocate rd in (editor_area) set (rd_ptr);

001433  aa   000067 2360 07	ldq  	55,dl
001434  aa  6 00176 3735 20	epp7 	pr6|126,*		qid_ptr
001435  aa  7 00022 3521 20	epp2 	pr7|18,*		editor_area
001436  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
001437  aa   777774 7100 04	tra  	-4,ic		001433
001440  aa  6 00174 2521 00	spri2	pr6|124		rd_ptr
						STATEMENT 1 ON LINE 431
	rd.regl = 0;

001441  aa  2 00024 4501 00	stz  	pr2|20		rd.regl
						STATEMENT 1 ON LINE 433
	qid.regexp_data_ptr = rd_ptr;

001442  aa  6 00176 3735 20	epp7 	pr6|126,*		qid_ptr
001443  aa  7 00030 2521 00	spri2	pr7|24		qid.regexp_data_ptr
						STATEMENT 1 ON LINE 435
	return;

001444  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO cleanup                                            STATEMENT 1 ON LINE 440
cleanup:
     entry (P_qid_ptr);

001445  ta     001417000000
001446  da     000124300000
001447  aa   000320 6270 00	eax7 	208
001450  aa  7 00034 3521 20	epp2 	pr7|28,*
001451  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001452  aa     000002000000
001453  aa     000000000000
						STATEMENT 1 ON LINE 443
	qid_ptr = P_qid_ptr;

001454  aa  6 00032 3735 20	epp7 	pr6|26,*
001455  aa  7 00002 3715 20	epp5 	pr7|2,*		P_qid_ptr
001456  aa  5 00000 3715 20	epp5 	pr5|0,*		P_qid_ptr
001457  aa  6 00176 6515 00	spri5	pr6|126		qid_ptr
						STATEMENT 1 ON LINE 445
	if qid.regexp_data_ptr ^= null () then do;

001460  aa  5 00030 2371 00	ldaq 	pr5|24		qid.regexp_data_ptr
001461  aa   776345 6770 04	eraq 	-795,ic		000026 = 077777000043 000001000000
001462  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001463  aa   000006 6000 04	tze  	6,ic		001471
						STATEMENT 1 ON LINE 446
	     free qid.regexp_data_ptr -> rd in (editor_area);

001464  aa  5 00030 3715 00	epp5 	pr5|24		qid.regexp_data_ptr
001465  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 447
	     qid.regexp_data_ptr = null ();

001466  aa   776340 2370 04	ldaq 	-800,ic		000026 = 077777000043 000001000000
001467  aa  6 00176 3735 20	epp7 	pr6|126,*		qid_ptr
001470  aa  7 00030 7571 00	staq 	pr7|24		qid.regexp_data_ptr
						STATEMENT 1 ON LINE 448
	end;

						STATEMENT 1 ON LINE 450
	return;

001471  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 541
     end search_file_;

BEGIN PROCEDURE end_sub_expression
ENTRY TO end_sub_expression                                 STATEMENT 1 ON LINE 454
end_sub_expression:
     procedure ();

001472  aa  6 00224 6501 00	spri4	pr6|148
						STATEMENT 1 ON LINE 459
	if l > 0 | type = 1				/* If current search string subexpression outstanding. */
	then do;

001473  aa  6 00166 2361 00	ldq  	pr6|118		l
001474  aa   000004 6054 04	tpnz 	4,ic		001500
001475  aa  6 00167 2361 00	ldq  	pr6|119		type
001476  aa   000001 1160 07	cmpq 	1,dl
001477  aa   000150 6010 04	tnz  	104,ic		001647
						STATEMENT 1 ON LINE 461
	     if type = 2				/* A string search preceded by ".*". */
	     then do;

001500  aa  6 00167 2361 00	ldq  	pr6|119		type
001501  aa   000002 1160 07	cmpq 	2,dl
001502  aa   000046 6010 04	tnz  	38,ic		001550
						STATEMENT 1 ON LINE 463
		dot_count = 0;

001503  aa  6 00232 4501 00	stz  	pr6|154		dot_count
						STATEMENT 1 ON LINE 464
		do ir = rd.regl to last_string + 1 by -1;

001504  aa  6 00171 2361 00	ldq  	pr6|121		last_string
001505  aa   000001 0760 07	adq  	1,dl
001506  aa  6 00234 7561 00	stq  	pr6|156
001507  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001510  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
001511  aa  6 00233 7561 00	stq  	pr6|155		ir
001512  aa  6 00233 2361 00	ldq  	pr6|155		ir
001513  aa  6 00234 1161 00	cmpq 	pr6|156
001514  aa   000025 6040 04	tmi  	21,ic		001541
						STATEMENT 1 ON LINE 466
		     if rd.reg_info (ir).search_type = 5/* A dot subexpressionn. */
		     then dot_count = dot_count + rd.reg_info (ir).len;

001515  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001516  aa  7 77777 2351 06	lda  	pr7|-1,ql		rd.search_type
001517  aa   000033 7350 00	als  	27
001520  aa   000077 7330 00	lrs  	63
001521  aa  6 00277 7561 00	stq  	pr6|191		rd.search_type
001522  aa   000005 1160 07	cmpq 	5,dl
001523  aa   000007 6010 04	tnz  	7,ic		001532
001524  aa  6 00233 7271 00	lxl7 	pr6|155		ir
001525  aa  7 77777 2351 17	lda  	pr7|-1,7		rd.len
001526  aa   000011 7350 00	als  	9
001527  aa   000077 7330 00	lrs  	63
001530  aa  6 00232 0561 00	asq  	pr6|154		dot_count
001531  aa   000003 7100 04	tra  	3,ic		001534
						STATEMENT 1 ON LINE 469
		     else if rd.reg_info (ir).search_type ^= 4
						/* A star subexpression. */
		     then go to done_dot_star;

001532  aa   000004 1160 07	cmpq 	4,dl
001533  aa   000006 6010 04	tnz  	6,ic		001541
						STATEMENT 1 ON LINE 472
		     rd.regl = rd.regl - 1;

001534  aa   000001 3360 07	lcq  	1,dl
001535  aa  7 00024 0561 00	asq  	pr7|20		rd.regl
						STATEMENT 1 ON LINE 473
		end;

001536  aa   000001 3360 07	lcq  	1,dl
001537  aa  6 00233 0561 00	asq  	pr6|155		ir
001540  aa   777752 7100 04	tra  	-22,ic		001512
						STATEMENT 1 ON LINE 474
done_dot_star:
		if dot_count > 0 then call builder (5, dot_count);

001541  aa  6 00232 2361 00	ldq  	pr6|154		dot_count
001542  aa   000005 6044 04	tmoz 	5,ic		001547
001543  aa   000005 2360 07	ldq  	5,dl
001544  aa  6 00277 7561 00	stq  	pr6|191
001545  aa   000161 3520 04	epp2 	113,ic		001726 = 000004000000
001546  aa   000102 6700 04	tsp4 	66,ic		001650
						STATEMENT 1 ON LINE 477
		last_star = 0;

001547  aa  6 00172 4501 00	stz  	pr6|122		last_star
						STATEMENT 1 ON LINE 478
	     end;

						STATEMENT 1 ON LINE 479
	     if last_string = rd.regl - 1 & last_star = rd.regl
						/* Optimize ab*b to abb*. Also b*b to bb*. */
	     then do;

001550  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001551  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
001552  aa   000001 1760 07	sbq  	1,dl
001553  aa  6 00171 1161 00	cmpq 	pr6|121		last_string
001554  aa   000061 6010 04	tnz  	49,ic		001635
001555  aa  6 00172 2361 00	ldq  	pr6|122		last_star
001556  aa  7 00024 1161 00	cmpq 	pr7|20		rd.regl
001557  aa   000056 6010 04	tnz  	46,ic		001635
						STATEMENT 1 ON LINE 482
		ir = verify (substr (rd.reg, st, l), rd.reg_info (last_star).search_char) - 1;

001560  aa  6 00170 7271 00	lxl7 	pr6|120		st
001561  aa   000003 6270 17	eax7 	3,7
001562  aa  7 00025 3521 00	epp2 	pr7|21		rd.reg
001563  aa  2 00000 5005 17	a9bd 	pr2|0,7
001564  aa  6 00166 2361 00	ldq  	pr6|118		l
001565  aa  6 00172 7261 00	lxl6 	pr6|122		last_star
001566  aa  7 77777 3515 16	epp1 	pr7|-1,6		rd.search_char
001567  aa   000001 2350 07	lda  	1,dl
001570  aa  0 01244 7001 00	tsx0 	pr0|676		verify_eis
001571  aa   000001 1760 07	sbq  	1,dl
001572  aa  6 00233 7561 00	stq  	pr6|155		ir
						STATEMENT 1 ON LINE 483
		if ir < 0 then ir = l;

001573  aa   000003 6050 04	tpl  	3,ic		001576
001574  aa  6 00166 2361 00	ldq  	pr6|118		l
001575  aa  6 00233 7561 00	stq  	pr6|155		ir
						STATEMENT 1 ON LINE 484
		if ir > 0				/* Move the matches to the previous string. */
		then do;

001576  aa   000037 6044 04	tmoz 	31,ic		001635
						STATEMENT 1 ON LINE 486
		     if last_string = 0		/* Oops, there was really no previous string. */
		     then do;

001577  aa  6 00171 2361 00	ldq  	pr6|121		last_string
001600  aa   000016 6010 04	tnz  	14,ic		001616
						STATEMENT 1 ON LINE 488
			last_string = 1;

001601  aa   000001 2360 07	ldq  	1,dl
001602  aa  6 00171 7561 00	stq  	pr6|121		last_string
						STATEMENT 1 ON LINE 489
			unspec (rd.reg_info (2)) = unspec (rd.reg_info (1));

001603  aa  7 00000 2351 00	lda  	pr7|0
001604  aa  7 00001 7551 00	sta  	pr7|1
						STATEMENT 1 ON LINE 491
			last_star = last_star + 1;

001605  aa  6 00172 0541 00	aos  	pr6|122		last_star
						STATEMENT 1 ON LINE 492
			rd.reg_info (2).start = ir + 1;

001606  aa  6 00233 2361 00	ldq  	pr6|155		ir
001607  aa   000001 0760 07	adq  	1,dl
001610  aa   000055 7370 00	lls  	45
001611  aa  7 00001 5511 10	stba 	pr7|1,10		rd.start
						STATEMENT 1 ON LINE 494
			rd.reg_info (1).search_type = 0;

001612  aa   000000 2350 03	lda  	0,du
001613  aa  7 00000 5511 04	stba 	pr7|0,04		rd.search_type
						STATEMENT 1 ON LINE 496
			rd.regl = 2;

001614  aa   000002 2360 07	ldq  	2,dl
001615  aa  7 00024 7561 00	stq  	pr7|20		rd.regl
						STATEMENT 1 ON LINE 497
		     end;

						STATEMENT 1 ON LINE 498
		     rd.reg_info (last_string).len = rd.reg_info (last_string).len + ir;

001616  aa  6 00171 7261 00	lxl6 	pr6|121		last_string
001617  aa  7 77777 2351 16	lda  	pr7|-1,6		rd.len
001620  aa   000011 7350 00	als  	9
001621  aa   000077 7330 00	lrs  	63
001622  aa  6 00233 0761 00	adq  	pr6|155		ir
001623  aa   000066 7370 00	lls  	54
001624  aa  7 77777 3715 16	epp5 	pr7|-1,6		rd.len
001625  aa  5 00000 5511 20	stba 	pr5|0,20		rd.len
						STATEMENT 1 ON LINE 500
		     st = st + ir;

001626  aa  6 00233 2361 00	ldq  	pr6|155		ir
001627  aa  6 00170 0561 00	asq  	pr6|120		st
						STATEMENT 1 ON LINE 501
		     l = l - ir;

001630  aa  6 00233 3361 00	lcq  	pr6|155		ir
001631  aa  6 00166 0561 00	asq  	pr6|118		l
						STATEMENT 1 ON LINE 502
		     if l = 0 then return;

001632  aa  6 00166 2361 00	ldq  	pr6|118		l
001633  aa   000002 6010 04	tnz  	2,ic		001635
001634  aa  6 00224 6101 00	rtcd 	pr6|148
						STATEMENT 1 ON LINE 503
		end;

						STATEMENT 1 ON LINE 504
	     end;

						STATEMENT 1 ON LINE 505
	     call builder (type, l);

001635  aa   000063 3520 04	epp2 	51,ic		001720 = 000004000000
001636  aa   000012 6700 04	tsp4 	10,ic		001650
						STATEMENT 1 ON LINE 506
	     type = 3;

001637  aa   000003 2360 07	ldq  	3,dl
001640  aa  6 00167 7561 00	stq  	pr6|119		type
						STATEMENT 1 ON LINE 507
	     last_string = rd.regl;

001641  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001642  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
001643  aa  6 00171 7561 00	stq  	pr6|121		last_string
						STATEMENT 1 ON LINE 508
	     st = st + l;

001644  aa  6 00166 2361 00	ldq  	pr6|118		l
001645  aa  6 00170 0561 00	asq  	pr6|120		st
						STATEMENT 1 ON LINE 509
	     l = 0;

001646  aa  6 00166 4501 00	stz  	pr6|118		l
						STATEMENT 1 ON LINE 510
	end;

						STATEMENT 1 ON LINE 512
	return;

001647  aa  6 00224 6101 00	rtcd 	pr6|148
						STATEMENT 1 ON LINE 514
     end end_sub_expression;

  END PROCEDURE end_sub_expression
BEGIN PROCEDURE builder
ENTRY TO builder                                            STATEMENT 1 ON LINE 518
builder:
     procedure (id, size);

001650  aa  6 00236 6501 00	spri4	pr6|158
001651  aa  6 00240 2521 00	spri2	pr6|160
						STATEMENT 1 ON LINE 523
	if rd.regl = hbound (rd.reg_info, 1)		/* Insure we have not exceeded the stack. */
	then do;

001652  aa  6 00174 3735 20	epp7 	pr6|124,*		rd_ptr
001653  aa  7 00024 2361 00	ldq  	pr7|20		rd.regl
001654  aa   000024 1160 07	cmpq 	20,dl
001655  aa   000024 6010 04	tnz  	20,ic		001701
						STATEMENT 1 ON LINE 525
	     if silent_sw then
		acode = error_table_$regexp_too_complex;

001656  aa  6 00104 2351 00	lda  	pr6|68		silent_sw
001657  aa   000005 6000 04	tze  	5,ic		001664
001660  aa  6 00044 3701 20	epp4 	pr6|36,*
001661  la  4 00104 2361 20	ldq  	pr4|68,*		error_table_$regexp_too_complex
001662  aa  6 00220 7561 20	stq  	pr6|144,*		acode
001663  aa   000015 7100 04	tra  	13,ic		001700
						STATEMENT 1 ON LINE 527
	     else call ioa_ ("Regular expression is too complex.");

001664  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001665  aa   776154 00 0044	desc9a	-916,36		000040 = 122145147165
001666  aa  6 00300 00 0044	desc9a	pr6|192,36
001667  aa  6 00300 3521 00	epp2 	pr6|192
001670  aa  6 00314 2521 00	spri2	pr6|204
001671  aa   776125 3520 04	epp2 	-939,ic		000016 = 524000000042
001672  aa  6 00316 2521 00	spri2	pr6|206
001673  aa  6 00312 6211 00	eax1 	pr6|202
001674  aa   004000 4310 07	fld  	2048,dl
001675  aa  6 00044 3701 20	epp4 	pr6|36,*
001676  la  4 00112 3521 20	epp2 	pr4|74,*		ioa_
001677  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 528
	     go to fatal;

001700  aa   776426 7100 04	tra  	-746,ic		000326
						STATEMENT 1 ON LINE 529
	end;

						STATEMENT 1 ON LINE 530
	rd.regl = rd.regl + 1;

001701  aa  7 00024 0541 00	aos  	pr7|20		rd.regl
						STATEMENT 1 ON LINE 531
	rd.reg_info (rd.regl).search_type = id;

001702  aa  2 00002 2361 20	ldq  	pr2|2,*		id
001703  aa  7 00024 7271 00	lxl7 	pr7|20		rd.regl
001704  aa  7 77777 3715 17	epp5 	pr7|-1,7		rd.search_type
001705  aa  5 00000 5521 04	stbq 	pr5|0,04		rd.search_type
						STATEMENT 1 ON LINE 532
	rd.reg_info (rd.regl).len = size;

001706  aa  2 00004 2361 20	ldq  	pr2|4,*		size
001707  aa   000066 7370 00	lls  	54
001710  aa  7 77777 3715 17	epp5 	pr7|-1,7		rd.len
001711  aa  5 00000 5511 20	stba 	pr5|0,20		rd.len
						STATEMENT 1 ON LINE 533
	rd.reg_info (rd.regl).start = st;

001712  aa  6 00170 2361 00	ldq  	pr6|120		st
001713  aa   000055 7370 00	lls  	45
001714  aa  7 77777 3715 17	epp5 	pr7|-1,7		rd.start
001715  aa  5 00000 5511 10	stba 	pr5|0,10		rd.start
						STATEMENT 1 ON LINE 535
	return;

001716  aa  6 00236 6101 00	rtcd 	pr6|158
						STATEMENT 1 ON LINE 537
     end builder;

  END PROCEDURE builder
  END PROCEDURE search_file_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
