	COMPILATION LISTING OF SEGMENT mcs_trace
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1110.98_Tue_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* format: style3,linecom,ifthenstmt,ifthendo,ifthen,^indnoniterdo,indnoniterend,indcomtxt,^inditerdo,indend,idind30 */
        9 mcs_trace:
       10      procedure (Devx);
       11 
       12 /* Routine for tracing events in ring 0 MCS. */
       13 /* Written by C. Hornig, September 1979. */
       14 
       15 dcl	Devx			fixed bin parameter;
       16 dcl	Chainp			pointer parameter;
       17 
  1     1 /* Begin include file mcs_trace_data.incl.pl1 */
  1     2 
  1     3 dcl (trace_array_ptr, trace_entry_ptr) pointer;
  1     4 dcl  trace_array_size uns fixed bin (18);
  1     5 
  1     6 dcl 1 trace_array aligned based (trace_array_ptr),	/* trace control information */
  1     7     2 num_entries uns fixed bin (18),			/* number of entries in trace table */
  1     8     2 idx bit (36) aligned,				/* index of next entry to use */
  1     9     2 entry (trace_array_size refer (trace_array.num_entries)) aligned like trace_entry;
  1    10 
  1    11 dcl 1 trace_entry aligned based (trace_entry_ptr),
  1    12     2 time fixed bin (71),				/* time sample taken */
  1    13     2 devx unsigned fixed bin (18) unaligned,		/* channel traced */
  1    14     2 message char (54) unaligned;
  1    15 
  1    16 /* End include file mcs_trace_data.incl.pl1 */
       18 
       19 
       20 dcl	formline_			entry (fixed bin, fixed bin, pointer, fixed bin (21), fixed bin);
       21 
       22 dcl	initialized		bit aligned internal static init ("0"b);
       23 dcl	mapc			character (512) aligned internal static init ("");
       24 
       25 dcl	(my_idx, next_idx)		fixed bin (35) aligned;
       26 dcl	(bsize, i)		fixed bin;
       27 
       28 dcl	bwords			(256) bit (36) aligned based (blockp);
       29 
       30 dcl	(addr, binary, bit, clock, length, pointer, stacq)
       31 				builtin;
       32 
       33 /* * * * * * * * * * * * * * * * * * * */
       34 
       35 	call setup;
       36 	call get_entry;
       37 	call formline_ (2, 3, addr (trace_entry.message), length (trace_entry.message), 1);
       38 return_to_caller:
       39 	return;
       40 
       41 /* * * * * * * * * * BUFFER_CHAIN * * * * * * * * * */
       42 
       43 buffer_chain:
       44      entry (Devx, Chainp);
       45 
       46 	call setup;
       47 	do blockp = Chainp repeat (pointer (ttybp, buffer.next)) while (rel (blockp) ^= ""b);
       48 	     bsize = 16 * (1 + buffer.size_code);
       49 	     call fill_in (" ^d words at ^6.3b; ^d chars; flags: ^[eop,^]^[conv,^]^[break^]", bsize, rel (blockp),
       50 		buffer.tally, buffer.flags.end_of_page, buffer.flags.converted, buffer.flags.break);
       51 	     do i = 1 by 2 to bsize;
       52 		if (bwords (i) | bwords (i + 1)) ^= ""b then
       53 		     call fill_in (" ^2d: ^w ^w ^8a", (i - 1) * 4, bwords (i), bwords (i + 1),
       54 			translate (substr (string (buffer.chars), i * 4 - 7, 8), mapc));
       55 		end;
       56 	     end;
       57 	return;
       58 
       59 /* * * * * * * * * * INIT * * * * * * * * * */
       60 
       61 setup:
       62      procedure;
       63 	ttybp = addr (tty_buf$);
       64 	if ^initialized then do;
       65 	     mapc = copy (".", 32) || substr (collate9 (), 33, 95) || copy (".", 385);
       66 	     initialized = "1"b;
       67 	     end;
       68 	if ^tty_buf.trace.enable then goto return_to_caller;
       69 	if tty_buf.trace.data_offset = ""b then goto return_to_caller;
       70 	trace_array_ptr = pointer (ttybp, tty_buf.trace.data_offset);
       71 	if trace_array.num_entries = 0 then goto return_to_caller;
       72 	lctep = addr (tty_buf.lct_ptr -> lct.lcte_array (Devx));
       73 	if lcte.flags.trace = (tty_buf.trace.default_mode & ^lcte.flags.trace_force) then goto return_to_caller;
       74      end setup;
       75 
       76 /* * * * * * * * * * GET_ENTRY * * * * * * * * * */
       77 
       78 get_entry:
       79      procedure;
       80 snarf_trace_entry:
       81 	my_idx = binary (trace_array.idx);		/* idx is where our message will go */
       82 	next_idx = my_idx + 1;
       83 	if next_idx > trace_array.num_entries then next_idx = 1;
       84 						/* where next entry will go */
       85 	if ^stacq (trace_array.idx, unspec (next_idx), unspec (my_idx)) then goto snarf_trace_entry;
       86 						/* now grab the entry */
       87 	trace_entry_ptr = addr (trace_array.entry (my_idx));
       88 	trace_entry.time = clock ();
       89 	trace_entry.devx = Devx;
       90      end get_entry;
       91 
       92 /* * * * * * * * * * FILL_IN * * * * * * * * * */
       93 
       94 fill_in:
       95      procedure options (variable, non_quick);
       96 	call get_entry;
       97 	call formline_ (1, 2, addr (trace_entry.message), length (trace_entry.message), 1);
       98      end fill_in;
       99 
  2     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  2     2 
  2     3 /* Date Last Modified and Reason
  2     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  2     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  2     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  2     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  2     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  2     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  2    10*   Modified November 1979 by C. Hornig for MCS tracing.
  2    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  2    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  2    13*   Modified March 1980 by Robert Coren to reorganize metering information
  2    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  2    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  2    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  2    17**/
  2    18 
  2    19 dcl  ttybp ptr,
  2    20      tty_buf$ ext static,				/* tty buffer segment */
  2    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  2    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  2    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  2    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  2    25 
  2    26 
  2    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  2    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  2    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  2    30 
  2    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  2    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  2    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  2    34 
  2    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  2    36     2 slock bit (36),				/* per system lock */
  2    37     2 absorig fixed bin (24),				/* abs address of this seg */
  2    38     2 borig bit (18),				/* index of start of buffer area */
  2    39     2 bleft fixed bin (18),				/* words left in pool */
  2    40     2 free bit (18),				/* pointer to start of free pool */
  2    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  2    42     2 padb1 bit (28) unaligned,
  2    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  2    44 
  2    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  2    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  2    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  2    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  2    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  2    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  2    51     2 minbuf fixed bin (18),				/* min output buffer size */
  2    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  2    53 
  2    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  2    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  2    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  2    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  2    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  2    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  2    60 
  2    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  2    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  2    63     2 bfx fixed bin,				/* used in calls to iobm */
  2    64     2 nquits fixed bin (35),				/* number of quits */
  2    65     2 space_needed_data,
  2    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  2    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  2    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  2    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  2    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  2    71 
  2    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  2    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  2    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  2    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  2    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  2    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  2    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  2    79 
  2    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  2    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  2    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  2    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  2    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  2    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  2    86 
  2    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  2    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  2    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  2    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  2    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  2    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  2    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  2    94 
  2    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  2    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  2    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  2    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  2    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  2   100     2 echo_neg_mux_nonecho fixed bin (35),
  2   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  2   102 
  2   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  2   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  2   105     2 trace unaligned,				/* tracing information */
  2   106       3 flags,
  2   107       4 enable bit,					/* global tracing control */
  2   108       4 default_mode bit,				/* whether to trace channels by default */
  2   109       4 read bit,					/* read */
  2   110       4 write bit,					/* write */
  2   111       4 data bit,					/* buffers on reads and writes */
  2   112       4 control bit,				/* control, priv_control, and hpriv_control */
  2   113       4 modes bit,					/* (get set check)_modes */
  2   114       4 interrupt bit,				/* interrupt, interrupt_later */
  2   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  2   116       4 start bit,					/* start, stop */
  2   117       4 shutdown bit,				/* shutdown */
  2   118       4 space_man bit,				/* tty_space_man$* */
  2   119       4 pad_flags bit (6),
  2   120       3 data_offset bit (18),				/* offset of tracing data */
  2   121 
  2   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  2   123 
  2   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  2   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  2   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  2   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  2   128 
  2   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  2   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  2   131 
  2   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  2   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  2   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  2   135 
  2   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  2   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  2   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  2   139 
  2   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  2   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  2   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  2   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  2   144 
  2   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  2   146 
  2   147     2 pad2 (13) fixed bin (35),
  2   148 
  2   149     2 free_space fixed bin;				/* start of free space region */
  2   150 
  2   151 
  3     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  3     2 
  3     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  3     4 
  3     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     6 
  3     7 /* format: style3 */
  3     8 
  3     9 declare	lock_ptr		pointer;
  3    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  3    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    13 	  2 flags		aligned,
  3    14 	    3 notify_sw	bit (1) unaligned,
  3    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    16 
  3    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2   152 
  2   153 
  2   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      100 
  4     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      101 
  5     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  5     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  5     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  5     9*     implementation.
  5    10*                                                   END HISTORY COMMENTS */
  5    11 
  5    12 
  5    13 /*
  5    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  5    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  5    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  5    17**/
  5    18 
  5    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  5    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  5    21 
  5    22 
  5    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  5    24     2 next bit (18),				/* foward pointer to next free block */
  5    25     2 size fixed bin;				/* number of words in this block */
  5    26 
  5    27 
  5    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  5    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  5    30     2 flags unaligned,
  5    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  5    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  5    33       3 break bit (1) unaligned,			/* buffer contains break character */
  5    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  5    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  5    36       3 pad bit (1) unaligned,
  5    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  5    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  5    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  5    40 
  5    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  5    42 
  5    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  5    44 
  5    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      102 
      103 
      104      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1110.9  mcs_trace.pl1                     >udd>sm>ds>w>ml>mcs_trace.pl1
18           1    06/30/80  1500.3  mcs_trace_data.incl.pl1           >ldd>incl>mcs_trace_data.incl.pl1
100          2    01/06/85  1522.1  tty_buf.incl.pl1                  >ldd>incl>tty_buf.incl.pl1
2-152        3    01/06/85  1522.1  hc_fast_lock.incl.pl1             >ldd>incl>hc_fast_lock.incl.pl1
101          4    11/08/82  1105.8  lct.incl.pl1                      >ldd>incl>lct.incl.pl1
102          5    07/21/88  2136.0  tty_buffer_block.incl.pl1         >ldd>incl>tty_buffer_block.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Chainp                                 parameter       pointer                  dcl 16 ref 43 47
Devx                                   parameter       fixed bin(17,0)          dcl 15 ref 9 43 72 89
addr                                                   builtin function         dcl 30 ref 37 37 63 72 87 97 97
binary                                                 builtin function         dcl 30 ref 80
blockp                          000114 automatic       pointer                  dcl 5-19 set ref 47* 47* 48 49 49 49 49 49 49 52 52
                                                                                  52 52 52 52* 56
break                     0(20)        based           bit(1)                   level 3 packed packed unaligned dcl 5-28 set ref 49*
bsize                           000106 automatic       fixed bin(17,0)          dcl 26 set ref 48* 49* 51
buffer                                 based           structure                level 1 dcl 5-28
bwords                                 based           bit(36)                  array dcl 28 set ref 52 52 52* 52*
chars                     1            based           char(1)                  array level 2 packed packed unaligned dcl 5-28 ref
                                                                                  52 52
clock                                                  builtin function         dcl 30 ref 88
converted                 0(19)        based           bit(1)                   level 3 packed packed unaligned dcl 5-28 set ref 49*
data_offset             102(18)        based           bit(18)                  level 3 packed packed unaligned dcl 2-35 ref 69 70
default_mode            102(01)        based           bit(1)                   level 4 packed packed unaligned dcl 2-35 ref 73
devx                      2            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-11
                                                                                  set ref 89*
enable                  102            based           bit(1)                   level 4 packed packed unaligned dcl 2-35 ref 68
end_of_page               0(18)        based           bit(1)                   level 3 packed packed unaligned dcl 5-28 set ref 49*
entry                     2            based           structure                array level 2 dcl 1-6 set ref 87
flags                   102            based           structure                level 3 in structure "tty_buf" packed packed
                                                                                  unaligned dcl 2-35 in procedure "mcs_trace"
flags                     2(09)        based           structure                level 2 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "mcs_trace"
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 5-28 in procedure "mcs_trace"
formline_                       000212 constant        entry                    external dcl 20 ref 37 97
hc_fast_lock                           based           structure                level 1 dcl 3-10
i                               000107 automatic       fixed bin(17,0)          dcl 26 set ref 51* 52 52 52 52 52 52 52*
idx                       1            based           bit(36)                  level 2 dcl 1-6 ref 80 85
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "mcs_trace"
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "mcs_trace"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "mcs_trace"
initialized                     000010 internal static bit(1)                   initial dcl 22 set ref 64 66*
lct                                    based           structure                level 1 dcl 4-11
lct_ptr                   6            based           pointer                  level 2 dcl 2-35 ref 72
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 72
lctep                           000112 automatic       pointer                  dcl 4-8 set ref 72* 73 73
length                                                 builtin function         dcl 30 ref 37 37 97 97
mapc                            000011 internal static char(512)                initial dcl 23 set ref 52 52 65*
message                   2(18)        based           char(54)                 level 2 packed packed unaligned dcl 1-11 set ref 37
                                                                                  37 37 37 97 97 97 97
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "mcs_trace"
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "mcs_trace"
my_idx                          000104 automatic       fixed bin(35,0)          dcl 25 set ref 80* 82 85 87
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-28
                                                                                  ref 56
next_idx                        000105 automatic       fixed bin(35,0)          dcl 25 set ref 82* 83 83* 85
num_entries                            based           fixed bin(18,0)          level 2 unsigned dcl 1-6 ref 71 83
pointer                                                builtin function         dcl 30 ref 56 70
size_code                 0(24)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 5-28
                                                                                  ref 48
stacq                                                  builtin function         dcl 30 ref 85
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-28
                                                                                  set ref 49*
time                                   based           fixed bin(71,0)          level 2 dcl 1-11 set ref 88*
trace                     2(16)        based           bit(1)                   level 3 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "mcs_trace" ref 73
trace                   102            based           structure                level 2 in structure "tty_buf" packed packed
                                                                                  unaligned dcl 2-35 in procedure "mcs_trace"
trace_array                            based           structure                level 1 dcl 1-6
trace_array_ptr                 000100 automatic       pointer                  dcl 1-3 set ref 70* 71 80 83 85 87
trace_entry                            based           structure                level 1 dcl 1-11
trace_entry_ptr                 000102 automatic       pointer                  dcl 1-3 set ref 37 37 37 37 87* 88 89 97 97 97 97
trace_force               2(15)        based           bit(1)                   level 3 packed packed unaligned dcl 4-20 ref 73
tty_buf                                based           structure                level 1 dcl 2-35
tty_buf$                        000214 external static fixed bin(17,0)          dcl 2-19 set ref 63
ttybp                           000110 automatic       pointer                  dcl 2-19 set ref 56 63* 68 69 70 70 72 73

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 2-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 2-32
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 2-33
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 2-19
bit                                                    builtin function         dcl 30
bsizec                                 internal static fixed bin(17,0)          initial dcl 2-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 2-29
free_block                             based           structure                level 1 dcl 5-23
free_blockp                            automatic       pointer                  dcl 5-20
input_bpart                            internal static fixed bin(18,0)          initial dcl 2-19
lcnt                                   based           structure                level 1 dcl 4-65
lcntp                                  automatic       pointer                  dcl 4-63
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
lctp                                   automatic       pointer                  dcl 4-7
lock_ptr                               automatic       pointer                  dcl 3-9
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 5-43
output_bpart                           internal static fixed bin(18,0)          initial dcl 2-19
qblock_size                            internal static fixed bin(17,0)          initial dcl 2-27
saved_meters                           based           structure                level 1 dcl 4-68
trace_array_size                       automatic       fixed bin(18,0)          unsigned dcl 1-4
tty_ev                                 internal static fixed bin(17,0)          initial dcl 2-19

NAMES DECLARED BY EXPLICIT CONTEXT.
buffer_chain                    000314 constant        entry                    external dcl 43
fill_in                         000653 constant        entry                    internal dcl 94 ref 49 52
get_entry                       000607 constant        entry                    internal dcl 78 ref 36 96
mcs_trace                       000241 constant        entry                    external dcl 9
return_to_caller                000307 constant        label                    dcl 38 ref 68 69 71 73
setup                           000511 constant        entry                    internal dcl 61 ref 35 46
snarf_trace_entry               000614 constant        label                    dcl 80 ref 85

NAMES DECLARED BY CONTEXT OR IMPLICATION.
collate9                                               builtin function         ref 65
copy                                                   builtin function         ref 65 65
rel                                                    builtin function         ref 47 49 49
string                                                 builtin function         ref 52 52
substr                                                 builtin function         ref 52 52 65
translate                                              builtin function         ref 52 52
unspec                                                 builtin function         ref 85 85

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1004        1222     723        1014
Length      1470     723       216         231      61         202

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mcs_trace                           250 external procedure  is an external procedure.  
setup                                   internal procedure  shares stack frame of external procedure mcs_trace.  
get_entry                            64 internal procedure  is called by several nonquick procedures.  
fill_in                              82 internal procedure  is declared options(non_quick), and is declared options(variable).  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 initialized                 mcs_trace
000011 mapc                        mcs_trace

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mcs_trace                000100 trace_array_ptr             mcs_trace
                         000102 trace_entry_ptr             mcs_trace
                         000104 my_idx                      mcs_trace
                         000105 next_idx                    mcs_trace
                         000106 bsize                       mcs_trace
                         000107 i                           mcs_trace
                         000110 ttybp                       mcs_trace
                         000112 lctep                       mcs_trace
                         000114 blockp                      mcs_trace

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out        call_int_this_desc  call_int_this       call_int_other
return_mac          shorten_stack       ext_entry           int_entry           set_chars_eis       translate_2
fetch_chars_eis     stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
formline_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
tty_buf$


CONSTANTS
000000  aa     524000000010

000001  aa     514000000044

000002  aa     404000000030

000003  aa     524000000017

000004  aa     516000000001

000005  aa     606000000011

000006  aa     514000000022

000007  aa     524000000077

000010  aa     464000000000

000011  aa     404000000021

000012  aa  040 136 062 144	 ^2d
000013  aa  072 040 136 167	: ^w
000014  aa  040 136 167 040	 ^w 
000015  aa  136 070 141 000	^8a

000016  aa  040 136 144 040	 ^d 
000017  aa  167 157 162 144	word
000020  aa  163 040 141 164	s at
000021  aa  040 136 066 056	 ^6.
000022  aa  063 142 073 040	3b; 
000023  aa  136 144 040 143	^d c
000024  aa  150 141 162 163	hars
000025  aa  073 040 146 154	; fl
000026  aa  141 147 163 072	ags:
000027  aa  040 136 133 145	 ^[e
000030  aa  157 160 054 136	op,^
000031  aa  135 136 133 143	]^[c
000032  aa  157 156 166 054	onv,
000033  aa  136 135 136 133	^]^[
000034  aa  142 162 145 141	brea
000035  aa  153 136 135 000	k^]

000036  aa  000 001 002 003	 
000037  aa  004 005 006 007	
000040  aa  010 011 012 013		

000041  aa  014 015 016 017	
000042  aa  020 021 022 023	
000043  aa  024 025 026 027	
000044  aa  030 031 032 033	
000045  aa  034 035 036 037	
000046  aa  040 041 042 043	 !"#
000047  aa  044 045 046 047	$%&'
000050  aa  050 051 052 053	()*+
000051  aa  054 055 056 057	,-./
000052  aa  060 061 062 063	0123
000053  aa  064 065 066 067	4567
000054  aa  070 071 072 073	89:;
000055  aa  074 075 076 077	<=>?
000056  aa  100 101 102 103	@ABC
000057  aa  104 105 106 107	DEFG
000060  aa  110 111 112 113	HIJK
000061  aa  114 115 116 117	LMNO
000062  aa  120 121 122 123	PQRS
000063  aa  124 125 126 127	TUVW
000064  aa  130 131 132 133	XYZ[
000065  aa  134 135 136 137	\]^_
000066  aa  140 141 142 143	`abc
000067  aa  144 145 146 147	defg
000070  aa  150 151 152 153	hijk
000071  aa  154 155 156 157	lmno
000072  aa  160 161 162 163	pqrs
000073  aa  164 165 166 167	tuvw
000074  aa  170 171 172 173	xyz{
000075  aa  174 175 176 177	|}~
000076  aa  200 201 202 203	ÄÅÇÉ
000077  aa  204 205 206 207	ÑÖÜá
000100  aa  210 211 212 213	àâäã
000101  aa  214 215 216 217	åçéè
000102  aa  220 221 222 223	êëíì
000103  aa  224 225 226 227	îïñó
000104  aa  230 231 232 233	òôöõ
000105  aa  234 235 236 237	úùûü
000106  aa  240 241 242 243	†°¢£
000107  aa  244 245 246 247	§•¶ß
000110  aa  250 251 252 253	®©™´
000111  aa  254 255 256 257	¨≠ÆØ
000112  aa  260 261 262 263	∞±≤≥
000113  aa  264 265 266 267	¥µ∂∑
000114  aa  270 271 272 273	∏π∫ª
000115  aa  274 275 276 277	ºΩæø
000116  aa  300 301 302 303	¿¡¬√
000117  aa  304 305 306 307	ƒ≈∆«
000120  aa  310 311 312 313	»… À
000121  aa  314 315 316 317	ÃÕŒœ
000122  aa  320 321 322 323	–—“”
000123  aa  324 325 326 327	‘’÷◊
000124  aa  330 331 332 333	ÿŸ⁄€
000125  aa  334 335 336 337	‹›ﬁﬂ
000126  aa  340 341 342 343	‡·‚„
000127  aa  344 345 346 347	‰ÂÊÁ
000130  aa  350 351 352 353	ËÈÍÎ
000131  aa  354 355 356 357	ÏÌÓÔ
000132  aa  360 361 362 363	ÒÚÛ
000133  aa  364 365 366 367	Ùıˆ˜
000134  aa  370 371 372 373	¯˘˙˚
000135  aa  374 375 376 377	¸˝˛ˇ
000136  aa  400 401 402 403	 
000137  aa  404 405 406 407	
000140  aa  410 411 412 413		

000141  aa  414 415 416 417	
000142  aa  420 421 422 423	
000143  aa  424 425 426 427	
000144  aa  430 431 432 433	
000145  aa  434 435 436 437	
000146  aa  440 441 442 443	 !"#
000147  aa  444 445 446 447	$%&'
000150  aa  450 451 452 453	()*+
000151  aa  454 455 456 457	,-./
000152  aa  460 461 462 463	0123
000153  aa  464 465 466 467	4567
000154  aa  470 471 472 473	89:;
000155  aa  474 475 476 477	<=>?
000156  aa  500 501 502 503	@ABC
000157  aa  504 505 506 507	DEFG
000160  aa  510 511 512 513	HIJK
000161  aa  514 515 516 517	LMNO
000162  aa  520 521 522 523	PQRS
000163  aa  524 525 526 527	TUVW
000164  aa  530 531 532 533	XYZ[
000165  aa  534 535 536 537	\]^_
000166  aa  540 541 542 543	`abc
000167  aa  544 545 546 547	defg
000170  aa  550 551 552 553	hijk
000171  aa  554 555 556 557	lmno
000172  aa  560 561 562 563	pqrs
000173  aa  564 565 566 567	tuvw
000174  aa  570 571 572 573	xyz{
000175  aa  574 575 576 577	|}~
000176  aa  600 601 602 603	ÄÅÇÉ
000177  aa  604 605 606 607	ÑÖÜá
000200  aa  610 611 612 613	àâäã
000201  aa  614 615 616 617	åçéè
000202  aa  620 621 622 623	êëíì
000203  aa  624 625 626 627	îïñó
000204  aa  630 631 632 633	òôöõ
000205  aa  634 635 636 637	úùûü
000206  aa  640 641 642 643	†°¢£
000207  aa  644 645 646 647	§•¶ß
000210  aa  650 651 652 653	®©™´
000211  aa  654 655 656 657	¨≠ÆØ
000212  aa  660 661 662 663	∞±≤≥
000213  aa  664 665 666 667	¥µ∂∑
000214  aa  670 671 672 673	∏π∫ª
000215  aa  674 675 676 677	ºΩæø
000216  aa  700 701 702 703	¿¡¬√
000217  aa  704 705 706 707	ƒ≈∆«
000220  aa  710 711 712 713	»… À
000221  aa  714 715 716 717	ÃÕŒœ
000222  aa  720 721 722 723	–—“”
000223  aa  724 725 726 727	‘’÷◊
000224  aa  730 731 732 733	ÿŸ⁄€
000225  aa  734 735 736 737	‹›ﬁﬂ
000226  aa  740 741 742 743	‡·‚„
000227  aa  744 745 746 747	‰ÂÊÁ
000230  aa  750 751 752 753	ËÈÍÎ
000231  aa  754 755 756 757	ÏÌÓÔ
000232  aa  760 761 762 763	ÒÚÛ
000233  aa  764 765 766 767	Ùıˆ˜
000234  aa  770 771 772 773	¯˘˙˚
000235  aa  774 775 776 777	¸˝˛ˇ

BEGIN PROCEDURE mcs_trace
ENTRY TO mcs_trace                                          STATEMENT 1 ON LINE 9
mcs_trace:
     procedure (Devx);

000236  at     000001000011
000237  ta     000236000000
000240  da     000033300000
000241  aa   000400 6270 00	eax7 	256
000242  aa  7 00034 3521 20	epp2 	pr7|28,*
000243  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000244  aa     000002000000
000245  aa     000000000000
						STATEMENT 1 ON LINE 35
	call setup;

000246  aa   000243 6700 04	tsp4 	163,ic		000511
						STATEMENT 1 ON LINE 36
	call get_entry;

000247  aa  6 00056 6211 00	eax1 	pr6|46
000250  aa   000000 4310 07	fld  	0,dl
000251  aa   000336 3520 04	epp2 	222,ic		000607 = 000100627000
000252  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 37
	call formline_ (2, 3, addr (trace_entry.message), length (trace_entry.message), 1);

000253  aa   000002 2360 07	ldq  	2,dl
000254  aa  6 00126 7561 00	stq  	pr6|86
000255  aa   000003 2360 07	ldq  	3,dl
000256  aa  6 00127 7561 00	stq  	pr6|87
000257  aa   000002 7270 07	lxl7 	2,dl
000260  aa  6 00102 3735 20	epp7 	pr6|66,*		trace_entry_ptr
000261  aa  7 00002 3521 00	epp2 	pr7|2		trace_entry.message
000262  aa  2 00000 5005 17	a9bd 	pr2|0,7
000263  aa  6 00130 2521 00	spri2	pr6|88
000264  aa   000066 2360 07	ldq  	54,dl
000265  aa  6 00132 7561 00	stq  	pr6|90
000266  aa   000001 2360 07	ldq  	1,dl
000267  aa  6 00133 7561 00	stq  	pr6|91
000270  aa  6 00126 3521 00	epp2 	pr6|86
000271  aa  6 00136 2521 00	spri2	pr6|94
000272  aa  6 00127 3521 00	epp2 	pr6|87
000273  aa  6 00140 2521 00	spri2	pr6|96
000274  aa  6 00130 3521 00	epp2 	pr6|88
000275  aa  6 00142 2521 00	spri2	pr6|98
000276  aa  6 00132 3521 00	epp2 	pr6|90
000277  aa  6 00144 2521 00	spri2	pr6|100
000300  aa  6 00133 3521 00	epp2 	pr6|91
000301  aa  6 00146 2521 00	spri2	pr6|102
000302  aa  6 00134 6211 00	eax1 	pr6|92
000303  aa   024000 4310 07	fld  	10240,dl
000304  aa  6 00044 3701 20	epp4 	pr6|36,*
000305  la  4 00212 3521 20	epp2 	pr4|138,*		formline_
000306  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 38
return_to_caller:
	return;

000307  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO buffer_chain                                       STATEMENT 1 ON LINE 43
buffer_chain:
     entry (Devx, Chainp);

000310  at     000002000011
000311  ta     000010000000
000312  ta     000310000000
000313  da     000042300000
000314  aa   000400 6270 00	eax7 	256
000315  aa  7 00034 3521 20	epp2 	pr7|28,*
000316  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000317  aa     000004000000
000320  aa     000000000000
						STATEMENT 1 ON LINE 46
	call setup;

000321  aa   000170 6700 04	tsp4 	120,ic		000511
						STATEMENT 1 ON LINE 47
	do blockp = Chainp repeat (pointer (ttybp, buffer.next)) while (rel (blockp) ^= ""b);

000322  aa  6 00032 3735 20	epp7 	pr6|26,*
000323  aa  7 00004 3715 20	epp5 	pr7|4,*		Chainp
000324  aa  5 00000 3715 20	epp5 	pr5|0,*		Chainp
000325  aa  6 00114 6515 00	spri5	pr6|76		blockp
000326  aa  6 00114 6351 20	eaa  	pr6|76,*		blockp
000327  aa   000161 6000 04	tze  	113,ic		000510
						STATEMENT 1 ON LINE 48
	     bsize = 16 * (1 + buffer.size_code);

000330  aa  6 00114 2351 20	lda  	pr6|76,*		buffer.size_code
000331  aa   000030 7350 00	als  	24
000332  aa   000105 7730 00	lrl  	69
000333  aa   000001 0760 07	adq  	1,dl
000334  aa   000004 7360 00	qls  	4
000335  aa  6 00106 7561 00	stq  	pr6|70		bsize
						STATEMENT 1 ON LINE 49
	     call fill_in (" ^d words at ^6.3b; ^d chars; flags: ^[eop,^]^[conv,^]^[break^]", bsize, rel (blockp),
		buffer.tally, buffer.flags.end_of_page, buffer.flags.converted, buffer.flags.break);

000336  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000337  aa   777460 00 0100	desc9a	-208,64		000016 = 040136144040
000340  aa  6 00150 00 0100	desc9a	pr6|104,64
000341  aa  6 00114 6351 20	eaa  	pr6|76,*		blockp
000342  aa  6 00133 7551 00	sta  	pr6|91
000343  aa  6 00150 3521 00	epp2 	pr6|104
000344  aa  6 00172 2521 00	spri2	pr6|122
000345  aa  6 00106 3521 00	epp2 	pr6|70		bsize
000346  aa  6 00174 2521 00	spri2	pr6|124
000347  aa  6 00133 3521 00	epp2 	pr6|91
000350  aa  6 00176 2521 00	spri2	pr6|126
000351  aa   000033 7270 07	lxl7 	27,dl
000352  aa  6 00114 3521 20	epp2 	pr6|76,*		buffer.tally
000353  aa  2 00000 5035 17	abd  	pr2|0,7
000354  aa  6 00200 2521 00	spri2	pr6|128
000355  aa   000022 7260 07	lxl6 	18,dl
000356  aa  6 00114 3521 20	epp2 	pr6|76,*		buffer.end_of_page
000357  aa  2 00000 5035 16	abd  	pr2|0,6
000360  aa  6 00202 2521 00	spri2	pr6|130
000361  aa   000023 7250 07	lxl5 	19,dl
000362  aa  6 00114 3521 20	epp2 	pr6|76,*		buffer.converted
000363  aa  2 00000 5035 15	abd  	pr2|0,5
000364  aa  6 00204 2521 00	spri2	pr6|132
000365  aa   000024 7240 07	lxl4 	20,dl
000366  aa  6 00114 3521 20	epp2 	pr6|76,*		buffer.break
000367  aa  2 00000 5035 14	abd  	pr2|0,4
000370  aa  6 00206 2521 00	spri2	pr6|134
000371  aa   777416 3520 04	epp2 	-242,ic		000007 = 524000000077
000372  aa  6 00212 2521 00	spri2	pr6|138
000373  aa   777416 3520 04	epp2 	-242,ic		000011 = 404000000021
000374  aa  6 00214 2521 00	spri2	pr6|140
000375  aa   777411 3520 04	epp2 	-247,ic		000006 = 514000000022
000376  aa  6 00216 2521 00	spri2	pr6|142
000377  aa   777406 3520 04	epp2 	-250,ic		000005 = 606000000011
000400  aa  6 00220 2521 00	spri2	pr6|144
000401  aa   777403 3520 04	epp2 	-253,ic		000004 = 516000000001
000402  aa  6 00222 2521 00	spri2	pr6|146
000403  aa  6 00224 2521 00	spri2	pr6|148
000404  aa  6 00226 2521 00	spri2	pr6|150
000405  aa  6 00170 6211 00	eax1 	pr6|120
000406  aa   034000 4310 07	fld  	14336,dl
000407  aa   000244 3520 04	epp2 	164,ic		000653 = 000140627000
000410  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 51
	     do i = 1 by 2 to bsize;

000411  aa  6 00106 2361 00	ldq  	pr6|70		bsize
000412  aa  6 00116 7561 00	stq  	pr6|78
000413  aa   000001 2360 07	ldq  	1,dl
000414  aa  6 00107 7561 00	stq  	pr6|71		i
000415  aa   000000 0110 03	nop  	0,du
000416  aa  6 00107 2361 00	ldq  	pr6|71		i
000417  aa  6 00116 1161 00	cmpq 	pr6|78
000420  aa   000062 6054 04	tpnz 	50,ic		000502
						STATEMENT 1 ON LINE 52
		if (bwords (i) | bwords (i + 1)) ^= ""b then
		     call fill_in (" ^2d: ^w ^w ^8a", (i - 1) * 4, bwords (i), bwords (i + 1),
			translate (substr (string (buffer.chars), i * 4 - 7, 8), mapc));

000421  aa  6 00114 3735 20	epp7 	pr6|76,*		blockp
000422  aa  7 77777 2351 06	lda  	pr7|-1,ql		bwords
000423  aa  7 00000 2751 06	ora  	pr7|0,ql		bwords
000424  aa   000052 6000 04	tze  	42,ic		000476
000425  aa   777365 2370 04	ldaq 	-267,ic		000012 = 040136062144 072040136167
000426  aa  6 00134 7571 00	staq 	pr6|92
000427  aa   777365 2370 04	ldaq 	-267,ic		000014 = 040136167040 136070141000
000430  aa  6 00136 7571 00	staq 	pr6|94
000431  aa  6 00107 2361 00	ldq  	pr6|71		i
000432  aa   000001 1760 07	sbq  	1,dl
000433  aa   000002 7360 00	qls  	2
000434  aa  6 00133 7561 00	stq  	pr6|91
000435  aa   000010 2360 07	ldq  	8,dl
000436  aa  6 00107 7271 00	lxl7 	pr6|71		i
000437  aa  7 77777 3521 17	epp2 	pr7|-1,7
000440  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
000441  aa   001000 2360 07	ldq  	512,dl
000442  aa  6 00044 3701 20	epp4 	pr6|36,*
000443  ia  4 00011 3521 00	epp2 	pr4|9		mapc
000444  aa  0 01272 7001 00	tsx0 	pr0|698		translate_2
000445  aa  0 01374 7001 00	tsx0 	pr0|764		fetch_chars_eis
000446  aa  6 00130 7571 00	staq 	pr6|88
000447  aa  6 00134 3521 00	epp2 	pr6|92
000450  aa  6 00172 2521 00	spri2	pr6|122
000451  aa  6 00133 3521 00	epp2 	pr6|91
000452  aa  6 00174 2521 00	spri2	pr6|124
000453  aa  7 77777 3521 17	epp2 	pr7|-1,7		bwords
000454  aa  6 00176 2521 00	spri2	pr6|126
000455  aa  7 00000 3521 17	epp2 	pr7|0,7		bwords
000456  aa  6 00200 2521 00	spri2	pr6|128
000457  aa  6 00130 3521 00	epp2 	pr6|88
000460  aa  6 00202 2521 00	spri2	pr6|130
000461  aa   777322 3520 04	epp2 	-302,ic		000003 = 524000000017
000462  aa  6 00206 2521 00	spri2	pr6|134
000463  aa   777317 3520 04	epp2 	-305,ic		000002 = 404000000030
000464  aa  6 00210 2521 00	spri2	pr6|136
000465  aa   777314 3520 04	epp2 	-308,ic		000001 = 514000000044
000466  aa  6 00212 2521 00	spri2	pr6|138
000467  aa  6 00214 2521 00	spri2	pr6|140
000470  aa   777310 3520 04	epp2 	-312,ic		000000 = 524000000010
000471  aa  6 00216 2521 00	spri2	pr6|142
000472  aa  6 00170 6211 00	eax1 	pr6|120
000473  aa   024000 4310 07	fld  	10240,dl
000474  aa   000157 3520 04	epp2 	111,ic		000653 = 000140627000
000475  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
						STATEMENT 1 ON LINE 55
		end;

000476  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000477  aa   000002 2360 07	ldq  	2,dl
000500  aa  6 00107 0561 00	asq  	pr6|71		i
000501  aa   777715 7100 04	tra  	-51,ic		000416
						STATEMENT 1 ON LINE 56
	     end;

000502  aa  6 00114 2351 20	lda  	pr6|76,*		buffer.next
000503  aa   000066 7730 00	lrl  	54
000504  aa  6 00110 3521 20	epp2 	pr6|72,*		ttybp
000505  aa   000000 3120 06	eawp2	0,ql
000506  aa  6 00114 2521 00	spri2	pr6|76		blockp
000507  aa   777617 7100 04	tra  	-113,ic		000326
						STATEMENT 1 ON LINE 57
	return;

000510  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 104
     end;

BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 61
setup:
     procedure;

000511  aa  6 00120 6501 00	spri4	pr6|80
						STATEMENT 1 ON LINE 63
	ttybp = addr (tty_buf$);

000512  aa  6 00044 3701 20	epp4 	pr6|36,*
000513  la  4 00214 3735 20	epp7 	pr4|140,*		tty_buf$
000514  aa  6 00110 6535 00	spri7	pr6|72		ttybp
						STATEMENT 1 ON LINE 64
	if ^initialized then do;

000515  ia  4 00010 2351 00	lda  	pr4|8		initialized
000516  aa   000027 6010 04	tnz  	23,ic		000545
						STATEMENT 1 ON LINE 65
	     mapc = copy (".", 32) || substr (collate9 (), 33, 95) || copy (".", 385);

000517  aa  056 100 100 400	mlr  	(),(pr),fill(056)
000520  aa   000000 00 0000	desc9a	0,0
000521  aa  6 00230 00 0601	desc9a	pr6|152,385
000522  aa   000040 2360 07	ldq  	32,dl
000523  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000524  aa  056 100 100 400	mlr  	(),(pr),fill(056)
000525  aa   000000 00 0000	desc9a	0,0
000526  aa  2 00000 00 0040	desc9a	pr2|0,32
000527  aa   000177 2360 07	ldq  	127,dl
000530  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
000531  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000532  aa   777315 00 0137	desc9a	-307,95		000046 = 040041042043
000533  aa  2 00010 00 0137	desc9a	pr2|8,95
000534  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000535  aa  2 00000 00 0177	desc9a	pr2|0,127
000536  ia  4 00011 00 0177	desc9a	pr4|9,127		mapc
000537  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000540  aa  6 00230 00 0601	desc9a	pr6|152,385
000541  ia  4 00050 60 0601	desc9a	pr4|40(3),385	mapc
						STATEMENT 1 ON LINE 66
	     initialized = "1"b;

000542  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000543  aa   400000 2350 03	lda  	131072,du
000544  ia  4 00010 7551 00	sta  	pr4|8		initialized
						STATEMENT 1 ON LINE 67
	     end;

						STATEMENT 1 ON LINE 68
	if ^tty_buf.trace.enable then goto return_to_caller;

000545  aa  7 00102 2351 00	lda  	pr7|66		tty_buf.enable
000546  aa   400000 3150 03	cana 	131072,du
000547  aa   777540 6000 04	tze  	-160,ic		000307
						STATEMENT 1 ON LINE 69
	if tty_buf.trace.data_offset = ""b then goto return_to_caller;

000550  aa  7 00102 2351 00	lda  	pr7|66		tty_buf.data_offset
000551  aa   000022 7350 00	als  	18
000552  aa   777535 6000 04	tze  	-163,ic		000307
						STATEMENT 1 ON LINE 70
	trace_array_ptr = pointer (ttybp, tty_buf.trace.data_offset);

000553  aa  7 00000 3521 00	epp2 	pr7|0
000554  aa   000000 3120 01	eawp2	0,au
000555  aa  6 00100 2521 00	spri2	pr6|64		trace_array_ptr
						STATEMENT 1 ON LINE 71
	if trace_array.num_entries = 0 then goto return_to_caller;

000556  aa  2 00000 2361 00	ldq  	pr2|0		trace_array.num_entries
000557  aa   777530 6000 04	tze  	-168,ic		000307
						STATEMENT 1 ON LINE 72
	lctep = addr (tty_buf.lct_ptr -> lct.lcte_array (Devx));

000560  aa  6 00032 3715 20	epp5 	pr6|26,*
000561  aa  5 00002 2361 20	ldq  	pr5|2,*		Devx
000562  aa   000005 7360 00	qls  	5
000563  aa  7 00006 3535 20	epp3 	pr7|6,*		tty_buf.lct_ptr
000564  aa  3 77760 3515 06	epp1 	pr3|-16,ql	lct.lcte_array
000565  aa  6 00112 2515 00	spri1	pr6|74		lctep
						STATEMENT 1 ON LINE 73
	if lcte.flags.trace = (tty_buf.trace.default_mode & ^lcte.flags.trace_force) then goto return_to_caller;

000566  aa  1 00002 2351 00	lda  	pr1|2		lcte.trace_force
000567  aa   000017 7350 00	als  	15
000570  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000571  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000572  aa  6 00371 7551 00	sta  	pr6|249
000573  aa  7 00102 2351 00	lda  	pr7|66		tty_buf.default_mode
000574  aa   000001 7350 00	als  	1
000575  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000576  aa  6 00371 3751 00	ana  	pr6|249
000577  aa  6 00371 7551 00	sta  	pr6|249
000600  aa  1 00002 2351 00	lda  	pr1|2		lcte.trace
000601  aa   000020 7350 00	als  	16
000602  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000603  aa  6 00371 1151 00	cmpa 	pr6|249
000604  aa   777503 6000 04	tze  	-189,ic		000307
						STATEMENT 1 ON LINE 74
     end setup;

000605  aa  6 00120 6101 00	rtcd 	pr6|80
  END PROCEDURE setup
BEGIN PROCEDURE get_entry
ENTRY TO get_entry                                          STATEMENT 1 ON LINE 78
get_entry:
     procedure;

000606  da     000050200000
000607  aa   000100 6270 00	eax7 	64
000610  aa  7 00034 3521 20	epp2 	pr7|28,*
000611  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000612  aa     000000000000
000613  aa     000000000000
						STATEMENT 1 ON LINE 80
snarf_trace_entry:
	my_idx = binary (trace_array.idx);

000614  aa  6 00040 3735 20	epp7 	pr6|32,*
000615  aa  7 00100 3715 20	epp5 	pr7|64,*		trace_array_ptr
000616  aa  5 00001 2351 00	lda  	pr5|1		trace_array.idx
000617  aa   000044 7730 00	lrl  	36
000620  aa  7 00104 7561 00	stq  	pr7|68		my_idx
						STATEMENT 1 ON LINE 82
	next_idx = my_idx + 1;

000621  aa   000044 7770 00	llr  	36
000622  aa   000044 7330 00	lrs  	36
000623  aa   000001 0330 07	adl  	1,dl
000624  aa  7 00105 7561 00	stq  	pr7|69		next_idx
						STATEMENT 1 ON LINE 83
	if next_idx > trace_array.num_entries then next_idx = 1;

000625  aa  5 00000 1161 00	cmpq 	pr5|0		trace_array.num_entries
000626  aa   000003 6044 04	tmoz 	3,ic		000631
000627  aa   000001 2360 07	ldq  	1,dl
000630  aa  7 00105 7561 00	stq  	pr7|69		next_idx
						STATEMENT 1 ON LINE 85
	if ^stacq (trace_array.idx, unspec (next_idx), unspec (my_idx)) then goto snarf_trace_entry;

000631  aa  7 00105 2351 00	lda  	pr7|69
000632  aa  5 00001 3521 00	epp2 	pr5|1		trace_array.idx
000633  aa  7 00104 2361 00	ldq  	pr7|68
000634  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
000635  aa   777757 6000 04	tze  	-17,ic		000614
						STATEMENT 1 ON LINE 87
	trace_entry_ptr = addr (trace_array.entry (my_idx));

000636  aa  7 00104 2361 00	ldq  	pr7|68		my_idx
000637  aa   000004 7360 00	qls  	4
000640  aa  5 77762 3535 06	epp3 	pr5|-14,ql	trace_array.entry
000641  aa  7 00102 2535 00	spri3	pr7|66		trace_entry_ptr
						STATEMENT 1 ON LINE 88
	trace_entry.time = clock ();

000642  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
000643  aa  3 00000 7571 00	staq 	pr3|0		trace_entry.time
						STATEMENT 1 ON LINE 89
	trace_entry.devx = Devx;

000644  aa  6 00040 3735 20	epp7 	pr6|32,*
000645  aa  7 00032 3515 20	epp1 	pr7|26,*
000646  aa  1 00002 2361 20	ldq  	pr1|2,*		Devx
000647  aa   000066 7370 00	lls  	54
000650  aa  3 00002 5511 60	stba 	pr3|2,60		trace_entry.devx
						STATEMENT 1 ON LINE 90
     end get_entry;

000651  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE get_entry
BEGIN PROCEDURE fill_in
ENTRY TO fill_in                                            STATEMENT 1 ON LINE 94
fill_in:
     procedure options (variable, non_quick);

000652  da     000055240000
000653  aa   000140 6270 00	eax7 	96
000654  aa  7 00034 3521 20	epp2 	pr7|28,*
000655  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000656  aa     000000000000
000657  aa     000000000000
						STATEMENT 1 ON LINE 96
	call get_entry;

000660  aa   000001 7270 07	lxl7 	1,dl
000661  aa  6 00056 6211 00	eax1 	pr6|46
000662  aa   000000 4310 07	fld  	0,dl
000663  aa   777724 3520 04	epp2 	-44,ic		000607 = 000100627000
000664  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 97
	call formline_ (1, 2, addr (trace_entry.message), length (trace_entry.message), 1);

000665  aa   000001 2360 07	ldq  	1,dl
000666  aa  6 00100 7561 00	stq  	pr6|64
000667  aa   000002 2360 07	ldq  	2,dl
000670  aa  6 00101 7561 00	stq  	pr6|65
000671  aa  6 00040 3735 20	epp7 	pr6|32,*
000672  aa   000002 7270 07	lxl7 	2,dl
000673  aa  7 00102 3715 20	epp5 	pr7|66,*		trace_entry_ptr
000674  aa  5 00002 3521 00	epp2 	pr5|2		trace_entry.message
000675  aa  2 00000 5005 17	a9bd 	pr2|0,7
000676  aa  6 00102 2521 00	spri2	pr6|66
000677  aa   000066 2360 07	ldq  	54,dl
000700  aa  6 00104 7561 00	stq  	pr6|68
000701  aa   000001 2360 07	ldq  	1,dl
000702  aa  6 00105 7561 00	stq  	pr6|69
000703  aa  6 00100 3521 00	epp2 	pr6|64
000704  aa  6 00110 2521 00	spri2	pr6|72
000705  aa  6 00101 3521 00	epp2 	pr6|65
000706  aa  6 00112 2521 00	spri2	pr6|74
000707  aa  6 00102 3521 00	epp2 	pr6|66
000710  aa  6 00114 2521 00	spri2	pr6|76
000711  aa  6 00104 3521 00	epp2 	pr6|68
000712  aa  6 00116 2521 00	spri2	pr6|78
000713  aa  6 00105 3521 00	epp2 	pr6|69
000714  aa  6 00120 2521 00	spri2	pr6|80
000715  aa  6 00106 6211 00	eax1 	pr6|70
000716  aa   024000 4310 07	fld  	10240,dl
000717  aa  6 00044 3701 20	epp4 	pr6|36,*
000720  la  4 00212 3521 20	epp2 	pr4|138,*		formline_
000721  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 98
     end fill_in;

000722  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE fill_in
  END PROCEDURE mcs_trace


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
