	COMPILATION LISTING OF SEGMENT decode_clock_value_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1531.1 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       12 /*									*/
       13 /* N__a_m_e:  decode_clock_value_							*/
       14 /*									*/
       15 /*      Given a Multics standard calander clock value, decode_clock_value_ will decode	*/
       16 /* this value into a date and time value.					*/
       17 /*									*/
       18 /* E__n_t_r_y:  decode_clock_value_$decode_clock_value_				*/
       19 /*									*/
       20 /*      This entry point returns the month, day of the month, the year, the time of day,	*/
       21 /* and the day of the week represented by a Multics standard calendar clock value.	*/
       22 /* In addition, the current time zone, used in the calculation, is returned.		*/
       23 /*									*/
       24 /* U__s_a_g_e									*/
       25 /*									*/
       26 /*      declare decode_clock_value_ entry (fixed bin(71), fixed bin, fixed bin, fixed bin, */
       27 /*	      fixed bin(71), fixed bin, char(3), fixed bin(35));			*/
       28 /*									*/
       29 /*      call decode_clock_value_ (clock, month, day, year, time, day_of_week, zone);	*/
       30 /* 1) clock	is the clock value to be decode.  It must represent a date within	*/
       31 /*		the 20th Century. (In)					*/
       32 /*									*/
       33 /* 2) month	is a month number (January = 1, December = 12) (Out)		*/
       34 /*									*/
       35 /* 3) day		is the number of a day of the month. (Out)			*/
       36 /*									*/
       37 /* 4) year	is the number of a year (e.g, 1973). (Out)			*/
       38 /*									*/
       39 /* 5) time	is the time of day, in micro-seconds since midnight. (Output)	*/
       40 /*									*/
       41 /* 6) day_of_week	is the number of a day of the week (Monday = 1, Sunday = 7). (Out)	*/
       42 /*									*/
       43 /* 7) zone	is the current time zone, in which the date and time numbers are	*/
       44 /*		expressed. (Out)						*/
       45 
       46 /* E__n_t_r_y:  decode_clock_value_$date_time					*/
       47 /*									*/
       48 /*      This entry point returns the month, day of the month, the year, the hour of the	*/
       49 /* day, the minute of the hour, the second of the minute, the micro-seconds of the second, */
       50 /* and the day of the week represented by a Multics standard calendar clock value.	*/
       51 /* The caller may specify one of the time zones in the time_table_ in which the decoded	*/
       52 /* clock value is to be expressed, or may request that the value be expressed in the	*/
       53 /* current time zone.							*/
       54 /*									*/
       55 /* U__s_a_g_e									*/
       56 /*									*/
       57 /*      declare decode_clock_value_$date_time entry (fixed bin(71), fixed bin, fixed bin,	*/
       58 /*	      fixed bin, fixed bin, fixed bin, fixed bin, fixed bin(71), fixed bin,	*/
       59 /*	      char(3), fixed bin(35));					*/
       60 /*									*/
       61 /*      call decode_clock_value_$date_time (clock, month, day, year, hour, minute,	*/
       62 /*	   second, micro_second, day_of_week, zone, code);			*/
       63 /*									*/
       64 /* 1) clock	is the clock value to be decoded. (In)				*/
       65 /*									*/
       66 /* 2) month	is a month number (January = 1, December = 12). (Out)		*/
       67 /*									*/
       68 /* 3) day		is the number of a day of the month. (Out)			*/
       69 /*									*/
       70 /* 4) year	is the number of a year. (Out)				*/
       71 /*									*/
       72 /* 5) hour	is the number of an hour of the day (midnight = 0, noon = 12, 	*/
       73 /*		11 PM = 23). (Out)						*/
       74 /*									*/
       75 /* 6) minute	is the number of a minute of the hour. (Out)			*/
       76 /*									*/
       77 /* 7) second	is the number of a second of the hour. (Out)			*/
       78 /*									*/
       79 /* 8) micro_second	is the number of micro-seconds in excess of a second. (Out)		*/
       80 /*									*/
       81 /* 9) day_of_week	is the number of the day of the week. (Out)			*/
       82 /*									*/
       83 /* 10) zone	is the character string abbreviation of one of the time zones in the	*/
       84 /*		time_table_.  The decoded clock value is to be expressed in this time	*/
       85 /*		zone. (In)						*/
       86 /*		If the zone character string is a blank string, then the clock value	*/
       87 /*		is expressed in the current time zone, and the character string	*/
       88 /*		abbreviation for that zone is returned. (Out)			*/
       89 /*									*/
       90 /* 11) code	is one of the following status codes. (Out)			*/
       91 /*									*/
       92 /*     0		the clock value was decoded successfully.			*/
       93 /*									*/
       94 /*     error_table_$unimplemented_version					*/
       95 /*		the current version of time_table_ is not the version this proc	*/
       96 /*		knows about.						*/
       97 /*									*/
       98 /*     error_table_$unknown_zone						*/
       99 /*		the time zone specified by the caller was not found in the 		*/
      100 /*		time_table_.						*/
      101 /*									*/
      102 /*     error_table_$bad_year							*/
      103 /*		the clock value to be decoded did not lie within the 20th Century.	*/
      104 
      105 /* E__n_t_r_y:	 decode_clock_value_$time						*/
      106 /*									*/
      107 /*      This entry point returns the hour, minute, second, and microsecond for		*/
      108 /* a given clock value.							*/
      109 /*									*/
      110 /* U__s_a_g_e									*/
      111 /*									*/
      112 /*     declare decode_clock_value_$time entry (fixed bin (71), fixed bin,		*/
      113 /*	     fixed bin, fixed bin, fixed bin (71), char (3), fixed bin (35));		*/
      114 /*									*/
      115 /*     call decode_clock_value_$time (clock, hour, minute, second, microsecond,		*/
      116 /*	  zone, code);							*/
      117 /*									*/
      118 /* 1) - 7)	are as above.						*/
      119 
      120 /* Entry:  decode_clock_value_$all						*/
      121 /*									*/
      122 /*      This entry point returns all of the information available from $date_time entry,	*/
      123 /* plus the number of whole days contained in the clock value, and the day of the year	*/
      124 /* represented by the clock value.						*/
      125 /*									*/
      126 /* U__s_a_g_e									*/
      127 /*									*/
      128 /*      declare decode_clock_value_$all entry (fixed bin(71), fixed bin, fixed bin,	*/
      129 /*	      fixed bin, fixed bin, fixed bin, fixed bin, fixed bin(71), fixed bin,	*/
      130 /*	      char(3), fixed bin, fixed bin, fixed bin(35));			*/
      131 /*									*/
      132 /*      call decode_clock_value_$all (clock, month, day, year, hour, minute, second,	*/
      133 /*           micro_second, day_of_week, zone, days_in_clock, day_of_year, code);	*/
      134 /*									*/
      135 /* 1) - 10)	are as above.						*/
      136 /* 11) days_in_clock							*/
      137 /*		is the number of whole days contained in the clock value,	*/
      138 /*		with January 1, 1901 counting as the 1st day. (Out)		*/
      139 /* 12) day_of_year	is the number of the day of the year (from 1 to 366). (Out)		*/
      140 /* 13) code	is as above.						*/
      141 /*									*/
      142 /* N__o_t_e									*/
      143 /*									*/
      144 /*      If the clock value given to decode_clock_value_$decode_clock_value_ does not lie	*/
      145 /* within the 20th Century, then zero values will be returned for the the month, day,	*/
      146 /* year, time, and day of the week.						*/
      147 /*									*/
      148 /* S__t_a_t_u_s									*/
      149 /*									*/
      150 /* 0) Created:  Aug, 1971 by Dan Bricklin					*/
      151 /*	a) based on a program written by M. Smith.				*/
      152 /* 1) Recoded:  Aug, 1973 by Gary Dixon						*/
      153 /*	a) recoded to use algorithm of datebin_					*/
      154 /*	b) date_time entry point added to provide an entry point which generates as	*/
      155 /*	   output the time values which encode_clock_value_ accepts as input.		*/
      156 /* 2) Modified:   April 1980 by C. Hornig for perprocess time zones.			*/
      157 /* 3) Modified: 9 September 1980 by G. Palter to fix TR07116 (see encode_clock_value_)	*/
      158 /*									*/
      159 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      160 
      161 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      162 
      163 
      164 decode_clock_value_:
      165      procedure (Aclock, month, day, year, us_in_day, day_of_week, Azone);
      166 
      167 dcl						/*	parameters			*/
      168     Aclock fixed bin (71),				/* a clock value. (In)			*/
      169     month fixed bin,				/* a month number. 1 = Jan, 12 = Dec. (Out)	*/
      170     day fixed bin,					/* a day of the month. (Out)			*/
      171     year fixed bin,					/* a year number. (Out)			*/
      172     hour fixed bin,					/* an hour of the day. 0 = midnite, 12 = noon,	*/
      173 						/* 23 = 11 PM. (Out)			*/
      174     minute fixed bin,				/* a minute of the hour. (Out)		*/
      175     second fixed bin,				/* a second of the minute. (Out)		*/
      176     micro_second fixed bin (71),			/* a micro-second. (Out)			*/
      177     us_in_day fixed bin (71),				/* micro-second of the day (Out)		*/
      178     day_of_week fixed bin,				/* a day of the week number. 1 = Mon, 7 = Sun.	*/
      179 						/* (Out)					*/
      180     Azone char (3),					/* a time zone character string. (In/Out)	*/
      181     days_in_clock fixed bin,				/* number of whole days contained in clock value	*/
      182 						/*   with January 1, 1901 = 1st day. (Out)	*/
      183     day_of_year fixed bin,				/* day of the year represented by clock value.	*/
      184 						/*   (Out)				*/
      185     code fixed bin (35);				/* an error code. (Out)			*/
      186 
      187 dcl						/*	automatic variables			*/
      188     Sall bit (1) aligned init ("0"b),			/* on if entered at $all entry point.		*/
      189     Stime bit (1) aligned init ("0"b),			/* on if entered at $time entrypoint */
      190     clock fixed bin (71),				/* a clock value temp.			*/
      191     date fixed bin,					/* a number of days in this year.		*/
      192     i fixed bin,					/* a do-group index.			*/
      193     time fixed bin (35),				/* a number of minutes/hours.			*/
      194     (tot_secs, tot_mins, tot_hrs) fixed bin (35),
      195     zone char (3) aligned;				/* a time zone temp.			*/
      196 
      197 dcl (addr, divide, mod, translate) builtin;
      198 
      199 dcl						/*	static variables			*/
      200     MAXIMUM_TIME fixed binary (71) static options (constant) initial (3124223999999999),
      201 						/* Largest clock reading that this subroutine will decode: it
      202*						   corresponds to the last microsecond of 1 January 2000 gmt */
      203 
      204     (
      205     error_table_$bad_year,
      206     error_table_$unimplemented_version,
      207     error_table_$unknown_zone
      208     ) fixed bin (35) ext static,
      209     time_data_$time_delta fixed bin (71) ext static,	/* offset, in micro-seconds, of current time zone	*/
      210 						/* from GMT.				*/
      211     time_data_$time_zone char (3) aligned ext static;	/* name of the current time zone.		*/
      212 
      213 declare time_data_$time_data_init entry;
      214 
  1     1 	/* START OF:	time_zones_.incl.pl1	Created:  August, 1973 by G. C. Dixon		*/
  1     2 
  1     3      dcl	time_table_$zones		fixed bin(35) ext static;
  1     4 						/* the table of acceptable time zone values,	*/
  1     5 						/* and their offset, in microseconds, from	*/
  1     6 						/* Greenwich Mean Time (GMT).			*/
  1     7 
  1     8      dcl	1 time_zones		aligned based (addr (time_table_$zones)),
  1     9 	  2 version		fixed bin,	/* table version number. (This is version 1).	*/
  1    10 	  2 number		fixed bin,	/* number of time zones in table.		*/
  1    11 	  2 values (0 refer (time_zones.number)),
  1    12 	    3 zone		char(3) aligned,	/* the time zone character string.		*/
  1    13 	    3 pad			fixed bin,
  1    14 	    3 zone_offset		fixed bin(71);	/* the offset, in microseconds, which must be	*/
  1    15 						/*   added to convert a time expressed in this	*/
  1    16 						/*   time zone to a time expressed in the	*/
  1    17 						/*   Greenwich Mean Time (GMT) zone.		*/
  1    18      dcl	Vtime_zones_1		fixed bin int static options(constant) init (1);
  1    19 						/* time_table_$zones version number.		*/
  1    20 
  1    21 	/* END OF:	time_zones_.incl.pl1						*/
      215 
      216 
      217 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      218 
      219 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      220 /*									*/
      221 /*	1) shift clock value to current time zone.				*/
      222 /*	2) make sure clock value lies within the 20th century.  The number of days	*/
      223 /*	   is the 20th century (Jan 1, 1901 to Dec 31, 1999) is 36159.  A zero	*/
      224 /*	   clock value represents Jan 1, 1901.					*/
      225 /*	3) return number of micro-seconds as an argument.				*/
      226 /*	4) Save number of days for use later in the algorithm.			*/
      227 /*									*/
      228 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      229 
      230 	if (Aclock < 0) | (Aclock > MAXIMUM_TIME) then goto bad_clock;
      231 	call init_time_data;
      232 	clock = Aclock - time_data_$time_delta;		/* shift clock value to current time zone.	*/
      233 	Azone = time_data_$time_zone;			/* return name of current time zone.		*/
      234 
      235 	if clock >= 0
      236 	then date = divide (clock, 86400000000, 17, 0);	/* 86400000000 is number of micro-second in a day. */
      237 	else date = divide (clock - 86399999999, 86400000000, 17, 0);
      238 	us_in_day = clock - (date * 86400000000);
      239 	go to common;
      240 
      241 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      242 
      243 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      244 
      245 
      246 all:
      247      entry (Aclock, month, day, year, hour, minute, second, micro_second, day_of_week, Azone, days_in_clock, day_of_year,
      248 	code);
      249 
      250 	Sall = "1"b;				/* initialize switch indicating special arguments	*/
      251 						/*   are returned by this entry point.		*/
      252 	goto get_time;
      253 
      254 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      255 
      256 time:
      257      entry (Aclock, hour, minute, second, micro_second, Azone, code);
      258 
      259 	Stime = "1"b;
      260 	goto get_time;
      261 
      262 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      263 
      264 date_time:
      265      entry (Aclock, month, day, year, hour, minute, second, micro_second, day_of_week, Azone, code);
      266 
      267 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      268 /*									*/
      269 /*	1) initialize error code to 0.					*/
      270 /*	2) shift clock value to specified time zone.				*/
      271 /*	3) make sure clock value lies within 20th century.			*/
      272 /*									*/
      273 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      274 
      275 get_time:
      276 	code = 0;
      277 	if (Aclock < 0) | (Aclock > MAXIMUM_TIME) then goto bad_clock;
      278 	call init_time_data;
      279 	if Azone = "" then Azone = time_data_$time_zone;	/* if caller did not specify time zone, then	*/
      280 						/* use the current time zone.			*/
      281 	zone = translate (Azone, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      282 	if zone = time_data_$time_zone
      283 	then clock = Aclock - time_data_$time_delta;
      284 	else do;					/* otherwise, find the specified zone in the	*/
      285 	     if time_zones.version ^= Vtime_zones_1 then go to bad_version;
      286 	     do i = 1 to time_zones.number while (time_zones.zone (i) ^= zone);
      287 	     end;
      288 	     if i > time_zones.number then go to bad_zone;/* if zone not in table, report error to caller.	*/
      289 
      290 	     clock = Aclock - time_zones.zone_offset (i); /* shift clock value to reflect specified zone.	*/
      291 	     end;
      292 
      293 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      294 /*									*/
      295 /*	1) compute number of micro-seconds in excess of 1 second in clock value.	*/
      296 /*	2) compute number of seconds in excess of 1 minute in clock value.		*/
      297 /*	3) compute number of minutes in excess of 1 hour in clock value.		*/
      298 /*	4) compute number of hours in excess of 1 day in clock value.		*/
      299 /*									*/
      300 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      301 
      302 	if clock >= 0 then do;
      303 	     tot_secs = divide (clock, 1000000, 35, 0);
      304 	     tot_mins = divide (tot_secs, 60, 35, 0);
      305 	     tot_hrs = divide (tot_mins, 60, 35, 0);
      306 	     date = divide (tot_hrs, 24, 17, 0);
      307 	     end;
      308 	else do;
      309 	     tot_secs = divide (clock - 999999, 1000000, 35, 0);
      310 	     tot_mins = divide (tot_secs - 59, 60, 35, 0);
      311 	     tot_hrs = divide (tot_mins - 59, 60, 35, 0);
      312 	     date = divide (tot_hrs - 23, 24, 17, 0);
      313 	     end;
      314 	micro_second = clock - 1000000 * tot_secs;
      315 	second = tot_secs - 60 * tot_mins;
      316 	minute = tot_mins - 60 * tot_hrs;
      317 	hour = tot_hrs - 24 * date;
      318 	if Stime then return;			/* all done for short entry */
      319 
      320 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      321 /*									*/
      322 /* 	1) compute day of the week.  Jan 1, 1901, our zero time value, was a Tuesday.	*/
      323 /*	2) compute the year.						*/
      324 /*	3) compute the month of the year, and day of the month, using the algorithm of	*/
      325 /*	   Richard A. Stone; Communications of the ACM;				*/
      326 /*	   Vol 13, No 10; October, 1970; p 621.					*/
      327 /*									*/
      328 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      329 
      330 common:
      331 	if Sall then days_in_clock = date + 1;		/* return day count for $all entry point.	*/
      332 	day_of_week = mod (date + 1, 7) + 1;		/* mod (day_no, 7) = 1; => Tue			*/
      333 						/*	         = 0 => Mon			*/
      334 						/* add 1 to make 1 = Mon, 7 = Sun.		*/
      335 
      336 	if date >= 0
      337 	then year = 1901 + 4 * divide (date, 1461, 17, 0);
      338 	else year = 1901 + 4 * divide (date - 1460, 1461, 17, 0);
      339 	date = mod (date, 1461);
      340 	if date < 1460 then do;
      341 	     year = year + divide (date, 365, 17, 0);	/* calculate the year number */
      342 	     date = mod (date, 365);
      343 	     end;
      344 	else do;
      345 	     year = year + 3;
      346 	     date = 365;
      347 	     end;
      348 
      349 	if Sall then day_of_year = date + 1;		/* return day-in-year count for $all entry point.	*/
      350 						/* Use Stone's algorithm to compute month number.	*/
      351 	if mod (year, 4) = 0
      352 	then if date > 59
      353 	     then date = date + 1;
      354 	     else ;
      355 	else if date > 58
      356 	     then date = date + 2;
      357 	     else ;
      358 
      359 	date = date + 92;				/* Algorithm says to add 92 days.		*/
      360 	month = divide ((100 * date), 3055, 17, 0);	/* divide number of days by 30.55.		*/
      361 	day = date - divide ((3055 * month), 100, 17, 0); /* month-number * 30.55 gives number of days 	*/
      362 						/* before the first day of this month.		*/
      363 	month = month - 2;				/* Algorithm says subtract 2 to get month number.	*/
      364 	return;
      365 
      366 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      367 
      368 bad_clock:
      369 	code = error_table_$bad_year;			/* clock value was not within the 20th Century.	*/
      370 	go to error;
      371 
      372 bad_zone:
      373 	code = error_table_$unknown_zone;		/* specified time zone not found in time_table_.	*/
      374 	go to error;
      375 
      376 bad_version:
      377 	code = error_table_$unimplemented_version;
      378 error:
      379 	month = 0;
      380 	day = 0;
      381 	year = 0;
      382 	micro_second = 0;
      383 	day_of_week = 0;
      384 	return;
      385 
      386 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      387 
      388 init_time_data:
      389      procedure;
      390 	if time_data_$time_delta = -1 then call time_data_$time_data_init;
      391      end init_time_data;
      392 
      393      end decode_clock_value_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1134.0  decode_clock_value_.pl1           >dumps>old_dumps>hardcore>decode_clock_value_.pl1
215          1    11/04/76  1639.9  time_zones_.incl.pl1              >ldd>include>time_zones_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Aclock                                 parameter       fixed bin(71,0)          dcl 167 ref 164 230 230 232 246 256 264 277 277 282
                                                                                  290
Azone                                  parameter       char(3)                  unaligned dcl 167 set ref 164 233* 246 256 264 279
                                                                                  279* 281
MAXIMUM_TIME                    000000 constant        fixed bin(71,0)          initial dcl 199 ref 230 277
Sall                            000100 automatic       bit(1)                   initial dcl 187 set ref 187* 250* 330 349
Stime                           000101 automatic       bit(1)                   initial dcl 187 set ref 187* 259* 318
Vtime_zones_1                          constant        fixed bin(17,0)          initial dcl 1-18 ref 285
addr                                                   builtin function         dcl 197 ref 285 286 286 288 290
clock                           000102 automatic       fixed bin(71,0)          dcl 187 set ref 232* 235 235 237 238 282* 290* 302
                                                                                  303 309 314
code                                   parameter       fixed bin(35,0)          dcl 167 set ref 246 256 264 275* 368* 372* 376*
date                            000104 automatic       fixed bin(17,0)          dcl 187 set ref 235* 237* 238 306* 312* 317 330 332
                                                                                  336 336 338 339* 339 340 341 342* 342 346* 349 351
                                                                                  351* 351 355 355* 355 359* 359 360 361
day                                    parameter       fixed bin(17,0)          dcl 167 set ref 164 246 264 361* 380*
day_of_week                            parameter       fixed bin(17,0)          dcl 167 set ref 164 246 264 332* 383*
day_of_year                            parameter       fixed bin(17,0)          dcl 167 set ref 246 349*
days_in_clock                          parameter       fixed bin(17,0)          dcl 167 set ref 246 330*
divide                                                 builtin function         dcl 197 ref 235 237 303 304 305 306 309 310 311 312
                                                                                  336 338 341 360 361
error_table_$bad_year           000010 external static fixed bin(35,0)          dcl 199 ref 368
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 199 ref 376
error_table_$unknown_zone       000014 external static fixed bin(35,0)          dcl 199 ref 372
hour                                   parameter       fixed bin(17,0)          dcl 167 set ref 246 256 264 317*
i                               000105 automatic       fixed bin(17,0)          dcl 187 set ref 286* 286* 288 290
micro_second                           parameter       fixed bin(71,0)          dcl 167 set ref 246 256 264 314* 382*
minute                                 parameter       fixed bin(17,0)          dcl 167 set ref 246 256 264 316*
mod                                                    builtin function         dcl 197 ref 332 339 342 351
month                                  parameter       fixed bin(17,0)          dcl 167 set ref 164 246 264 360* 361 363* 363 378*
number                    1            based           fixed bin(17,0)          level 2 dcl 1-8 ref 286 288
second                                 parameter       fixed bin(17,0)          dcl 167 set ref 246 256 264 315*
time_data_$time_data_init       000022 constant        entry                    external dcl 213 ref 390
time_data_$time_delta           000016 external static fixed bin(71,0)          dcl 199 ref 232 282 390
time_data_$time_zone            000020 external static char(3)                  dcl 199 ref 233 279 282
time_table_$zones               000024 external static fixed bin(35,0)          dcl 1-3 set ref 285 286 286 288 290
time_zones                             based           structure                level 1 dcl 1-8
tot_hrs                         000110 automatic       fixed bin(35,0)          dcl 187 set ref 305* 306 311* 312 316 317
tot_mins                        000107 automatic       fixed bin(35,0)          dcl 187 set ref 304* 305 310* 311 315 316
tot_secs                        000106 automatic       fixed bin(35,0)          dcl 187 set ref 303* 304 309* 310 314 315
translate                                              builtin function         dcl 197 ref 281
us_in_day                              parameter       fixed bin(71,0)          dcl 167 set ref 164 238*
values                    2            based           structure                array level 2 dcl 1-8
version                                based           fixed bin(17,0)          level 2 dcl 1-8 ref 285
year                                   parameter       fixed bin(17,0)          dcl 167 set ref 164 246 264 336* 338* 341* 341 345*
                                                                                  345 351 381*
zone                            000111 automatic       char(3)                  dcl 187 in procedure "decode_clock_value_" set ref
                                                                                  281* 282 286
zone                      2            based           char(3)                  array level 3 in structure "time_zones" dcl 1-8
                                                                                  in procedure "decode_clock_value_" ref 286
zone_offset               4            based           fixed bin(71,0)          array level 3 dcl 1-8 ref 290

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
time                                   automatic       fixed bin(35,0)          dcl 187

NAMES DECLARED BY EXPLICIT CONTEXT.
all                             000133 constant        entry                    external dcl 246
bad_clock                       000576 constant        label                    dcl 368 ref 230 277
bad_version                     000605 constant        label                    dcl 376 ref 285
bad_zone                        000602 constant        label                    dcl 372 ref 288
common                          000462 constant        label                    dcl 330 ref 239
date_time                       000227 constant        entry                    external dcl 264
decode_clock_value_             000047 constant        entry                    external dcl 164
error                           000607 constant        label                    dcl 378 ref 370 374
get_time                        000254 constant        label                    dcl 275 ref 252 260
init_time_data                  000617 constant        entry                    internal dcl 388 ref 231 278
time                            000171 constant        entry                    external dcl 256

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1176        1224    1041        1206
Length      1440    1041        26         177     135           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
decode_clock_value_                 100 external procedure  is an external procedure.  
init_time_data                          internal procedure  shares stack frame of external procedure decode_clock_value_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
decode_clock_value_      000100 Sall                        decode_clock_value_
                         000101 Stime                       decode_clock_value_
                         000102 clock                       decode_clock_value_
                         000104 date                        decode_clock_value_
                         000105 i                           decode_clock_value_
                         000106 tot_secs                    decode_clock_value_
                         000107 tot_mins                    decode_clock_value_
                         000110 tot_hrs                     decode_clock_value_
                         000111 zone                        decode_clock_value_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              mpfx2               mod_fx1             ext_entry           divide_fx3
divide_fx4

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
time_data_$time_data_init

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_year         error_table_$unimplemented_version                          error_table_$unknown_zone
time_data_$time_delta         time_data_$time_zone          time_table_$zones


CONSTANTS
000633  aa  000 001 002 003	 
000634  aa  004 005 006 007	
000635  aa  010 011 012 013		

000636  aa  014 015 016 017	
000637  aa  020 021 022 023	
000640  aa  024 025 026 027	
000641  aa  030 031 032 033	
000642  aa  034 035 036 037	
000643  aa  040 041 042 043	 !"#
000644  aa  044 045 046 047	$%&'
000645  aa  050 051 052 053	()*+
000646  aa  054 055 056 057	,-./
000647  aa  060 061 062 063	0123
000650  aa  064 065 066 067	4567
000651  aa  070 071 072 073	89:;
000652  aa  074 075 076 077	<=>?
000653  aa  100 141 142 143	@abc
000654  aa  144 145 146 147	defg
000655  aa  150 151 152 153	hijk
000656  aa  154 155 156 157	lmno
000657  aa  160 161 162 163	pqrs
000660  aa  164 165 166 167	tuvw
000661  aa  170 171 172 133	xyz[
000662  aa  134 135 136 137	\]^_
000663  aa  140 141 142 143	`abc
000664  aa  144 145 146 147	defg
000665  aa  150 151 152 153	hijk
000666  aa  154 155 156 157	lmno
000667  aa  160 161 162 163	pqrs
000670  aa  164 165 166 167	tuvw
000671  aa  170 171 172 173	xyz{
000672  aa  174 175 176 177	|}~
000673  aa  200 201 202 203	ÄÅÇÉ
000674  aa  204 205 206 207	ÑÖÜá
000675  aa  210 211 212 213	àâäã
000676  aa  214 215 216 217	åçéè
000677  aa  220 221 222 223	êëíì
000700  aa  224 225 226 227	îïñó
000701  aa  230 231 232 233	òôöõ
000702  aa  234 235 236 237	úùûü
000703  aa  240 241 242 243	†°¢£
000704  aa  244 245 246 247	§•¶ß
000705  aa  250 251 252 253	®©™´
000706  aa  254 255 256 257	¨≠ÆØ
000707  aa  260 261 262 263	∞±≤≥
000710  aa  264 265 266 267	¥µ∂∑
000711  aa  270 271 272 273	∏π∫ª
000712  aa  274 275 276 277	ºΩæø
000713  aa  300 301 302 303	¿¡¬√
000714  aa  304 305 306 307	ƒ≈∆«
000715  aa  310 311 312 313	»… À
000716  aa  314 315 316 317	ÃÕŒœ
000717  aa  320 321 322 323	–—“”
000720  aa  324 325 326 327	‘’÷◊
000721  aa  330 331 332 333	ÿŸ⁄€
000722  aa  334 335 336 337	‹›ﬁﬂ
000723  aa  340 341 342 343	‡·‚„
000724  aa  344 345 346 347	‰ÂÊÁ
000725  aa  350 351 352 353	ËÈÍÎ
000726  aa  354 355 356 357	ÏÌÓÔ
000727  aa  360 361 362 363	ÒÚÛ
000730  aa  364 365 366 367	Ùıˆ˜
000731  aa  370 371 372 373	¯˘˙˚
000732  aa  374 375 376 377	¸˝˛ˇ
000733  aa  400 401 402 403	 
000734  aa  404 405 406 407	
000735  aa  410 411 412 413		

000736  aa  414 415 416 417	
000737  aa  420 421 422 423	
000740  aa  424 425 426 427	
000741  aa  430 431 432 433	
000742  aa  434 435 436 437	
000743  aa  440 441 442 443	 !"#
000744  aa  444 445 446 447	$%&'
000745  aa  450 451 452 453	()*+
000746  aa  454 455 456 457	,-./
000747  aa  460 461 462 463	0123
000750  aa  464 465 466 467	4567
000751  aa  470 471 472 473	89:;
000752  aa  474 475 476 477	<=>?
000753  aa  500 501 502 503	@ABC
000754  aa  504 505 506 507	DEFG
000755  aa  510 511 512 513	HIJK
000756  aa  514 515 516 517	LMNO
000757  aa  520 521 522 523	PQRS
000760  aa  524 525 526 527	TUVW
000761  aa  530 531 532 533	XYZ[
000762  aa  534 535 536 537	\]^_
000763  aa  540 541 542 543	`abc
000764  aa  544 545 546 547	defg
000765  aa  550 551 552 553	hijk
000766  aa  554 555 556 557	lmno
000767  aa  560 561 562 563	pqrs
000770  aa  564 565 566 567	tuvw
000771  aa  570 571 572 573	xyz{
000772  aa  574 575 576 577	|}~
000773  aa  600 601 602 603	ÄÅÇÉ
000774  aa  604 605 606 607	ÑÖÜá
000775  aa  610 611 612 613	àâäã
000776  aa  614 615 616 617	åçéè
000777  aa  620 621 622 623	êëíì
001000  aa  624 625 626 627	îïñó
001001  aa  630 631 632 633	òôöõ
001002  aa  634 635 636 637	úùûü
001003  aa  640 641 642 643	†°¢£
001004  aa  644 645 646 647	§•¶ß
001005  aa  650 651 652 653	®©™´
001006  aa  654 655 656 657	¨≠ÆØ
001007  aa  660 661 662 663	∞±≤≥
001010  aa  664 665 666 667	¥µ∂∑
001011  aa  670 671 672 673	∏π∫ª
001012  aa  674 675 676 677	ºΩæø
001013  aa  700 701 702 703	¿¡¬√
001014  aa  704 705 706 707	ƒ≈∆«
001015  aa  710 711 712 713	»… À
001016  aa  714 715 716 717	ÃÕŒœ
001017  aa  720 721 722 723	–—“”
001020  aa  724 725 726 727	‘’÷◊
001021  aa  730 731 732 733	ÿŸ⁄€
001022  aa  734 735 736 737	‹›ﬁﬂ
001023  aa  740 741 742 743	‡·‚„
001024  aa  744 745 746 747	‰ÂÊÁ
001025  aa  750 751 752 753	ËÈÍÎ
001026  aa  754 755 756 757	ÏÌÓÔ
001027  aa  760 761 762 763	ÒÚÛ
001030  aa  764 765 766 767	Ùıˆ˜
001031  aa  770 771 772 773	¯˘˙˚
001032  aa  774 775 776 777	¸˝˛ˇ

000000  aa     000000130627
000001  aa     342555777777


001033  aa     000000000555

001034  aa     000000002665

000002  aa     000003641077

001035  aa     000000000030

001036  aa     000000000074

000003  aa     000003641100

001037  aa     000000000007

000004  aa     404000000043

000005  aa     526000000003

001040  aa     000000000004

000006  aa     404000000021

000007  aa     410000000107

000010  aa     000000000000
000011  aa     000000000000

000012  aa     000000000001
000013  aa     203565657777

000014  aa     000000000001
000015  aa     203565660000

000016  aa  101 102 103 104	ABCD
000017  aa  105 106 107 110	EFGH
000020  aa  111 112 113 114	IJKL
000021  aa  115 116 117 120	MNOP
000022  aa  121 122 123 124	QRST
000023  aa  125 126 127 130	UVWX
000024  aa  131 132 000 000	YZ

000025  aa  141 142 143 144	abcd
000026  aa  145 146 147 150	efgh
000027  aa  151 152 153 154	ijkl
000030  aa  155 156 157 160	mnop
000031  aa  161 162 163 164	qrst
000032  aa  165 166 167 170	uvwx
000033  aa  171 172 000 000	yz

BEGIN PROCEDURE decode_clock_value_
PROLOGUE SEQUENCE
000034  aa  6 00140 4401 00	sxl0 	pr6|96
						STATEMENT 1 ON LINE 187
000035  aa  6 00100 4501 00	stz  	pr6|64		Sall
000036  aa  6 00101 4501 00	stz  	pr6|65		Stime
000037  aa  6 00140 7201 00	lxl0 	pr6|96
000040  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO decode_clock_value_                                STATEMENT 1 ON LINE 164
decode_clock_value_:
     procedure (Aclock, month, day, year, us_in_day, day_of_week, Azone);

000041  at     000007000007
000042  tt     000006000006
000043  tt     000006000007
000044  tt     000006000005
000045  ta     000041000000
000046  da     000112300000
000047  aa   000160 6270 00	eax7 	112
000050  aa  7 00034 3521 20	epp2 	pr7|28,*
000051  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000052  aa     000016000000
000053  aa     000000000000
000054  aa  6 00032 3735 20	epp7 	pr6|26,*
000055  aa  7 00014 3715 20	epp5 	pr7|12,*
000056  aa  6 00122 6515 00	spri5	pr6|82
000057  aa  7 00016 3535 20	epp3 	pr7|14,*
000060  aa  6 00124 2535 00	spri3	pr6|84
000061  aa   777753 7000 04	tsx0 	-21,ic		000034
						STATEMENT 1 ON LINE 230
	if (Aclock < 0) | (Aclock > MAXIMUM_TIME) then goto bad_clock;

000062  aa  6 00032 3735 20	epp7 	pr6|26,*
000063  aa  7 00002 2371 20	ldaq 	pr7|2,*		Aclock
000064  aa   000512 6040 04	tmi  	330,ic		000576
000065  aa   777713 1170 04	cmpaq	-53,ic		000000 = 000000130627 342555777777
000066  aa   000510 6054 04	tpnz 	328,ic		000576
						STATEMENT 1 ON LINE 231
	call init_time_data;

000067  aa   000530 6700 04	tsp4 	344,ic		000617
						STATEMENT 1 ON LINE 232
	clock = Aclock - time_data_$time_delta;

000070  aa  6 00032 3735 20	epp7 	pr6|26,*
000071  aa  7 00002 2371 20	ldaq 	pr7|2,*		Aclock
000072  aa  6 00044 3701 20	epp4 	pr6|36,*
000073  la  4 00016 1771 20	sbaq 	pr4|14,*		time_data_$time_delta
000074  aa  6 00102 7571 00	staq 	pr6|66		clock
						STATEMENT 1 ON LINE 233
	Azone = time_data_$time_zone;

000075  aa  6 00124 3715 20	epp5 	pr6|84,*
000076  la  4 00020 3535 20	epp3 	pr4|16,*		time_data_$time_zone
000077  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000100  aa  3 00000 00 0003	desc9a	pr3|0,3		time_data_$time_zone
000101  aa  5 00000 00 0003	desc9a	pr5|0,3		Azone
						STATEMENT 1 ON LINE 235
	if clock >= 0
	then date = divide (clock, 86400000000, 17, 0);

000102  aa   000006 6040 04	tmi  	6,ic		000110
000103  aa   777711 3520 04	epp2 	-55,ic		000014 = 000000000001
000104  aa  0 01265 7001 00	tsx0 	pr0|693		divide_fx4
000105  aa     000000000000
000106  aa  6 00104 7561 00	stq  	pr6|68		date
000107  aa   000006 7100 04	tra  	6,ic		000115
						STATEMENT 1 ON LINE 237
	else date = divide (clock - 86399999999, 86400000000, 17, 0);

000110  aa   777702 1770 04	sbaq 	-62,ic		000012 = 000000000001 203565657777
000111  aa   777703 3520 04	epp2 	-61,ic		000014 = 000000000001
000112  aa  0 01265 7001 00	tsx0 	pr0|693		divide_fx4
000113  aa     000000000000
000114  aa  6 00104 7561 00	stq  	pr6|68		date
						STATEMENT 1 ON LINE 238
	us_in_day = clock - (date * 86400000000);

000115  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
000116  aa   000000 5330 00	negl 	0
000117  aa  6 00102 0771 00	adaq 	pr6|66		clock
000120  aa  7 00012 7571 20	staq 	pr7|10,*		us_in_day
						STATEMENT 1 ON LINE 239
	go to common;

000121  aa   000341 7100 04	tra  	225,ic		000462
ENTRY TO all                                                STATEMENT 1 ON LINE 246
all:
     entry (Aclock, month, day, year, hour, minute, second, micro_second, day_of_week, Azone, days_in_clock, day_of_year,
	code);

000122  at     000015000007
000123  tt     000006000006
000124  tt     000006000006
000125  tt     000006000006
000126  tt     000007000006
000127  tt     000005000006
000130  tt     000006000004
000131  ta     000122000000
000132  da     000116300000
000133  aa   000160 6270 00	eax7 	112
000134  aa  7 00034 3521 20	epp2 	pr7|28,*
000135  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000136  aa     000032000000
000137  aa     000000000000
000140  aa  6 00032 3735 20	epp7 	pr6|26,*
000141  aa  7 00012 3715 20	epp5 	pr7|10,*
000142  aa  6 00112 6515 00	spri5	pr6|74
000143  aa  7 00014 3535 20	epp3 	pr7|12,*
000144  aa  6 00114 2535 00	spri3	pr6|76
000145  aa  7 00016 3515 20	epp1 	pr7|14,*
000146  aa  6 00116 2515 00	spri1	pr6|78
000147  aa  7 00020 3715 20	epp5 	pr7|16,*
000150  aa  6 00120 6515 00	spri5	pr6|80
000151  aa  7 00022 3535 20	epp3 	pr7|18,*
000152  aa  6 00122 2535 00	spri3	pr6|82
000153  aa  7 00024 3515 20	epp1 	pr7|20,*
000154  aa  6 00124 2515 00	spri1	pr6|84
000155  aa  7 00032 3715 20	epp5 	pr7|26,*
000156  aa  6 00126 6515 00	spri5	pr6|86
000157  aa   777655 7000 04	tsx0 	-83,ic		000034
						STATEMENT 1 ON LINE 250
	Sall = "1"b;

000160  aa   400000 2350 03	lda  	131072,du
000161  aa  6 00100 7551 00	sta  	pr6|64		Sall
						STATEMENT 1 ON LINE 252
	goto get_time;

000162  aa   000072 7100 04	tra  	58,ic		000254
ENTRY TO time                                               STATEMENT 1 ON LINE 256
time:
     entry (Aclock, hour, minute, second, micro_second, Azone, code);

000163  at     000007000007
000164  tt     000006000006
000165  tt     000006000007
000166  tt     000005000004
000167  ta     000163000000
000170  da     000123300000
000171  aa   000160 6270 00	eax7 	112
000172  aa  7 00034 3521 20	epp2 	pr7|28,*
000173  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000174  aa     000016000000
000175  aa     000000000000
000176  aa  6 00032 3735 20	epp7 	pr6|26,*
000177  aa  7 00004 3715 20	epp5 	pr7|4,*
000200  aa  6 00112 6515 00	spri5	pr6|74
000201  aa  7 00006 3535 20	epp3 	pr7|6,*
000202  aa  6 00114 2535 00	spri3	pr6|76
000203  aa  7 00010 3515 20	epp1 	pr7|8,*
000204  aa  6 00116 2515 00	spri1	pr6|78
000205  aa  7 00012 3715 20	epp5 	pr7|10,*
000206  aa  6 00120 6515 00	spri5	pr6|80
000207  aa  7 00014 3535 20	epp3 	pr7|12,*
000210  aa  6 00124 2535 00	spri3	pr6|84
000211  aa  7 00016 3515 20	epp1 	pr7|14,*
000212  aa  6 00126 2515 00	spri1	pr6|86
000213  aa   777621 7000 04	tsx0 	-111,ic		000034
						STATEMENT 1 ON LINE 259
	Stime = "1"b;

000214  aa   400000 2350 03	lda  	131072,du
000215  aa  6 00101 7551 00	sta  	pr6|65		Stime
						STATEMENT 1 ON LINE 260
	goto get_time;

000216  aa   000036 7100 04	tra  	30,ic		000254
ENTRY TO date_time                                          STATEMENT 1 ON LINE 264
date_time:
     entry (Aclock, month, day, year, hour, minute, second, micro_second, day_of_week, Azone, code);

000217  at     000013000007
000220  tt     000006000006
000221  tt     000006000006
000222  tt     000006000006
000223  tt     000007000006
000224  tt     000005000004
000225  ta     000217000000
000226  da     000131300000
000227  aa   000160 6270 00	eax7 	112
000230  aa  7 00034 3521 20	epp2 	pr7|28,*
000231  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000232  aa     000026000000
000233  aa     000000000000
000234  aa  6 00032 3735 20	epp7 	pr6|26,*
000235  aa  7 00012 3715 20	epp5 	pr7|10,*
000236  aa  6 00112 6515 00	spri5	pr6|74
000237  aa  7 00014 3535 20	epp3 	pr7|12,*
000240  aa  6 00114 2535 00	spri3	pr6|76
000241  aa  7 00016 3515 20	epp1 	pr7|14,*
000242  aa  6 00116 2515 00	spri1	pr6|78
000243  aa  7 00020 3715 20	epp5 	pr7|16,*
000244  aa  6 00120 6515 00	spri5	pr6|80
000245  aa  7 00022 3535 20	epp3 	pr7|18,*
000246  aa  6 00122 2535 00	spri3	pr6|82
000247  aa  7 00024 3515 20	epp1 	pr7|20,*
000250  aa  6 00124 2515 00	spri1	pr6|84
000251  aa  7 00026 3715 20	epp5 	pr7|22,*
000252  aa  6 00126 6515 00	spri5	pr6|86
000253  aa   777561 7000 04	tsx0 	-143,ic		000034
						STATEMENT 1 ON LINE 275
get_time:
	code = 0;

000254  aa  6 00126 4501 20	stz  	pr6|86,*		code
						STATEMENT 1 ON LINE 277
	if (Aclock < 0) | (Aclock > MAXIMUM_TIME) then goto bad_clock;

000255  aa  6 00032 3735 20	epp7 	pr6|26,*
000256  aa  7 00002 2371 20	ldaq 	pr7|2,*		Aclock
000257  aa   000317 6040 04	tmi  	207,ic		000576
000260  aa   777520 1170 04	cmpaq	-176,ic		000000 = 000000130627 342555777777
000261  aa   000315 6054 04	tpnz 	205,ic		000576
						STATEMENT 1 ON LINE 278
	call init_time_data;

000262  aa   000335 6700 04	tsp4 	221,ic		000617
						STATEMENT 1 ON LINE 279
	if Azone = "" then Azone = time_data_$time_zone;

000263  aa  6 00124 3735 20	epp7 	pr6|84,*
000264  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000265  aa  7 00000 00 0003	desc9a	pr7|0,3		Azone
000266  aa   000547 00 0000	desc9a	359,0		001033 = 000000000555
000267  aa   000006 6010 04	tnz  	6,ic		000275
000270  aa  6 00044 3701 20	epp4 	pr6|36,*
000271  la  4 00020 3715 20	epp5 	pr4|16,*		time_data_$time_zone
000272  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000273  aa  5 00000 00 0003	desc9a	pr5|0,3		time_data_$time_zone
000274  aa  7 00000 00 0003	desc9a	pr7|0,3		Azone
						STATEMENT 1 ON LINE 281
	zone = translate (Azone, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");

000275  aa  6 00111 4501 00	stz  	pr6|73		zone
000276  aa  040 100 160 500	mvt  	(pr),(pr),fill(040)
000277  aa  7 00000 00 0003	desc9a	pr7|0,3		Azone
000300  aa  6 00111 00 0003	desc9a	pr6|73,3		zone
000301  aa   000335 0000 04	arg  	221,ic		000633 = 000001002003
						STATEMENT 1 ON LINE 282
	if zone = time_data_$time_zone
	then clock = Aclock - time_data_$time_delta;

000302  aa  6 00111 2351 00	lda  	pr6|73		zone
000303  aa  6 00044 3701 20	epp4 	pr6|36,*
000304  la  4 00020 1151 20	cmpa 	pr4|16,*		time_data_$time_zone
000305  aa   000006 6010 04	tnz  	6,ic		000313
000306  aa  6 00032 3715 20	epp5 	pr6|26,*
000307  aa  5 00002 2371 20	ldaq 	pr5|2,*		Aclock
000310  la  4 00016 1771 20	sbaq 	pr4|14,*		time_data_$time_delta
000311  aa  6 00102 7571 00	staq 	pr6|66		clock
000312  aa   000041 7100 04	tra  	33,ic		000353
						STATEMENT 1 ON LINE 284
	else do;

						STATEMENT 1 ON LINE 285
	     if time_zones.version ^= Vtime_zones_1 then go to bad_version;

000313  la  4 00024 3715 20	epp5 	pr4|20,*		time_table_$zones
000314  aa  6 00142 6515 00	spri5	pr6|98
000315  aa  5 00000 2361 00	ldq  	pr5|0		time_zones.version
000316  aa   000001 1160 07	cmpq 	1,dl
000317  aa   000266 6010 04	tnz  	182,ic		000605
						STATEMENT 1 ON LINE 286
	     do i = 1 to time_zones.number while (time_zones.zone (i) ^= zone);

000320  aa  5 00001 2361 00	ldq  	pr5|1		time_zones.number
000321  aa  6 00130 7561 00	stq  	pr6|88
000322  aa   000001 2360 07	ldq  	1,dl
000323  aa  6 00105 7561 00	stq  	pr6|69		i
000324  aa  6 00105 2361 00	ldq  	pr6|69		i
000325  aa  6 00130 1161 00	cmpq 	pr6|88
000326  aa   000011 6054 04	tpnz 	9,ic		000337
000327  aa   000002 7360 00	qls  	2
000330  aa  6 00044 3701 20	epp4 	pr6|36,*
000331  la  4 00024 3735 20	epp7 	pr4|20,*
000332  aa  7 77776 2351 06	lda  	pr7|-2,ql		time_zones.zone
000333  aa  6 00111 1151 00	cmpa 	pr6|73		zone
000334  aa   000003 6000 04	tze  	3,ic		000337
						STATEMENT 1 ON LINE 287
	     end;

000335  aa  6 00105 0541 00	aos  	pr6|69		i
000336  aa   777766 7100 04	tra  	-10,ic		000324
						STATEMENT 1 ON LINE 288
	     if i > time_zones.number then go to bad_zone;

000337  aa  6 00044 3701 20	epp4 	pr6|36,*
000340  la  4 00024 3735 20	epp7 	pr4|20,*		time_table_$zones
000341  aa  6 00142 6535 00	spri7	pr6|98
000342  aa  6 00105 2361 00	ldq  	pr6|69		i
000343  aa  7 00001 1161 00	cmpq 	pr7|1		time_zones.number
000344  aa   000236 6054 04	tpnz 	158,ic		000602
						STATEMENT 1 ON LINE 290
	     clock = Aclock - time_zones.zone_offset (i);

000345  aa   000002 7360 00	qls  	2
000346  aa  6 00032 3715 20	epp5 	pr6|26,*
000347  aa   000000 6270 06	eax7 	0,ql
000350  aa  5 00002 2371 20	ldaq 	pr5|2,*		Aclock
000351  aa  7 00000 1771 17	sbaq 	pr7|0,7		time_zones.zone_offset
000352  aa  6 00102 7571 00	staq 	pr6|66		clock
						STATEMENT 1 ON LINE 291
	     end;

						STATEMENT 1 ON LINE 302
	if clock >= 0 then do;

000353  aa   000014 6040 04	tmi  	12,ic		000367
						STATEMENT 1 ON LINE 303
	     tot_secs = divide (clock, 1000000, 35, 0);

000354  aa   777427 3520 04	epp2 	-233,ic		000003 = 000003641100
000355  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000356  aa     000000000000
000357  aa  6 00106 7561 00	stq  	pr6|70		tot_secs
						STATEMENT 1 ON LINE 304
	     tot_mins = divide (tot_secs, 60, 35, 0);

000360  aa   000074 5060 07	div  	60,dl
000361  aa  6 00107 7561 00	stq  	pr6|71		tot_mins
						STATEMENT 1 ON LINE 305
	     tot_hrs = divide (tot_mins, 60, 35, 0);

000362  aa   000074 5060 07	div  	60,dl
000363  aa  6 00110 7561 00	stq  	pr6|72		tot_hrs
						STATEMENT 1 ON LINE 306
	     date = divide (tot_hrs, 24, 17, 0);

000364  aa   000030 5060 07	div  	24,dl
000365  aa  6 00104 7561 00	stq  	pr6|68		date
						STATEMENT 1 ON LINE 307
	     end;

000366  aa   000042 7100 04	tra  	34,ic		000430
						STATEMENT 1 ON LINE 308
	else do;

						STATEMENT 1 ON LINE 309
	     tot_secs = divide (clock - 999999, 1000000, 35, 0);

000367  aa   000000 5330 00	negl 	0
000370  aa   777412 0330 04	adl  	-246,ic		000002 = 000003641077
000371  aa   000000 5330 00	negl 	0
000372  aa   777411 3520 04	epp2 	-247,ic		000003 = 000003641100
000373  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000374  aa     000000000000
000375  aa  6 00106 7561 00	stq  	pr6|70		tot_secs
						STATEMENT 1 ON LINE 310
	     tot_mins = divide (tot_secs - 59, 60, 35, 0);

000376  aa  6 00106 3361 00	lcq  	pr6|70		tot_secs
000377  aa   000044 7770 00	llr  	36
000400  aa   000044 7330 00	lrs  	36
000401  aa   000073 0330 07	adl  	59,dl
000402  aa   000000 5330 00	negl 	0
000403  aa   000433 3520 04	epp2 	283,ic		001036 = 000000000074
000404  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000405  aa     000000000000
000406  aa  6 00107 7561 00	stq  	pr6|71		tot_mins
						STATEMENT 1 ON LINE 311
	     tot_hrs = divide (tot_mins - 59, 60, 35, 0);

000407  aa  6 00107 3361 00	lcq  	pr6|71		tot_mins
000410  aa   000044 7770 00	llr  	36
000411  aa   000044 7330 00	lrs  	36
000412  aa   000073 0330 07	adl  	59,dl
000413  aa   000000 5330 00	negl 	0
000414  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000415  aa     000000000000
000416  aa  6 00110 7561 00	stq  	pr6|72		tot_hrs
						STATEMENT 1 ON LINE 312
	     date = divide (tot_hrs - 23, 24, 17, 0);

000417  aa  6 00110 3361 00	lcq  	pr6|72		tot_hrs
000420  aa   000044 7770 00	llr  	36
000421  aa   000044 7330 00	lrs  	36
000422  aa   000027 0330 07	adl  	23,dl
000423  aa   000000 5330 00	negl 	0
000424  aa   000411 3520 04	epp2 	265,ic		001035 = 000000000030
000425  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000426  aa     000000000000
000427  aa  6 00104 7561 00	stq  	pr6|68		date
						STATEMENT 1 ON LINE 313
	     end;

						STATEMENT 1 ON LINE 314
	micro_second = clock - 1000000 * tot_secs;

000430  aa   777353 2360 04	ldq  	-277,ic		000003 = 000003641100
000431  aa  6 00106 4021 00	mpy  	pr6|70		tot_secs
000432  aa   000000 5330 00	negl 	0
000433  aa  6 00102 0771 00	adaq 	pr6|66		clock
000434  aa  6 00120 7571 20	staq 	pr6|80,*		micro_second
						STATEMENT 1 ON LINE 315
	second = tot_secs - 60 * tot_mins;

000435  aa   000074 2360 07	ldq  	60,dl
000436  aa  6 00107 4021 00	mpy  	pr6|71		tot_mins
000437  aa   000000 5330 00	negl 	0
000440  aa  6 00106 0331 00	adl  	pr6|70		tot_secs
000441  aa  6 00116 7561 20	stq  	pr6|78,*		second
						STATEMENT 1 ON LINE 316
	minute = tot_mins - 60 * tot_hrs;

000442  aa   000074 2360 07	ldq  	60,dl
000443  aa  6 00110 4021 00	mpy  	pr6|72		tot_hrs
000444  aa   000000 5330 00	negl 	0
000445  aa  6 00107 0331 00	adl  	pr6|71		tot_mins
000446  aa  6 00114 7561 20	stq  	pr6|76,*		minute
						STATEMENT 1 ON LINE 317
	hour = tot_hrs - 24 * date;

000447  aa  6 00104 2361 00	ldq  	pr6|68		date
000450  aa   000030 4020 07	mpy  	24,dl
000451  aa  6 00141 7561 00	stq  	pr6|97
000452  aa  6 00110 3361 00	lcq  	pr6|72		tot_hrs
000453  aa   000044 7770 00	llr  	36
000454  aa   000044 7330 00	lrs  	36
000455  aa  6 00141 0331 00	adl  	pr6|97
000456  aa   000000 5330 00	negl 	0
000457  aa  6 00112 7561 20	stq  	pr6|74,*		hour
						STATEMENT 1 ON LINE 318
	if Stime then return;

000460  aa  6 00101 2351 00	lda  	pr6|65		Stime
000461  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 330
common:
	if Sall then days_in_clock = date + 1;

000462  aa  6 00100 2351 00	lda  	pr6|64		Sall
000463  aa   000005 6000 04	tze  	5,ic		000470
000464  aa  6 00104 2361 00	ldq  	pr6|68		date
000465  aa   000001 0760 07	adq  	1,dl
000466  aa  6 00032 3735 20	epp7 	pr6|26,*
000467  aa  7 00026 7561 20	stq  	pr7|22,*		days_in_clock
						STATEMENT 1 ON LINE 332
	day_of_week = mod (date + 1, 7) + 1;

000470  aa  6 00104 2361 00	ldq  	pr6|68		date
000471  aa   000001 0760 07	adq  	1,dl
000472  aa   000345 3520 04	epp2 	229,ic		001037 = 000000000007
000473  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000474  aa   000001 0760 07	adq  	1,dl
000475  aa  6 00122 7561 20	stq  	pr6|82,*		day_of_week
						STATEMENT 1 ON LINE 336
	if date >= 0
	then year = 1901 + 4 * divide (date, 1461, 17, 0);

000476  aa  6 00104 2361 00	ldq  	pr6|68		date
000477  aa   000007 6040 04	tmi  	7,ic		000506
000500  aa   002665 5060 07	div  	1461,dl
000501  aa   000002 7360 00	qls  	2
000502  aa   003555 0760 07	adq  	1901,dl
000503  aa  6 00032 3735 20	epp7 	pr6|26,*
000504  aa  7 00010 7561 20	stq  	pr7|8,*		year
000505  aa   000007 7100 04	tra  	7,ic		000514
						STATEMENT 1 ON LINE 338
	else year = 1901 + 4 * divide (date - 1460, 1461, 17, 0);

000506  aa   002664 1760 07	sbq  	1460,dl
000507  aa   002665 5060 07	div  	1461,dl
000510  aa   000002 7360 00	qls  	2
000511  aa   003555 0760 07	adq  	1901,dl
000512  aa  6 00032 3735 20	epp7 	pr6|26,*
000513  aa  7 00010 7561 20	stq  	pr7|8,*		year
						STATEMENT 1 ON LINE 339
	date = mod (date, 1461);

000514  aa  6 00104 2361 00	ldq  	pr6|68		date
000515  aa   000317 3520 04	epp2 	207,ic		001034 = 000000002665
000516  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000517  aa  6 00104 7561 00	stq  	pr6|68		date
						STATEMENT 1 ON LINE 340
	if date < 1460 then do;

000520  aa   002664 1160 07	cmpq 	1460,dl
000521  aa   000010 6050 04	tpl  	8,ic		000531
						STATEMENT 1 ON LINE 341
	     year = year + divide (date, 365, 17, 0);

000522  aa   000555 5060 07	div  	365,dl
000523  aa  7 00010 0561 20	asq  	pr7|8,*		year
						STATEMENT 1 ON LINE 342
	     date = mod (date, 365);

000524  aa  6 00104 2361 00	ldq  	pr6|68		date
000525  aa   000306 3520 04	epp2 	198,ic		001033 = 000000000555
000526  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000527  aa  6 00104 7561 00	stq  	pr6|68		date
						STATEMENT 1 ON LINE 343
	     end;

000530  aa   000005 7100 04	tra  	5,ic		000535
						STATEMENT 1 ON LINE 344
	else do;

						STATEMENT 1 ON LINE 345
	     year = year + 3;

000531  aa   000003 2360 07	ldq  	3,dl
000532  aa  7 00010 0561 20	asq  	pr7|8,*		year
						STATEMENT 1 ON LINE 346
	     date = 365;

000533  aa   000555 2360 07	ldq  	365,dl
000534  aa  6 00104 7561 00	stq  	pr6|68		date
						STATEMENT 1 ON LINE 347
	     end;

						STATEMENT 1 ON LINE 349
	if Sall then day_of_year = date + 1;

000535  aa  6 00100 2351 00	lda  	pr6|64		Sall
000536  aa   000003 6000 04	tze  	3,ic		000541
000537  aa   000001 0760 07	adq  	1,dl
000540  aa  7 00030 7561 20	stq  	pr7|24,*		day_of_year
						STATEMENT 1 ON LINE 351
	if mod (year, 4) = 0
	then if date > 59
	     then date = date + 1;

000541  aa  7 00010 2361 20	ldq  	pr7|8,*		year
000542  aa   000276 3520 04	epp2 	190,ic		001040 = 000000000004
000543  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000544  aa   000006 6010 04	tnz  	6,ic		000552
000545  aa  6 00104 2361 00	ldq  	pr6|68		date
000546  aa   000073 1160 07	cmpq 	59,dl
000547  aa   000010 6044 04	tmoz 	8,ic		000557
000550  aa  6 00104 0541 00	aos  	pr6|68		date
						STATEMENT 1 ON LINE 354
	     else ;

000551  aa   000006 7100 04	tra  	6,ic		000557
						STATEMENT 1 ON LINE 355
	else if date > 58
	     then date = date + 2;

000552  aa  6 00104 2361 00	ldq  	pr6|68		date
000553  aa   000072 1160 07	cmpq 	58,dl
000554  aa   000003 6044 04	tmoz 	3,ic		000557
000555  aa   000002 2360 07	ldq  	2,dl
000556  aa  6 00104 0561 00	asq  	pr6|68		date
						STATEMENT 1 ON LINE 359
	date = date + 92;

000557  aa   000134 2360 07	ldq  	92,dl
000560  aa  6 00104 0561 00	asq  	pr6|68		date
						STATEMENT 1 ON LINE 360
	month = divide ((100 * date), 3055, 17, 0);

000561  aa  6 00104 2361 00	ldq  	pr6|68		date
000562  aa   000144 4020 07	mpy  	100,dl
000563  aa   005757 5060 07	div  	3055,dl
000564  aa  7 00004 7561 20	stq  	pr7|4,*		month
						STATEMENT 1 ON LINE 361
	day = date - divide ((3055 * month), 100, 17, 0);

000565  aa   005757 4020 07	mpy  	3055,dl
000566  aa   000144 5060 07	div  	100,dl
000567  aa  6 00141 7561 00	stq  	pr6|97
000570  aa  6 00104 2361 00	ldq  	pr6|68		date
000571  aa  6 00141 1761 00	sbq  	pr6|97
000572  aa  7 00006 7561 20	stq  	pr7|6,*		day
						STATEMENT 1 ON LINE 363
	month = month - 2;

000573  aa   000002 3360 07	lcq  	2,dl
000574  aa  7 00004 0561 20	asq  	pr7|4,*		month
						STATEMENT 1 ON LINE 364
	return;

000575  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 368
bad_clock:
	code = error_table_$bad_year;

000576  aa  6 00044 3701 20	epp4 	pr6|36,*
000577  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_year
000600  aa  6 00126 7561 20	stq  	pr6|86,*		code
						STATEMENT 1 ON LINE 370
	go to error;

000601  aa   000006 7100 04	tra  	6,ic		000607
						STATEMENT 1 ON LINE 372
bad_zone:
	code = error_table_$unknown_zone;

000602  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$unknown_zone
000603  aa  6 00126 7561 20	stq  	pr6|86,*		code
						STATEMENT 1 ON LINE 374
	go to error;

000604  aa   000003 7100 04	tra  	3,ic		000607
						STATEMENT 1 ON LINE 376
bad_version:
	code = error_table_$unimplemented_version;

000605  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$unimplemented_version
000606  aa  6 00126 7561 20	stq  	pr6|86,*		code
						STATEMENT 1 ON LINE 378
error:
	month = 0;

000607  aa  6 00032 3735 20	epp7 	pr6|26,*
000610  aa  7 00004 4501 20	stz  	pr7|4,*		month
						STATEMENT 1 ON LINE 380
	day = 0;

000611  aa  7 00006 4501 20	stz  	pr7|6,*		day
						STATEMENT 1 ON LINE 381
	year = 0;

000612  aa  7 00010 4501 20	stz  	pr7|8,*		year
						STATEMENT 1 ON LINE 382
	micro_second = 0;

000613  aa   777175 2370 04	ldaq 	-387,ic		000010 = 000000000000 000000000000
000614  aa  6 00120 7571 20	staq 	pr6|80,*		micro_second
						STATEMENT 1 ON LINE 383
	day_of_week = 0;

000615  aa  6 00122 4501 20	stz  	pr6|82,*		day_of_week
						STATEMENT 1 ON LINE 384
	return;

000616  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 393
     end decode_clock_value_;

BEGIN PROCEDURE init_time_data
ENTRY TO init_time_data                                     STATEMENT 1 ON LINE 388
init_time_data:
     procedure;

000617  aa  6 00132 6501 00	spri4	pr6|90
						STATEMENT 1 ON LINE 390
	if time_data_$time_delta = -1 then call time_data_$time_data_init;

000620  aa   000001 3360 07	lcq  	1,dl
000621  aa   000044 7770 00	llr  	36
000622  aa   000044 7330 00	lrs  	36
000623  aa  6 00044 3701 20	epp4 	pr6|36,*
000624  la  4 00016 1171 20	cmpaq	pr4|14,*		time_data_$time_delta
000625  aa   000005 6010 04	tnz  	5,ic		000632
000626  aa  6 00056 6211 00	eax1 	pr6|46
000627  aa   000000 4310 07	fld  	0,dl
000630  la  4 00022 3521 20	epp2 	pr4|18,*		time_data_$time_data_init
000631  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 391
     end init_time_data;

000632  aa  6 00132 6101 00	rtcd 	pr6|90
  END PROCEDURE init_time_data
  END PROCEDURE decode_clock_value_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
