	COMPILATION LISTING OF SEGMENT rldr_input_
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 06/12/90  1510.5 mdt Tue
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-02-11,GWMay), approve(), audit(), install():
       17*     old history comments:
       18*         Modified 5/79 by D. Vinograd to correct calling sequence to read_page
       19*                       so that variable already_there is passed as arg, and to
       20*                       correctly handle pages which are non null but contain all
       21*                       zeros. These are not writen out by the dumper and so must be
       22*                       fabricated by the reloader.
       23*         Modified April 1982 by J. Bongiovanni for new label.
       24*         Modified June 1982 by GA Texada to report read errors.
       25*         Modified July 1982 by GA Texada to fix phx13000 and fix a bug
       26*                       introduced above.
       27*         Modified Sept 1982 by Texada to get volume names via command_query_.
       28*         Modified: 12/2/82 by GAT for emergency MR10.1 fix for phx14335.
       29*         Modified Nov. 1982 by GAT to provide the pv name of last object read
       30*                       sucessfully when skipping objects due to tape problems.
       31*         Modified 03/01/83 by GA Texada for multiple physical volume reloading.
       32*     DONT FORGET TO REMOVE THE pvolid CODE!!!
       33*         Modified 03/12/85 by Greg Texada to fix phx19165, don't give up so
       34*                       soon when resynching (D. Kitson).
       35*  2) change(86-02-11,GWMay), approve(86-07-10,MCR7445), audit(86-11-19,GDixon),
       36*     install(86-11-21,MR12.0-1223):
       37*     changed position of call to rldr_vtoc_buffer_$write before do loop to
       38*     support changes in the subroutine.  Removed all error message
       39*     documentation.  This module is not covered by the policy for error
       40*     message doc.
       41*  3) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       42*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       43*     Correct error message documentation.
       44*  4) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
       45*     install(88-10-17,MR12.2-1173):
       46*     Changed the routine read_page to be read_object.  Because of changes to
       47*     the format of volume dump tapes, entire segments are read from the tape
       48*     with null pages handled when writing to disk.
       49*     
       50*     Installed a completely new read routine to handle tapes which contain
       51*     incomplete data.
       52*  5) change(90-02-06,Farley), approve(90-05-09,MCR8174),
       53*     audit(90-04-02,WAAnderson), install(90-06-12,MR12.4-1014):
       54*     Modified skip_chars procedure to account for times when the data is
       55*     "DELIMITED", when calling the read procedure.
       56*                                                   END HISTORY COMMENTS */
       57 
       58 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       59 
       60 
       61 rldr_input_: proc;
       62 
       63 /* This routine provides  all necessary input functions for the volume reloader. It
       64*   generates the list of dump volumes  necessary to recreate the physical volume, and then reads them
       65*   in the correct order(reverse chronological). It uses the control seg as a look aside memory to determine if a
       66*   vtoce has already been reloaded from a newer dump volume. If so we skip the older copy. We return to the
       67*   caller only when a new object has been found. If the object supeerceeds an existant object we set a flag. */
       68 
       69 dcl (pattern_match_label, retry_attach_label) label;
       70 dcl avolname	     char (32) var;
       71 dcl (already_there, resynching_completed, resynching, new_volume, YES, a_new_volume, new_info, skip_next_header_check, ring_1) bit (1);
       72 dcl (code, ignore, words_skipped) fixed bin (35);
       73 dcl att_desc	     char (256);
       74 dcl resynch_retry_count  fixed bin;
       75 dcl rets		     char (79) varying;
       76 dcl rets_len	     fixed bin (21);
       77 dcl (incr_open_time, cons_open_time, comp_open_time, time_unmounted) fixed bin (71);
       78 dcl (comp_cycle_uid, cons_cycle_uid, volid) bit (36);
       79 dcl (entry, vtocx, vlx, a_pvindex, pvindex, idx, sortx, num_pos) fixed bin;
       80 dcl (nel, nelt)	     fixed bin (21);
       81 dcl char_buf	     char (256 * CHARS_PER_PAGE) based (rldr_data_.data_object_bp);
       82 dcl word		     (size (backup_volume_header)) bit (36) based (recordp);
       83 dcl input_buf	     (divide (nelt, CHARS_PER_WORD, 17, 0)) bit (36) based (recordp);
       84 dcl string	     bit (BITS_PER_WORD * size (backup_volume_header)) based (recordp);
       85 dcl (char_num, pvname, lvname, volname) char (32);
       86 
       87 dcl warning_printed	     bit (1) static init ("0"b);
       88 dcl get_object	     fixed bin static init (1) options (constant);
       89 dcl read_object	     fixed bin static init (2) options (constant);
       90 dcl init		     fixed bin static init (3) options (constant);
       91 dcl collect_stats	     fixed bin static init (4) options (constant);
       92 dcl myname	     char (32) var int static init ("rldr_input_") options (constant);
       93 dcl DELIMITED	     bit (1) aligned internal static options (constant)
       94 		     init ("1"b);
       95 dcl FORWARD_CHAR_POSITIONING fixed bin int static init (3) options (constant);
       96 dcl rldr_vtoc_buffer_$write entry (ptr, fixed bin (35));
       97 dcl hc_backup_$decode_uidpath entry ((0:15) bit (36) aligned, char (*), char (*), fixed bin (35));
       98 dcl get_group_id_	     entry returns (char (32));
       99 dcl hcs_$level_get	     entry returns (fixed bin);
      100 dcl timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry);
      101 dcl timer_manager_$reset_alarm_call entry (entry);
      102 dcl mdc_$find_volname    entry (bit (36), char (*), char (*), fixed bin (35));
      103 dcl cv_dec_check_	     entry (char (*), fixed bin (35)) returns (fixed bin);
      104 dcl ioa_		     entry options (variable);
      105 dcl ioa_$rsnnl	     entry () options (variable);
      106 dcl command_query_	     entry options (variable);
      107 dcl command_query_$yes_no entry () options (variable);
      108 dcl set_lock_$lock	     entry (bit (36) aligned, fixed bin, fixed bin (35));
      109 dcl set_lock_$unlock     entry (bit (36) aligned, fixed bin (35));
      110 dcl rldr_vtoc_header_$update entry (ptr, fixed bin, fixed bin (35));
      111 dcl rldr_volume_map_$update entry (ptr, fixed bin, fixed bin (35));
      112 dcl rldr_report_$error_output entry options (variable);
      113 dcl rldr_report_$online_output entry options (variable);
      114 
      115 dcl error_table_$action_not_performed fixed bin (35) ext static;
      116 dcl error_table_$data_loss fixed bin (35) ext static;
      117 dcl error_table_$device_end fixed bin (35) ext static;
      118 dcl error_table_$root    fixed bin (35) ext static;
      119 dcl error_table_$resource_unavailable ext fixed bin (35);
      120 dcl error_table_$end_of_info ext fixed bin (35);
      121 dcl error_table_$bad_volid ext fixed bin (35);
      122 
      123 dcl seg_fault_error	     condition;
      124 
      125 dcl (addcharno, addr, fixed, index, size, null, unspec, bin,
      126   divide, length, maxlength, min, mod, rtrim, search, ptr, substr) builtin;
      127 
      128 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      129 
      130 
      131 get_object: entry (rldr_datap, skip_next_header_check, vtocep, vtocx, already_there, a_pvindex, code);
      132 
      133 /* This entry reads dump volumes until it encounters a vtoce that either has not been read or is newer
      134*   then the already read.  It returns to the caller with this info. The parameter pvindex is output
      135* index into rldr_data_.pvname on which the object belongs.
      136**/
      137 
      138 /* set local variables */
      139     entry = get_object;
      140     a_pvindex, vtocx = -1;
      141     code = 0;
      142     already_there = "0"b;
      143     recordp = rldr_data_.volume_record_bp;
      144 
      145 /* if switch not attached do so */
      146     if rldr_data_.inputvol_iocbp = null then call attach;	/*  return label for int proc if errors */
      147 search_loop:
      148 						/* set flags */
      149     resynching_completed = "0"b;
      150     resynching = "0"b;
      151     new_info = "0"b;
      152 						/* read till we fail or find new data */
      153     do while (^new_info & code = 0);
      154       call read_volume_record;
      155     end;
      156 						/* copy vtoc entry */
      157     if pvindex >= 1 then do;
      158         controlp = rldr_data_.controlp (pvindex);
      159         vtocep -> vtoce = backup_volume_record.vtoce;
      160         a_pvindex = pvindex;
      161       end;
      162 get_object_ret:
      163     return;
      164 
      165 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      166 
      167 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      168 
      169 read_object: entry (rldr_datap, a_pvindex, a_new_volume, skip_next_header_check, pages_returned, code);
      170 
      171 dcl (pad_chars, pages_returned) fixed bin;
      172 
      173     entry = read_object;
      174     pvindex = a_pvindex;
      175     a_new_volume = "0"b;
      176     resynching_completed = "0"b;
      177     resynching = "0"b;
      178     skip_next_header_check = "0"b;
      179     pages_returned, nelt, code = 0;
      180     recordp = rldr_data_.volume_record_bp;
      181     controlp = rldr_data_.controlp (pvindex);
      182     nel = backup_volume_record.rec2_len;
      183 
      184     call read (rldr_data_.data_object_bp, nel, nelt,
      185          (backup_volume_record.version > 1), code);
      186 
      187     pages_returned = divide (nelt + CHARS_PER_PAGE - 1, CHARS_PER_PAGE, 17);
      188     pad_chars = CHARS_PER_PAGE - mod (nelt, CHARS_PER_PAGE);
      189     if pad_chars < CHARS_PER_PAGE then
      190       unspec (substr (char_buf, nelt + 1, pad_chars)) = "0"b;
      191 
      192     call check_input_error;
      193 
      194     if new_volume then do;
      195         rldr_control (backup_volume_record.vtocx).uid = "0"b; /* clean up */
      196         rldr_control (backup_volume_record.vtocx).volid = "0"b;
      197         a_new_volume = new_volume;
      198         return;
      199       end;
      200 
      201     skip_next_header_check = resynching_completed;
      202     return;
      203 
      204 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      205 
      206 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      207 
      208 
      209 init_volume_list: entry (rldr_datap, code);
      210 
      211 /* This entry scans the volume log and builds the list of dump volumes required to recreate the
      212*   physical volume(s). This list is referred to as a reload group. */
      213 
      214     entry = init;
      215     code = 0;
      216     skip = rldr_data_.skip;
      217 
      218     vlx = 0;
      219     do pvindex = 1 to rldr_data_.npvs;
      220       labelp, old_labelp = rldr_data_.labelp (pvindex);
      221       bvlp = rldr_data_.bvlp (pvindex);
      222       if label.volmap_version = 1 | label.volmap_version = 2
      223 	 then time_unmounted = label.time_unmounted;
      224       else time_unmounted = old_label.time_unmounted;
      225       if rldr_data_.manual then return;			/* if manual mode don't need volume list */
      226       call lock_volume_log;				/* lock volume log for scan */
      227       if code ^= 0 then return;
      228 
      229 /* Back scan the volume log to develop the list of dump volumes necessary to recreate the physical volume. This
      230*   list is referred to as a reload group. The basic scheme is touse incremental duymp volumes until they are superceeded
      231*   by consolidated dump volumes and consolidated dump volumes until a complete dump volume is found. Care must
      232*   be taken for the case where the dumping process overlapped, as well as for the multi volume consolidated
      233*   or complete dump. Dump volumes not closed are not used, else we might try to use a still mounted incremental dump
      234*   volume. */
      235 
      236       incr_open_time = 0;
      237       cons_open_time = 0;
      238       comp_open_time = 0;
      239       comp_cycle_uid = "0"b;
      240       cons_cycle_uid = "0"b;
      241       do idx = backup_volume_log.next to 1 by -1;
      242         bvlep = addr (backup_volume_log.array (idx));
      243         if bvle.dump_type = incr then do;
      244 	  if cons_open_time ^= 0 | comp_open_time ^= 0 then do;
      245 	      if (cons_open_time ^= 0 & cons_open_time < bvle.close_time)
      246 		 | (comp_open_time ^= 0 & comp_open_time < bvle.close_time)
      247 		 then call log_volume_name;
      248 	    end;
      249 	  else do;
      250 	      call log_volume_name;
      251 	      incr_open_time = open_time ();
      252 	    end;
      253 	end;
      254         else if bvle.dump_type = cons then do;
      255 	  if comp_open_time ^= 0 then do;
      256 	      if comp_open_time < bvle.close_time
      257 		 | cons_cycle_uid = bvle.cycle_uid then call log_volume_name;
      258 	    end;
      259 	  else do;
      260 	      call log_volume_name;
      261 	      cons_open_time = open_time ();
      262 	      cons_cycle_uid = bvle.cycle_uid;
      263 	    end;
      264 	end;
      265         else if bvle.dump_type = comp then do;
      266 	  if comp_cycle_uid ^= "0"b then do;
      267 	      if comp_cycle_uid = bvle.cycle_uid then call log_volume_name;
      268 	      comp_open_time = open_time ();
      269 	    end;
      270 	  else do;
      271 	      comp_cycle_uid = bvle.cycle_uid;
      272 	      comp_open_time = open_time ();
      273 	      call log_volume_name;
      274 	    end;
      275 	end;
      276       end;
      277       call unlock_volume_log;				/* all done so unlock */
      278     end;
      279     rldr_input_volume_list.num_entries = vlx;
      280     rldr_input_volume_list.curn_entry = 0;
      281 
      282 /* If we are restarting search the control seg for the volume name/position in the list			*/
      283 /*   of dump volumes to be read.								*/
      284 /* If we ARE restarting, then we only need to look at ONE control because we forced them all to be the same	*/
      285     if rldr_data_.common.restart then do;		/* find out where we were */
      286         controlp = rldr_data_.controlp (1);
      287         do idx = rldr_input_volume_list.curn_entry + 1 to rldr_input_volume_list.num_entries
      288 	   while (rldr_input_volume_list (idx).volname ^= rldr_control.curn_volname);
      289         end;
      290         if idx > rldr_input_volume_list.num_entries then do;
      291 	  code = error_table_$bad_volid;
      292 	  call rldr_report_$error_output (rldr_datap, code, myname, "Error locating restart volume");
      293 	  return;
      294 	end;
      295         rldr_input_volume_list.curn_entry = idx - 1;
      296       end;
      297     if rldr_input_volume_list.num_entries <= 0 then do;	/* check for null list			*/
      298         call rldr_report_$error_output (rldr_datap, 0, myname,
      299 	   "No dump volumes selected for this reload.");	/* see error message doc at end		*/
      300         code = error_table_$action_not_performed;
      301       end;
      302     else do;
      303         if ^rldr_data_.brief then do;			/* Tell operator ahead of time what dump volumes we want */
      304 	  call rldr_report_$online_output (rldr_datap, 0, myname, "Please get the following input volumes");
      305 	  rets = "";
      306 	  do idx = rldr_input_volume_list.curn_entry + 1 to rldr_input_volume_list.num_entries;
      307 	    call ioa_$rsnnl ("^(^a,^)", rets, rets_len, (rets) || " " || rldr_input_volume_list (idx).volname);
      308 	    if idx ^= rldr_input_volume_list.num_entries then
      309 	      if (rets_len + (length (rtrim (rldr_input_volume_list (idx + 1).volname))) + 2
      310 		 > maxlength (rets)) then do;
      311 						/* avoid problems if writing to the Operator Console*/
      312 		call rldr_report_$online_output (rldr_datap, 0, "", "^a", rtrim (rets, ","));
      313 		rets = "";
      314 	        end;
      315 	  end;
      316 	  if rets ^= "" then call rldr_report_$online_output (rldr_datap, 0, "", "^a", rtrim (rets, ","));
      317 	end;
      318       end;
      319     return;
      320 
      321 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      322 
      323 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      324 
      325 
      326 collect_stats: entry (rldr_datap, a_pvindex);
      327 
      328 /* This entry collects statistics about what is being reloaded. We collect statistics on a per dump volume
      329*   read basis as well as summary statistics about the entire reload. */
      330 
      331     entry = collect_stats;
      332     pvindex = a_pvindex;
      333     recordp = rldr_data_.volume_record_bp;
      334     controlp = rldr_data_.controlp (pvindex);
      335 
      336 
      337 /* if non-null object */
      338     if backup_volume_record.uid ^= "0"b then do;
      339 						/* if directory */
      340         if backup_volume_record.dirsw then do;
      341 	  rldr_control.dir_num = rldr_control.dir_num + 1;
      342 	  rldr_control.dir_rec = rldr_control.dir_rec + fixed (backup_volume_record.records);
      343 	  rldr_control.input_vol_dir_num = rldr_control.input_vol_dir_num + 1;
      344 	  rldr_control.input_vol_dir_rec = rldr_control.input_vol_dir_rec +
      345 	       fixed (backup_volume_record.records);
      346 	end;
      347         else do;					/* or segment */
      348 	  rldr_control.seg_num = rldr_control.seg_num + 1;
      349 	  rldr_control.input_vol_seg_num = rldr_control.input_vol_seg_num + 1;
      350 	  rldr_control.input_vol_seg_rec = rldr_control.input_vol_seg_rec +
      351 	       fixed (backup_volume_record.records);
      352 	  rldr_control.seg_rec = rldr_control.seg_rec + fixed (backup_volume_record.records);
      353 	end;
      354       end;
      355     else rldr_control.num_null_vtoce = rldr_control.num_null_vtoce + 1;
      356     return;
      357 
      358 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      359 
      360 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      361 
      362 
      363 log_volume_name: proc;
      364 
      365 /* This proc is called to add a dump volume to the volume list of a reload group. It is added to the list
      366*   if it has segments or directories from this volume and if it not already part
      367*   of the list. If the dump volume was created with a different io module then the one
      368*   that will be used to read it, the operator is queried as to whether he wants to use it. */
      369 
      370     if bvle.dir_num = 0 & bvle.seg_num = 0 then return;
      371     if rldr_data_.save & bvle.open_time < time_unmounted then return;
      372 
      373     do sortx = 1 to vlx;
      374       if rldr_input_volume_list (sortx).volname = bvle.volname
      375 	 & rldr_input_volume_list (sortx).volid = bvle.volid then return; /* already in list */
      376     end;
      377 
      378     do sortx = 1 to rldr_skip_list.next;
      379       if rldr_skip_list (sortx).volname = bvle.volname then return;
      380     end;
      381 
      382     if bvle.io_module ^= rldr_data_.io_module then do;
      383         query_info.version = query_info_version_5;
      384         call command_query_$yes_no (YES, 0, myname, "",
      385 	   "io outer module ^a which wrote volume ^a is different than that specified to read the volume.
      386  Do you wish to use the volume ?", bvle.io_module, bvle.volname);
      387         if ^YES then do;
      388 	  rldr_skip_list.next = rldr_skip_list.next + 1;
      389 	  rldr_skip_list (rldr_skip_list.next).volname = bvle.volname;
      390 	  return;
      391 	end;
      392       end;
      393 
      394     vlx = vlx + 1;
      395     rldr_input_volume_list (vlx).volname = bvle.volname;
      396     rldr_input_volume_list (vlx).volid = bvle.volid;
      397 
      398   end log_volume_name;
      399 
      400 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      401 
      402 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      403 
      404 
      405 read_volume_record: proc;
      406 
      407 /* This proc reads a logical record from a dump volume and determines if the object is newer
      408*   then the one previously found(if any). It does this by using a look aside memory stored in the control seg,
      409*   indexed by vtoc index, with the dump volume id as the field. */
      410 
      411 /* set non-local retrun label */
      412     pattern_match_label = pattern_match;
      413     new_volume = "0"b;
      414 						/* read logical record header */
      415     if skip_next_header_check then do;
      416         skip_next_header_check = "0"b;
      417         goto pattern_match_label;
      418       end;
      419     nel = CHARS_PER_WORD * size (backup_volume_header);
      420     call read (recordp, nel, nelt, ^DELIMITED, code);
      421     call check_input_error;
      422     if new_volume then return;
      423 						/* check record header */
      424     if backup_volume_record.pattern1 ^= pattern1
      425          | backup_volume_record.pattern2 ^= pattern2
      426          | backup_volume_record.pattern3 ^= pattern3 then do;
      427         code = -1;
      428         call check_input_error;			/* treat as bad read */
      429         if new_volume then return;
      430       end;
      431 
      432 pattern_match:
      433     new_volume = "0"b;
      434 						/* read rest of header */
      435     nel = backup_volume_record.rec1_len - size (backup_volume_header) * CHARS_PER_WORD;
      436     call read (ptr (recordp, size (backup_volume_header)),
      437          nel, nelt, ^DELIMITED, code);
      438     call check_input_error;
      439     if new_volume then return;
      440 						/* if info data then safe store */
      441     if backup_volume_record.rec1_type = info_type then do;
      442         call record_info;
      443         if code ^= 0 then return;
      444       end;
      445 						/* otherwise if not object then skip */
      446     if backup_volume_record.rec1_type ^= vtoce_type then do;
      447         nel = backup_volume_record.rec2_len;
      448         if nel ^= 0 then call skip_chars;
      449         return;
      450       end;
      451 						/* skip if version is different */
      452     if backup_volume_record.version ^= backup_volume_record_version_1 &
      453          backup_volume_record.version ^= backup_volume_record_version_2 then do;
      454 bad_record: call rldr_report_$error_output (rldr_datap, 0, myname, "Invalid volume record on dump volume",
      455 	   volname);
      456         nel = backup_volume_record.rec2_len;
      457         if nel ^= 0 then call skip_chars;
      458         return;
      459       end;
      460 						/* record last valid uid */
      461     if backup_volume_record.uid ^= "0"b then do;
      462         rldr_data_.last_valid_puid = backup_volume_record.uid_path;
      463         rldr_data_.last_valid_vtoce_ename = backup_volume_record.primary_name;
      464         rldr_data_.last_pvid = backup_volume_record.pvid;
      465         rldr_data_.last_vtocx = backup_volume_record.vtocx;
      466       end;
      467 						/* inform operator of last valid object read */
      468     if resynching_completed & backup_volume_record.uid ^= "0"b then do;
      469         resynching_completed = "0"b;
      470         call find_volname ((backup_volume_record.pvid), pvname, lvname, code);
      471         if code = 0 then
      472 	call rldr_report_$error_output (rldr_datap, 0, myname,
      473 	     "first object after resynching ^a on pv ^a ^[(vtocx = ^d)^;^s^] of logical volume ^a",
      474 	     convert_puid_ (), pvname, (backup_volume_record.pvid ^= (36)"0"b),
      475 	     backup_volume_record.vtocx, lvname);
      476         else call rldr_report_$error_output (rldr_datap, 0, myname,
      477 	        "first object after resynching ^a", convert_puid_ ());
      478       end;
      479     do pvindex = 1 to rldr_data_.npvs;
      480 						/* if this object was from any physical volumes */
      481       if backup_volume_record.pvid = rldr_data_.pvid (pvindex) then do;
      482 						/* on our list				*/
      483 	if rldr_data_.abandoned (pvindex) then goto exit_pvid_check;
      484 						/* but not these				*/
      485 	controlp = rldr_data_.controlp (pvindex);
      486 	vtocx = backup_volume_record.vtocx;		/* pick up index */
      487 	if vtocx > rldr_control.n_vtoce - 1 then do;
      488 	    call rldr_report_$error_output (rldr_datap, 0, myname, "VTOCE index out of range on pv ^a",
      489 	         rldr_data_.pvname (pvindex));
      490 	    nel = backup_volume_record.rec2_len;
      491 	    if nel ^= 0 then call skip_chars;
      492 	    return;
      493 	  end;
      494 
      495 /* Check to see if this vtocx has already been encountered. If so
      496*   then skip it. If its a null vtoce then flag it as seen but don't treat it as new info.  If encountered
      497*   but the time_dumped is latter then this copy is newer so its new info. If never encountered its new info. */
      498 
      499 	already_there = "0"b;
      500 	if rldr_control (vtocx).time_dumped < bin (backup_volume_record.time_dumped || (16)"0"b, 52) then do;
      501 	    already_there = (rldr_control (vtocx).uid ^= "0"b & rldr_control (vtocx).time_dumped ^= 0);
      502 	    rldr_control (vtocx).time_dumped = bin (backup_volume_record.time_dumped || (16)"0"b, 52);
      503 	    rldr_control (vtocx).uid = backup_volume_record.uid;
      504 	    new_info = "1"b;
      505 	    return;
      506 	  end;
      507 	goto exit_pvid_check;
      508         end;
      509     end;
      510 exit_pvid_check:
      511     do pvindex = 1 to rldr_data_.npvs;			/* make them all look alike			*/
      512       controlp = rldr_data_.controlp (pvindex);
      513       rldr_control.num_rejected = rldr_control.num_rejected + 1;
      514     end;
      515     pvindex = 0;					/* flag					*/
      516     nel = backup_volume_record.rec2_len;
      517     call skip_chars;
      518     return;
      519 
      520   end read_volume_record;
      521 
      522 
      523 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      524 
      525 skip_chars: proc;
      526 
      527 /* This proc  skips forward on the dump volume the number of characters specified by nel.
      528**/
      529 
      530     nelt = nel;
      531     call read (null, nel, nelt, (backup_volume_record.rec1_type = vtoce_type & backup_volume_record.version > backup_volume_record_version_1), code);
      532     call check_input_error;
      533     if entry = get_object & new_volume then goto search_loop;
      534 
      535   end skip_chars;
      536 
      537 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      538 
      539 
      540 check_input_error: proc;
      541 
      542 /* This proc checks for error after a read of a dump volume. If we have reached the end of the dump volume then
      543*   we detach the volume, update the volume map and vtoc header on the physical volume and attach a new dump
      544*   volume.  If an error has occurred we attemp to recover by repositioning the dump volume at the beginning
      545*   of the next logical dump record. If we are already recovering we pretend the error never happened.
      546*   Of course if no error has occured we return. */
      547 
      548 dcl i		     fixed bin;
      549 
      550     new_volume = "0"b;
      551     if code ^= 0 | nel ^= nelt then do;
      552         if (code = error_table_$end_of_info | code = error_table_$device_end) then do;
      553 	  if resynching then do;
      554 	      call rldr_report_$error_output (rldr_datap, 0, myname, "Resynchronization terminated by end of volume");
      555 	      call rldr_report_$error_output (rldr_datap, 0, myname, "^d words skipped", words_skipped);
      556 	    end;
      557 detach_and_continue:
      558 	  call detach;
      559 	  do i = 1 to rldr_data_.npvs;		/* for each pv that had something on this dump volume*/
      560 	    controlp = rldr_data_.controlp (i);
      561 	    if (rldr_control.dir_rec ^= 0 | rldr_control.seg_rec ^= 0
      562 	         | rldr_control.num_null_vtoce ^= 0) then do;
      563 	        call rldr_vtoc_header_$update (rldr_datap, i, code);
      564 	        if code ^= 0 then
      565 		call rldr_report_$error_output (rldr_datap, code, myname, "Error updating vtoc header on pv ^a",
      566 		     rldr_data_.pvname (i));
      567 	        call rldr_volume_map_$update (rldr_datap, i, code);
      568 	        if code ^= 0 then
      569 		call rldr_report_$error_output (rldr_datap, code, myname, "Error updating volume map on pv ^a",
      570 		     rldr_data_.pvname (i));
      571 	      end;
      572 	  end;
      573 	  call attach;
      574 	  new_volume = "1"b;
      575 	  return;
      576 	end;
      577         else do;
      578 	  if ^resynching then do;
      579 	      if nel ^= nelt then
      580 	        call rldr_report_$error_output (rldr_datap, 0, myname, "Read did not complete on ^a",
      581 		   rldr_data_.controlp (1) -> rldr_control.curn_volname);
      582 	      if code = -1 then
      583 	        call rldr_report_$error_output (rldr_datap, 0, myname, "Invalid dump record header on ^a",
      584 		   rldr_data_.controlp (1) -> rldr_control.curn_volname);
      585 	      else call rldr_report_$error_output (rldr_datap, code, myname, "I/O error reading input volume ^a",
      586 		      rldr_data_.controlp (1) -> rldr_control.curn_volname);
      587 	      call find_volname ((rldr_data_.last_pvid), pvname, lvname, code);
      588 	      if code ^= 0 then
      589 	        call rldr_report_$error_output (rldr_datap, 0, myname, "bad input record after ^a - resynching started",
      590 		   convert_puid_ ());
      591 	      else call rldr_report_$error_output (rldr_datap, 0, myname,
      592 		      "bad input record after ^a on pv ^a ^[(vtocx = ^d)^;^s^] of logical volume ^a - resynching started",
      593 		      convert_puid_ (), pvname, (rldr_data_.last_pvid ^= (36)"0"b),
      594 		      rldr_data_.last_vtocx, lvname);
      595 	      resynch_retry_count = 0;
      596 	      call resynch_input_volume;
      597 
      598 	      if entry = get_object then do;
      599 		if resynching_completed then goto pattern_match_label;
      600 		else if new_volume then goto search_loop;
      601 	        end;
      602 	      else if entry = read_object then do;
      603 		code = -1;
      604 		return;
      605 	        end;
      606 	    end;
      607 	  else do;				/* already had an error			*/
      608 	      resynch_retry_count = resynch_retry_count + 1;
      609 						/* keep track so we don't try this forever	*/
      610 	      if resynch_retry_count > 64 then do;
      611 		call rldr_report_$error_output (rldr_datap, code, myname,
      612 		     "Resynchronization failed due to I/O error during resynching on volume ^a.",
      613 		     rldr_data_.controlp (1) -> rldr_control.curn_volname);
      614 		goto detach_and_continue;
      615 	        end;
      616 	    end;
      617 	end;
      618       end;
      619 
      620   end check_input_error;
      621 
      622 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      623 
      624 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      625 
      626 
      627 attach: proc;
      628 
      629 /* This proc attaches the next dump volume either on the list or as specified by the operator. If we are
      630*   in the manual mode we treat each dump volume as coming from a list of one item. If the operator has specified
      631*   an alternate input attach description then we use it, else we use the default. We also initialize some per dump
      632*   volume counters. */
      633 
      634 dcl i		     fixed bin;
      635 
      636 retry_attach:
      637     retry_attach_label = retry_attach;
      638 						/* use dump volume list */
      639     if ^rldr_data_.manual then do;
      640         rldr_input_volume_list.curn_entry = rldr_input_volume_list.curn_entry + 1;
      641         if rldr_input_volume_list.curn_entry > rldr_input_volume_list.num_entries then do;
      642 no_more:	  code = error_table_$end_of_info;
      643 	  goto get_object_ret;
      644 	end;
      645         volid = rldr_input_volume_list (rldr_input_volume_list.curn_entry).volid;
      646         volname = rldr_input_volume_list (rldr_input_volume_list.curn_entry).volname;
      647 
      648         do i = 1 to rldr_data_.npvs;			/* make all controls look the same		*/
      649 	controlp = rldr_data_.controlp (i);
      650 	rldr_control.curn_volname = volname;
      651 	rldr_control.curn_volid = volid;
      652         end;
      653       end;
      654     else do;					/* operator will tell us which to use */
      655         query_info.yes_or_no_sw = "0"b;			/* query_info is ok, except for this		*/
      656 request: call command_query_ (addr (query_info), avolname, myname, "Type input volume name: ");
      657         volname = avolname;				/* make it the right type			*/
      658         if volname = "" then goto request;
      659         if volname = "." then goto no_more;
      660         volid = get_volid_ (volname);
      661         if code ^= 0 then do;
      662 	  call ioa_ ("invalid volume identifier ^a", volname);
      663 	  goto request;
      664 	end;
      665         query_info.yes_or_no_sw = "1"b;			/* back to normal				*/
      666         do i = 1 to rldr_data_.npvs;			/* make them all look the same		*/
      667 	controlp = rldr_data_.controlp (i);
      668 	rldr_control.curn_volname = volname;
      669 	rldr_control.curn_volid = volid;
      670         end;
      671         rldr_input_volume_list.curn_entry = 1;
      672         rldr_input_volume_list (rldr_input_volume_list.curn_entry).volname = volname;
      673         rldr_input_volume_list (rldr_input_volume_list.curn_entry).volid = volid;
      674       end;
      675 						/* use supplied attach description if it exists */
      676     if rldr_data_.input_volume_desc ^= "" then
      677       call ioa_$rsnnl (rldr_data_.input_volume_desc, att_desc, (0), volname);
      678     else call ioa_$rsnnl ("tape_mult_ ^a -system", att_desc, (0), volname);
      679 						/* attach dump volume */
      680     if get_group_id_ () = "Initializer.SysDaemon.z" & hcs_$level_get () = 1 then ring_1 = "1"b;
      681     else ring_1 = "0"b;
      682 retry: if ring_1 then call timer_manager_$alarm_call (180, "11"b, attach_timer);
      683     call iox_$attach_name ("input_volume", rldr_data_.inputvol_iocbp, att_desc, null, code);
      684     if ring_1 then call timer_manager_$reset_alarm_call (attach_timer);
      685     if code ^= 0 then do;
      686         if code = error_table_$resource_unavailable then do;
      687 	  query_info.version = query_info_version_5;
      688 	  call command_query_$yes_no (YES, 0, myname, "", "
      689 The physical drive or dump volume is not available or is in use by an other process.
      690 Do you wish to retry the attachment");
      691 	  if YES then goto retry;
      692 	end;
      693         call rldr_report_$error_output (rldr_datap, code, myname, "Unable to attach dump volume ^a", volname);
      694         goto retry_attach_label;
      695       end;
      696 						/* open switch for reading */
      697     call iox_$open (rldr_data_.inputvol_iocbp, Stream_input, "0"b, code);
      698     if code ^= 0 then do;
      699         call rldr_report_$error_output (rldr_datap, code, myname, "Error on opening dump volume ^a", volname);
      700         call iox_$detach_iocb (rldr_data_.inputvol_iocbp, ignore);
      701         goto retry_attach;
      702       end;
      703     do i = 1 to rldr_data_.npvs;			/* again, make them all look the same		*/
      704       controlp = rldr_data_.controlp (i);		/* reset per dump volume counters */
      705       rldr_control.input_vol_seg_num = 0;
      706       rldr_control.input_vol_seg_rec = 0;
      707       rldr_control.input_vol_dir_num = 0;
      708       rldr_control.input_vol_dir_rec = 0;
      709     end;
      710     return;
      711 
      712   end attach;
      713 
      714 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      715 
      716 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      717 
      718 
      719 detach: proc;
      720 
      721 /* This proc detaches a dump volume and reports what infomation on it was reloaded */
      722 dcl i		     fixed bin;
      723 						/* close dump volume */
      724     call iox_$close (rldr_data_.inputvol_iocbp, code);
      725     if code ^= 0 then
      726       call rldr_report_$error_output (rldr_datap, code, myname, "Unable to close dump volume ^a", volname);
      727 						/* and detach */
      728     call iox_$detach_iocb (rldr_data_.inputvol_iocbp, code);
      729     if code ^= 0 then
      730       call rldr_report_$error_output (rldr_datap, code, myname, "Unable to detach dump volume ^a", volname);
      731     rldr_data_.inputvol_iocbp = null;			/* be sure */
      732 						/* tell operator what we did */
      733     call rldr_vtoc_buffer_$write (rldr_datap, ignore);
      734     do i = 1 to rldr_data_.npvs;
      735       controlp = rldr_data_.controlp (i);
      736       if (rldr_control.input_vol_dir_rec ^= 0 | rldr_control.input_vol_seg_rec ^= 0) then do;
      737 	call rldr_report_$online_output (rldr_datap, 0, myname,
      738 	     "reloaded from input volume ^a ^d records of ^d directories and ^d records of ^d segments on pv ^a",
      739 	     rldr_control.curn_volname, rldr_control.input_vol_dir_rec, rldr_control.input_vol_dir_num,
      740 	     rldr_control.input_vol_seg_rec, rldr_control.input_vol_seg_num, rldr_data_.pvname (i));
      741 						/* reset per dump volume counters */
      742 
      743 	rldr_control.input_vol_seg_num = 0;
      744 	rldr_control.input_vol_seg_rec = 0;
      745 	rldr_control.input_vol_dir_num = 0;
      746 	rldr_control.input_vol_dir_rec = 0;
      747         end;
      748     end;
      749 
      750     return;
      751 
      752   end detach;
      753 
      754 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      755 
      756 
      757 lock_volume_log: proc;
      758 
      759 /* This proc locks the volume log */
      760 
      761     call set_lock_$lock (backup_volume_log.lock, -1, code);
      762     if code ^= 0 then
      763       call rldr_report_$error_output (rldr_datap, code, myname, "Error locking volume log ^a.volog",
      764 	 rldr_data_.pvname (pvindex));
      765     return;
      766 
      767   end lock_volume_log;
      768 
      769 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      770 
      771 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      772 
      773 
      774 resynch_input_volume: proc;
      775 
      776 /* This proc  resynchronizes a dump volume by stepping through the input one word at a time until it
      777*   recognizes the volume header unique pattern or until we get to the end of the volume. An upper
      778*   bound of one million words is placed on the loop so it will finish */
      779 
      780 /* set flag */
      781     resynching = "1"b;
      782     resynching_completed = "0"b;
      783 						/* clear buffer and set flag */
      784     input_buf (*) = "0"b;
      785     new_volume = "0"b;
      786 						/* read logical record header */
      787     nel = CHARS_PER_WORD * size (backup_volume_header);
      788     call read (recordp, nel, nelt, ^DELIMITED, code);
      789     call check_input_error;
      790 						/* if end of dump volume we are done */
      791     if new_volume then return;
      792 						/* count words skipped */
      793     words_skipped = 0;
      794 						/* test for pattern match */
      795 test: if word (1) = pattern1 & word (4) = pattern2 & word (7) = pattern3 then do;
      796         call rldr_report_$error_output (rldr_datap, 0, myname, "Synchronization completed ^d words skipped on dump volume ^a",
      797 	   words_skipped, rldr_data_.controlp (1) -> rldr_control.curn_volname);
      798         resynching = "0"b;
      799         resynching_completed = "1"b;
      800         return;
      801       end;
      802 						/* shift buffer right 1 word and read next word */
      803     string = substr (string, 37, (size (backup_volume_header) - 1) * BITS_PER_WORD);
      804     new_volume = "0"b;
      805     nel = CHARS_PER_WORD;
      806     call read (addr (word (size (backup_volume_header))),
      807          nel, nelt, ^DELIMITED, code);
      808     call check_input_error;
      809     if new_volume then return;
      810 						/* count words skipped and test for limit */
      811     words_skipped = words_skipped + 1;
      812     if words_skipped > 256 * WORDS_PER_PAGE then do;	/* put a limit on it */
      813         call rldr_report_$error_output (rldr_datap, 0, myname, "Resynchronization failed on dump volume ^a",
      814 	   rldr_data_.controlp (1) -> rldr_control.curn_volname);
      815         code = error_table_$end_of_info;
      816         call check_input_error;
      817         return;
      818       end;
      819     goto test;
      820 
      821   end resynch_input_volume;
      822 
      823 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      824 
      825 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      826 
      827 unlock_volume_log: proc;
      828 
      829 /* This proc unlocks the volume log */
      830 
      831     call set_lock_$unlock (backup_volume_log.lock, code);
      832     if code ^= 0 then
      833       call rldr_report_$error_output (rldr_datap, code, myname, "Error unlocking volume log ^a.volog",
      834 	 rldr_data_.pvname (pvindex));
      835   end unlock_volume_log;
      836 
      837 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      838 
      839 record_info: proc;
      840 dcl reattach	     bit (1);
      841 
      842 /* This proc picks up data stored in the info record on the dump volume. For the first dump volume
      843*   we just collect the info. For subsequent dump volumes checks are made to see that the
      844*   dump volume comes from this site or  is not out of chronological order. In addition we check for disk type
      845*   conversion. */
      846 
      847     reattach = "0"b;
      848     infop = rldr_data_.infop;
      849     infop -> backup_info = recordp -> backup_info;
      850     if backup_info.version = backup_info_version_2 &
      851          rldr_data_.controlp (1) -> rldr_control.curn_volname ^= backup_info.dump_volname
      852     then do;
      853         call rldr_report_$error_output (rldr_datap, 0, myname, "Attempt to mount unrequested dump volume ^a",
      854 	   backup_info.dump_volname);
      855         reattach = "1"b;
      856         rldr_input_volume_list.curn_entry = rldr_input_volume_list.curn_entry - 1;
      857       end;
      858     if rldr_data_.rpv then do;
      859         if (rldr_data_.rpv_disk_type ^= backup_info.rpv_disk_type) & ^warning_printed then do;
      860 	  warning_printed = "1"b;
      861 	  call rldr_report_$online_output (rldr_datap, 0, myname, "Warning - new disk type for rpv");
      862 	end;
      863       end;
      864     else do;					/* ensure same system for now...		*/
      865         if (rldr_data_.rpv_pvid ^= backup_info.rpv_pvid) then do;
      866 	  call rldr_report_$error_output (rldr_datap, 0, myname,
      867 	       "Attempt to use non local site dump volume ^a", backup_info.dump_volname);
      868 	  reattach = "1"b;
      869 	end;
      870       end;
      871     if reattach then do;
      872         call detach;				/* get rid of bad dump volume */
      873         call attach;				/* get new one */
      874         goto search_loop;
      875       end;
      876     return;
      877   end record_info;
      878 
      879 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      880 
      881 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      882 
      883 
      884 get_volid_: proc (name) returns (bit (36));
      885 
      886 /* This proc constructs a volume id from a volume name. This is a interim measure until all dump volume are registered
      887*   and have a unique id. This construction restricts the volume name to two or less non numeric characters followed
      888*   by any numeric value less then 262144. */
      889 
      890 dcl name		     char (32);
      891 dcl 1 volid	     aligned,
      892     2 char	     char (2) unaligned,
      893     2 num		     fixed bin unaligned;
      894 
      895 /* util rcp_ interface defined
      896*   call rcp_$volname_info (volname, volid, code);
      897*   if code ^= 0 then do;
      898*   call rldr_report_$error_output (rldr_datap, code, myname, "Unknown volname specified");
      899*
      900*   we' fudge it */
      901 
      902     volid.char = "";
      903     num_pos = search (name, "0123456789");
      904     if num_pos > 3 | num_pos = 0 then do;
      905 bad_volid: code = error_table_$bad_volid;
      906         return (""b);
      907       end;
      908     else do;
      909         if num_pos = 2 then substr (volid.char, 2, 1) = substr (name, 1, 1);
      910         else volid.char = substr (name, 1, 2);
      911         char_num = substr (name, num_pos, length (name) - num_pos);
      912         num = cv_dec_check_ (char_num, code);
      913         if code ^= 0 then goto bad_volid;
      914         volid.num = num;
      915       end;
      916     return (unspec (volid));
      917 
      918   end get_volid_;
      919 
      920 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      921 
      922 
      923 open_time: proc returns (fixed bin (71));
      924 
      925 /* This proc retruns the open(start) time of a single or multi volume dump volume */
      926 
      927 dcl temp		     fixed bin (71);
      928 dcl jdx		     fixed bin;
      929     if bvle.dump_type = incr then return (bvle.open_time);
      930     do jdx = idx to 1 by -1;
      931       if backup_volume_log.array (jdx).cycle_uid = bvle.cycle_uid then
      932         temp = backup_volume_log.array (jdx).open_time;
      933     end;
      934     return (temp);
      935 
      936   end open_time;
      937 
      938 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      939 
      940 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      941 
      942 
      943 attach_timer: proc;
      944 
      945 /* This proc is the query portion of the remount/refusal mechanism described above */
      946 
      947     call command_query_$yes_no (YES, 0, myname, "", "Attachment of dump volume ^a not completed. Do you wish to retry ?",
      948          rldr_control.curn_volname);
      949     if YES then rldr_input_volume_list.curn_entry = rldr_input_volume_list.curn_entry - 1;
      950     goto retry_attach_label;
      951   end attach_timer;
      952 
      953 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      954 
      955 
      956 convert_puid_: proc returns (char (168));
      957 
      958 /* This proc is used to convert a unique id pathname to an ascii pathname  */
      959 
      960 dcl dn		     char (168);
      961 dcl en		     char (32);
      962 dcl ret_dn	     char (168);
      963 dcl ec		     fixed bin (35);
      964 
      965     if rldr_data_.stranger then goto ret_unk;		/* can't possible tell him this		*/
      966     on seg_fault_error goto ret_unk;
      967     call hc_backup_$decode_uidpath (rldr_data_.last_valid_puid, dn, en, ec);
      968     if ec = error_table_$root then ;
      969     else if ec ^= 0 then
      970 ret_unk: return ("UNKNOWN");
      971     call ioa_$rsnnl ("^a^[>^]^[^a>^;^s^]^a", ret_dn, (0), dn, dn ^= ">", en ^= "", en, rldr_data_.last_valid_vtoce_ename);
      972     revert seg_fault_error;
      973     return (ret_dn);
      974   end convert_puid_;
      975 
      976 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      977 
      978 find_volname:
      979   proc (apvid, apvname, alvname, acode);
      980 dcl acode		     fixed bin (35),
      981   (apvname, alvname)     char (32),
      982   apvid		     bit (36);
      983 
      984     acode = 0;
      985     apvname, alvname = "UNKNOWN";
      986     if rldr_data_.stranger then acode = -1;		/* can't possibly help			*/
      987     else call mdc_$find_volname (apvid, apvname, alvname, acode);
      988 
      989   end find_volname;
      990 
      991 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      992 
      993 read: proc (return_buffer_ptr,
      994        Nrequested_chars,
      995        Nreturned_chars,
      996        Sdelimited,
      997        code);
      998 
      999 dcl return_buffer_ptr    ptr,
     1000   Nrequested_chars	     fixed bin (21),
     1001   Nreturned_chars	     fixed bin (21),
     1002   Sdelimited	     bit (1) aligned,
     1003   code		     fixed bin (35);
     1004 
     1005 dcl input_buffer	     char (256 * CHARS_PER_PAGE)
     1006 		     based (rldr_data_.input_buffer_ptr);
     1007 
     1008 dcl return_string	     char (Nrequested_chars)
     1009 		     based (return_buffer_ptr);
     1010 
     1011 dcl Nassign_chars	     fixed bin (21),
     1012   Nread_chars	     fixed bin (21),
     1013   end_of_record	     fixed bin,
     1014   tape_check1 /* bit (72) */ char (8),
     1015   tape_check2 /* bit (72) */ char (8);
     1016 
     1017     Nreturned_chars, Nread_chars, code = 0;
     1018 
     1019     do while (Nreturned_chars < Nrequested_chars & code = 0);
     1020       if rldr_data_.input_buffer_len = 0 then do;
     1021 	rldr_data_.input_buffer_start = 1;
     1022 
     1023 	if Sdelimited & Nreturned_chars = 0 then do;
     1024 	    call iox_$get_chars (rldr_data_.inputvol_iocbp,
     1025 	         addr (tape_check1), length (tape_check1), Nread_chars, code);
     1026 	    if code ^= 0 then return;
     1027 	  end;
     1028 
     1029 	if return_buffer_ptr = null then do;
     1030 	    call iox_$position (rldr_data_.inputvol_iocbp, FORWARD_CHAR_POSITIONING,
     1031 	         Nrequested_chars - Nreturned_chars, code);
     1032 	    Nreturned_chars = Nreturned_chars + Nrequested_chars;
     1033 	  end;
     1034 	else do;
     1035 	    call iox_$get_chars (rldr_data_.inputvol_iocbp,
     1036 	         addcharno (return_buffer_ptr, Nreturned_chars),
     1037 	         Nrequested_chars - Nreturned_chars, Nread_chars, code);
     1038 	    Nreturned_chars = Nreturned_chars + Nread_chars;
     1039 	  end;
     1040 	if code ^= 0 then return;
     1041 
     1042 	if Sdelimited then do;
     1043 	    call iox_$get_chars (rldr_data_.inputvol_iocbp,
     1044 	         addr (tape_check2), length (tape_check2), Nread_chars, code);
     1045 	    if code ^= 0 then
     1046 	      return;
     1047 
     1048 	    if tape_check1 ^= tape_check2 then do;
     1049 						/* found a short segment, move       */
     1050 						/* return string into the temp input */
     1051 						/* buffer and start parsing          */
     1052 	        rldr_data_.input_buffer_len = Nreturned_chars;
     1053 	        substr (input_buffer, 1, rldr_data_.input_buffer_len) =
     1054 		   return_string;
     1055 	      end;
     1056 	  end;
     1057         end;
     1058 
     1059       else
     1060 	 if Sdelimited then do;
     1061 	tape_check1 = substr (input_buffer,
     1062 	     rldr_data_.input_buffer_start, length (tape_check1));
     1063 	tape_check2 = "";
     1064 	rldr_data_.input_buffer_start =
     1065 	     rldr_data_.input_buffer_start + length (tape_check1);
     1066 	rldr_data_.input_buffer_len =
     1067 	     rldr_data_.input_buffer_len - length (tape_check1);
     1068         end;
     1069 
     1070       if rldr_data_.input_buffer_len > 0 then do;
     1071 	Nassign_chars =
     1072 	     min (rldr_data_.input_buffer_len, Nrequested_chars);
     1073 
     1074 	if Sdelimited then do;
     1075 	    if tape_check1 ^= tape_check2 then do;
     1076 	        end_of_record = index (substr (input_buffer, rldr_data_.input_buffer_start,
     1077 		   rldr_data_.input_buffer_len), tape_check1);
     1078 	        if end_of_record > 0 then do;
     1079 		  Nassign_chars = end_of_record - 1;
     1080 		  if Nrequested_chars ^= Nassign_chars then
     1081 		    code = error_table_$data_loss;
     1082 		end;
     1083 	      end;
     1084 	  end;
     1085 
     1086 	if return_buffer_ptr ^= null then
     1087 	  return_string = substr (input_buffer,
     1088 	       rldr_data_.input_buffer_start, Nassign_chars);
     1089 	Nreturned_chars = Nassign_chars;
     1090 
     1091 	rldr_data_.input_buffer_start =
     1092 	     rldr_data_.input_buffer_start + Nassign_chars;
     1093 	rldr_data_.input_buffer_len =
     1094 	     rldr_data_.input_buffer_len - Nassign_chars;
     1095 
     1096 	if Sdelimited & rldr_data_.input_buffer_len > 0 then do;
     1097 	    rldr_data_.input_buffer_start =
     1098 	         rldr_data_.input_buffer_start + length (tape_check2);
     1099 	    substr (input_buffer, 1, rldr_data_.input_buffer_len) =
     1100 	         substr (input_buffer, rldr_data_.input_buffer_start,
     1101 	         rldr_data_.input_buffer_len - length (tape_check2))
     1102 	         || tape_check2;
     1103 	    rldr_data_.input_buffer_start = 1;
     1104 	  end;
     1105         end;
     1106     end;
     1107 
     1108     return;
     1109   end read;
     1110 
  1     1 /* BEGIN INCLUDE FILE ... rldr_input_volume_list.incl.pl1 ... last modified March 1976 */
  1     2 
  1     3 dcl 1 rldr_input_volume_list based (rldr_data_.input_vol_lstp) aligned,
  1     4     2 num_entries fixed bin,				/* number of input volumes in list */
  1     5     2 curn_entry fixed bin,				/* index of current input volume */
  1     6     2 array (100),					/* entry array */
  1     7       3 volname char (32),				/* input volume name */
  1     8       3 volid bit (36);				/* input volume id */
  1     9 
  1    10 /* END INCLUDE FILE ... rldr_input_volume_list.incl.pl1 */
     1111 
  2     1 /* BEGIN INCLUDE FILE ... backup_info.incl.pl1 ... June 1976 */
  2     2 
  2     3 dcl  infop ptr;					/* ptr to structure */
  2     4 
  2     5 dcl  backup_info_version_2 fixed bin static init (2) options (constant); /* version number */
  2     6 
  2     7 dcl 1 backup_info based (infop) aligned,
  2     8     2 header like backup_volume_header aligned,
  2     9     2 version fixed bin,				/* version number */
  2    10     2 rpv_pvid bit (36),				/* pvid of rpv */
  2    11     2 rpv_lvid bit (36),				/* lvid of rpv */
  2    12     2 rpv_disk_type fixed bin,			/* disk model index of rpv */
  2    13     2 dump_volid bit (36),				/* dump volume id */
  2    14     2 pad bit (36),
  2    15     2 dump_type fixed bin,				/* type of dump */
  2    16     2 dump_volname char (32),				/* volname of dump volume */
  2    17     2 system_id char (32),				/* system identifier */
  2    18     2 control_file char (168),			/* path name of dump control file */
  2    19     2 operator char (32);				/* operator who started dump */
  2    20 
  2    21 /* END INCLUDE FILE ... backup_info.incl.pl1 */
     1112 
     1113 
  3     1 /* BEGIN INCLUDE FILE ... backup_volume_log.incl.pl1 ... Feb 1976 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(88-03-03,GWMay), approve(89-10-03,MCR8135),
  3     6*     audit(89-10-04,Beattie), install(89-10-10,MR12.3-1089):
  3     7*     Added values for storing the number of incremental and consolidated dump
  3     8*     sets to retain in the volume log.  Incremented version number to 3.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 /*     Modified: 3/7/84 by GA Texada to change to version 2						*/
  3    13 dcl  bvlp ptr;
  3    14 dcl  bvlep ptr;
  3    15 
  3    16 dcl  backup_volume_log_version_1 fixed bin static init (1) options (constant);
  3    17 dcl  backup_volume_log_version_2 fixed bin init(2) int static options(constant);
  3    18 dcl  backup_volume_log_version_3 fixed bin init(3) int static options(constant);
  3    19 
  3    20 dcl 1 backup_volume_log based (bvlp) aligned,
  3    21     2 header like backup_volume_header aligned,
  3    22     2 info like backup_pvol_info aligned,
  3    23     2 version fixed bin,				/* version number */
  3    24     2 lock bit (36),				/* shared data base */
  3    25     2 pvname char (32),				/* physical volume name */
  3    26     2 pvid bit (36),				/* physical volume id */
  3    27     2 next fixed bin,				/* next available dump record */
  3    28     2 reload_groups fixed bin,			/* number of reload groups in log */
  3    29     2 purge_control (3),				/* control selective purging by dump type */
  3    30       3 group (36) bit (1) unaligned,			/* up to 36 reload groups */
  3    31     2 disk_type fixed bin unal,			/* type of disk drive			*/	
  3    32     2 half_word_pad bit(18) unal,			/* MBZ					*/
  3    33     2 rpv_pvid bit(36),				/* pvid of this volumes RPV			*/
  3    34     2 Nsaved_incr_sets fixed bin,			/* number of incr cycles to retain */
  3    35     2 Nsaved_cons_sets fixed bin,			/* number of incr cycles to retain */
  3    36     2 pad (31) bit (36),				/* for future expansion (MBZ)			*/
  3    37     2 array (1:1 refer (backup_volume_log.next)) like bvle aligned;
  3    38 
  3    39 dcl 1 bvle based (bvlep) aligned,
  3    40     2 cycle_uid bit (36),				/* uid of this dump cycle */
  3    41     2 dump_type fixed bin,				/* type of dump */
  3    42     2 volname char (32),				/* name of output volume */
  3    43     2 open_time fixed bin (71),			/* opening time of dump pass on this physical volume */
  3    44     2 close_time fixed bin (71),			/* ending time of dump pass */
  3    45     2 volid bit (36),				/* uid of output volume */
  3    46     2 io_module char (32),				/* outer module name that wrote this volume */
  3    47     2 flags,					/* flags */
  3    48       3 purge_scan_logged bit (1) unaligned,		/* if on object looged during purge scan */
  3    49       3 pad1 bit (35) unaligned,
  3    50     2 pad (7) bit (36),				/* for future expansion */
  3    51    (2 dir_num fixed bin,				/* number of dirs dumped on this pass */
  3    52     2 dir_rec fixed bin,				/* number of records of dirs */
  3    53     2 seg_num fixed bin,				/* number of segs dumped on this pass */
  3    54     2 seg_rec fixed bin) unaligned;			/* number of records of segs */
  3    55 
  3    56 /* END INCLUDE FILE ... backup_volume_log */
     1114 
  4     1 /* BEGIN INCLUDE FILE ... backup_pvol_info.incl.pl1 */
  4     2 
  4     3 dcl  bpvip ptr;
  4     4 
  4     5 dcl 1 backup_pvol_info based (bpvip) aligned,
  4     6     2 label like label aligned,
  4     7     2 n_vtoce fixed bin,
  4     8     2 n_free_vtoce fixed bin,
  4     9     2 n_rec fixed bin,
  4    10     2 baseadd fixed bin,
  4    11     2 n_free_rec fixed bin;
  4    12 
  4    13 /* END INCLUDE FILE ... backup_pvol_info.incl.pl1 */
     1115 
     1116 
  5     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  5     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     6*     Add the subvolume info.
  5     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  5     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  5     9*     Added inconsistent_dbm bit used to determine consistency of volume
  5    10*     dumper bit maps.
  5    11*                                                   END HISTORY COMMENTS */
  5    12 
  5    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  5    14 /* Note: fsout_vol clears pad fields before writing the label */
  5    15 
  5    16 dcl  labelp ptr;
  5    17 
  5    18 dcl 1 label based (labelp) aligned,
  5    19 
  5    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  5    21 
  5    22     2 gcos (5*64) fixed bin,
  5    23 
  5    24 /* Now we have the Multics label */
  5    25 
  5    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  5    27     2 version fixed bin,				/* Version 1 */
  5    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  5    29     2 pv_name char (32),				/* Physical volume name. */
  5    30     2 lv_name char (32),				/* Name of logical volume for pack */
  5    31     2 pvid bit (36),				/* Unique ID of this pack */
  5    32     2 lvid bit (36),				/* unique ID of its logical vol */
  5    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  5    34     2 time_registered fixed bin (71),			/* time imported to system */
  5    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  5    36     2 vol_size fixed bin,				/* total size of volume, in records */
  5    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  5    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  5    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  5    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  5    41     2 flagpad bit (33) unal,
  5    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  5    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  5    44     2 password bit (72),				/* not yet used */
  5    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  5    46     2 this_sv fixed bin,				/* what subvolume number it is */
  5    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  5    48     2 pad1 (13) fixed bin,
  5    49     2 time_mounted fixed bin (71),			/* time mounted */
  5    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  5    51 
  5    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  5    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  5    54* */
  5    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  5    56     2 pad6 fixed bin,				
  5    57 
  5    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  5    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  5    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  5    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  5    62     2 pad1a (2) fixed bin,
  5    63     2 err_hist_size fixed bin,			/* size of pack error history */
  5    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  5    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  5    66     2 pad2 (40) fixed bin,
  5    67     2 root,
  5    68       3 here bit (1),				/* TRUE if the root is on this pack */
  5    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  5    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  5    71       3 pad7 bit (1) aligned,				
  5    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  5    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  5    74       3 esd_state fixed bin,				/* State of esd */
  5    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  5    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  5    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  5    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  5    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  5    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  5    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  5    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  5    83     2 pad3 (52) fixed bin,
  5    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  5    85     2 parts (47),
  5    86       3 part char (4),				/* Name of partition */
  5    87       3 frec fixed bin,				/* First record */
  5    88       3 nrec fixed bin,				/* Number of records */
  5    89       3 pad5 fixed bin,
  5    90     2 pad4 (5*64) fixed bin;
  5    91 
  5    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  5    93 
  5    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
     1117 
     1118 
  6     1 /* BEGIN INCLUDE FILE ... old_fs_vol_label.incl.pl1 .. March 1982 */
  6     2 
  6     3 /* Pre-MR10 Volume Label */
  6     4 
  6     5 dcl  old_labelp ptr;
  6     6 
  6     7 dcl 1 old_label based (old_labelp) aligned,
  6     8 
  6     9 /* First comes data not used by Multics.. for compatibility with GCOS */
  6    10 
  6    11     2 gcos (5*64) fixed bin,
  6    12 
  6    13 /* Now we have the Multics label */
  6    14 
  6    15     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  6    16     2 version fixed bin,				/* Version 1 */
  6    17     2 mfg_serial char (32),				/* Manufacturer's serial number */
  6    18     2 pv_name char (32),				/* Physical volume name. */
  6    19     2 lv_name char (32),				/* Name of logical volume for pack */
  6    20     2 pvid bit (36),				/* Unique ID of this pack */
  6    21     2 lvid bit (36),				/* unique ID of its logical vol */
  6    22     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  6    23     2 time_registered fixed bin (71),			/* time imported to system */
  6    24     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  6    25     2 vol_size fixed bin,				/* total size of volume, in records */
  6    26     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  6    27     2 not_used bit (1) unal,				/* uset to be multiple_class */
  6    28     2 private bit (1) unal,				/* TRUE if was registered as private */
  6    29     2 flagpad bit (34) unal,
  6    30     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  6    31     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  6    32     2 password bit (72),				/* not yet used */
  6    33     2 pad1 (16) fixed bin,
  6    34     2 time_mounted fixed bin (71),			/* time mounted */
  6    35     2 time_map_updated fixed bin (71),			/* time vmap known good */
  6    36     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  6    37     2 time_salvaged fixed bin (71),			/* time salvaged */
  6    38     2 time_of_boot fixed bin (71),			/* time of last bootload */
  6    39     2 pd_time fixed bin (71),				/* PDMAP time of last PD which saw this vol */
  6    40     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  6    41     2 pad1a fixed bin,
  6    42     2 pad7 fixed bin,
  6    43     2 err_hist_size fixed bin,			/* size of pack error history */
  6    44     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  6    45     2 time_last_reloaded fixed bin (71),		/* what it says */
  6    46     2 pad5 (2) fixed bin,
  6    47     2 pad6 (3) fixed bin,
  6    48     2 pad2 (35) fixed bin,
  6    49     2 root,
  6    50       3 here bit (1),				/* TRUE if the root is on this pack */
  6    51       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  6    52       3 shutdown_state fixed bin,			/* Status of hierarchy */
  6    53       3 pd_active bit (1) aligned,			/* Unflushed PD exists */
  6    54       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  6    55       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  6    56       3 esd_state fixed bin,				/* State of esd */
  6    57     2 pad3 (60) fixed bin,
  6    58     2 nparts fixed bin,				/* Number of special partitions on pack */
  6    59     2 parts (47),
  6    60       3 part char (4),				/* Name of partition */
  6    61       3 frec fixed bin,				/* First record */
  6    62       3 nrec fixed bin,				/* Number of records */
  6    63       3 pad5 fixed bin,
  6    64     2 pad4 (5*64) fixed bin;
  6    65 
  6    66 
  6    67 /* END INCLUDE FILE old_fs_vol_label.incl.pl1 */
     1119 
     1120 
  7     1 /* BEGIN INCLUDE FILE ... backup_static_variables.incl.pl1 ... March 1976 */
  7     2 
  7     3 
  7     4 dcl  incr fixed bin init (1) internal static options (constant); /* incremental dump mode */
  7     5 dcl  cons fixed bin init (2) internal static options (constant); /* consolidated dump mode */
  7     6 dcl  comp fixed bin init (3) internal static options (constant); /* complete dump mode */
  7     7 dcl  backup_version_1 fixed bin init (1) static internal options (constant); /* backup_version_1 of input/output structures */
  7     8 
  7     9 
  7    10 
  7    11 /* END INCLUDE FILE ... backup_static_variables.incl.pl1 */
     1121 
  8     1 /* BEGIN INCLUDE FILE ... backup_volume_header ... Feb 1976 */
  8     2 
  8     3 dcl  hdp ptr;					/* ptr to header */
  8     4 
  8     5 dcl 1 backup_volume_header based (hdp) aligned,
  8     6     2 pattern1 bit (36),				/* unique  word 1 */
  8     7     2 rec1_type fixed bin,				/* record 1 type */
  8     8     2 rec1_len fixed bin,				/* length in chars */
  8     9     2 pattern2 bit (36),				/* unique word 2 */
  8    10     2 rec2_type fixed bin,				/* record 2 type */
  8    11     2 rec2_len fixed bin,				/* length in chars */
  8    12     2 pattern3 bit (36),				/* unique word 3 */
  8    13     2 time_dumped bit (36);				/* dump time of this record */
  8    14 
  8    15 dcl  vtoce_type fixed bin static init (1) options (constant); /* type code for vtoce */
  8    16 dcl  dir_type fixed bin static init (2) options (constant); /* type code for directory */
  8    17 dcl  seg_type fixed bin static init (3) options (constant); /* type code for segment */
  8    18 dcl  null_type fixed bin static init (4) options (constant); /* type code for null record */
  8    19 dcl  volume_log_type fixed bin static init (5) options (constant); /* type code for volume log */
  8    20 dcl  prev_output_log_type fixed bin static init (6) options (constant); /* type code for prev output log */
  8    21 dcl  contents_type fixed bin static init (7) options (constant); /* type code for contents segment of previous volume */
  8    22 dcl  info_type fixed bin static init (8) options (constant); /* type code for info structure */
  8    23 
  8    24 dcl  pattern1 bit (36) int static init ("110111000011001100011101101010100101"b) options (constant);
  8    25 dcl  pattern2 bit (36) int static init ("101001010101101110001100110000111011"b) options (constant);
  8    26 dcl  pattern3 bit (36) int static init ("001000111100110011100010010101011010"b) options (constant);
  8    27 
  8    28 /* END INCLUDE FILE ... backup_volume_header */
     1122 
  9     1 /* BEGIN INCLUDE FILE ... backup_volume_record.incl.pl1 ... March 1976 */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  9     7*     install(88-10-17,MR12.2-1173):
  9     8*     Added a version 2 constant
  9     9*                                                   END HISTORY COMMENTS */
  9    10 
  9    11 
  9    12 dcl  recordp ptr;
  9    13 
  9    14 dcl  backup_volume_record_version_1 fixed bin static init (1) options (constant);
  9    15 dcl  backup_volume_record_version_2 fixed bin static init (2) options (constant);
  9    16 
  9    17 dcl 1 backup_volume_record based (recordp) aligned,
  9    18     2 header like backup_volume_header aligned,
  9    19     2 version fixed bin,				/* version number of structure */
  9    20     2 pvid bit (36),				/* physical volume id */
  9    21     2 vtocx fixed bin,				/* vtoc index of returned vtoc entry */
  9    22     2 vtoce like vtoce aligned;			/* vtoc entry */
  9    23 
  9    24 /* END INCLUDE FILE ... backup_volume_record.incl.pl1 */
     1123 
     1124 
 10     1 /* BEGIN INCLUDE FILE ... rldr_data_.incl.pl1 ... March 1976 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
 10     6*     audit(86-05-22,GWMay), install(86-07-18,MR12.0-1098):
 10     7*     Add device_name to support the -pvname_device argument to reload.
 10     8*  2) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
 10     9*     install(88-10-17,MR12.2-1173):
 10    10*     Added pointer and length values for use as an input_buffer for
 10    11*     intermediate reads.
 10    12*                                                   END HISTORY COMMENTS */
 10    13 
 10    14 
 10    15 /* Severely modified 3/1/83 by GA Texada to support multiple physical */
 10    16 /*          volume reloading.				          */
 10    17 /*          Modified: 3/5/84 by GA Texada to make restart a per pv attribute */
 10    18 /*		  and add stranger flag.			*/
 10    19 
 10    20 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
 10    21 
 10    22 
 10    23 dcl rldr_datap	     ptr,
 10    24   rldr_data_max_pvs	     fixed bin,
 10    25 
 10    26   1 rldr_data_	     aligned based (rldr_datap),
 10    27     2 common	     like rldr_data_common,		/* only one of each needed			*/
 10    28     2 per_pv	     (rldr_data_max_pvs refer (rldr_data_.npvs)) like rldr_data_perpv,
 10    29 
 10    30   1 rldr_data_common     aligned,
 10    31     2 bits,
 10    32     ( 3 save	     bit (1),			/* if on can use disk pack restored by BOS */
 10    33       3 first_volume     bit (1),			/* if on indicates we are on first volume */
 10    34       3 rpv	     bit (1),			/* if on indicates we are reloading rpv */
 10    35       3 data_init	     bit (1),			/* if on data structure initialized to null state */
 10    36       3 arg_init	     bit (1),			/* on if arguments have been processed */
 10    37       3 disable_error_report bit (1),			/* if on will disable error messages */
 10    38       3 no_object	     bit (1),			/* if on only vtoces will be reloaded */
 10    39       3 err_online	     bit (1),			/* if on error messages written to error output */
 10    40       3 detach	     bit (1),			/* if on attached media will  be detached */
 10    41       3 brief	     bit (1),			/* if on brief mode enabled */
 10    42       3 manual	     bit (1),			/* if on operator will select input volumes */
 10    43       3 restart	     bit (1),			/* -restart was supplied			*/
 10    44       3 stranger	     bit (1),			/* ON if the pv's do not belong to the mounted RPV*/
 10    45       3 pad0	     bit (23)) unal,
 10    46       3 old_256K_switch  bit (2) aligned,		/* state of 256KW connection switch before we came along*/
 10    47       (3 last_pvid,					/* pvid of last good object read		*/
 10    48       3 rpv_pvid,					/* rpv pvid */
 10    49       3 rpv_lvid)	     bit (36),			/* rpv lvid */
 10    50       3 last_valid_puid  (0:15) bit (36),		/* last non-zero path uid read from input medium */
 10    51     2 chars,
 10    52     ( 3 sys_dir,					/* directory where vologs are */
 10    53       3 default_sys_dir) char (168),			/* default directory where vologs are */
 10    54       (3 last_valid_vtoce_ename,			/* last valid entry name from VTOCE */
 10    55       3 operator,					/* operator's name or initials */
 10    56       3 io_module)	     char (32),			/* name of io outer module used to read input */
 10    57       (3 input_volume_desc,				/* optional input medium attach description */
 10    58       3 output_volume_desc) char (256),			/* optional output medium attach description */
 10    59     2 fixed,
 10    60     ( 3 num_abandoned,				/* count these as we go along			*/
 10    61       3 last_vtocx,					/* vtocx of last valid object read		*/
 10    62       3 npvs,					/* the number of pv names given to the reload_volume command*/
 10    63       3 rpv_disk_type)   fixed bin,			/* model index of rpv disk drive */
 10    64       (3 start_time,				/* time reload started */
 10    65       3 from_time)	     fixed bin (71),		/*  time from which dump tapes should be skipped */
 10    66       3 input_buffer_len fixed bin (21),		/* length of the data in the read buffer */
 10    67       3 input_buffer_start fixed bin (21),		/* position in read buffer where new data begins */
 10    68     2 ptrs,
 10    69     ( 3 inputvol_iocbp,				/* iocb ptr for input */
 10    70       3 error_iocbp,				/* iocb ptr for error output */
 10    71       3 skip,					/* ptr to skip list */
 10    72       3 volume_record_bp,				/* ptr to temp seg containing most recent volume record */
 10    73       3 infop,					/* ptr to temp seg containig tdump info */
 10    74       3 data_object_bp,				/* ptr to temp seg containing most recent object from input medium */
 10    75       3 input_vol_lstp  ptr,				/* ptr to temp seg containing list of input media */
 10    76       3 input_buffer_ptr)  ptr,			/* ptr to read buffer */
 10    77  
 10    78 
 10    79   1 rldr_data_perpv	     aligned,			/* one entry per physical volume to be reloaded	*/
 10    80     2 flags,
 10    81       3 abandoned	     bit (1) unal,			/* we quit due to some error			*/
 10    82       3 restart	     bit (1),			/* if on unitialized volume ok and reload will restart */
 10    83       3 mbz0	     bit (34) unal,			/* beware, RFU				*/
 10    84     (2 pvname,					/* physical volume name */
 10    85     2 lvname,					/* logical volume name of physical volume being reloaded */
 10    86     2 disk_model)	     char (32),			/* model name of disk drive */
 10    87     2 device_name	     char (8),
 10    88     (2 lvid,					/* logical volume id of volume being reloaded */
 10    89     2 pvid)	     bit (36),			/* physical volume id of volume being reloaded */
 10    90     (2 prev_wordx,					/* index to fsmap */
 10    91     2 prev_bitx,					/* index to fsmap */
 10    92     2 disk_type,					/* model index of disk drive */
 10    93     2 usable_sectors,				/* usable sectors per cylinder of disk pack */
 10    94     2 unusable_sectors,				/* unusable sectors per cylinder of disk pack */
 10    95     2 n_vtoce)	     fixed bin,			/* number of vtoce on disk pack */
 10    96     (2 vtocbp,					/* ptr to vtoc buffer seg */
 10    97     2 vtoc_headerp,					/* ptr to temp seg containing the vtoc header */
 10    98     2 labelp,					/* ptr to temp seg containing pack label */
 10    99     2 bvlp,					/* ptr to volume log */
 10   100     2 outputvol_iocbp,				/* iocb ptr for output */
 10   101     2 controlp,					/* ptr to seg containing reload control info about vtoc */
 10   102     2 vol_mapp)	     ptr,				/* ptr to temp seg containing volume map */
 10   103 
 10   104   1 rldr_data_nulled_pv  aligned int static options (constant),
 10   105     2 flags,
 10   106       3 abandoned	     bit (1) init ("0"b) unal,
 10   107       3 restart	     bit (1) init ("0"b) unal,
 10   108       3 mbz0	     bit (34) init ((34)"0"b) unal,
 10   109       (2 pvname,
 10   110     2 lvname,
 10   111     2 disk_model)	     char (32) init (""),
 10   112     2 device_name	     char (8) init (""),
 10   113     (2 lvid,
 10   114     2 pvid)	     bit (36) init ("0"b),
 10   115     (2 prev_wordx,
 10   116     2 prev_bitx,
 10   117     2 disk_type,
 10   118     2 usable_sectors,
 10   119     2 unusable_sectors,
 10   120     2 n_vtoce)	     fixed bin init (0),
 10   121     (2 vtocbp,
 10   122     2 vtoc_headerp,
 10   123     2 labelp,
 10   124     2 bvlp,
 10   125     2 outputvol_iocbp,
 10   126     2 controlp,
 10   127     2 vol_mapp)	     ptr init (null ());
 10   128 
 10   129 
 10   130 /* END INCLUDE FILE rldr_data_.incl.pl1 */
     1125 
     1126 
 11     1 /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
 11     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
 11     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
 11     4 
 11     5 dcl  vtocep ptr;
 11     6 
 11     7 dcl 1 vtoce based (vtocep) aligned,
 11     8 
 11     9 
 11    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
 11    11 
 11    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
 11    13 
 11    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
 11    15     2 csl bit (9),					/* current segment length - in 1024 word units */
 11    16     2 records bit (9),				/* number of records used by the seg in second storage */
 11    17     2 pad2 bit (9),
 11    18 
 11    19     2 dtu bit (36),					/* date and time segment was last used */
 11    20 
 11    21     2 dtm bit (36),					/* date and time segment was last modified */
 11    22 
 11    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
 11    24     2 deciduous bit (1),				/* true if hc_sdw */
 11    25     2 nid bit (1),					/* no incremental dump switch */
 11    26     2 dnzp bit (1),					/* Dont null zero pages */
 11    27     2 gtpd bit (1),					/* Global transparent paging device */
 11    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
 11    29     2 damaged bit (1),				/* TRUE if contents damaged */
 11    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
 11    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
 11    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
 11    33     2 pad3 bit (8),
 11    34     2 dirsw bit (1),				/* directory switch */
 11    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
 11    36     2 pad4 bit (16)) unaligned,			/* not used */
 11    37 
 11    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
 11    39 
 11    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
 11    41 
 11    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
 11    43 
 11    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
 11    45 
 11    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
 11    47 
 11    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
 11    49 
 11    50 
 11    51 
 11    52 
 11    53 
 11    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
 11    55 
 11    56     2 pad6 (10) bit (36),				/* not used */
 11    57 
 11    58     2 ncd bit (1),					/* no complete dump switch */
 11    59     2 pad7 bit (17),
 11    60     2 pad8 bit (18),
 11    61 
 11    62     2 dtd bit (36),					/* date-time-dumped */
 11    63 
 11    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
 11    65 
 11    66     2 master_dir_uid bit (36),			/* superior master directory uid */
 11    67 
 11    68 
 11    69 
 11    70 
 11    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
 11    72 
 11    73     2 primary_name char (32),				/* primary name of the segment */
 11    74 
 11    75     2 time_created bit (36),				/* time the segment was created */
 11    76 
 11    77     2 par_pvid bit (36),				/* physical volume id of the parent */
 11    78 
 11    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
 11    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
 11    81 
 11    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
 11    83 
 11    84     2 access_class bit (72),				/* access class in branch */
 11    85     2 perm_flags aligned,
 11    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
 11    87       3 pad9 bit (35) unal,
 11    88     2 owner bit (36);				/* pvid of this volume */
 11    89 
 11    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
 11    91 
 11    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
 11    93     2 pad1 bit (7*36),
 11    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
 11    95     2 pad2 bit (184*36);
 11    96 
 11    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
     1127 
     1128 
 12     1 /* BEGIN INCLUDE FILE ...  rldr_control.incl.pll ... March 1976 */
 12     2 
 12     3 dcl  controlp ptr;					/* ptr to control segment */
 12     4 
 12     5 dcl 1 rldr_control based (controlp) aligned,		/* structure of control segment for reloader */
 12     6     2 curn_volname char (32),				/* volune name of present input volume */
 12     7     2 dir_num fixed bin,				/* number of directories reloaded */
 12     8     2 dir_rec fixed bin,				/* number of driectory records reloaded */
 12     9     2 seg_num fixed bin,				/* number of segments reloaded */
 12    10     2 seg_rec fixed bin,				/* number of segment records reloaded */
 12    11     2 input_vol_dir_num fixed bin,			/* number of directories reloaded from  input vol */
 12    12     2 input_vol_dir_rec fixed bin,			/* number of driectory records reloaded from  input vol */
 12    13     2 input_vol_seg_num fixed bin,			/* number of segments reloaded from input vol */
 12    14     2 input_vol_seg_rec fixed bin,			/* number of segment records reloaded from input vol */
 12    15     2 num_null_vtoce fixed bin,			/* number of null vtoce reloaded */
 12    16     2 num_rejected fixed bin,				/* number of data objects on input media that were skipped */
 12    17     2 curn_volid bit (36),				/* volume id of present input volume */
 12    18     2 label like label aligned,
 12    19     2 vol_map like  vol_map aligned,
 12    20     2 vtoc_header like  vtoc_header aligned,
 12    21     2 array (0 : 1),				/* look aside memory of vtoces reloaded */
 12    22       3 uid bit (36),				/* uid of reloaded vtoce */
 12    23       3 buffer_idx fixed bin,				/* index in vtoc buffer */
 12    24       3 time_dumped fixed bin(71),			/* time object dumped */
 12    25       3 volid bit (36);				/* volid of input volume vtoce reloaded from */
 12    26 
 12    27 /* END INCLUDE FILE ... rld_control.incl.pl1 */
     1129 
     1130 
 13     1 /* BEGIN INCLUDE FILE ... vol_map.incl.pl1 */
 13     2 
 13     3 dcl   vol_mapp	ptr;
 13     4 
 13     5 dcl 1 vol_map based (vol_mapp) aligned,
 13     6 
 13     7     2 n_rec fixed bin(17),				/* number of records represented in the map */
 13     8     2 base_add fixed bin(17),				/* record number for first bit in bit map */
 13     9     2 n_free_rec fixed bin(17),			/* number of free records */
 13    10     2 bit_map_n_words fixed bin(17),			/* number of words of the bit map */
 13    11     2 pad (60) bit(36),				/* pad to 64 words */
 13    12     2 bit_map (3*1024 - 64) bit(36) ;			/* bit map - the entire vol map occupies 3 records */
 13    13 
 13    14 /* END INCLUDE ... vol_map */
     1131 
 14     1 /* BEGIN INCLUDE FILE ... vtoc_header.incl.pl1 */
 14     2 
 14     3 dcl  vtoc_headerp ptr;
 14     4 
 14     5 dcl 1 vtoc_header based (vtoc_headerp) aligned,
 14     6 
 14     7     2 version fixed bin (17),				/* version number. The current version number is 1. * */
 14     8     2 n_vtoce fixed bin (17),				/* number of vtoc entries */
 14     9     2 vtoc_last_recno fixed bin (17),			/* record number of the last record of the vtoc */
 14    10     2 n_free_vtoce fixed bin (17),			/* number of free vtoc entries */
 14    11     2 first_free_vtocx fixed bin (17),			/* index of the first vtoce in the free list */
 14    12     2 pad (3) bit (36),
 14    13     2 dmpr_bit_map (2048 - 8) bit (36);			/* space for dmpr bit map */
 14    14 
 14    15 /* END INCLUDE ... vtoc_header */
 14    16 
     1132 
     1133 
 15     1 /* Begin include file ..... iox_modes.incl.pl1 */
 15     2 
 15     3 /* Written by C. D. Tavares, 03/17/75 */
 15     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 15     5 
 15     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 15     7     ("stream_input", "stream_output", "stream_input_output",
 15     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 15     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 15    10      "direct_input", "direct_output", "direct_update");
 15    11 
 15    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 15    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 15    14 
 15    15 dcl (Stream_input initial (1),
 15    16      Stream_output initial (2),
 15    17      Stream_input_output initial (3),
 15    18      Sequential_input initial (4),
 15    19      Sequential_output initial (5),
 15    20      Sequential_input_output initial (6),
 15    21      Sequential_update initial (7),
 15    22      Keyed_sequential_input initial (8),
 15    23      Keyed_sequential_output initial (9),
 15    24      Keyed_sequential_update initial (10),
 15    25      Direct_input initial (11),
 15    26      Direct_output initial (12),
 15    27      Direct_update initial (13)) fixed bin int static options (constant);
 15    28 
 15    29 /* End include file ..... iox_modes.incl.pl1 */
     1134 
     1135 
 16     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
 16     2 
 16     3 /* Written 05/04/78 by C. D. Tavares */
 16     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
 16     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
 16     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
 16     7 
 16     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
 16     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
 16    10      iox_$close entry (pointer, fixed bin (35)),
 16    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
 16    12      iox_$delete_record entry (pointer, fixed bin (35)),
 16    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
 16    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
 16    15      iox_$err_not_attached entry options (variable),
 16    16      iox_$err_not_closed entry options (variable),
 16    17      iox_$err_no_operation entry options (variable),
 16    18      iox_$err_not_open entry options (variable),
 16    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
 16    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
 16    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 16    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 16    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
 16    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
 16    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
 16    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
 16    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
 16    28      iox_$propagate entry (pointer),
 16    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 16    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 16    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
 16    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 16    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 16    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 16    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 16    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
 16    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
 16    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
 16    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
 16    40 
 16    41 dcl (iox_$user_output,
 16    42      iox_$user_input,
 16    43      iox_$user_io,
 16    44      iox_$error_output) external static pointer;
 16    45 
 16    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
     1136 
     1137 
 17     1 /* BEGIN INCLUDE FILE ... rldr_skip_list.incl.pl1 ... 11/76 */
 17     2 
 17     3 dcl skip ptr;
 17     4 
 17     5 dcl 1 rldr_skip_list aligned based (skip),
 17     6     2 next fixed bin,
 17     7     2 array(1),
 17     8       3 volname char(32);
 17     9 
 17    10 /* END INCLUDE FILE ... rldr_skip_list.incl.pl1 */
     1138 
 18     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
 18     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
 18     3 /*	version number changed to 4, 08/10/78 WOS */
 18     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
 18     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
 18     6 
 18     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
 18     8     2 version fixed bin,				/* version of this structure - must be set, see below */
 18     9     2 switches aligned,                                     /* various bit switch values */
 18    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
 18    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
 18    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
 18    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
 18    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
 18    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
 18    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
 18    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
 18    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
 18    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
 18    20 
 18    21 /*  Limit of data defined for version 2 */
 18    22 
 18    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
 18    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
 18    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
 18    26 						/* minimum of 30 seconds required for repeat */
 18    27 						/* otherwise, no repeat will occur */
 18    28 /* Limit of data defined for version 4 */
 18    29 
 18    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
 18    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
 18    32 
 18    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
 18    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
 18    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
 18    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
 18    37 
 18    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     1139 
     1140 
 19     1 /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
 19     2 
 19     3 /****^  HISTORY COMMENTS:
 19     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
 19     5*     install(86-11-21,MR12.0-1223):
 19     6*     created.
 19     7*                                                   END HISTORY COMMENTS */
 19     8 
 19     9 /* format: off */
 19    10 
 19    11 /* ************************************************************************ */
 19    12 /*							      */
 19    13 /* Function: Provides constants for commonly used Multics system values.    */
 19    14 /*							      */
 19    15 /* Usage: These values are available for use in place of "magic" numbers    */
 19    16 /*        (unexplained numbers) in programming applications.	      */
 19    17 /*							      */
 19    18 /* Definitions:						      */
 19    19 /*							      */
 19    20 /*   PER             bit     character/byte     word     page     segment   */
 19    21 /*		 					      */
 19    22 /*   bits              1            9             36     36864    9400320   */
 19    23 /*   characters/bytes	      1	           4      4096    1044480   */
 19    24 /*   words				 1      1024     261120   */
 19    25 /*   pages				           1        255   */
 19    26 /*   segments						  1   */
 19    27 /*							      */
 19    28 /*  The base values for a bit, char, word and page are determined by the    */
 19    29 /*  Multics hardware implementation.  The other values are calculated from  */
 19    30 /*  their relation to one another as shown in the matrix above.	      */
 19    31 /*							      */
 19    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
 19    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
 19    34 /*		  = 9 * 4					      */
 19    35 /*		  = 36					      */
 19    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
 19    37 /*		  = 9 * 4 * 1024				      */
 19    38 /*		  = 36864					      */
 19    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
 19    40 /*		    PAGES_PER_SEGMENT			      */
 19    41 /*		  = 9 * 4 * 1024 * 255			      */
 19    42 /*		  = 9400320				      */
 19    43 /*							      */
 19    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
 19    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
 19    46 /*		  = 4 * 1024				      */
 19    47 /*		  = 4096					      */
 19    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
 19    49 /*		  = 4 * 1024 * 255				      */
 19    50 /*		  = 1044480				      */
 19    51 /*							      */
 19    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
 19    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
 19    54 /*		  = 1024 * 255				      */
 19    55 /*		  = 261120				      */
 19    56 /*							      */
 19    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
 19    58 /*							      */
 19    59 /* ************************************************************************ */
 19    60 
 19    61        declare BITS_PER_CHAR		fixed bin (4) internal static
 19    62 				options (constant) initial (9);
 19    63 
 19    64        declare BITS_PER_WORD		fixed bin (6) internal static
 19    65 				options (constant) initial (36);
 19    66 
 19    67        declare BITS_PER_PAGE		fixed bin (16) internal static
 19    68 				options (constant) initial (36864);
 19    69 
 19    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
 19    71 				options (constant) initial (9400320);
 19    72 
 19    73        declare CHARS_PER_WORD		fixed bin (3) internal static
 19    74 				options (constant) initial (4);
 19    75 
 19    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
 19    77 				options (constant) initial (4096);
 19    78 
 19    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
 19    80 				options (constant) initial (1044480);
 19    81 
 19    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
 19    83 
 19    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
 19    85 				options (constant) initial (1024);
 19    86 
 19    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
 19    88 
 19    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
 19    90 				options (constant) initial (261120);
 19    91 
 19    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
 19    93 				options (constant) initial (255);
 19    94 
 19    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
 19    96 
     1141 
     1142 
     1143   end rldr_input_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/12/90  1510.5  rldr_input_.pl1                   >spec>install>1014>rldr_input_.pl1
1111         1    05/23/77  1019.3  rldr_input_volume_list.incl.pl1   >ldd>include>rldr_input_volume_list.incl.pl1
1112         2    09/05/80  1236.5  backup_info.incl.pl1              >ldd>include>backup_info.incl.pl1
1114         3    10/12/89  2113.4  backup_volume_log.incl.pl1        >ldd>include>backup_volume_log.incl.pl1
1115         4    06/07/77  1333.6  backup_pvol_info.incl.pl1         >ldd>include>backup_pvol_info.incl.pl1
1117         5    07/21/88  2136.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
1119         6    05/27/82  1625.8  old_fs_vol_label.incl.pl1         >ldd>include>old_fs_vol_label.incl.pl1
1121         7    09/05/80  1236.5  backup_static_variables.incl.pl1  >ldd>include>backup_static_variables.incl.pl1
1122         8    09/05/80  1236.5  backup_volume_header.incl.pl1     >ldd>include>backup_volume_header.incl.pl1
1123         9    10/18/88  1315.0  backup_volume_record.incl.pl1     >ldd>include>backup_volume_record.incl.pl1
1125        10    10/18/88  1315.0  rldr_data_.incl.pl1               >ldd>include>rldr_data_.incl.pl1
1127        11    10/04/83  1205.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
1129        12    04/01/81  0930.5  rldr_control.incl.pl1             >ldd>include>rldr_control.incl.pl1
1131        13    04/29/76  1150.5  vol_map.incl.pl1                  >ldd>include>vol_map.incl.pl1
1132        14    05/23/77  1019.3  vtoc_header.incl.pl1              >ldd>include>vtoc_header.incl.pl1
1134        15    02/02/78  1329.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1136        16    05/23/83  1016.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
1138        17    11/09/77  0813.6  rldr_skip_list.incl.pl1           >ldd>include>rldr_skip_list.incl.pl1
1139        18    03/11/83  1304.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
1141        19    11/24/86  1343.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_WORD                          constant        fixed bin(6,0)           initial dcl 19-64 ref 803 803 803
CHARS_PER_PAGE                  010156 constant        fixed bin(13,0)          initial dcl 19-76 ref 187 187 188 188 189 189 1053
                                                                                  1061 1076 1086 1099 1099
CHARS_PER_WORD                         constant        fixed bin(3,0)           initial dcl 19-73 ref 419 435 784 787 805
DELIMITED                              constant        bit(1)                   initial dcl 93 ref 420 436 788 806
FORWARD_CHAR_POSITIONING        000074 constant        fixed bin(17,0)          initial dcl 95 set ref 1030*
Nassign_chars                   000100 automatic       fixed bin(21,0)          dcl 1011 set ref 1071* 1079* 1080 1086 1089 1091
                                                                                  1093
Nread_chars                     000101 automatic       fixed bin(21,0)          dcl 1011 set ref 1017* 1024* 1035* 1038 1043*
Nrequested_chars                       parameter       fixed bin(21,0)          dcl 999 ref 993 1019 1030 1032 1035 1053 1071 1080
                                                                                  1086
Nreturned_chars                        parameter       fixed bin(21,0)          dcl 999 set ref 993 1017* 1019 1023 1030 1032* 1032
                                                                                  1035 1035 1035 1038* 1038 1052 1089*
Sdelimited                             parameter       bit(1)                   dcl 999 ref 993 1023 1042 1059 1074 1096
Stream_input                    000071 constant        fixed bin(17,0)          initial dcl 15-15 set ref 697*
WORDS_PER_PAGE                         constant        fixed bin(11,0)          initial dcl 19-84 ref 812
YES                             000124 automatic       bit(1)                   packed unaligned dcl 71 set ref 384* 387 688* 691
                                                                                  947* 949
a_new_volume                           parameter       bit(1)                   packed unaligned dcl 71 set ref 169 175* 197*
a_pvindex                              parameter       fixed bin(17,0)          dcl 79 set ref 131 140* 160* 169 174 326 332
abandoned               434            based           bit(1)                   array level 4 packed packed unaligned dcl 10-23 ref
                                                                                  483
acode                                  parameter       fixed bin(35,0)          dcl 980 set ref 978 984* 986* 987*
addcharno                                              builtin function         dcl 125 ref 1035 1035
addr                                                   builtin function         dcl 125 ref 242 656 656 806 806 1024 1024 1043 1043
already_there                          parameter       bit(1)                   packed unaligned dcl 71 set ref 131 142* 499* 501*
alvname                                parameter       char(32)                 packed unaligned dcl 980 set ref 978 985* 987*
answer_iocbp              6     001104 automatic       pointer                  initial level 2 dcl 18-7 set ref 18-7*
apvid                                  parameter       bit(36)                  packed unaligned dcl 980 set ref 978 987*
apvname                                parameter       char(32)                 packed unaligned dcl 980 set ref 978 985* 987*
array                  2100            based           structure                array level 2 in structure "backup_volume_log"
                                                                                  dcl 3-20 in procedure "rldr_input_" set ref 242
array                     2            based           structure                array level 2 in structure "rldr_input_volume_list"
                                                                                  dcl 1-3 in procedure "rldr_input_"
array                 14024            based           structure                array level 2 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_"
array                     1            based           structure                array level 2 in structure "rldr_skip_list" dcl 17-5
                                                                                  in procedure "rldr_input_"
att_desc                        000131 automatic       char(256)                packed unaligned dcl 73 set ref 676* 678* 683*
avolname                        000110 automatic       varying char(32)         dcl 70 set ref 656* 657
backup_info                            based           structure                level 1 dcl 2-7 set ref 849* 849
backup_info_version_2                  constant        fixed bin(17,0)          initial dcl 2-5 ref 850
backup_pvol_info                       based           structure                level 1 dcl 4-5
backup_volume_header                   based           structure                level 1 dcl 8-5 ref 419 435 436 436 787 803 803 803
                                                                                  806 806
backup_volume_log                      based           structure                level 1 dcl 3-20
backup_volume_record                   based           structure                level 1 dcl 9-17
backup_volume_record_version_1         constant        fixed bin(17,0)          initial dcl 9-14 ref 452 531
backup_volume_record_version_2         constant        fixed bin(17,0)          initial dcl 9-15 ref 452
bin                                                    builtin function         dcl 125 ref 500 502
bits                                   based           structure                level 3 dcl 10-23
brief                     0(09)        based           bit(1)                   level 4 packed packed unaligned dcl 10-23 ref 303
bvle                                   based           structure                level 1 dcl 3-39
bvlep                           000350 automatic       pointer                  dcl 3-14 set ref 242* 243 245 245 254 256 256 262
                                                                                  265 267 271 370 370 371 374 374 379 382 384 384
                                                                                  389 395 396 929 929 931
bvlp                            000346 automatic       pointer                  dcl 3-13 in procedure "rldr_input_" set ref 221* 241
                                                                                  242 761 831 931 931
bvlp                    510            based           pointer                  array level 3 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 221
char                            000112 automatic       char(2)                  level 2 packed packed unaligned dcl 891 set ref 902*
                                                                                  909* 910*
char_buf                               based           char                     packed unaligned dcl 81 set ref 189*
char_num                        000303 automatic       char(32)                 packed unaligned dcl 85 set ref 911* 912*
chars                    25            based           structure                level 3 dcl 10-23
close_time               14            based           fixed bin(71,0)          level 2 dcl 3-39 ref 245 245 256
code                                   parameter       fixed bin(35,0)          dcl 72 in procedure "rldr_input_" set ref 131 141*
                                                                                  153 169 179* 184* 209 215* 227 291* 292* 300* 420*
                                                                                  427* 436* 443 470* 471 531* 551 552 552 563* 564
                                                                                  564* 567* 568 568* 582 585* 587* 588 603* 611*
                                                                                  642* 661 683* 685 686 693* 697* 698 699* 724* 725
                                                                                  725* 728* 729 729* 761* 762 762* 788* 806* 815*
                                                                                  831* 832 832* 905* 912* 913
code                                   parameter       fixed bin(35,0)          dcl 999 in procedure "read" set ref 993 1017* 1019
                                                                                  1024* 1026 1030* 1035* 1040 1043* 1045 1080*
collect_stats                          constant        fixed bin(17,0)          initial dcl 91 ref 331
command_query_                  000036 constant        entry                    external dcl 106 ref 656
command_query_$yes_no           000040 constant        entry                    external dcl 107 ref 384 688 947
common                                 based           structure                level 2 dcl 10-23
comp                                   constant        fixed bin(17,0)          initial dcl 7-6 ref 265
comp_cycle_uid                  000270 automatic       bit(36)                  packed unaligned dcl 78 set ref 239* 266 267 271*
comp_open_time                  000264 automatic       fixed bin(71,0)          dcl 77 set ref 238* 244 245 245 255 256 268* 272*
cons                                   constant        fixed bin(17,0)          initial dcl 7-5 ref 254
cons_cycle_uid                  000271 automatic       bit(36)                  packed unaligned dcl 78 set ref 240* 256 262*
cons_open_time                  000262 automatic       fixed bin(71,0)          dcl 77 set ref 237* 244 245 245 261*
controlp                        001100 automatic       pointer                  dcl 12-3 in procedure "rldr_input_" set ref 158*
                                                                                  181* 195 196 286* 287 334* 341 341 342 342 343 343
                                                                                  344 344 348 348 349 349 350 350 352 352 355 355
                                                                                  485* 487 500 501 501 502 503 512* 513 513 560* 561
                                                                                  561 561 649* 650 651 667* 668 669 704* 705 706 707
                                                                                  708 735* 736 736 737 737 737 737 737 743 744 745
                                                                                  746 947
controlp                514            based           pointer                  array level 3 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 158 181 286 334 485
                                                                                  512 560 579 582 585 611 649 667 704 735 796 813
                                                                                  850
cp_escape_control         1(02) 001104 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7*
curn_entry                1            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 280* 287 295* 306 640* 640
                                                                                  641 645 646 671* 672 673 856* 856 949* 949
curn_volid               22            based           bit(36)                  level 2 dcl 12-5 set ref 651* 669*
curn_volname                           based           char(32)                 level 2 dcl 12-5 set ref 287 579* 582* 585* 611*
                                                                                  650* 668* 737* 796* 813* 850 947*
cv_dec_check_                   000030 constant        entry                    external dcl 103 ref 912
cycle_uid                              based           bit(36)                  level 2 in structure "bvle" dcl 3-39 in procedure
                                                                                  "rldr_input_" ref 256 262 267 271 931
cycle_uid              2100            based           bit(36)                  array level 3 in structure "backup_volume_log"
                                                                                  dcl 3-20 in procedure "rldr_input_" set ref 931
data_object_bp          426            based           pointer                  level 4 dcl 10-23 set ref 184* 189
dir_num                  10            based           fixed bin(17,0)          level 2 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_" set ref 341* 341
dir_num                  37            based           fixed bin(17,0)          level 2 in structure "bvle" packed packed unaligned
                                                                                  dcl 3-39 in procedure "rldr_input_" ref 370
dir_rec                  11            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 342* 342 561
dirsw                    20(18)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 ref 340
divide                                                 builtin function         dcl 125 ref 187 784
dn                              000100 automatic       char(168)                packed unaligned dcl 960 set ref 967* 971* 971
dump_type                 1            based           fixed bin(17,0)          level 2 dcl 3-39 ref 243 254 265 929
dump_volname             17            based           char(32)                 level 2 dcl 2-7 set ref 850 853* 866*
ec                              000234 automatic       fixed bin(35,0)          dcl 963 set ref 967* 968 969
en                              000152 automatic       char(32)                 packed unaligned dcl 961 set ref 967* 971 971*
end_of_record                   000102 automatic       fixed bin(17,0)          dcl 1011 set ref 1076* 1078 1079
entry                           000273 automatic       fixed bin(17,0)          dcl 79 set ref 139* 173* 214* 331* 533 598 602
error_table_$action_not_performed
                                000056 external static fixed bin(35,0)          dcl 115 ref 300
error_table_$bad_volid          000072 external static fixed bin(35,0)          dcl 121 ref 291 905
error_table_$data_loss          000060 external static fixed bin(35,0)          dcl 116 ref 1080
error_table_$device_end         000062 external static fixed bin(35,0)          dcl 117 ref 552
error_table_$end_of_info        000070 external static fixed bin(35,0)          dcl 120 ref 552 642 815
error_table_$resource_unavailable
                                000066 external static fixed bin(35,0)          dcl 119 ref 686
error_table_$root               000064 external static fixed bin(35,0)          dcl 118 ref 968
explanation_len          14     001104 automatic       fixed bin(21,0)          initial level 2 dcl 18-7 set ref 18-7*
explanation_ptr          12     001104 automatic       pointer                  initial level 2 dcl 18-7 set ref 18-7*
fixed                                                  builtin function         dcl 125 in procedure "rldr_input_" ref 342 344 350
                                                                                  352
fixed                   402            based           structure                level 3 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_"
flags                   434            based           structure                array level 3 dcl 10-23
get_group_id_                   000016 constant        entry                    external dcl 98 ref 680
get_object                             constant        fixed bin(17,0)          initial dcl 88 ref 139 533 598
hc_backup_$decode_uidpath       000014 constant        entry                    external dcl 97 ref 967
hcs_$level_get                  000020 constant        entry                    external dcl 99 ref 680
hdp                                    automatic       pointer                  dcl 8-3 ref 419 435 436 436 787 803 803 803 806 806
header                                 based           structure                level 2 dcl 9-17
i                               000100 automatic       fixed bin(17,0)          dcl 722 in procedure "detach" set ref 734* 735 737*
i                               000100 automatic       fixed bin(17,0)          dcl 634 in procedure "attach" set ref 648* 649* 666*
                                                                                  667* 703* 704*
i                               000100 automatic       fixed bin(17,0)          dcl 548 in procedure "check_input_error" set ref
                                                                                  559* 560 563* 564 567* 568*
idx                             000276 automatic       fixed bin(17,0)          dcl 79 set ref 241* 242* 287* 287* 290 295 306* 307
                                                                                  308 308* 930
ignore                          000127 automatic       fixed bin(35,0)          dcl 72 set ref 700* 733*
incr                                   constant        fixed bin(17,0)          initial dcl 7-4 ref 243 929
incr_open_time                  000260 automatic       fixed bin(71,0)          dcl 77 set ref 236* 251*
index                                                  builtin function         dcl 125 ref 1076
info_type                              constant        fixed bin(17,0)          initial dcl 8-22 ref 441
infop                   424            based           pointer                  level 4 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 848
infop                           000344 automatic       pointer                  dcl 2-3 in procedure "rldr_input_" set ref 848* 849
                                                                                  850 850 853 859 865 866
init                                   constant        fixed bin(17,0)          initial dcl 90 ref 214
input_buf                              based           bit(36)                  array packed unaligned dcl 83 set ref 784*
input_buffer                           based           char                     packed unaligned dcl 1005 set ref 1053* 1061 1076
                                                                                  1086 1099* 1099
input_buffer_len        412            based           fixed bin(21,0)          level 4 dcl 10-23 set ref 1020 1052* 1053 1066* 1066
                                                                                  1070 1071 1076 1093* 1093 1096 1099 1099
input_buffer_ptr        432            based           pointer                  level 4 dcl 10-23 ref 1053 1061 1076 1086 1099 1099
input_buffer_start      413            based           fixed bin(21,0)          level 4 dcl 10-23 set ref 1021* 1061 1064* 1064 1076
                                                                                  1086 1091* 1091 1097* 1097 1099 1103*
input_vol_dir_num        14            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 343* 343 707* 737* 745*
input_vol_dir_rec        15            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 344* 344 708* 736 737* 746*
input_vol_lstp          430            based           pointer                  level 4 dcl 10-23 ref 279 280 287 287 287 290 295
                                                                                  297 306 306 307 308 308 374 374 395 396 640 640
                                                                                  641 641 645 645 646 646 671 672 672 673 673 856
                                                                                  856 949 949
input_vol_seg_num        16            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 349* 349 705* 737* 743*
input_vol_seg_rec        17            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 350* 350 706* 736 737* 744*
input_volume_desc       201            based           char(256)                level 4 dcl 10-23 set ref 676 676*
inputvol_iocbp          414            based           pointer                  level 4 dcl 10-23 set ref 146 683* 697* 700* 724*
                                                                                  728* 731* 1024* 1030* 1035* 1043*
io_module               171            based           char(32)                 level 4 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 382
io_module                17            based           char(32)                 level 2 in structure "bvle" dcl 3-39 in procedure
                                                                                  "rldr_input_" set ref 382 384*
ioa_                            000032 constant        entry                    external dcl 104 ref 662
ioa_$rsnnl                      000034 constant        entry                    external dcl 105 ref 307 676 678 971
iox_$attach_name                000074 constant        entry                    external dcl 16-8 ref 683
iox_$close                      000076 constant        entry                    external dcl 16-8 ref 724
iox_$detach_iocb                000100 constant        entry                    external dcl 16-8 ref 700 728
iox_$get_chars                  000102 constant        entry                    external dcl 16-8 ref 1024 1035 1043
iox_$open                       000104 constant        entry                    external dcl 16-8 ref 697
iox_$position                   000106 constant        entry                    external dcl 16-8 ref 1030
jdx                             001220 automatic       fixed bin(17,0)          dcl 928 set ref 930* 931 931*
label                                  based           structure                level 1 dcl 5-18
labelp                          000352 automatic       pointer                  dcl 5-16 in procedure "rldr_input_" set ref 220* 222
                                                                                  222 222
labelp                  506            based           pointer                  array level 3 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 220
last_pvid                 2            based           bit(36)                  level 4 dcl 10-23 set ref 464* 587 591
last_valid_puid           5            based           bit(36)                  array level 4 dcl 10-23 set ref 462* 967*
last_valid_vtoce_ename
                        151            based           char(32)                 level 4 dcl 10-23 set ref 463* 971*
last_vtocx              403            based           fixed bin(17,0)          level 4 dcl 10-23 set ref 465* 591*
length                                                 builtin function         dcl 125 ref 308 911 1024 1024 1043 1043 1061 1064
                                                                                  1066 1097 1099
literal_sw                1(05) 001104 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7*
lock                   2016            based           bit(36)                  level 2 dcl 3-20 set ref 761* 831*
lvname                          000323 automatic       char(32)                 packed unaligned dcl 85 set ref 470* 471* 587* 591*
manual                    0(10)        based           bit(1)                   level 4 packed packed unaligned dcl 10-23 ref 225
                                                                                  639
maxlength                                              builtin function         dcl 125 ref 308
mdc_$find_volname               000026 constant        entry                    external dcl 102 ref 987
min                                                    builtin function         dcl 125 ref 1071
mod                                                    builtin function         dcl 125 ref 188
myname                          000003 constant        varying char(32)         initial dcl 92 set ref 292* 298* 304* 384* 454* 471*
                                                                                  476* 488* 554* 555* 564* 568* 579* 582* 585* 588*
                                                                                  591* 611* 656* 688* 693* 699* 725* 729* 737* 762*
                                                                                  796* 813* 832* 853* 861* 866* 947*
n_vtoce               10025            based           fixed bin(17,0)          level 3 dcl 12-5 ref 487
name                                   parameter       char(32)                 packed unaligned dcl 890 ref 884 903 909 910 911 911
nel                             000301 automatic       fixed bin(21,0)          dcl 80 set ref 182* 184* 419* 420* 435* 436* 447*
                                                                                  448 456* 457 490* 491 516* 530 531* 551 579 787*
                                                                                  788* 805* 806*
nelt                            000302 automatic       fixed bin(21,0)          dcl 80 set ref 179* 184* 187 188 189 420* 436* 530*
                                                                                  531* 551 579 784 788* 806*
new_info                        000125 automatic       bit(1)                   packed unaligned dcl 71 set ref 151* 153 504*
new_volume                      000123 automatic       bit(1)                   packed unaligned dcl 71 set ref 194 197 413* 422 429
                                                                                  432* 439 533 550* 574* 600 785* 791 804* 809
next                                   based           fixed bin(17,0)          level 2 in structure "rldr_skip_list" dcl 17-5
                                                                                  in procedure "rldr_input_" set ref 378 388* 388
                                                                                  389
next                   2030            based           fixed bin(17,0)          level 2 in structure "backup_volume_log" dcl 3-20
                                                                                  in procedure "rldr_input_" ref 241
npvs                    404            based           fixed bin(17,0)          level 4 dcl 10-23 ref 219 479 510 559 648 666 703
                                                                                  734
null                                                   builtin function         dcl 125 ref 146 18-7 18-7 18-7 531 531 683 683 731
                                                                                  1029 1086
num                       0(18) 000112 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 891 set ref 912*
                                                                                  914* 914
num_entries                            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 279* 287 290 297 306 308 641
num_null_vtoce           20            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 355* 355 561
num_pos                         000300 automatic       fixed bin(17,0)          dcl 79 set ref 903* 904 904 909 911 911
num_rejected             21            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 513* 513
old_label                              based           structure                level 1 dcl 6-7
old_labelp                      000354 automatic       pointer                  dcl 6-5 set ref 220* 224
open_time                12            based           fixed bin(71,0)          level 2 in structure "bvle" dcl 3-39 in procedure
                                                                                  "rldr_input_" ref 371 929
open_time              2112            based           fixed bin(71,0)          array level 3 in structure "backup_volume_log"
                                                                                  dcl 3-20 in procedure "rldr_input_" set ref 931
pad_chars                       000343 automatic       fixed bin(17,0)          dcl 171 set ref 188* 189 189
padding                   1(07) 001104 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7*
pages_returned                         parameter       fixed bin(17,0)          dcl 171 set ref 169 179* 187*
pattern1                               based           bit(36)                  level 3 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 424
pattern1                        000002 constant        bit(36)                  initial packed unaligned dcl 8-24 in procedure
                                                                                  "rldr_input_" ref 424 795
pattern2                        000001 constant        bit(36)                  initial packed unaligned dcl 8-25 in procedure
                                                                                  "rldr_input_" ref 424 795
pattern2                  3            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 424
pattern3                        000000 constant        bit(36)                  initial packed unaligned dcl 8-26 in procedure
                                                                                  "rldr_input_" ref 424 795
pattern3                  6            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 424
pattern_match_label             000100 automatic       label variable           dcl 69 set ref 412* 417 599
per_pv                  434            based           structure                array level 2 dcl 10-23
primary_name            273            based           char(32)                 level 3 packed packed unaligned dcl 9-17 ref 463
prompt_after_explanation
                          1(06) 001104 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7*
ptr                                                    builtin function         dcl 125 ref 436 436
ptrs                    414            based           structure                level 3 dcl 10-23
pvid                    472            based           bit(36)                  array level 3 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 481
pvid                     11            based           bit(36)                  level 2 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 464 470 471 481
pvindex                         000275 automatic       fixed bin(17,0)          dcl 79 set ref 157 158 160 174* 181 219* 220 221*
                                                                                  332* 334 479* 481 483 485 488* 510* 512* 515* 762
                                                                                  832
pvname                          000313 automatic       char(32)                 packed unaligned dcl 85 in procedure "rldr_input_"
                                                                                  set ref 470* 471* 587* 591*
pvname                  437            based           char(32)                 array level 3 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" set ref 488* 564* 568*
                                                                                  737* 762* 832*
query_code                3     001104 automatic       fixed bin(35,0)          initial level 2 dcl 18-7 set ref 18-7*
query_info                      001104 automatic       structure                level 1 dcl 18-7 set ref 656 656
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 18-35 ref 383 687
question_iocbp            4     001104 automatic       pointer                  initial level 2 dcl 18-7 set ref 18-7*
read_object                            constant        fixed bin(17,0)          initial dcl 89 ref 173 602
reattach                        001206 automatic       bit(1)                   packed unaligned dcl 840 set ref 847* 855* 868* 871
rec1_len                  2            based           fixed bin(17,0)          level 3 dcl 9-17 ref 435
rec1_type                 1            based           fixed bin(17,0)          level 3 dcl 9-17 ref 441 446 531
rec2_len                  5            based           fixed bin(17,0)          level 3 dcl 9-17 ref 182 447 456 490 516
recordp                         000356 automatic       pointer                  dcl 9-12 set ref 143* 159 180* 182 184 195 196 333*
                                                                                  338 340 342 344 350 352 420* 424 424 424 435 436
                                                                                  436 441 446 447 452 452 456 461 462 463 464 465
                                                                                  468 470 471 471 481 486 490 500 502 503 516 531
                                                                                  531 784 788* 795 795 795 803 803 806 806 849
records                  15(18)        based           bit(9)                   level 3 packed packed unaligned dcl 9-17 ref 342 344
                                                                                  350 352
repeat_time              10     001104 automatic       fixed bin(71,0)          initial level 2 dcl 18-7 set ref 18-7*
restart                   0(11)        based           bit(1)                   level 4 packed packed unaligned dcl 10-23 ref 285
resynch_retry_count             000231 automatic       fixed bin(17,0)          dcl 74 set ref 595* 608* 608 610
resynching                      000122 automatic       bit(1)                   packed unaligned dcl 71 set ref 150* 177* 553 578
                                                                                  781* 798*
resynching_completed            000121 automatic       bit(1)                   packed unaligned dcl 71 set ref 147* 176* 201 468
                                                                                  469* 599 782* 799*
ret_dn                          000162 automatic       char(168)                packed unaligned dcl 962 set ref 971* 973
retry_attach_label              000104 automatic       label variable           dcl 69 set ref 636* 694 950
rets                            000232 automatic       varying char(79)         dcl 75 set ref 305* 307* 307 308 312 312 313* 316
                                                                                  316 316
rets_len                        000257 automatic       fixed bin(21,0)          dcl 76 set ref 307* 308
return_buffer_ptr                      parameter       pointer                  dcl 999 ref 993 1029 1035 1035 1053 1086 1086
return_string                          based           char                     packed unaligned dcl 1008 set ref 1053 1086*
ring_1                          000126 automatic       bit(1)                   packed unaligned dcl 71 set ref 680* 681* 682 684
rldr_control                           based           structure                level 1 dcl 12-5
rldr_data_                             based           structure                level 1 dcl 10-23
rldr_data_common                000360 automatic       structure                level 1 dcl 10-23
rldr_data_perpv                 001014 automatic       structure                level 1 dcl 10-23
rldr_datap                             parameter       pointer                  dcl 10-23 set ref 131 143 146 158 169 180 181 184
                                                                                  189 209 216 219 220 221 225 279 280 285 286 287
                                                                                  287 287 290 292* 295 297 298* 303 304* 306 306 307
                                                                                  308 308 312* 316* 326 333 334 371 374 374 382 395
                                                                                  396 454* 462 463 464 465 471* 476* 479 481 483 485
                                                                                  488* 488 510 512 554* 555* 559 560 563* 564* 564
                                                                                  567* 568* 568 579* 579 582* 582 585* 585 587 588*
                                                                                  591* 591 591 611* 611 639 640 640 641 641 645 645
                                                                                  646 646 648 649 666 667 671 672 672 673 673 676
                                                                                  676 683 693* 697 699* 700 703 704 724 725* 728
                                                                                  729* 731 733* 734 735 737* 737 762* 762 796* 796
                                                                                  813* 813 832* 832 848 850 853* 856 856 858 859
                                                                                  861* 865 866* 949 949 965 967 971 986 1020 1021
                                                                                  1024 1030 1035 1043 1052 1053 1053 1061 1061 1064
                                                                                  1064 1066 1066 1070 1071 1076 1076 1076 1086 1086
                                                                                  1091 1091 1093 1093 1096 1097 1097 1099 1099 1099
                                                                                  1099 1099 1103
rldr_input_volume_list                 based           structure                level 1 dcl 1-3
rldr_report_$error_output       000052 constant        entry                    external dcl 112 ref 292 298 454 471 476 488 554 555
                                                                                  564 568 579 582 585 588 591 611 693 699 725 729
                                                                                  762 796 813 832 853 866
rldr_report_$online_output      000054 constant        entry                    external dcl 113 ref 304 312 316 737 861
rldr_skip_list                         based           structure                level 1 dcl 17-5
rldr_volume_map_$update         000050 constant        entry                    external dcl 111 ref 567
rldr_vtoc_buffer_$write         000012 constant        entry                    external dcl 96 ref 733
rldr_vtoc_header_$update        000046 constant        entry                    external dcl 110 ref 563
rpv                       0(02)        based           bit(1)                   level 4 packed packed unaligned dcl 10-23 ref 858
rpv_disk_type            13            based           fixed bin(17,0)          level 2 in structure "backup_info" dcl 2-7
                                                                                  in procedure "rldr_input_" set ref 859
rpv_disk_type           405            based           fixed bin(17,0)          level 4 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 859
rpv_pvid                  3            based           bit(36)                  level 4 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 865
rpv_pvid                 11            based           bit(36)                  level 2 in structure "backup_info" dcl 2-7
                                                                                  in procedure "rldr_input_" set ref 865
rtrim                                                  builtin function         dcl 125 ref 308 312 312 316 316
save                                   based           bit(1)                   level 4 packed packed unaligned dcl 10-23 ref 371
search                                                 builtin function         dcl 125 ref 903
seg_fault_error                 000000 stack reference condition                dcl 123 ref 966 972
seg_num                  40            based           fixed bin(17,0)          level 2 in structure "bvle" packed packed unaligned
                                                                                  dcl 3-39 in procedure "rldr_input_" ref 370
seg_num                  12            based           fixed bin(17,0)          level 2 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_" set ref 348* 348
seg_rec                  13            based           fixed bin(17,0)          level 2 dcl 12-5 set ref 352* 352 561
set_lock_$lock                  000042 constant        entry                    external dcl 108 ref 761
set_lock_$unlock                000044 constant        entry                    external dcl 109 ref 831
size                                                   builtin function         dcl 125 ref 419 435 436 436 787 803 803 803 806 806
skip                    420            based           pointer                  level 4 in structure "rldr_data_" dcl 10-23
                                                                                  in procedure "rldr_input_" ref 216
skip                            001102 automatic       pointer                  dcl 17-3 in procedure "rldr_input_" set ref 216* 378
                                                                                  379 388 388 389 389
skip_next_header_check                 parameter       bit(1)                   packed unaligned dcl 71 set ref 131 169 178* 201*
                                                                                  415 416*
sortx                           000277 automatic       fixed bin(17,0)          dcl 79 set ref 373* 374 374* 378* 379*
status_code               2     001104 automatic       fixed bin(35,0)          initial level 2 dcl 18-7 set ref 18-7*
stranger                  0(12)        based           bit(1)                   level 4 packed packed unaligned dcl 10-23 ref 965
                                                                                  986
string                                 based           bit                      packed unaligned dcl 84 set ref 803* 803
substr                                                 builtin function         dcl 125 set ref 189 803 909* 909 910 911 1053* 1061
                                                                                  1076 1086 1099* 1099
suppress_name_sw          1(01) 001104 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7*
suppress_spacing          1(04) 001104 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7*
switches                  1     001104 automatic       structure                level 2 dcl 18-7
tape_check1                     000104 automatic       char(8)                  packed unaligned dcl 1011 set ref 1024 1024 1024
                                                                                  1024 1048 1061* 1061 1064 1066 1075 1076
tape_check2                     000106 automatic       char(8)                  packed unaligned dcl 1011 set ref 1043 1043 1043
                                                                                  1043 1048 1063* 1075 1097 1099 1099
temp                            001216 automatic       fixed bin(71,0)          dcl 927 set ref 931* 934
time_dumped               7            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 500 502
time_dumped           14026            based           fixed bin(71,0)          array level 3 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_" set ref 500 501 502*
time_unmounted          612            based           fixed bin(71,0)          level 2 in structure "label" dcl 5-18 in procedure
                                                                                  "rldr_input_" ref 222
time_unmounted          604            based           fixed bin(71,0)          level 2 in structure "old_label" dcl 6-7
                                                                                  in procedure "rldr_input_" ref 224
time_unmounted                  000266 automatic       fixed bin(71,0)          dcl 77 in procedure "rldr_input_" set ref 222* 224*
                                                                                  371
timer_manager_$alarm_call       000022 constant        entry                    external dcl 100 ref 682
timer_manager_$reset_alarm_call 000024 constant        entry                    external dcl 101 ref 684
uid                   14024            based           bit(36)                  array level 3 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_" set ref 195* 501 503*
uid                      14            based           bit(36)                  level 3 in structure "backup_volume_record" packed
                                                                                  packed unaligned dcl 9-17 in procedure
                                                                                  "rldr_input_" ref 338 461 468 503
uid_path                253            based           bit(36)                  array level 3 packed packed unaligned dcl 9-17 ref
                                                                                  462
unspec                                                 builtin function         dcl 125 set ref 189* 916
version                         001104 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 18-7
                                                                                  in procedure "rldr_input_" set ref 383* 687*
version                  10            based           fixed bin(17,0)          level 2 in structure "backup_info" dcl 2-7
                                                                                  in procedure "rldr_input_" set ref 850
version                  10            based           fixed bin(17,0)          level 2 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 184 452 452 531
vlx                             000274 automatic       fixed bin(17,0)          dcl 79 set ref 218* 279 373 394* 394 395 396
vol_map                                based           structure                level 1 dcl 13-5
volid                           000112 automatic       structure                level 1 dcl 891 in procedure "get_volid_" set ref
                                                                                  916
volid                 14030            based           bit(36)                  array level 3 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_" set ref 196*
volid                    16            based           bit(36)                  level 2 in structure "bvle" dcl 3-39 in procedure
                                                                                  "rldr_input_" ref 374 396
volid                           000272 automatic       bit(36)                  packed unaligned dcl 78 in procedure "rldr_input_"
                                                                                  set ref 645* 651 660* 669 673
volid                    12            based           bit(36)                  array level 3 in structure "rldr_input_volume_list"
                                                                                  dcl 1-3 in procedure "rldr_input_" set ref 374
                                                                                  396* 645 673*
volmap_version          604            based           fixed bin(17,0)          level 2 dcl 5-18 ref 222 222
volname                   2            based           char(32)                 array level 3 in structure "rldr_input_volume_list"
                                                                                  dcl 1-3 in procedure "rldr_input_" set ref 287 307
                                                                                  308 374 395* 646 672*
volname                   1            based           char(32)                 array level 3 in structure "rldr_skip_list" dcl 17-5
                                                                                  in procedure "rldr_input_" set ref 379 389*
volname                         000333 automatic       char(32)                 packed unaligned dcl 85 in procedure "rldr_input_"
                                                                                  set ref 454* 646* 650 657* 658 659 660* 662* 668
                                                                                  672 676* 678* 693* 699* 725* 729*
volname                   2            based           char(32)                 level 2 in structure "bvle" dcl 3-39 in procedure
                                                                                  "rldr_input_" set ref 374 379 384* 389 395
volume_record_bp        422            based           pointer                  level 4 dcl 10-23 ref 143 180 333
vtoc_header           10024            based           structure                level 2 in structure "rldr_control" dcl 12-5
                                                                                  in procedure "rldr_input_"
vtoc_header                            based           structure                level 1 dcl 14-5 in procedure "rldr_input_"
vtoce                    13            based           structure                level 2 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" ref 159
vtoce                                  based           structure                level 1 dcl 11-7 in procedure "rldr_input_" set ref
                                                                                  159*
vtoce_type                             constant        fixed bin(17,0)          initial dcl 8-15 ref 446 531
vtocep                                 parameter       pointer                  dcl 11-5 ref 131 159
vtocx                                  parameter       fixed bin(17,0)          dcl 79 in procedure "rldr_input_" set ref 131 140*
                                                                                  486* 487 500 501 501 502 503
vtocx                    12            based           fixed bin(17,0)          level 2 in structure "backup_volume_record" dcl 9-17
                                                                                  in procedure "rldr_input_" set ref 195 196 465
                                                                                  471* 486
warning_printed                 000010 internal static bit(1)                   initial packed unaligned dcl 87 set ref 859 860*
word                                   based           bit(36)                  array packed unaligned dcl 82 set ref 795 795 795
                                                                                  806 806
words_skipped                   000130 automatic       fixed bin(35,0)          dcl 72 set ref 555* 793* 796* 811* 811 812
yes_or_no_sw              1     001104 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 18-7 set
                                                                                  ref 18-7* 655* 665*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 19-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 19-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 19-70
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 19-79
Direct_input                           internal static fixed bin(17,0)          initial dcl 15-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 15-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 15-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 15-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 15-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 15-15
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 5-92
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 19-92
Sequential_input                       internal static fixed bin(17,0)          initial dcl 15-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 15-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 15-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 15-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 15-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 15-15
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 19-89
backup_version_1                       internal static fixed bin(17,0)          initial dcl 7-7
backup_volume_log_version_1            internal static fixed bin(17,0)          initial dcl 3-16
backup_volume_log_version_2            internal static fixed bin(17,0)          initial dcl 3-17
backup_volume_log_version_3            internal static fixed bin(17,0)          initial dcl 3-18
bpvip                                  automatic       pointer                  dcl 4-3
contents_type                          internal static fixed bin(17,0)          initial dcl 8-21
dir_type                               internal static fixed bin(17,0)          initial dcl 8-16
iox_$attach_loud                000000 constant        entry                    external dcl 16-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 16-8
iox_$close_file                 000000 constant        entry                    external dcl 16-8
iox_$control                    000000 constant        entry                    external dcl 16-8
iox_$delete_record              000000 constant        entry                    external dcl 16-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 16-8
iox_$detach                     000000 constant        entry                    external dcl 16-8
iox_$err_no_operation           000000 constant        entry                    external dcl 16-8
iox_$err_not_attached           000000 constant        entry                    external dcl 16-8
iox_$err_not_closed             000000 constant        entry                    external dcl 16-8
iox_$err_not_open               000000 constant        entry                    external dcl 16-8
iox_$error_output                      external static pointer                  dcl 16-41
iox_$find_iocb                  000000 constant        entry                    external dcl 16-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 16-8
iox_$get_line                   000000 constant        entry                    external dcl 16-8
iox_$look_iocb                  000000 constant        entry                    external dcl 16-8
iox_$modes                      000000 constant        entry                    external dcl 16-8
iox_$move_attach                000000 constant        entry                    external dcl 16-8
iox_$open_file                  000000 constant        entry                    external dcl 16-8
iox_$propagate                  000000 constant        entry                    external dcl 16-8
iox_$put_chars                  000000 constant        entry                    external dcl 16-8
iox_$read_key                   000000 constant        entry                    external dcl 16-8
iox_$read_length                000000 constant        entry                    external dcl 16-8
iox_$read_record                000000 constant        entry                    external dcl 16-8
iox_$rewrite_record             000000 constant        entry                    external dcl 16-8
iox_$seek_key                   000000 constant        entry                    external dcl 16-8
iox_$user_input                        external static pointer                  dcl 16-41
iox_$user_io                           external static pointer                  dcl 16-41
iox_$user_output                       external static pointer                  dcl 16-41
iox_$write_record               000000 constant        entry                    external dcl 16-8
iox_modes                              internal static char(24)                 initial array dcl 15-6
null_type                              internal static fixed bin(17,0)          initial dcl 8-18
prev_output_log_type                   internal static fixed bin(17,0)          initial dcl 8-20
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 18-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 18-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 18-36
rldr_data_max_pvs                      automatic       fixed bin(17,0)          dcl 10-23
rldr_data_nulled_pv                    internal static structure                level 1 dcl 10-23
seg_type                               internal static fixed bin(17,0)          initial dcl 8-17
seg_vtoce                              based           structure                level 1 dcl 11-92
short_iox_modes                        internal static char(4)                  initial array dcl 15-12
vol_mapp                               automatic       pointer                  dcl 13-3
volume_log_type                        internal static fixed bin(17,0)          initial dcl 8-19
vtoc_headerp                           automatic       pointer                  dcl 14-3
vtoce_parts                            based           bit(2304)                array dcl 11-90

NAMES DECLARED BY EXPLICIT CONTEXT.
attach                          004447 constant        entry                    internal dcl 627 ref 146 573 873
attach_timer                    006765 constant        entry                    internal dcl 943 ref 682 682 684 684
bad_record                      002735 constant        label                    dcl 454
bad_volid                       006640 constant        label                    dcl 905 ref 913
check_input_error               003462 constant        entry                    internal dcl 540 ref 192 421 428 438 532 789 808 816
collect_stats                   002253 constant        entry                    external dcl 326
convert_puid_                   007050 constant        entry                    internal dcl 956 ref 471 471 476 476 588 588 591 591
detach                          005422 constant        entry                    internal dcl 719 ref 557 872
detach_and_continue             003576 constant        label                    dcl 557 ref 614
exit_pvid_check                 003361 constant        label                    dcl 510 ref 483 507
find_volname                    007247 constant        entry                    internal dcl 978 ref 470 587
get_object                      001050 constant        entry                    external dcl 131
get_object_ret                  001147 constant        label                    dcl 162 ref 643
get_volid_                      006614 constant        entry                    internal dcl 884 ref 660
init_volume_list                001334 constant        entry                    external dcl 209
lock_volume_log                 005721 constant        entry                    internal dcl 757 ref 226
log_volume_name                 002337 constant        entry                    internal dcl 363 ref 245 250 256 260 267 273
no_more                         004473 constant        label                    dcl 642 ref 659
open_time                       006727 constant        entry                    internal dcl 923 ref 251 261 268 272
pattern_match                   002645 constant        label                    dcl 432 ref 412
read                            007324 constant        entry                    internal dcl 993 ref 184 420 436 531 788 806
read_object                     001156 constant        entry                    external dcl 169
read_volume_record              002551 constant        entry                    internal dcl 405 ref 154
record_info                     006375 constant        entry                    internal dcl 839 ref 442
request                         004544 constant        label                    dcl 656 ref 658 663
resynch_input_volume            006006 constant        entry                    internal dcl 774 ref 596
ret_unk                         007142 constant        label                    dcl 969 ref 965 966
retry                           005050 constant        label                    dcl 682 ref 691
retry_attach                    004454 constant        label                    dcl 636 ref 636 701
rldr_input_                     001033 constant        entry                    external dcl 61
search_loop                     001114 constant        label                    dcl 147 ref 533 600 874
skip_chars                      003412 constant        entry                    internal dcl 525 ref 448 457 491 517
test                            006073 constant        label                    dcl 795 ref 819
unlock_volume_log               006314 constant        entry                    internal dcl 827 ref 277

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10666       10776   10163       10676
Length     11666   10163       110         654     502           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rldr_input_                        1043 external procedure  is an external procedure.  
log_volume_name                         internal procedure  shares stack frame of external procedure rldr_input_.  
read_volume_record                      internal procedure  shares stack frame of external procedure rldr_input_.  
skip_chars                              internal procedure  shares stack frame of external procedure rldr_input_.  
check_input_error                   310 internal procedure  calls itself recursively.  
attach                              182 internal procedure  is called by several nonquick procedures.  
detach                              174 internal procedure  is called by several nonquick procedures.  
lock_volume_log                         internal procedure  shares stack frame of external procedure rldr_input_.  
resynch_input_volume                    internal procedure  shares stack frame of internal procedure check_input_error.  
unlock_volume_log                       internal procedure  shares stack frame of external procedure rldr_input_.  
record_info                             internal procedure  shares stack frame of external procedure rldr_input_.  
get_volid_                              internal procedure  shares stack frame of internal procedure attach.  
open_time                               internal procedure  shares stack frame of external procedure rldr_input_.  
attach_timer                        110 internal procedure  is assigned to an entry variable.  
convert_puid_                       220 internal procedure  enables or reverts conditions.  
on unit on line 966                  64 on unit               
find_volname                         82 internal procedure  is called by several nonquick procedures.  
read                                 88 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 warning_printed             rldr_input_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
attach                   000100 i                           attach
                         000112 volid                       get_volid_
check_input_error        000100 i                           check_input_error
convert_puid_            000100 dn                          convert_puid_
                         000152 en                          convert_puid_
                         000162 ret_dn                      convert_puid_
                         000234 ec                          convert_puid_
detach                   000100 i                           detach
read                     000100 Nassign_chars               read
                         000101 Nread_chars                 read
                         000102 end_of_record               read
                         000104 tape_check1                 read
                         000106 tape_check2                 read
rldr_input_              000100 pattern_match_label         rldr_input_
                         000104 retry_attach_label          rldr_input_
                         000110 avolname                    rldr_input_
                         000121 resynching_completed        rldr_input_
                         000122 resynching                  rldr_input_
                         000123 new_volume                  rldr_input_
                         000124 YES                         rldr_input_
                         000125 new_info                    rldr_input_
                         000126 ring_1                      rldr_input_
                         000127 ignore                      rldr_input_
                         000130 words_skipped               rldr_input_
                         000131 att_desc                    rldr_input_
                         000231 resynch_retry_count         rldr_input_
                         000232 rets                        rldr_input_
                         000257 rets_len                    rldr_input_
                         000260 incr_open_time              rldr_input_
                         000262 cons_open_time              rldr_input_
                         000264 comp_open_time              rldr_input_
                         000266 time_unmounted              rldr_input_
                         000270 comp_cycle_uid              rldr_input_
                         000271 cons_cycle_uid              rldr_input_
                         000272 volid                       rldr_input_
                         000273 entry                       rldr_input_
                         000274 vlx                         rldr_input_
                         000275 pvindex                     rldr_input_
                         000276 idx                         rldr_input_
                         000277 sortx                       rldr_input_
                         000300 num_pos                     rldr_input_
                         000301 nel                         rldr_input_
                         000302 nelt                        rldr_input_
                         000303 char_num                    rldr_input_
                         000313 pvname                      rldr_input_
                         000323 lvname                      rldr_input_
                         000333 volname                     rldr_input_
                         000343 pad_chars                   rldr_input_
                         000344 infop                       rldr_input_
                         000346 bvlp                        rldr_input_
                         000350 bvlep                       rldr_input_
                         000352 labelp                      rldr_input_
                         000354 old_labelp                  rldr_input_
                         000356 recordp                     rldr_input_
                         000360 rldr_data_common            rldr_input_
                         001014 rldr_data_perpv             rldr_input_
                         001100 controlp                    rldr_input_
                         001102 skip                        rldr_input_
                         001104 query_info                  rldr_input_
                         001206 reattach                    record_info
                         001216 temp                        open_time
                         001220 jdx                         open_time

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          move_label_var      make_label_var
tra_ext_1           tra_ext_2           mdfx1               enable_op           shorten_stack       ext_entry
int_entry           set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                command_query_$yes_no         cv_dec_check_                 get_group_id_
hc_backup_$decode_uidpath     hcs_$level_get                ioa_                          ioa_$rsnnl
iox_$attach_name              iox_$close                    iox_$detach_iocb              iox_$get_chars
iox_$open                     iox_$position                 mdc_$find_volname             rldr_report_$error_output
rldr_report_$online_output    rldr_volume_map_$update       rldr_vtoc_buffer_$write       rldr_vtoc_header_$update
set_lock_$lock                set_lock_$unlock              timer_manager_$alarm_call
timer_manager_$reset_alarm_call

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_volid        error_table_$data_loss
error_table_$device_end       error_table_$end_of_info      error_table_$resource_unavailable
error_table_$root


CONSTANTS
007733  aa  000 000 000 000	    
007734  aa  000 000 000 000	    
007735  aa  000 000 000 000	    
007736  aa  000 000 000 000	    
007737  aa  000 000 000 000	    
007740  aa  000 000 000 000	    
007741  aa  000 000 000 000	    
007742  aa  000 000 000 000	    
007743  aa  000 000 000 000	    
007744  aa  000 000 000 000	    
007745  aa  000 000 000 000	    
007746  aa  000 000 000 000	    
007747  aa  777 777 777 777	
007750  aa  777 777 777 777	
007751  aa  777 777 000 000	  
007752  aa  000 000 000 000	    
007753  aa  000 000 000 000	    
007754  aa  000 000 000 000	    
007755  aa  000 000 000 000	    
007756  aa  000 000 000 000	    
007757  aa  000 000 000 000	    
007760  aa  000 000 000 000	    
007761  aa  000 000 000 000	    
007762  aa  000 000 000 000	    
007763  aa  000 000 000 000	    
007764  aa  000 000 000 000	    
007765  aa  000 000 000 000	    
007766  aa  000 000 000 000	    
007767  aa  000 000 000 000	    
007770  aa  000 000 000 000	    
007771  aa  000 000 000 000	    
007772  aa  000 000 000 000	    
007773  aa  000 000 000 000	    
007774  aa  000 000 000 000	    
007775  aa  000 000 000 000	    
007776  aa  000 000 000 000	    
007777  aa  000 000 000 000	    
010000  aa  000 000 000 000	    
010001  aa  000 000 000 000	    
010002  aa  000 000 000 000	    
010003  aa  000 000 000 000	    
010004  aa  000 000 000 000	    
010005  aa  000 000 000 000	    
010006  aa  000 000 000 000	    
010007  aa  000 000 000 000	    
010010  aa  000 000 000 000	    
010011  aa  000 000 000 000	    
010012  aa  000 000 000 000	    
010013  aa  000 000 000 000	    
010014  aa  000 000 000 000	    
010015  aa  000 000 000 000	    
010016  aa  000 000 000 000	    
010017  aa  000 000 000 000	    
010020  aa  000 000 000 000	    
010021  aa  000 000 000 000	    
010022  aa  000 000 000 000	    
010023  aa  000 000 000 000	    
010024  aa  000 000 000 000	    
010025  aa  000 000 000 000	    
010026  aa  000 000 000 000	    
010027  aa  000 000 000 000	    
010030  aa  000 000 000 000	    
010031  aa  000 000 000 000	    
010032  aa  000 000 000 000	    
010033  aa  000 000 000 000	    
010034  aa  000 000 000 000	    
010035  aa  000 000 000 000	    
010036  aa  000 000 000 000	    
010037  aa  000 000 000 000	    
010040  aa  000 000 000 000	    
010041  aa  000 000 000 000	    
010042  aa  000 000 000 000	    
010043  aa  000 000 000 000	    
010044  aa  000 000 000 000	    
010045  aa  000 000 000 000	    
010046  aa  000 000 000 000	    
010047  aa  000 000 000 000	    
010050  aa  000 000 000 000	    
010051  aa  000 000 000 000	    
010052  aa  000 000 000 000	    
010053  aa  000 000 000 000	    
010054  aa  000 000 000 000	    
010055  aa  000 000 000 000	    
010056  aa  000 000 000 000	    
010057  aa  000 000 000 000	    
010060  aa  000 000 000 000	    
010061  aa  000 000 000 000	    
010062  aa  000 000 000 000	    
010063  aa  000 000 000 000	    
010064  aa  000 000 000 000	    
010065  aa  000 000 000 000	    
010066  aa  000 000 000 000	    
010067  aa  000 000 000 000	    
010070  aa  000 000 000 000	    
010071  aa  000 000 000 000	    
010072  aa  000 000 000 000	    
010073  aa  000 000 000 000	    
010074  aa  000 000 000 000	    
010075  aa  000 000 000 000	    
010076  aa  000 000 000 000	    
010077  aa  000 000 000 000	    
010100  aa  000 000 000 000	    
010101  aa  000 000 000 000	    
010102  aa  000 000 000 000	    
010103  aa  000 000 000 000	    
010104  aa  000 000 000 000	    
010105  aa  000 000 000 000	    
010106  aa  000 000 000 000	    
010107  aa  000 000 000 000	    
010110  aa  000 000 000 000	    
010111  aa  000 000 000 000	    
010112  aa  000 000 000 000	    
010113  aa  000 000 000 000	    
010114  aa  000 000 000 000	    
010115  aa  000 000 000 000	    
010116  aa  000 000 000 000	    
010117  aa  000 000 000 000	    
010120  aa  000 000 000 000	    
010121  aa  000 000 000 000	    
010122  aa  000 000 000 000	    
010123  aa  000 000 000 000	    
010124  aa  000 000 000 000	    
010125  aa  000 000 000 000	    
010126  aa  000 000 000 000	    
010127  aa  000 000 000 000	    
010130  aa  000 000 000 000	    
010131  aa  000 000 000 000	    
010132  aa  000 000 000 000	    

010134  aa     000002000000
010135  aa     000000000000
010136  aa     600000000041
010137  aa     000264000000

010140  aa     000002000000
010141  aa     000000000000
010142  aa     600000000041
010143  aa     000262000000

010144  aa     000002000000
010145  aa     000000000000
010146  aa     600000000041
010147  aa     000260000000

010150  aa     773777777777

010151  aa     767777777777

010152  aa     757777777777

010153  aa     637777777777

010154  aa     577777777777

010155  aa     377777777777

010156  aa     000000010000

000000  aa     107463422532

000001  aa     512556146073

000002  aa     670314355245

000003  aa     000000000013
000004  aa  162 154 144 162	rldr
000005  aa  137 151 156 160	_inp
000006  aa  165 164 137 040	ut_ 
000007  aa  040 040 040 040	    
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    
000012  aa  040 040 040 040	    
000013  aa  040 040 040 040	    


010157  aa  076 000 000 000	>

000014  aa     524000000024

000015  aa     524000000102

000016  aa     524000000054

000017  aa     524000000053

000020  aa     524000000052

000021  aa     524000000074

000022  aa     524000000036

000023  aa     524000000037

000024  aa     524000000171

000025  aa     524000000014

000026  aa     524000000025

000027  aa     526000000400

000030  aa     524000000400

000031  aa     524000000034

010160  aa  056 000 000 000	.

000032  aa     524000000030

000033  aa     524000000111

000034  aa     524000000141

000035  aa     524000000056

000036  aa     524000000033

000037  aa     524000000042

000040  aa     524000000043

000041  aa     524000000020

000042  aa     524000000055

000043  aa     524000000041

000044  aa     514000000001

000045  aa     524000000250

000046  aa     524000000123

000047  aa     524000000044

000050  aa     524000000040

000051  aa     524000000176

000052  aa     524000000002

000053  aa     524000000000

010161  aa  040 000 000 000	 

000054  aa     404000000025

000055  aa     530000000117

000056  aa     524000000007

000057  aa     524000000046

000060  aa     524000000051

000061  aa     404000000005

000062  aa     524000000035

000063  aa     530000000040

010162  aa     777777777777

000064  aa     464000000000

000065  aa     526000000250

000066  aa     410000000107

000067  aa     516000000044

000070  aa     526000000040

000071  aa     000000000001

000072  aa     404000000021

000073  aa     404000000043

000074  aa     000000000003

000075  aa     516000000001

000076  aa  040 040 040 040	    
000077  aa  040 040 040 040	    

000100  aa  125 116 113 116	UNKN
000101  aa  117 127 116 000	OWN

000102  aa     000000000000
000103  aa     000000000264

000104  aa  136 050 136 141	^(^a
000105  aa  054 136 051 000	,^)

000106  aa     000000000000
000107  aa     000000000000

000110  aa     077777000043
000111  aa     000001000000

000112  aa  060 061 062 063	0123
000113  aa  064 065 066 067	4567
000114  aa  070 071 000 000	89

000115  aa  151 156 160 165	inpu
000116  aa  164 137 166 157	t_vo
000117  aa  154 165 155 145	lume

000120  aa     514100000044
000121  aa     000000000000
000122  aa     000000000017
000123  aa     000000000001

000124  aa  136 144 040 167	^d w
000125  aa  157 162 144 163	ords
000126  aa  040 163 153 151	 ski
000127  aa  160 160 145 144	pped

000130  aa  163 145 147 137	seg_
000131  aa  146 141 165 154	faul
000132  aa  164 137 145 162	t_er
000133  aa  162 157 162 000	ror

000134  aa  136 141 136 133	^a^[
000135  aa  076 136 135 136	>^]^
000136  aa  133 136 141 076	[^a>
000137  aa  136 073 136 163	^;^s
000140  aa  136 135 136 141	^]^a

000141  aa  111 156 151 164	Init
000142  aa  151 141 154 151	iali
000143  aa  172 145 162 056	zer.
000144  aa  123 171 163 104	SysD
000145  aa  141 145 155 157	aemo
000146  aa  156 056 172 000	n.z

000147  aa  164 141 160 145	tape
000150  aa  137 155 165 154	_mul
000151  aa  164 137 040 136	t_ ^
000152  aa  141 040 055 163	a -s
000153  aa  171 163 164 145	yste
000154  aa  155 000 000 000	m

000155  aa  124 171 160 145	Type
000156  aa  040 151 156 160	 inp
000157  aa  165 164 040 166	ut v
000160  aa  157 154 165 155	olum
000161  aa  145 040 156 141	e na
000162  aa  155 145 072 040	me: 

000163  aa  151 156 166 141	inva
000164  aa  154 151 144 040	lid 
000165  aa  166 157 154 165	volu
000166  aa  155 145 040 151	me i
000167  aa  144 145 156 164	dent
000170  aa  151 146 151 145	ifie
000171  aa  162 040 136 141	r ^a

000172  aa  122 145 141 144	Read
000173  aa  040 144 151 144	 did
000174  aa  040 156 157 164	 not
000175  aa  040 143 157 155	 com
000176  aa  160 154 145 164	plet
000177  aa  145 040 157 156	e on
000200  aa  040 136 141 000	 ^a

000201  aa  127 141 162 156	Warn
000202  aa  151 156 147 040	ing 
000203  aa  055 040 156 145	- ne
000204  aa  167 040 144 151	w di
000205  aa  163 153 040 164	sk t
000206  aa  171 160 145 040	ype 
000207  aa  146 157 162 040	for 
000210  aa  162 160 166 000	rpv

000211  aa  125 156 141 142	Unab
000212  aa  154 145 040 164	le t
000213  aa  157 040 144 145	o de
000214  aa  164 141 143 150	tach
000215  aa  040 144 165 155	 dum
000216  aa  160 040 166 157	p vo
000217  aa  154 165 155 145	lume
000220  aa  040 136 141 000	 ^a

000221  aa  125 156 141 142	Unab
000222  aa  154 145 040 164	le t
000223  aa  157 040 143 154	o cl
000224  aa  157 163 145 040	ose 
000225  aa  144 165 155 160	dump
000226  aa  040 166 157 154	 vol
000227  aa  165 155 145 040	ume 
000230  aa  136 141 000 000	^a

000231  aa  105 162 162 157	Erro
000232  aa  162 040 157 156	r on
000233  aa  040 157 160 145	 ope
000234  aa  156 151 156 147	ning
000235  aa  040 144 165 155	 dum
000236  aa  160 040 166 157	p vo
000237  aa  154 165 155 145	lume
000240  aa  040 136 141 000	 ^a

000241  aa  125 156 141 142	Unab
000242  aa  154 145 040 164	le t
000243  aa  157 040 141 164	o at
000244  aa  164 141 143 150	tach
000245  aa  040 144 165 155	 dum
000246  aa  160 040 166 157	p vo
000247  aa  154 165 155 145	lume
000250  aa  040 136 141 000	 ^a

000251  aa  111 156 166 141	Inva
000252  aa  154 151 144 040	lid 
000253  aa  144 165 155 160	dump
000254  aa  040 162 145 143	 rec
000255  aa  157 162 144 040	ord 
000256  aa  150 145 141 144	head
000257  aa  145 162 040 157	er o
000260  aa  156 040 136 141	n ^a

000261  aa  105 162 162 157	Erro
000262  aa  162 040 154 157	r lo
000263  aa  143 141 164 151	cati
000264  aa  156 147 040 162	ng r
000265  aa  145 163 164 141	esta
000266  aa  162 164 040 166	rt v
000267  aa  157 154 165 155	olum
000270  aa  145 000 000 000	e

000271  aa  105 162 162 157	Erro
000272  aa  162 040 165 156	r un
000273  aa  154 157 143 153	lock
000274  aa  151 156 147 040	ing 
000275  aa  166 157 154 165	volu
000276  aa  155 145 040 154	me l
000277  aa  157 147 040 136	og ^
000300  aa  141 056 166 157	a.vo
000301  aa  154 157 147 000	log

000302  aa  105 162 162 157	Erro
000303  aa  162 040 154 157	r lo
000304  aa  143 153 151 156	ckin
000305  aa  147 040 166 157	g vo
000306  aa  154 165 155 145	lume
000307  aa  040 154 157 147	 log
000310  aa  040 136 141 056	 ^a.
000311  aa  166 157 154 157	volo
000312  aa  147 000 000 000	g

000313  aa  111 057 117 040	I/O 
000314  aa  145 162 162 157	erro
000315  aa  162 040 162 145	r re
000316  aa  141 144 151 156	adin
000317  aa  147 040 151 156	g in
000320  aa  160 165 164 040	put 
000321  aa  166 157 154 165	volu
000322  aa  155 145 040 136	me ^
000323  aa  141 000 000 000	a

000324  aa  105 162 162 157	Erro
000325  aa  162 040 165 160	r up
000326  aa  144 141 164 151	dati
000327  aa  156 147 040 166	ng v
000330  aa  157 154 165 155	olum
000331  aa  145 040 155 141	e ma
000332  aa  160 040 157 156	p on
000333  aa  040 160 166 040	 pv 
000334  aa  136 141 000 000	^a

000335  aa  105 162 162 157	Erro
000336  aa  162 040 165 160	r up
000337  aa  144 141 164 151	dati
000340  aa  156 147 040 166	ng v
000341  aa  164 157 143 040	toc 
000342  aa  150 145 141 144	head
000343  aa  145 162 040 157	er o
000344  aa  156 040 160 166	n pv
000345  aa  040 136 141 000	 ^a

000346  aa  126 124 117 103	VTOC
000347  aa  105 040 151 156	E in
000350  aa  144 145 170 040	dex 
000351  aa  157 165 164 040	out 
000352  aa  157 146 040 162	of r
000353  aa  141 156 147 145	ange
000354  aa  040 157 156 040	 on 
000355  aa  160 166 040 136	pv ^
000356  aa  141 000 000 000	a

000357  aa  111 156 166 141	Inva
000360  aa  154 151 144 040	lid 
000361  aa  166 157 154 165	volu
000362  aa  155 145 040 162	me r
000363  aa  145 143 157 162	ecor
000364  aa  144 040 157 156	d on
000365  aa  040 144 165 155	 dum
000366  aa  160 040 166 157	p vo
000367  aa  154 165 155 145	lume

000370  aa  120 154 145 141	Plea
000371  aa  163 145 040 147	se g
000372  aa  145 164 040 164	et t
000373  aa  150 145 040 146	he f
000374  aa  157 154 154 157	ollo
000375  aa  167 151 156 147	wing
000376  aa  040 151 156 160	 inp
000377  aa  165 164 040 166	ut v
000400  aa  157 154 165 155	olum
000401  aa  145 163 000 000	es

000402  aa  101 164 164 145	Atte
000403  aa  155 160 164 040	mpt 
000404  aa  164 157 040 165	to u
000405  aa  163 145 040 156	se n
000406  aa  157 156 040 154	on l
000407  aa  157 143 141 154	ocal
000410  aa  040 163 151 164	 sit
000411  aa  145 040 144 165	e du
000412  aa  155 160 040 166	mp v
000413  aa  157 154 165 155	olum
000414  aa  145 040 136 141	e ^a

000415  aa  101 164 164 145	Atte
000416  aa  155 160 164 040	mpt 
000417  aa  164 157 040 155	to m
000420  aa  157 165 156 164	ount
000421  aa  040 165 156 162	 unr
000422  aa  145 161 165 145	eque
000423  aa  163 164 145 144	sted
000424  aa  040 144 165 155	 dum
000425  aa  160 040 166 157	p vo
000426  aa  154 165 155 145	lume
000427  aa  040 136 141 000	 ^a

000430  aa  122 145 163 171	Resy
000431  aa  156 143 150 162	nchr
000432  aa  157 156 151 172	oniz
000433  aa  141 164 151 157	atio
000434  aa  156 040 146 141	n fa
000435  aa  151 154 145 144	iled
000436  aa  040 157 156 040	 on 
000437  aa  144 165 155 160	dump
000440  aa  040 166 157 154	 vol
000441  aa  165 155 145 040	ume 
000442  aa  136 141 000 000	^a

000443  aa  116 157 040 144	No d
000444  aa  165 155 160 040	ump 
000445  aa  166 157 154 165	volu
000446  aa  155 145 163 040	mes 
000447  aa  163 145 154 145	sele
000450  aa  143 164 145 144	cted
000451  aa  040 146 157 162	 for
000452  aa  040 164 150 151	 thi
000453  aa  163 040 162 145	s re
000454  aa  154 157 141 144	load
000455  aa  056 000 000 000	.

000456  aa  142 141 144 040	bad 
000457  aa  151 156 160 165	inpu
000460  aa  164 040 162 145	t re
000461  aa  143 157 162 144	cord
000462  aa  040 141 146 164	 aft
000463  aa  145 162 040 136	er ^
000464  aa  141 040 055 040	a - 
000465  aa  162 145 163 171	resy
000466  aa  156 143 150 151	nchi
000467  aa  156 147 040 163	ng s
000470  aa  164 141 162 164	tart
000471  aa  145 144 000 000	ed

000472  aa  122 145 163 171	Resy
000473  aa  156 143 150 162	nchr
000474  aa  157 156 151 172	oniz
000475  aa  141 164 151 157	atio
000476  aa  156 040 164 145	n te
000477  aa  162 155 151 156	rmin
000500  aa  141 164 145 144	ated
000501  aa  040 142 171 040	 by 
000502  aa  145 156 144 040	end 
000503  aa  157 146 040 166	of v
000504  aa  157 154 165 155	olum
000505  aa  145 000 000 000	e

000506  aa  123 171 156 143	Sync
000507  aa  150 162 157 156	hron
000510  aa  151 172 141 164	izat
000511  aa  151 157 156 040	ion 
000512  aa  143 157 155 160	comp
000513  aa  154 145 164 145	lete
000514  aa  144 040 136 144	d ^d
000515  aa  040 167 157 162	 wor
000516  aa  144 163 040 163	ds s
000517  aa  153 151 160 160	kipp
000520  aa  145 144 040 157	ed o
000521  aa  156 040 144 165	n du
000522  aa  155 160 040 166	mp v
000523  aa  157 154 165 155	olum
000524  aa  145 040 136 141	e ^a

000525  aa  101 164 164 141	Atta
000526  aa  143 150 155 145	chme
000527  aa  156 164 040 157	nt o
000530  aa  146 040 144 165	f du
000531  aa  155 160 040 166	mp v
000532  aa  157 154 165 155	olum
000533  aa  145 040 136 141	e ^a
000534  aa  040 156 157 164	 not
000535  aa  040 143 157 155	 com
000536  aa  160 154 145 164	plet
000537  aa  145 144 056 040	ed. 
000540  aa  104 157 040 171	Do y
000541  aa  157 165 040 167	ou w
000542  aa  151 163 150 040	ish 
000543  aa  164 157 040 162	to r
000544  aa  145 164 162 171	etry
000545  aa  040 077 000 000	 ?

000546  aa  122 145 163 171	Resy
000547  aa  156 143 150 162	nchr
000550  aa  157 156 151 172	oniz
000551  aa  141 164 151 157	atio
000552  aa  156 040 146 141	n fa
000553  aa  151 154 145 144	iled
000554  aa  040 144 165 145	 due
000555  aa  040 164 157 040	 to 
000556  aa  111 057 117 040	I/O 
000557  aa  145 162 162 157	erro
000560  aa  162 040 144 165	r du
000561  aa  162 151 156 147	ring
000562  aa  040 162 145 163	 res
000563  aa  171 156 143 150	ynch
000564  aa  151 156 147 040	ing 
000565  aa  157 156 040 166	on v
000566  aa  157 154 165 155	olum
000567  aa  145 040 136 141	e ^a
000570  aa  056 000 000 000	.

000571  aa  146 151 162 163	firs
000572  aa  164 040 157 142	t ob
000573  aa  152 145 143 164	ject
000574  aa  040 141 146 164	 aft
000575  aa  145 162 040 162	er r
000576  aa  145 163 171 156	esyn
000577  aa  143 150 151 156	chin
000600  aa  147 040 136 141	g ^a
000601  aa  040 157 156 040	 on 
000602  aa  160 166 040 136	pv ^
000603  aa  141 040 136 133	a ^[
000604  aa  050 166 164 157	(vto
000605  aa  143 170 040 075	cx =
000606  aa  040 136 144 051	 ^d)
000607  aa  136 073 136 163	^;^s
000610  aa  136 135 040 157	^] o
000611  aa  146 040 154 157	f lo
000612  aa  147 151 143 141	gica
000613  aa  154 040 166 157	l vo
000614  aa  154 165 155 145	lume
000615  aa  040 136 141 000	 ^a

000616  aa  162 145 154 157	relo
000617  aa  141 144 145 144	aded
000620  aa  040 146 162 157	 fro
000621  aa  155 040 151 156	m in
000622  aa  160 165 164 040	put 
000623  aa  166 157 154 165	volu
000624  aa  155 145 040 136	me ^
000625  aa  141 040 136 144	a ^d
000626  aa  040 162 145 143	 rec
000627  aa  157 162 144 163	ords
000630  aa  040 157 146 040	 of 
000631  aa  136 144 040 144	^d d
000632  aa  151 162 145 143	irec
000633  aa  164 157 162 151	tori
000634  aa  145 163 040 141	es a
000635  aa  156 144 040 136	nd ^
000636  aa  144 040 162 145	d re
000637  aa  143 157 162 144	cord
000640  aa  163 040 157 146	s of
000641  aa  040 136 144 040	 ^d 
000642  aa  163 145 147 155	segm
000643  aa  145 156 164 163	ents
000644  aa  040 157 156 040	 on 
000645  aa  160 166 040 136	pv ^
000646  aa  141 000 000 000	a

000647  aa  142 141 144 040	bad 
000650  aa  151 156 160 165	inpu
000651  aa  164 040 162 145	t re
000652  aa  143 157 162 144	cord
000653  aa  040 141 146 164	 aft
000654  aa  145 162 040 136	er ^
000655  aa  141 040 157 156	a on
000656  aa  040 160 166 040	 pv 
000657  aa  136 141 040 136	^a ^
000660  aa  133 050 166 164	[(vt
000661  aa  157 143 170 040	ocx 
000662  aa  075 040 136 144	= ^d
000663  aa  051 136 073 136	)^;^
000664  aa  163 136 135 040	s^] 
000665  aa  157 146 040 154	of l
000666  aa  157 147 151 143	ogic
000667  aa  141 154 040 166	al v
000670  aa  157 154 165 155	olum
000671  aa  145 040 136 141	e ^a
000672  aa  040 055 040 162	 - r
000673  aa  145 163 171 156	esyn
000674  aa  143 150 151 156	chin
000675  aa  147 040 163 164	g st
000676  aa  141 162 164 145	arte
000677  aa  144 000 000 000	d

000700  aa  012 124 150 145	
The
000701  aa  040 160 150 171	 phy
000702  aa  163 151 143 141	sica
000703  aa  154 040 144 162	l dr
000704  aa  151 166 145 040	ive 
000705  aa  157 162 040 144	or d
000706  aa  165 155 160 040	ump 
000707  aa  166 157 154 165	volu
000710  aa  155 145 040 151	me i
000711  aa  163 040 156 157	s no
000712  aa  164 040 141 166	t av
000713  aa  141 151 154 141	aila
000714  aa  142 154 145 040	ble 
000715  aa  157 162 040 151	or i
000716  aa  163 040 151 156	s in
000717  aa  040 165 163 145	 use
000720  aa  040 142 171 040	 by 
000721  aa  141 156 040 157	an o
000722  aa  164 150 145 162	ther
000723  aa  040 160 162 157	 pro
000724  aa  143 145 163 163	cess
000725  aa  056 012 104 157	.
Do
000726  aa  040 171 157 165	 you
000727  aa  040 167 151 163	 wis
000730  aa  150 040 164 157	h to
000731  aa  040 162 145 164	 ret
000732  aa  162 171 040 164	ry t
000733  aa  150 145 040 141	he a
000734  aa  164 164 141 143	ttac
000735  aa  150 155 145 156	hmen
000736  aa  164 000 000 000	t

000737  aa  151 157 040 157	io o
000740  aa  165 164 145 162	uter
000741  aa  040 155 157 144	 mod
000742  aa  165 154 145 040	ule 
000743  aa  136 141 040 167	^a w
000744  aa  150 151 143 150	hich
000745  aa  040 167 162 157	 wro
000746  aa  164 145 040 166	te v
000747  aa  157 154 165 155	olum
000750  aa  145 040 136 141	e ^a
000751  aa  040 151 163 040	 is 
000752  aa  144 151 146 146	diff
000753  aa  145 162 145 156	eren
000754  aa  164 040 164 150	t th
000755  aa  141 156 040 164	an t
000756  aa  150 141 164 040	hat 
000757  aa  163 160 145 143	spec
000760  aa  151 146 151 145	ifie
000761  aa  144 040 164 157	d to
000762  aa  040 162 145 141	 rea
000763  aa  144 040 164 150	d th
000764  aa  145 040 166 157	e vo
000765  aa  154 165 155 145	lume
000766  aa  056 012 040 104	.
 D
000767  aa  157 040 171 157	o yo
000770  aa  165 040 167 151	u wi
000771  aa  163 150 040 164	sh t
000772  aa  157 040 165 163	o us
000773  aa  145 040 164 150	e th
000774  aa  145 040 166 157	e vo
000775  aa  154 165 155 145	lume
000776  aa  040 077 000 000	 ?

BEGIN PROCEDURE rldr_input_
PROLOGUE SEQUENCE
000777  aa  6 01221 4401 00	sxl0 	pr6|657
						STATEMENT 1 ON LINE 7 OF FILE 18
001000  aa  6 01106 4501 00	stz  	pr6|582		query_info.status_code
001001  aa  6 01107 4501 00	stz  	pr6|583		query_info.query_code
001002  aa   777106 2370 04	ldaq 	-442,ic		000110 = 077777000043 000001000000
001003  aa  6 01110 7571 00	staq 	pr6|584		query_info.question_iocbp
001004  aa  6 01112 7571 00	staq 	pr6|586		query_info.answer_iocbp
001005  aa   777101 2370 04	ldaq 	-447,ic		000106 = 000000000000 000000000000
001006  aa  6 01114 7571 00	staq 	pr6|588		query_info.repeat_time
001007  aa   777101 2370 04	ldaq 	-447,ic		000110 = 077777000043 000001000000
001010  aa  6 01116 7571 00	staq 	pr6|590		query_info.explanation_ptr
001011  aa  6 01120 4501 00	stz  	pr6|592		query_info.explanation_len
001012  aa   007143 2350 04	lda  	3683,ic		010155 = 377777777777
001013  aa  6 01105 3551 00	ansa 	pr6|581		query_info.yes_or_no_sw
001014  aa   007140 2350 04	lda  	3680,ic		010154 = 577777777777
001015  aa  6 01105 3551 00	ansa 	pr6|581		query_info.suppress_name_sw
001016  aa   007135 2350 04	lda  	3677,ic		010153 = 637777777777
001017  aa  6 01105 3551 00	ansa 	pr6|581		query_info.cp_escape_control
001020  aa   007132 2350 04	lda  	3674,ic		010152 = 757777777777
001021  aa  6 01105 3551 00	ansa 	pr6|581		query_info.suppress_spacing
001022  aa   007127 2350 04	lda  	3671,ic		010151 = 767777777777
001023  aa  6 01105 3551 00	ansa 	pr6|581		query_info.literal_sw
001024  aa   007124 2350 04	lda  	3668,ic		010150 = 773777777777
001025  aa  6 01105 3551 00	ansa 	pr6|581		query_info.prompt_after_explanation
001026  aa   774000 2350 03	lda  	260096,du
001027  aa  6 01105 3551 00	ansa 	pr6|581		query_info.padding
001030  aa  6 01221 7201 00	lxl0 	pr6|657
001031  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO rldr_input_                                        STATEMENT 1 ON LINE 61
rldr_input_: proc;

001032  da     000363200000
001033  aa   002040 6270 00	eax7 	1056
001034  aa  7 00034 3521 20	epp2 	pr7|28,*
001035  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001036  aa     000000000000
001037  aa     000000000000
001040  aa   777737 7000 04	tsx0 	-33,ic		000777
						STATEMENT 1 ON LINE 131
get_object: entry (rldr_datap, skip_next_header_check, vtocep, vtocx, already_there, a_pvindex, code);

001041  aa   000024 7100 04	tra  	20,ic		001065
ENTRY TO get_object                                         STATEMENT 1 ON LINE 131
get_object: entry (rldr_datap, skip_next_header_check, vtocep, vtocx, already_there, a_pvindex, code);

001042  at     000007000064
001043  tt     000075000064
001044  tt     000072000075
001045  tt     000072000073
001046  ta     001042000000
001047  da     000371300000
001050  aa   002040 6270 00	eax7 	1056
001051  aa  7 00034 3521 20	epp2 	pr7|28,*
001052  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001053  aa     000016000000
001054  aa     000000000000
001055  aa  6 00032 3735 20	epp7 	pr6|26,*
001056  aa  7 00004 3715 20	epp5 	pr7|4,*
001057  aa  6 01122 6515 00	spri5	pr6|594
001060  aa  7 00014 3535 20	epp3 	pr7|12,*
001061  aa  6 01126 2535 00	spri3	pr6|598
001062  aa  7 00016 3515 20	epp1 	pr7|14,*
001063  aa  6 01124 2515 00	spri1	pr6|596
001064  aa   777713 7000 04	tsx0 	-53,ic		000777
						STATEMENT 1 ON LINE 139
    entry = get_object;

001065  aa   000001 2360 07	ldq  	1,dl
001066  aa  6 00273 7561 00	stq  	pr6|187		entry
						STATEMENT 1 ON LINE 140
    a_pvindex, vtocx = -1;

001067  aa   000001 3360 07	lcq  	1,dl
001070  aa  6 01126 7561 20	stq  	pr6|598,*		a_pvindex
001071  aa  6 00032 3735 20	epp7 	pr6|26,*
001072  aa  7 00010 7561 20	stq  	pr7|8,*		vtocx
						STATEMENT 1 ON LINE 141
    code = 0;

001073  aa  6 01124 4501 20	stz  	pr6|596,*		code
						STATEMENT 1 ON LINE 142
    already_there = "0"b;

001074  aa  7 00012 3715 20	epp5 	pr7|10,*
001075  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
001076  aa   000000 00 0000	descb	0,0
001077  aa  5 00000 00 0001	descb	pr5|0,1		already_there
						STATEMENT 1 ON LINE 143
    recordp = rldr_data_.volume_record_bp;

001100  aa  7 00002 3535 20	epp3 	pr7|2,*		rldr_datap
001101  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
001102  aa  3 00422 3515 20	epp1 	pr3|274,*		rldr_data_.volume_record_bp
001103  aa  6 00356 2515 00	spri1	pr6|238		recordp
						STATEMENT 1 ON LINE 146
    if rldr_data_.inputvol_iocbp = null then call attach;

001104  aa  3 00414 2371 00	ldaq 	pr3|268		rldr_data_.inputvol_iocbp
001105  aa   777003 6770 04	eraq 	-509,ic		000110 = 077777000043 000001000000
001106  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001107  aa   000005 6010 04	tnz  	5,ic		001114
001110  aa  6 00056 6211 00	eax1 	pr6|46
001111  aa   000000 4310 07	fld  	0,dl
001112  aa   003335 3520 04	epp2 	1757,ic		004447 = 000300627000
001113  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 147
search_loop:
						/* set flags */
    resynching_completed = "0"b;

001114  aa  6 00121 4501 00	stz  	pr6|81		resynching_completed
						STATEMENT 1 ON LINE 150
    resynching = "0"b;

001115  aa  6 00122 4501 00	stz  	pr6|82		resynching
						STATEMENT 1 ON LINE 151
    new_info = "0"b;

001116  aa  6 00125 4501 00	stz  	pr6|85		new_info
						STATEMENT 1 ON LINE 153
    do while (^new_info & code = 0);

001117  aa   000000 0110 03	nop  	0,du
001120  aa  6 00125 2351 00	lda  	pr6|85		new_info
001121  aa   000005 6010 04	tnz  	5,ic		001126
001122  aa  6 01124 2361 20	ldq  	pr6|596,*		code
001123  aa   000003 6010 04	tnz  	3,ic		001126
						STATEMENT 1 ON LINE 154
      call read_volume_record;

001124  aa   001425 6700 04	tsp4 	789,ic		002551
						STATEMENT 1 ON LINE 155
    end;

001125  aa   777773 7100 04	tra  	-5,ic		001120
						STATEMENT 1 ON LINE 157
    if pvindex >= 1 then do;

001126  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
001127  aa   000001 1160 07	cmpq 	1,dl
001130  aa   000017 6040 04	tmi  	15,ic		001147
						STATEMENT 1 ON LINE 158
        controlp = rldr_data_.controlp (pvindex);

001131  aa   000064 4020 07	mpy  	52,dl
001132  aa  6 00032 3735 20	epp7 	pr6|26,*
001133  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001134  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001135  aa  5 00430 3535 26	epp3 	pr5|280,ql*	rldr_data_.controlp
001136  aa  6 01100 2535 00	spri3	pr6|576		controlp
						STATEMENT 1 ON LINE 159
        vtocep -> vtoce = backup_volume_record.vtoce;

001137  aa  7 00006 3515 20	epp1 	pr7|6,*		vtocep
001140  aa  1 00000 3515 20	epp1 	pr1|0,*		vtocep
001141  aa  6 00356 3715 20	epp5 	pr6|238,*		recordp
001142  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001143  aa  5 00013 00 1400	desc9a	pr5|11,768	backup_volume_record.vtoce
001144  aa  1 00000 00 1400	desc9a	pr1|0,768		vtoce
						STATEMENT 1 ON LINE 160
        a_pvindex = pvindex;

001145  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
001146  aa  6 01126 7561 20	stq  	pr6|598,*		a_pvindex
						STATEMENT 1 ON LINE 161
      end;

						STATEMENT 1 ON LINE 162
get_object_ret:
    return;

001147  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read_object                                        STATEMENT 1 ON LINE 169
read_object: entry (rldr_datap, a_pvindex, a_new_volume, skip_next_header_check, pages_returned, code);

001150  at     000006000064
001151  tt     000072000075
001152  tt     000075000072
001153  ta     000073000000
001154  ta     001150000000
001155  da     000377300000
001156  aa   002040 6270 00	eax7 	1056
001157  aa  7 00034 3521 20	epp2 	pr7|28,*
001160  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001161  aa     000014000000
001162  aa     000000000000
001163  aa  6 00032 3735 20	epp7 	pr6|26,*
001164  aa  7 00004 3715 20	epp5 	pr7|4,*
001165  aa  6 01126 6515 00	spri5	pr6|598
001166  aa  7 00010 3535 20	epp3 	pr7|8,*
001167  aa  6 01122 2535 00	spri3	pr6|594
001170  aa  7 00014 3515 20	epp1 	pr7|12,*
001171  aa  6 01124 2515 00	spri1	pr6|596
001172  aa   777605 7000 04	tsx0 	-123,ic		000777
						STATEMENT 1 ON LINE 173
    entry = read_object;

001173  aa   000002 2360 07	ldq  	2,dl
001174  aa  6 00273 7561 00	stq  	pr6|187		entry
						STATEMENT 1 ON LINE 174
    pvindex = a_pvindex;

001175  aa  6 01126 2361 20	ldq  	pr6|598,*		a_pvindex
001176  aa  6 00275 7561 00	stq  	pr6|189		pvindex
						STATEMENT 1 ON LINE 175
    a_new_volume = "0"b;

001177  aa  6 00032 3735 20	epp7 	pr6|26,*
001200  aa  7 00006 3715 20	epp5 	pr7|6,*
001201  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
001202  aa   000000 00 0000	descb	0,0
001203  aa  5 00000 00 0001	descb	pr5|0,1		a_new_volume
						STATEMENT 1 ON LINE 176
    resynching_completed = "0"b;

001204  aa  6 00121 4501 00	stz  	pr6|81		resynching_completed
						STATEMENT 1 ON LINE 177
    resynching = "0"b;

001205  aa  6 00122 4501 00	stz  	pr6|82		resynching
						STATEMENT 1 ON LINE 178
    skip_next_header_check = "0"b;

001206  aa  6 01122 3535 20	epp3 	pr6|594,*
001207  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
001210  aa   000000 00 0000	descb	0,0
001211  aa  3 00000 00 0001	descb	pr3|0,1		skip_next_header_check
						STATEMENT 1 ON LINE 179
    pages_returned, nelt, code = 0;

001212  aa  7 00012 4501 20	stz  	pr7|10,*		pages_returned
001213  aa  6 00302 4501 00	stz  	pr6|194		nelt
001214  aa  6 01124 4501 20	stz  	pr6|596,*		code
						STATEMENT 1 ON LINE 180
    recordp = rldr_data_.volume_record_bp;

001215  aa  7 00002 3515 20	epp1 	pr7|2,*		rldr_datap
001216  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
001217  aa  1 00422 3715 20	epp5 	pr1|274,*		rldr_data_.volume_record_bp
001220  aa  6 00356 6515 00	spri5	pr6|238		recordp
						STATEMENT 1 ON LINE 181
    controlp = rldr_data_.controlp (pvindex);

001221  aa   000064 4020 07	mpy  	52,dl
001222  aa  1 00430 3535 26	epp3 	pr1|280,ql*	rldr_data_.controlp
001223  aa  6 01100 2535 00	spri3	pr6|576		controlp
						STATEMENT 1 ON LINE 182
    nel = backup_volume_record.rec2_len;

001224  aa  5 00005 2361 00	ldq  	pr5|5		backup_volume_record.rec2_len
001225  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 184
    call read (rldr_data_.data_object_bp, nel, nelt,
         (backup_volume_record.version > 1), code);

001226  aa  5 00010 2361 00	ldq  	pr5|8		backup_volume_record.version
001227  aa   000001 1160 07	cmpq 	1,dl
001230  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
001231  aa  6 01222 7551 00	sta  	pr6|658
001232  aa  1 00426 3521 00	epp2 	pr1|278		rldr_data_.data_object_bp
001233  aa  6 01226 2521 00	spri2	pr6|662
001234  aa  6 00301 3521 00	epp2 	pr6|193		nel
001235  aa  6 01230 2521 00	spri2	pr6|664
001236  aa  6 00302 3521 00	epp2 	pr6|194		nelt
001237  aa  6 01232 2521 00	spri2	pr6|666
001240  aa  6 01222 3521 00	epp2 	pr6|658
001241  aa  6 01234 2521 00	spri2	pr6|668
001242  aa  6 01124 3521 20	epp2 	pr6|596,*		code
001243  aa  6 01236 2521 00	spri2	pr6|670
001244  aa  6 01224 6211 00	eax1 	pr6|660
001245  aa   024000 4310 07	fld  	10240,dl
001246  aa   006056 3520 04	epp2 	3118,ic		007324 = 000140627000
001247  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 187
    pages_returned = divide (nelt + CHARS_PER_PAGE - 1, CHARS_PER_PAGE, 17);

001250  aa  6 00302 2361 00	ldq  	pr6|194		nelt
001251  aa   007777 0760 07	adq  	4095,dl
001252  aa   010000 5060 07	div  	4096,dl
001253  aa  6 00032 3735 20	epp7 	pr6|26,*
001254  aa  7 00012 7561 20	stq  	pr7|10,*		pages_returned
						STATEMENT 1 ON LINE 188
    pad_chars = CHARS_PER_PAGE - mod (nelt, CHARS_PER_PAGE);

001255  aa  6 00302 2361 00	ldq  	pr6|194		nelt
001256  aa   006700 3520 04	epp2 	3520,ic		010156 = 000000010000
001257  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
001260  aa  6 01222 7561 00	stq  	pr6|658
001261  aa  2 00000 2361 00	ldq  	pr2|0		CHARS_PER_PAGE
001262  aa  6 01222 1761 00	sbq  	pr6|658
001263  aa  6 00343 7561 00	stq  	pr6|227		pad_chars
						STATEMENT 1 ON LINE 189
    if pad_chars < CHARS_PER_PAGE then
      unspec (substr (char_buf, nelt + 1, pad_chars)) = "0"b;

001264  aa  2 00000 1161 00	cmpq 	pr2|0		CHARS_PER_PAGE
001265  aa   000014 6050 04	tpl  	12,ic		001301
001266  aa   000011 4020 07	mpy  	9,dl
001267  aa  6 01222 7561 00	stq  	pr6|658
001270  aa  6 00302 2361 00	ldq  	pr6|194		nelt
001271  aa   000011 4020 07	mpy  	9,dl
001272  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001273  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001274  aa  5 00426 3535 20	epp3 	pr5|278,*		rldr_data_.data_object_bp
001275  aa  6 01222 2351 00	lda  	pr6|658
001276  aa  003 146 060 400	csl  	(),(pr,rl,ql),fill(0),bool(move)
001277  aa   000000 00 0000	descb	0,0
001300  aa  3 00000 00 0005	descb	pr3|0,al
						STATEMENT 1 ON LINE 192
    call check_input_error;

001301  aa  6 00056 6211 00	eax1 	pr6|46
001302  aa   000000 4310 07	fld  	0,dl
001303  aa   002157 3520 04	epp2 	1135,ic		003462 = 000500627000
001304  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 194
    if new_volume then do;

001305  aa  6 00123 2351 00	lda  	pr6|83		new_volume
001306  aa   000015 6000 04	tze  	13,ic		001323
						STATEMENT 1 ON LINE 195
        rldr_control (backup_volume_record.vtocx).uid = "0"b;

001307  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
001310  aa  7 00012 2361 00	ldq  	pr7|10		backup_volume_record.vtocx
001311  aa   000006 4020 07	mpy  	6,dl
001312  aa  6 01100 3715 20	epp5 	pr6|576,*		controlp
001313  aa  5 14024 4501 06	stz  	pr5|6164,ql	rldr_control.uid
						STATEMENT 1 ON LINE 196
        rldr_control (backup_volume_record.vtocx).volid = "0"b;

001314  aa  5 14030 4501 06	stz  	pr5|6168,ql	rldr_control.volid
						STATEMENT 1 ON LINE 197
        a_new_volume = new_volume;

001315  aa  6 00032 3535 20	epp3 	pr6|26,*
001316  aa  3 00006 3515 20	epp1 	pr3|6,*
001317  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001320  aa  6 00123 00 0001	descb	pr6|83,1		new_volume
001321  aa  1 00000 00 0001	descb	pr1|0,1		a_new_volume
						STATEMENT 1 ON LINE 198
        return;

001322  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 199
      end;

						STATEMENT 1 ON LINE 201
    skip_next_header_check = resynching_completed;

001323  aa  6 01122 3735 20	epp7 	pr6|594,*
001324  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001325  aa  6 00121 00 0001	descb	pr6|81,1		resynching_completed
001326  aa  7 00000 00 0001	descb	pr7|0,1		skip_next_header_check
						STATEMENT 1 ON LINE 202
    return;

001327  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO init_volume_list                                   STATEMENT 1 ON LINE 209
init_volume_list: entry (rldr_datap, code);

001330  at     000002000064
001331  ta     000073000000
001332  ta     001330000000
001333  da     000407300000
001334  aa   002040 6270 00	eax7 	1056
001335  aa  7 00034 3521 20	epp2 	pr7|28,*
001336  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001337  aa     000004000000
001340  aa     000000000000
001341  aa  6 00032 3735 20	epp7 	pr6|26,*
001342  aa  7 00004 3715 20	epp5 	pr7|4,*
001343  aa  6 01124 6515 00	spri5	pr6|596
001344  aa   777433 7000 04	tsx0 	-229,ic		000777
						STATEMENT 1 ON LINE 214
    entry = init;

001345  aa   000003 2360 07	ldq  	3,dl
001346  aa  6 00273 7561 00	stq  	pr6|187		entry
						STATEMENT 1 ON LINE 215
    code = 0;

001347  aa  6 01124 4501 20	stz  	pr6|596,*		code
						STATEMENT 1 ON LINE 216
    skip = rldr_data_.skip;

001350  aa  6 00032 3735 20	epp7 	pr6|26,*
001351  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001352  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001353  aa  5 00420 3535 20	epp3 	pr5|272,*		rldr_data_.skip
001354  aa  6 01102 2535 00	spri3	pr6|578		skip
						STATEMENT 1 ON LINE 218
    vlx = 0;

001355  aa  6 00274 4501 00	stz  	pr6|188		vlx
						STATEMENT 1 ON LINE 219
    do pvindex = 1 to rldr_data_.npvs;

001356  aa  5 00404 2361 00	ldq  	pr5|260		rldr_data_.npvs
001357  aa  6 01130 7561 00	stq  	pr6|600
001360  aa   000001 2360 07	ldq  	1,dl
001361  aa  6 00275 7561 00	stq  	pr6|189		pvindex
001362  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
001363  aa  6 01130 1161 00	cmpq 	pr6|600
001364  aa   000157 6054 04	tpnz 	111,ic		001543
						STATEMENT 1 ON LINE 220
      labelp, old_labelp = rldr_data_.labelp (pvindex);

001365  aa   000064 4020 07	mpy  	52,dl
001366  aa  6 00032 3735 20	epp7 	pr6|26,*
001367  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001370  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001371  aa  5 00422 3535 26	epp3 	pr5|274,ql*	rldr_data_.labelp
001372  aa  6 00352 2535 00	spri3	pr6|234		labelp
001373  aa  6 00354 2535 00	spri3	pr6|236		old_labelp
						STATEMENT 1 ON LINE 221
      bvlp = rldr_data_.bvlp (pvindex);

001374  aa  5 00424 3515 26	epp1 	pr5|276,ql*	rldr_data_.bvlp
001375  aa  6 00346 2515 00	spri1	pr6|230		bvlp
						STATEMENT 1 ON LINE 222
      if label.volmap_version = 1 | label.volmap_version = 2
	 then time_unmounted = label.time_unmounted;

001376  aa  6 00352 3535 20	epp3 	pr6|234,*		labelp
001377  aa  3 00604 2361 00	ldq  	pr3|388		label.volmap_version
001400  aa   000001 1160 07	cmpq 	1,dl
001401  aa   000003 6000 04	tze  	3,ic		001404
001402  aa   000002 1160 07	cmpq 	2,dl
001403  aa   000004 6010 04	tnz  	4,ic		001407
001404  aa  3 00612 2371 00	ldaq 	pr3|394		label.time_unmounted
001405  aa  6 00266 7571 00	staq 	pr6|182		time_unmounted
001406  aa   000004 7100 04	tra  	4,ic		001412
						STATEMENT 1 ON LINE 224
      else time_unmounted = old_label.time_unmounted;

001407  aa  6 00354 3515 20	epp1 	pr6|236,*		old_labelp
001410  aa  1 00604 2371 00	ldaq 	pr1|388		old_label.time_unmounted
001411  aa  6 00266 7571 00	staq 	pr6|182		time_unmounted
						STATEMENT 1 ON LINE 225
      if rldr_data_.manual then return;

001412  aa  5 00000 2351 00	lda  	pr5|0		rldr_data_.manual
001413  aa   000200 3150 03	cana 	128,du
001414  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 226
      call lock_volume_log;

001415  aa   004304 6700 04	tsp4 	2244,ic		005721
						STATEMENT 1 ON LINE 227
      if code ^= 0 then return;

001416  aa  6 01124 2361 20	ldq  	pr6|596,*		code
001417  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 236
      incr_open_time = 0;

001420  aa   776466 2370 04	ldaq 	-714,ic		000106 = 000000000000 000000000000
001421  aa  6 00260 7571 00	staq 	pr6|176		incr_open_time
						STATEMENT 1 ON LINE 237
      cons_open_time = 0;

001422  aa  6 00262 7571 00	staq 	pr6|178		cons_open_time
						STATEMENT 1 ON LINE 238
      comp_open_time = 0;

001423  aa  6 00264 7571 00	staq 	pr6|180		comp_open_time
						STATEMENT 1 ON LINE 239
      comp_cycle_uid = "0"b;

001424  aa  6 00270 4501 00	stz  	pr6|184		comp_cycle_uid
						STATEMENT 1 ON LINE 240
      cons_cycle_uid = "0"b;

001425  aa  6 00271 4501 00	stz  	pr6|185		cons_cycle_uid
						STATEMENT 1 ON LINE 241
      do idx = backup_volume_log.next to 1 by -1;

001426  aa  6 00346 3735 20	epp7 	pr6|230,*		bvlp
001427  aa  7 02030 2361 00	ldq  	pr7|1048		backup_volume_log.next
001430  aa  6 00276 7561 00	stq  	pr6|190		idx
001431  aa   000000 0110 03	nop  	0,du
001432  aa  6 00276 2361 00	ldq  	pr6|190		idx
001433  aa   000001 1160 07	cmpq 	1,dl
001434  aa   000104 6040 04	tmi  	68,ic		001540
						STATEMENT 1 ON LINE 242
        bvlep = addr (backup_volume_log.array (idx));

001435  aa   000042 4020 07	mpy  	34,dl
001436  aa  6 00346 3735 20	epp7 	pr6|230,*		bvlp
001437  aa  7 02036 3735 06	epp7 	pr7|1054,ql	backup_volume_log.array
001440  aa  6 00350 6535 00	spri7	pr6|232		bvlep
						STATEMENT 1 ON LINE 243
        if bvle.dump_type = incr then do;

001441  aa  7 00001 2361 00	ldq  	pr7|1		bvle.dump_type
001442  aa   000001 1160 07	cmpq 	1,dl
001443  aa   000032 6010 04	tnz  	26,ic		001475
						STATEMENT 1 ON LINE 244
	  if cons_open_time ^= 0 | comp_open_time ^= 0 then do;

001444  aa  6 00264 2371 00	ldaq 	pr6|180		comp_open_time
001445  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001446  aa  6 01222 7551 00	sta  	pr6|658
001447  aa  6 00262 2371 00	ldaq 	pr6|178		cons_open_time
001450  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001451  aa  6 01223 7551 00	sta  	pr6|659
001452  aa   000003 6010 04	tnz  	3,ic		001455
001453  aa  6 01222 2351 00	lda  	pr6|658
001454  aa   000015 6000 04	tze  	13,ic		001471
						STATEMENT 1 ON LINE 245
	      if (cons_open_time ^= 0 & cons_open_time < bvle.close_time)
		 | (comp_open_time ^= 0 & comp_open_time < bvle.close_time)
		 then call log_volume_name;

001455  aa  6 01223 2351 00	lda  	pr6|659
001456  aa   000004 6000 04	tze  	4,ic		001462
001457  aa  6 00262 2371 00	ldaq 	pr6|178		cons_open_time
001460  aa  7 00014 1171 00	cmpaq	pr7|12		bvle.close_time
001461  aa   000006 6040 04	tmi  	6,ic		001467
001462  aa  6 01222 2351 00	lda  	pr6|658
001463  aa   000052 6000 04	tze  	42,ic		001535
001464  aa  6 00264 2371 00	ldaq 	pr6|180		comp_open_time
001465  aa  7 00014 1171 00	cmpaq	pr7|12		bvle.close_time
001466  aa   000047 6050 04	tpl  	39,ic		001535
001467  aa   000650 6700 04	tsp4 	424,ic		002337
						STATEMENT 1 ON LINE 248
	    end;

001470  aa   000045 7100 04	tra  	37,ic		001535
						STATEMENT 1 ON LINE 249
	  else do;

						STATEMENT 1 ON LINE 250
	      call log_volume_name;

001471  aa   000646 6700 04	tsp4 	422,ic		002337
						STATEMENT 1 ON LINE 251
	      incr_open_time = open_time ();

001472  aa   006452 3520 04	epp2 	3370,ic		010144 = 000002000000
001473  aa   005234 6700 04	tsp4 	2716,ic		006727
						STATEMENT 1 ON LINE 252
	    end;

						STATEMENT 1 ON LINE 253
	end;

001474  aa   000041 7100 04	tra  	33,ic		001535
						STATEMENT 1 ON LINE 254
        else if bvle.dump_type = cons then do;

001475  aa   000002 1160 07	cmpq 	2,dl
001476  aa   000020 6010 04	tnz  	16,ic		001516
						STATEMENT 1 ON LINE 255
	  if comp_open_time ^= 0 then do;

001477  aa  6 00264 2371 00	ldaq 	pr6|180		comp_open_time
001500  aa   000010 6000 04	tze  	8,ic		001510
						STATEMENT 1 ON LINE 256
	      if comp_open_time < bvle.close_time
		 | cons_cycle_uid = bvle.cycle_uid then call log_volume_name;

001501  aa  7 00014 1171 00	cmpaq	pr7|12		bvle.close_time
001502  aa   000004 6040 04	tmi  	4,ic		001506
001503  aa  6 00271 2351 00	lda  	pr6|185		cons_cycle_uid
001504  aa  7 00000 1151 00	cmpa 	pr7|0		bvle.cycle_uid
001505  aa   000030 6010 04	tnz  	24,ic		001535
001506  aa   000631 6700 04	tsp4 	409,ic		002337
						STATEMENT 1 ON LINE 258
	    end;

001507  aa   000026 7100 04	tra  	22,ic		001535
						STATEMENT 1 ON LINE 259
	  else do;

						STATEMENT 1 ON LINE 260
	      call log_volume_name;

001510  aa   000627 6700 04	tsp4 	407,ic		002337
						STATEMENT 1 ON LINE 261
	      cons_open_time = open_time ();

001511  aa   006427 3520 04	epp2 	3351,ic		010140 = 000002000000
001512  aa   005215 6700 04	tsp4 	2701,ic		006727
						STATEMENT 1 ON LINE 262
	      cons_cycle_uid = bvle.cycle_uid;

001513  aa  6 00350 2351 20	lda  	pr6|232,*		bvle.cycle_uid
001514  aa  6 00271 7551 00	sta  	pr6|185		cons_cycle_uid
						STATEMENT 1 ON LINE 263
	    end;

						STATEMENT 1 ON LINE 264
	end;

001515  aa   000020 7100 04	tra  	16,ic		001535
						STATEMENT 1 ON LINE 265
        else if bvle.dump_type = comp then do;

001516  aa   000003 1160 07	cmpq 	3,dl
001517  aa   000016 6010 04	tnz  	14,ic		001535
						STATEMENT 1 ON LINE 266
	  if comp_cycle_uid ^= "0"b then do;

001520  aa  6 00270 2351 00	lda  	pr6|184		comp_cycle_uid
001521  aa   000007 6000 04	tze  	7,ic		001530
						STATEMENT 1 ON LINE 267
	      if comp_cycle_uid = bvle.cycle_uid then call log_volume_name;

001522  aa  7 00000 1151 00	cmpa 	pr7|0		bvle.cycle_uid
001523  aa   000002 6010 04	tnz  	2,ic		001525
001524  aa   000613 6700 04	tsp4 	395,ic		002337
						STATEMENT 1 ON LINE 268
	      comp_open_time = open_time ();

001525  aa   006407 3520 04	epp2 	3335,ic		010134 = 000002000000
001526  aa   005201 6700 04	tsp4 	2689,ic		006727
						STATEMENT 1 ON LINE 269
	    end;

001527  aa   000006 7100 04	tra  	6,ic		001535
						STATEMENT 1 ON LINE 270
	  else do;

						STATEMENT 1 ON LINE 271
	      comp_cycle_uid = bvle.cycle_uid;

001530  aa  7 00000 2351 00	lda  	pr7|0		bvle.cycle_uid
001531  aa  6 00270 7551 00	sta  	pr6|184		comp_cycle_uid
						STATEMENT 1 ON LINE 272
	      comp_open_time = open_time ();

001532  aa   006402 3520 04	epp2 	3330,ic		010134 = 000002000000
001533  aa   005174 6700 04	tsp4 	2684,ic		006727
						STATEMENT 1 ON LINE 273
	      call log_volume_name;

001534  aa   000603 6700 04	tsp4 	387,ic		002337
						STATEMENT 1 ON LINE 274
	    end;

						STATEMENT 1 ON LINE 275
	end;

						STATEMENT 1 ON LINE 276
      end;

001535  aa   000001 3360 07	lcq  	1,dl
001536  aa  6 00276 0561 00	asq  	pr6|190		idx
001537  aa   777673 7100 04	tra  	-69,ic		001432
						STATEMENT 1 ON LINE 277
      call unlock_volume_log;

001540  aa   004554 6700 04	tsp4 	2412,ic		006314
						STATEMENT 1 ON LINE 278
    end;

001541  aa  6 00275 0541 00	aos  	pr6|189		pvindex
001542  aa   777620 7100 04	tra  	-112,ic		001362
						STATEMENT 1 ON LINE 279
    rldr_input_volume_list.num_entries = vlx;

001543  aa  6 00274 2361 00	ldq  	pr6|188		vlx
001544  aa  6 00032 3735 20	epp7 	pr6|26,*
001545  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001546  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001547  aa  5 00430 7561 20	stq  	pr5|280,*		rldr_input_volume_list.num_entries
						STATEMENT 1 ON LINE 280
    rldr_input_volume_list.curn_entry = 0;

001550  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
001551  aa  3 00001 4501 00	stz  	pr3|1		rldr_input_volume_list.curn_entry
						STATEMENT 1 ON LINE 285
    if rldr_data_.common.restart then do;

001552  aa  5 00000 2351 00	lda  	pr5|0		rldr_data_.restart
001553  aa   000100 3150 03	cana 	64,du
001554  aa   000074 6000 04	tze  	60,ic		001650
						STATEMENT 1 ON LINE 286
        controlp = rldr_data_.controlp (1);

001555  aa  5 00514 3515 20	epp1 	pr5|332,*		rldr_data_.controlp
001556  aa  6 01100 2515 00	spri1	pr6|576		controlp
						STATEMENT 1 ON LINE 287
        do idx = rldr_input_volume_list.curn_entry + 1 to rldr_input_volume_list.num_entries
	   while (rldr_input_volume_list (idx).volname ^= rldr_control.curn_volname);

001557  aa  3 00000 2361 00	ldq  	pr3|0		rldr_input_volume_list.num_entries
001560  aa  6 01131 7561 00	stq  	pr6|601
001561  aa  3 00001 2361 00	ldq  	pr3|1		rldr_input_volume_list.curn_entry
001562  aa   000001 0760 07	adq  	1,dl
001563  aa  6 00276 7561 00	stq  	pr6|190		idx
001564  aa  6 00276 2361 00	ldq  	pr6|190		idx
001565  aa  6 01131 1161 00	cmpq 	pr6|601
001566  aa   000016 6054 04	tpnz 	14,ic		001604
001567  aa   000011 4020 07	mpy  	9,dl
001570  aa  6 00032 3735 20	epp7 	pr6|26,*
001571  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001572  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001573  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
001574  aa  3 77771 3515 06	epp1 	pr3|-7,ql		rldr_input_volume_list.volname
001575  aa  6 01100 3735 20	epp7 	pr6|576,*		controlp
001576  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
001577  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_input_volume_list.volname
001600  aa  7 00000 00 0040	desc9a	pr7|0,32		rldr_control.curn_volname
001601  aa   000003 6000 04	tze  	3,ic		001604
						STATEMENT 1 ON LINE 289
        end;

001602  aa  6 00276 0541 00	aos  	pr6|190		idx
001603  aa   777761 7100 04	tra  	-15,ic		001564
						STATEMENT 1 ON LINE 290
        if idx > rldr_input_volume_list.num_entries then do;

001604  aa  6 00276 2361 00	ldq  	pr6|190		idx
001605  aa  6 00032 3735 20	epp7 	pr6|26,*
001606  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001607  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001610  aa  5 00430 1161 20	cmpq 	pr5|280,*		rldr_input_volume_list.num_entries
001611  aa   000034 6044 04	tmoz 	28,ic		001645
						STATEMENT 1 ON LINE 291
	  code = error_table_$bad_volid;

001612  aa  6 00044 3701 20	epp4 	pr6|36,*
001613  la  4 00072 2361 20	ldq  	pr4|58,*		error_table_$bad_volid
001614  aa  6 01124 7561 20	stq  	pr6|596,*		code
						STATEMENT 1 ON LINE 292
	  call rldr_report_$error_output (rldr_datap, code, myname, "Error locating restart volume");

001615  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001616  aa   776444 00 0040	desc9a	-732,32		000261 = 105162162157
001617  aa  6 01224 00 0040	desc9a	pr6|660,32
001620  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001621  aa  6 01246 2521 00	spri2	pr6|678
001622  aa  6 01124 3521 20	epp2 	pr6|596,*		code
001623  aa  6 01250 2521 00	spri2	pr6|680
001624  aa   776160 3520 04	epp2 	-912,ic		000004 = 162154144162
001625  aa  6 01252 2521 00	spri2	pr6|682
001626  aa  6 01224 3521 00	epp2 	pr6|660
001627  aa  6 01254 2521 00	spri2	pr6|684
001630  aa   776234 3520 04	epp2 	-868,ic		000064 = 464000000000
001631  aa  6 01256 2521 00	spri2	pr6|686
001632  aa   776241 3520 04	epp2 	-863,ic		000073 = 404000000043
001633  aa  6 01260 2521 00	spri2	pr6|688
001634  aa   776227 3520 04	epp2 	-873,ic		000063 = 530000000040
001635  aa  6 01262 2521 00	spri2	pr6|690
001636  aa   776224 3520 04	epp2 	-876,ic		000062 = 524000000035
001637  aa  6 01264 2521 00	spri2	pr6|692
001640  aa  6 01244 6211 00	eax1 	pr6|676
001641  aa   020000 4310 07	fld  	8192,dl
001642  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
001643  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 293
	  return;

001644  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 294
	end;

						STATEMENT 1 ON LINE 295
        rldr_input_volume_list.curn_entry = idx - 1;

001645  aa   000001 1760 07	sbq  	1,dl
001646  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
001647  aa  3 00001 7561 00	stq  	pr3|1		rldr_input_volume_list.curn_entry
						STATEMENT 1 ON LINE 296
      end;

						STATEMENT 1 ON LINE 297
    if rldr_input_volume_list.num_entries <= 0 then do;

001650  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001651  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001652  aa  5 00430 2361 20	ldq  	pr5|280,*		rldr_input_volume_list.num_entries
001653  aa   000036 6054 04	tpnz 	30,ic		001711
						STATEMENT 1 ON LINE 298
        call rldr_report_$error_output (rldr_datap, 0, myname,
	   "No dump volumes selected for this reload.");

001654  aa  6 01222 4501 00	stz  	pr6|658
001655  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001656  aa   776566 00 0054	desc9a	-650,44		000443 = 116157040144
001657  aa  6 01224 00 0054	desc9a	pr6|660,44
001660  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001661  aa  6 01246 2521 00	spri2	pr6|678
001662  aa  6 01222 3521 00	epp2 	pr6|658
001663  aa  6 01250 2521 00	spri2	pr6|680
001664  aa   776120 3520 04	epp2 	-944,ic		000004 = 162154144162
001665  aa  6 01252 2521 00	spri2	pr6|682
001666  aa  6 01224 3521 00	epp2 	pr6|660
001667  aa  6 01254 2521 00	spri2	pr6|684
001670  aa   776174 3520 04	epp2 	-900,ic		000064 = 464000000000
001671  aa  6 01256 2521 00	spri2	pr6|686
001672  aa   776167 3520 04	epp2 	-905,ic		000061 = 404000000005
001673  aa  6 01260 2521 00	spri2	pr6|688
001674  aa   776167 3520 04	epp2 	-905,ic		000063 = 530000000040
001675  aa  6 01262 2521 00	spri2	pr6|690
001676  aa   776162 3520 04	epp2 	-910,ic		000060 = 524000000051
001677  aa  6 01264 2521 00	spri2	pr6|692
001700  aa  6 01244 6211 00	eax1 	pr6|676
001701  aa   020000 4310 07	fld  	8192,dl
001702  aa  6 00044 3701 20	epp4 	pr6|36,*
001703  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
001704  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 300
        code = error_table_$action_not_performed;

001705  aa  6 00044 3701 20	epp4 	pr6|36,*
001706  la  4 00056 2361 20	ldq  	pr4|46,*		error_table_$action_not_performed
001707  aa  6 01124 7561 20	stq  	pr6|596,*		code
						STATEMENT 1 ON LINE 301
      end;

001710  aa   000336 7100 04	tra  	222,ic		002246
						STATEMENT 1 ON LINE 302
    else do;

						STATEMENT 1 ON LINE 303
        if ^rldr_data_.brief then do;

001711  aa  5 00000 2351 00	lda  	pr5|0		rldr_data_.brief
001712  aa   000400 3150 03	cana 	256,du
001713  aa   000333 6010 04	tnz  	219,ic		002246
						STATEMENT 1 ON LINE 304
	  call rldr_report_$online_output (rldr_datap, 0, myname, "Please get the following input volumes");

001714  aa  6 01222 4501 00	stz  	pr6|658
001715  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001716  aa   776453 00 0050	desc9a	-725,40		000370 = 120154145141
001717  aa  6 01224 00 0050	desc9a	pr6|660,40
001720  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001721  aa  6 01246 2521 00	spri2	pr6|678
001722  aa  6 01222 3521 00	epp2 	pr6|658
001723  aa  6 01250 2521 00	spri2	pr6|680
001724  aa   776060 3520 04	epp2 	-976,ic		000004 = 162154144162
001725  aa  6 01252 2521 00	spri2	pr6|682
001726  aa  6 01224 3521 00	epp2 	pr6|660
001727  aa  6 01254 2521 00	spri2	pr6|684
001730  aa   776134 3520 04	epp2 	-932,ic		000064 = 464000000000
001731  aa  6 01256 2521 00	spri2	pr6|686
001732  aa   776127 3520 04	epp2 	-937,ic		000061 = 404000000005
001733  aa  6 01260 2521 00	spri2	pr6|688
001734  aa   776127 3520 04	epp2 	-937,ic		000063 = 530000000040
001735  aa  6 01262 2521 00	spri2	pr6|690
001736  aa   776121 3520 04	epp2 	-943,ic		000057 = 524000000046
001737  aa  6 01264 2521 00	spri2	pr6|692
001740  aa  6 01244 6211 00	eax1 	pr6|676
001741  aa   020000 4310 07	fld  	8192,dl
001742  aa  6 00044 3701 20	epp4 	pr6|36,*
001743  la  4 00054 3521 20	epp2 	pr4|44,*		rldr_report_$online_output
001744  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 305
	  rets = "";

001745  aa  6 00232 4501 00	stz  	pr6|154		rets
						STATEMENT 1 ON LINE 306
	  do idx = rldr_input_volume_list.curn_entry + 1 to rldr_input_volume_list.num_entries;

001746  aa  6 00032 3735 20	epp7 	pr6|26,*
001747  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001750  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001751  aa  5 00430 2361 20	ldq  	pr5|280,*		rldr_input_volume_list.num_entries
001752  aa  6 01132 7561 00	stq  	pr6|602
001753  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
001754  aa  3 00001 2361 00	ldq  	pr3|1		rldr_input_volume_list.curn_entry
001755  aa   000001 0760 07	adq  	1,dl
001756  aa  6 00276 7561 00	stq  	pr6|190		idx
001757  aa   000000 0110 03	nop  	0,du
001760  aa  6 00276 2361 00	ldq  	pr6|190		idx
001761  aa  6 01132 1161 00	cmpq 	pr6|602
001762  aa   000200 6054 04	tpnz 	128,ic		002162
						STATEMENT 1 ON LINE 307
	    call ioa_$rsnnl ("^(^a,^)", rets, rets_len, (rets) || " " || rldr_input_volume_list (idx).volname);

001763  aa  6 00232 2361 00	ldq  	pr6|154		rets
001764  aa   000001 0760 07	adq  	1,dl
001765  aa  6 01223 7561 00	stq  	pr6|659
001766  aa   000040 0760 07	adq  	32,dl
001767  aa  6 01266 7561 00	stq  	pr6|694
001770  aa   524000 2760 03	orq  	174080,du
001771  aa  6 01222 7561 00	stq  	pr6|658
001772  aa   776112 2370 04	ldaq 	-950,ic		000104 = 136050136141 054136051000
001773  aa  6 01242 7571 00	staq 	pr6|674
001774  aa  6 00276 2361 00	ldq  	pr6|190		idx
001775  aa   000011 4020 07	mpy  	9,dl
001776  aa  6 01267 7561 00	stq  	pr6|695
001777  aa  6 01223 2361 00	ldq  	pr6|659
002000  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002001  aa  6 00232 7271 00	lxl7 	pr6|154		rets
002002  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002003  aa  6 00233 00 0017	desc9a	pr6|155,x7	rets
002004  aa  2 00000 00 0017	desc9a	pr2|0,x7
002005  aa  6 00232 7271 00	lxl7 	pr6|154		rets
002006  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
002007  aa   006153 00 0001	desc9a	3179,1		010161 = 040000000000
002010  aa  2 00000 00 0001	desc9a	pr2|0,1
002011  aa  6 01266 2361 00	ldq  	pr6|694
002012  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
002013  aa  6 01223 2351 00	lda  	pr6|659
002014  aa  6 00032 3735 20	epp7 	pr6|26,*
002015  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
002016  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
002017  aa  6 01267 7271 00	lxl7 	pr6|695
002020  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
002021  aa  3 77771 3515 17	epp1 	pr3|-7,7		rldr_input_volume_list.volname
002022  aa  040 105 100 500	mlr  	(pr),(pr,al),fill(040)
002023  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_input_volume_list.volname
002024  aa  2 00000 00 0040	desc9a	pr2|0,32
002025  aa  6 01254 2521 00	spri2	pr6|684
002026  aa  6 01242 3521 00	epp2 	pr6|674
002027  aa  6 01246 2521 00	spri2	pr6|678
002030  aa  6 00233 3521 00	epp2 	pr6|155		rets
002031  aa  6 01250 2521 00	spri2	pr6|680
002032  aa  6 00257 3521 00	epp2 	pr6|175		rets_len
002033  aa  6 01252 2521 00	spri2	pr6|682
002034  aa   776022 3520 04	epp2 	-1006,ic		000056 = 524000000007
002035  aa  6 01256 2521 00	spri2	pr6|686
002036  aa   776017 3520 04	epp2 	-1009,ic		000055 = 530000000117
002037  aa  6 01260 2521 00	spri2	pr6|688
002040  aa   776014 3520 04	epp2 	-1012,ic		000054 = 404000000025
002041  aa  6 01262 2521 00	spri2	pr6|690
002042  aa  6 01222 3521 00	epp2 	pr6|658
002043  aa  6 01264 2521 00	spri2	pr6|692
002044  aa  6 01244 6211 00	eax1 	pr6|676
002045  aa   020000 4310 07	fld  	8192,dl
002046  aa  6 00044 3701 20	epp4 	pr6|36,*
002047  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_$rsnnl
002050  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 308
	    if idx ^= rldr_input_volume_list.num_entries then
	      if (rets_len + (length (rtrim (rldr_input_volume_list (idx + 1).volname))) + 2
		 > maxlength (rets)) then do;

002051  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002052  aa  6 00276 2361 00	ldq  	pr6|190		idx
002053  aa  6 00032 3735 20	epp7 	pr6|26,*
002054  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
002055  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
002056  aa  5 00430 1161 20	cmpq 	pr5|280,*		rldr_input_volume_list.num_entries
002057  aa   000101 6000 04	tze  	65,ic		002160
002060  aa   000011 4020 07	mpy  	9,dl
002061  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
002062  aa  3 00002 3515 06	epp1 	pr3|2,ql		rldr_input_volume_list.volname
002063  aa  6 01222 7561 00	stq  	pr6|658
002064  aa  000 000 165 500	tctr 	(pr)
002065  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_input_volume_list.volname
002066  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
002067  aa  6 00056 0001 00	arg  	pr6|46
002070  aa  6 00056 2361 00	ldq  	pr6|46
002071  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002072  aa  6 01266 7561 00	stq  	pr6|694
002073  aa   000040 2360 07	ldq  	32,dl
002074  aa  6 01266 1761 00	sbq  	pr6|694
002075  aa  6 00257 0761 00	adq  	pr6|175		rets_len
002076  aa   000002 0760 07	adq  	2,dl
002077  aa   000117 1160 07	cmpq 	79,dl
002100  aa   000060 6044 04	tmoz 	48,ic		002160
						STATEMENT 1 ON LINE 312
		call rldr_report_$online_output (rldr_datap, 0, "", "^a", rtrim (rets, ","));

002101  aa  6 00232 7271 00	lxl7 	pr6|154		rets
002102  aa  000 000 165 540	tctr 	(pr,rl)
002103  aa  6 00233 00 0017	desc9a	pr6|155,x7	rets
002104  aa  0 76602 0001 00	arg  	pr0|-638		= 777777777777
002105  aa  6 00056 0001 00	arg  	pr6|46
002106  aa  6 00056 2361 00	ldq  	pr6|46
002107  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002110  aa  6 01223 7561 00	stq  	pr6|659
002111  aa  6 00232 2361 00	ldq  	pr6|154		rets
002112  aa  6 01223 1761 00	sbq  	pr6|659
002113  aa  6 01223 7561 00	stq  	pr6|659
002114  aa   524000 2760 03	orq  	174080,du
002115  aa  6 01266 7561 00	stq  	pr6|694
002116  aa  6 01267 4501 00	stz  	pr6|695
002117  aa   136141 2350 03	lda  	48225,du
002120  aa  6 01273 7551 00	sta  	pr6|699
002121  aa  6 01223 2361 00	ldq  	pr6|659
002122  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002123  aa  6 01306 2521 00	spri2	pr6|710
002124  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002125  aa  6 00233 00 0006	desc9a	pr6|155,ql	rets
002126  aa  2 00000 00 0006	desc9a	pr2|0,ql
002127  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
002130  aa  6 01276 2521 00	spri2	pr6|702
002131  aa  6 01267 3521 00	epp2 	pr6|695
002132  aa  6 01300 2521 00	spri2	pr6|704
002133  aa  6 01272 3521 00	epp2 	pr6|698
002134  aa  6 01302 2521 00	spri2	pr6|706
002135  aa  6 01273 3521 00	epp2 	pr6|699
002136  aa  6 01304 2521 00	spri2	pr6|708
002137  aa   775725 3520 04	epp2 	-1067,ic		000064 = 464000000000
002140  aa  6 01310 2521 00	spri2	pr6|712
002141  aa   775720 3520 04	epp2 	-1072,ic		000061 = 404000000005
002142  aa  6 01312 2521 00	spri2	pr6|714
002143  aa   775710 3520 04	epp2 	-1080,ic		000053 = 524000000000
002144  aa  6 01314 2521 00	spri2	pr6|716
002145  aa   775705 3520 04	epp2 	-1083,ic		000052 = 524000000002
002146  aa  6 01316 2521 00	spri2	pr6|718
002147  aa  6 01266 3521 00	epp2 	pr6|694
002150  aa  6 01320 2521 00	spri2	pr6|720
002151  aa  6 01274 6211 00	eax1 	pr6|700
002152  aa   024000 4310 07	fld  	10240,dl
002153  aa  6 00044 3701 20	epp4 	pr6|36,*
002154  la  4 00054 3521 20	epp2 	pr4|44,*		rldr_report_$online_output
002155  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 313
		rets = "";

002156  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002157  aa  6 00232 4501 00	stz  	pr6|154		rets
						STATEMENT 1 ON LINE 314
	        end;

						STATEMENT 1 ON LINE 315
	  end;

002160  aa  6 00276 0541 00	aos  	pr6|190		idx
002161  aa   777577 7100 04	tra  	-129,ic		001760
						STATEMENT 1 ON LINE 316
	  if rets ^= "" then call rldr_report_$online_output (rldr_datap, 0, "", "^a", rtrim (rets, ","));

002162  aa  6 00232 7271 00	lxl7 	pr6|154		rets
002163  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
002164  aa  6 00233 00 0017	desc9a	pr6|155,x7	rets
002165  aa   005774 00 0000	desc9a	3068,0		010157 = 076000000000
002166  aa   000057 6000 04	tze  	47,ic		002245
002167  aa  6 00232 7271 00	lxl7 	pr6|154		rets
002170  aa  000 000 165 540	tctr 	(pr,rl)
002171  aa  6 00233 00 0017	desc9a	pr6|155,x7	rets
002172  aa  0 76602 0001 00	arg  	pr0|-638		= 777777777777
002173  aa  6 00056 0001 00	arg  	pr6|46
002174  aa  6 00056 2361 00	ldq  	pr6|46
002175  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002176  aa  6 01223 7561 00	stq  	pr6|659
002177  aa  6 00232 2361 00	ldq  	pr6|154		rets
002200  aa  6 01223 1761 00	sbq  	pr6|659
002201  aa  6 01223 7561 00	stq  	pr6|659
002202  aa   524000 2760 03	orq  	174080,du
002203  aa  6 01266 7561 00	stq  	pr6|694
002204  aa  6 01273 4501 00	stz  	pr6|699
002205  aa   136141 2350 03	lda  	48225,du
002206  aa  6 01267 7551 00	sta  	pr6|695
002207  aa  6 01223 2361 00	ldq  	pr6|659
002210  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002211  aa  6 01306 2521 00	spri2	pr6|710
002212  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002213  aa  6 00233 00 0006	desc9a	pr6|155,ql	rets
002214  aa  2 00000 00 0006	desc9a	pr2|0,ql
002215  aa  6 00032 3735 20	epp7 	pr6|26,*
002216  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
002217  aa  6 01276 2521 00	spri2	pr6|702
002220  aa  6 01273 3521 00	epp2 	pr6|699
002221  aa  6 01300 2521 00	spri2	pr6|704
002222  aa  6 01272 3521 00	epp2 	pr6|698
002223  aa  6 01302 2521 00	spri2	pr6|706
002224  aa  6 01267 3521 00	epp2 	pr6|695
002225  aa  6 01304 2521 00	spri2	pr6|708
002226  aa   775636 3520 04	epp2 	-1122,ic		000064 = 464000000000
002227  aa  6 01310 2521 00	spri2	pr6|712
002230  aa   775631 3520 04	epp2 	-1127,ic		000061 = 404000000005
002231  aa  6 01312 2521 00	spri2	pr6|714
002232  aa   775621 3520 04	epp2 	-1135,ic		000053 = 524000000000
002233  aa  6 01314 2521 00	spri2	pr6|716
002234  aa   775616 3520 04	epp2 	-1138,ic		000052 = 524000000002
002235  aa  6 01316 2521 00	spri2	pr6|718
002236  aa  6 01266 3521 00	epp2 	pr6|694
002237  aa  6 01320 2521 00	spri2	pr6|720
002240  aa  6 01274 6211 00	eax1 	pr6|700
002241  aa   024000 4310 07	fld  	10240,dl
002242  aa  6 00044 3701 20	epp4 	pr6|36,*
002243  la  4 00054 3521 20	epp2 	pr4|44,*		rldr_report_$online_output
002244  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 317
	end;

002245  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
						STATEMENT 1 ON LINE 318
      end;

						STATEMENT 1 ON LINE 319
    return;

002246  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO collect_stats                                      STATEMENT 1 ON LINE 326
collect_stats: entry (rldr_datap, a_pvindex);

002247  at     000002000064
002250  ta     000072000000
002251  ta     002247000000
002252  da     000416300000
002253  aa   002040 6270 00	eax7 	1056
002254  aa  7 00034 3521 20	epp2 	pr7|28,*
002255  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002256  aa     000004000000
002257  aa     000000000000
002260  aa  6 00032 3735 20	epp7 	pr6|26,*
002261  aa  7 00004 3715 20	epp5 	pr7|4,*
002262  aa  6 01126 6515 00	spri5	pr6|598
002263  aa   776514 7000 04	tsx0 	-692,ic		000777
						STATEMENT 1 ON LINE 331
    entry = collect_stats;

002264  aa   000004 2360 07	ldq  	4,dl
002265  aa  6 00273 7561 00	stq  	pr6|187		entry
						STATEMENT 1 ON LINE 332
    pvindex = a_pvindex;

002266  aa  6 01126 2361 20	ldq  	pr6|598,*		a_pvindex
002267  aa  6 00275 7561 00	stq  	pr6|189		pvindex
						STATEMENT 1 ON LINE 333
    recordp = rldr_data_.volume_record_bp;

002270  aa  6 00032 3735 20	epp7 	pr6|26,*
002271  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
002272  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
002273  aa  5 00422 3535 20	epp3 	pr5|274,*		rldr_data_.volume_record_bp
002274  aa  6 00356 2535 00	spri3	pr6|238		recordp
						STATEMENT 1 ON LINE 334
    controlp = rldr_data_.controlp (pvindex);

002275  aa   000064 4020 07	mpy  	52,dl
002276  aa  5 00430 3515 26	epp1 	pr5|280,ql*	rldr_data_.controlp
002277  aa  6 01100 2515 00	spri1	pr6|576		controlp
						STATEMENT 1 ON LINE 338
    if backup_volume_record.uid ^= "0"b then do;

002300  aa  3 00014 2351 00	lda  	pr3|12		backup_volume_record.uid
002301  aa   000034 6000 04	tze  	28,ic		002335
						STATEMENT 1 ON LINE 340
        if backup_volume_record.dirsw then do;

002302  aa  3 00020 2351 00	lda  	pr3|16		backup_volume_record.dirsw
002303  aa   400000 3150 07	cana 	131072,dl
002304  aa   000015 6000 04	tze  	13,ic		002321
						STATEMENT 1 ON LINE 341
	  rldr_control.dir_num = rldr_control.dir_num + 1;

002305  aa  1 00010 0541 00	aos  	pr1|8		rldr_control.dir_num
						STATEMENT 1 ON LINE 342
	  rldr_control.dir_rec = rldr_control.dir_rec + fixed (backup_volume_record.records);

002306  aa  3 00015 2351 00	lda  	pr3|13		backup_volume_record.records
002307  aa   000022 7350 00	als  	18
002310  aa   000077 7730 00	lrl  	63
002311  aa  6 01270 7571 00	staq 	pr6|696
002312  aa  1 00011 0331 00	adl  	pr1|9		rldr_control.dir_rec
002313  aa  1 00011 7561 00	stq  	pr1|9		rldr_control.dir_rec
						STATEMENT 1 ON LINE 343
	  rldr_control.input_vol_dir_num = rldr_control.input_vol_dir_num + 1;

002314  aa  1 00014 0541 00	aos  	pr1|12		rldr_control.input_vol_dir_num
						STATEMENT 1 ON LINE 344
	  rldr_control.input_vol_dir_rec = rldr_control.input_vol_dir_rec +
	       fixed (backup_volume_record.records);

002315  aa  6 01270 2371 00	ldaq 	pr6|696
002316  aa  1 00015 0331 00	adl  	pr1|13		rldr_control.input_vol_dir_rec
002317  aa  1 00015 7561 00	stq  	pr1|13		rldr_control.input_vol_dir_rec
						STATEMENT 1 ON LINE 346
	end;

002320  aa   000016 7100 04	tra  	14,ic		002336
						STATEMENT 1 ON LINE 347
        else do;

						STATEMENT 1 ON LINE 348
	  rldr_control.seg_num = rldr_control.seg_num + 1;

002321  aa  1 00012 0541 00	aos  	pr1|10		rldr_control.seg_num
						STATEMENT 1 ON LINE 349
	  rldr_control.input_vol_seg_num = rldr_control.input_vol_seg_num + 1;

002322  aa  1 00016 0541 00	aos  	pr1|14		rldr_control.input_vol_seg_num
						STATEMENT 1 ON LINE 350
	  rldr_control.input_vol_seg_rec = rldr_control.input_vol_seg_rec +
	       fixed (backup_volume_record.records);

002323  aa  3 00015 2351 00	lda  	pr3|13		backup_volume_record.records
002324  aa   000022 7350 00	als  	18
002325  aa   000077 7730 00	lrl  	63
002326  aa  6 01270 7571 00	staq 	pr6|696
002327  aa  1 00017 0331 00	adl  	pr1|15		rldr_control.input_vol_seg_rec
002330  aa  1 00017 7561 00	stq  	pr1|15		rldr_control.input_vol_seg_rec
						STATEMENT 1 ON LINE 352
	  rldr_control.seg_rec = rldr_control.seg_rec + fixed (backup_volume_record.records);

002331  aa  6 01270 2371 00	ldaq 	pr6|696
002332  aa  1 00013 0331 00	adl  	pr1|11		rldr_control.seg_rec
002333  aa  1 00013 7561 00	stq  	pr1|11		rldr_control.seg_rec
						STATEMENT 1 ON LINE 353
	end;

						STATEMENT 1 ON LINE 354
      end;

002334  aa   000002 7100 04	tra  	2,ic		002336
						STATEMENT 1 ON LINE 355
    else rldr_control.num_null_vtoce = rldr_control.num_null_vtoce + 1;

002335  aa  1 00020 0541 00	aos  	pr1|16		rldr_control.num_null_vtoce
						STATEMENT 1 ON LINE 356
    return;

002336  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1143
  end rldr_input_;

BEGIN PROCEDURE log_volume_name
ENTRY TO log_volume_name                                    STATEMENT 1 ON LINE 363
log_volume_name: proc;

002337  aa  6 01134 6501 00	spri4	pr6|604
						STATEMENT 1 ON LINE 370
    if bvle.dir_num = 0 & bvle.seg_num = 0 then return;

002340  aa  6 00350 3735 20	epp7 	pr6|232,*		bvlep
002341  aa  7 00037 2351 00	lda  	pr7|31		bvle.dir_num
002342  aa   000066 7330 00	lrs  	54
002343  aa   000005 6010 04	tnz  	5,ic		002350
002344  aa  7 00040 2351 00	lda  	pr7|32		bvle.seg_num
002345  aa   000066 7330 00	lrs  	54
002346  aa   000002 6010 04	tnz  	2,ic		002350
002347  aa  6 01134 6101 00	rtcd 	pr6|604
						STATEMENT 1 ON LINE 371
    if rldr_data_.save & bvle.open_time < time_unmounted then return;

002350  aa  6 00032 3715 20	epp5 	pr6|26,*
002351  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
002352  aa  3 00000 2351 20	lda  	pr3|0,*		rldr_data_.save
002353  aa   400000 3150 03	cana 	131072,du
002354  aa   000005 6000 04	tze  	5,ic		002361
002355  aa  7 00012 2371 00	ldaq 	pr7|10		bvle.open_time
002356  aa  6 00266 1171 00	cmpaq	pr6|182		time_unmounted
002357  aa   000002 6050 04	tpl  	2,ic		002361
002360  aa  6 01134 6101 00	rtcd 	pr6|604
						STATEMENT 1 ON LINE 373
    do sortx = 1 to vlx;

002361  aa  6 00274 2361 00	ldq  	pr6|188		vlx
002362  aa  6 01142 7561 00	stq  	pr6|610
002363  aa   000001 2360 07	ldq  	1,dl
002364  aa  6 00277 7561 00	stq  	pr6|191		sortx
002365  aa   000000 0110 03	nop  	0,du
002366  aa  6 00277 2361 00	ldq  	pr6|191		sortx
002367  aa  6 01142 1161 00	cmpq 	pr6|610
002370  aa   000023 6054 04	tpnz 	19,ic		002413
						STATEMENT 1 ON LINE 374
      if rldr_input_volume_list (sortx).volname = bvle.volname
	 & rldr_input_volume_list (sortx).volid = bvle.volid then return;

002371  aa   000011 4020 07	mpy  	9,dl
002372  aa  6 01322 7561 00	stq  	pr6|722
002373  aa  6 00032 3735 20	epp7 	pr6|26,*
002374  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
002375  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
002376  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
002377  aa  3 77771 3515 06	epp1 	pr3|-7,ql		rldr_input_volume_list.volname
002400  aa  6 00350 3735 20	epp7 	pr6|232,*		bvlep
002401  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
002402  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_input_volume_list.volname
002403  aa  7 00002 00 0040	desc9a	pr7|2,32		bvle.volname
002404  aa   000005 6010 04	tnz  	5,ic		002411
002405  aa  3 00001 2351 06	lda  	pr3|1,ql		rldr_input_volume_list.volid
002406  aa  7 00016 1151 00	cmpa 	pr7|14		bvle.volid
002407  aa   000002 6010 04	tnz  	2,ic		002411
002410  aa  6 01134 6101 00	rtcd 	pr6|604
						STATEMENT 1 ON LINE 376
    end;

002411  aa  6 00277 0541 00	aos  	pr6|191		sortx
002412  aa   777754 7100 04	tra  	-20,ic		002366
						STATEMENT 1 ON LINE 378
    do sortx = 1 to rldr_skip_list.next;

002413  aa  6 01102 2361 20	ldq  	pr6|578,*		rldr_skip_list.next
002414  aa  6 01143 7561 00	stq  	pr6|611
002415  aa   000001 2360 07	ldq  	1,dl
002416  aa  6 00277 7561 00	stq  	pr6|191		sortx
002417  aa   000000 0110 03	nop  	0,du
002420  aa  6 00277 2361 00	ldq  	pr6|191		sortx
002421  aa  6 01143 1161 00	cmpq 	pr6|611
002422  aa   000015 6054 04	tpnz 	13,ic		002437
						STATEMENT 1 ON LINE 379
      if rldr_skip_list (sortx).volname = bvle.volname then return;

002423  aa   000003 7360 00	qls  	3
002424  aa  6 01322 7561 00	stq  	pr6|722
002425  aa  6 01102 3735 20	epp7 	pr6|578,*		skip
002426  aa  7 77771 3735 06	epp7 	pr7|-7,ql		rldr_skip_list.volname
002427  aa  6 00350 3715 20	epp5 	pr6|232,*		bvlep
002430  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
002431  aa  7 00000 00 0040	desc9a	pr7|0,32		rldr_skip_list.volname
002432  aa  5 00002 00 0040	desc9a	pr5|2,32		bvle.volname
002433  aa   000002 6010 04	tnz  	2,ic		002435
002434  aa  6 01134 6101 00	rtcd 	pr6|604
						STATEMENT 1 ON LINE 380
    end;

002435  aa  6 00277 0541 00	aos  	pr6|191		sortx
002436  aa   777762 7100 04	tra  	-14,ic		002420
						STATEMENT 1 ON LINE 382
    if bvle.io_module ^= rldr_data_.io_module then do;

002437  aa  6 00350 3735 20	epp7 	pr6|232,*		bvlep
002440  aa  6 00032 3715 20	epp5 	pr6|26,*
002441  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
002442  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
002443  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
002444  aa  7 00017 00 0040	desc9a	pr7|15,32		bvle.io_module
002445  aa  3 00171 00 0040	desc9a	pr3|121,32	rldr_data_.io_module
002446  aa   000064 6000 04	tze  	52,ic		002532
						STATEMENT 1 ON LINE 383
        query_info.version = query_info_version_5;

002447  aa   000005 2360 07	ldq  	5,dl
002450  aa  6 01104 7561 00	stq  	pr6|580		query_info.version
						STATEMENT 1 ON LINE 384
        call command_query_$yes_no (YES, 0, myname, "",
	   "io outer module ^a which wrote volume ^a is different than that specified to read the volume.
 Do you wish to use the volume ?", bvle.io_module, bvle.volname);

002451  aa  6 01322 4501 00	stz  	pr6|722
002452  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002453  aa   776265 00 0200	desc9a	-843,128		000737 = 151157040157
002454  aa  6 01324 00 0200	desc9a	pr6|724,128
002455  aa  6 00124 3521 00	epp2 	pr6|84		YES
002456  aa  6 01366 2521 00	spri2	pr6|758
002457  aa  6 01322 3521 00	epp2 	pr6|722
002460  aa  6 01370 2521 00	spri2	pr6|760
002461  aa   775323 3520 04	epp2 	-1325,ic		000004 = 162154144162
002462  aa  6 01372 2521 00	spri2	pr6|762
002463  aa  6 01323 3521 00	epp2 	pr6|723
002464  aa  6 01374 2521 00	spri2	pr6|764
002465  aa  6 01324 3521 00	epp2 	pr6|724
002466  aa  6 01376 2521 00	spri2	pr6|766
002467  aa  7 00017 3521 00	epp2 	pr7|15		bvle.io_module
002470  aa  6 01400 2521 00	spri2	pr6|768
002471  aa  7 00002 3521 00	epp2 	pr7|2		bvle.volname
002472  aa  6 01402 2521 00	spri2	pr6|770
002473  aa   775402 3520 04	epp2 	-1278,ic		000075 = 516000000001
002474  aa  6 01404 2521 00	spri2	pr6|772
002475  aa   775364 3520 04	epp2 	-1292,ic		000061 = 404000000005
002476  aa  6 01406 2521 00	spri2	pr6|774
002477  aa   775364 3520 04	epp2 	-1292,ic		000063 = 530000000040
002500  aa  6 01410 2521 00	spri2	pr6|776
002501  aa   775352 3520 04	epp2 	-1302,ic		000053 = 524000000000
002502  aa  6 01412 2521 00	spri2	pr6|778
002503  aa   775346 3520 04	epp2 	-1306,ic		000051 = 524000000176
002504  aa  6 01414 2521 00	spri2	pr6|780
002505  aa   775343 3520 04	epp2 	-1309,ic		000050 = 524000000040
002506  aa  6 01416 2521 00	spri2	pr6|782
002507  aa  6 01420 2521 00	spri2	pr6|784
002510  aa  6 01364 6211 00	eax1 	pr6|756
002511  aa   034000 4310 07	fld  	14336,dl
002512  aa  6 00044 3701 20	epp4 	pr6|36,*
002513  la  4 00040 3521 20	epp2 	pr4|32,*		command_query_$yes_no
002514  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 387
        if ^YES then do;

002515  aa  6 00124 2351 00	lda  	pr6|84		YES
002516  aa   400000 3150 03	cana 	131072,du
002517  aa   000013 6010 04	tnz  	11,ic		002532
						STATEMENT 1 ON LINE 388
	  rldr_skip_list.next = rldr_skip_list.next + 1;

002520  aa  6 01102 0541 20	aos  	pr6|578,*		rldr_skip_list.next
						STATEMENT 1 ON LINE 389
	  rldr_skip_list (rldr_skip_list.next).volname = bvle.volname;

002521  aa  6 01102 2361 20	ldq  	pr6|578,*		rldr_skip_list.next
002522  aa   000003 7360 00	qls  	3
002523  aa  6 01102 3735 20	epp7 	pr6|578,*		skip
002524  aa  7 77771 3735 06	epp7 	pr7|-7,ql		rldr_skip_list.volname
002525  aa  6 00350 3715 20	epp5 	pr6|232,*		bvlep
002526  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002527  aa  5 00002 00 0040	desc9a	pr5|2,32		bvle.volname
002530  aa  7 00000 00 0040	desc9a	pr7|0,32		rldr_skip_list.volname
						STATEMENT 1 ON LINE 390
	  return;

002531  aa  6 01134 6101 00	rtcd 	pr6|604
						STATEMENT 1 ON LINE 391
	end;

						STATEMENT 1 ON LINE 392
      end;

						STATEMENT 1 ON LINE 394
    vlx = vlx + 1;

002532  aa  6 00274 0541 00	aos  	pr6|188		vlx
						STATEMENT 1 ON LINE 395
    rldr_input_volume_list (vlx).volname = bvle.volname;

002533  aa  6 00274 2361 00	ldq  	pr6|188		vlx
002534  aa   000011 4020 07	mpy  	9,dl
002535  aa  6 00032 3735 20	epp7 	pr6|26,*
002536  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
002537  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
002540  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
002541  aa  3 77771 3515 06	epp1 	pr3|-7,ql		rldr_input_volume_list.volname
002542  aa  6 00350 3735 20	epp7 	pr6|232,*		bvlep
002543  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002544  aa  7 00002 00 0040	desc9a	pr7|2,32		bvle.volname
002545  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_input_volume_list.volname
						STATEMENT 1 ON LINE 396
    rldr_input_volume_list (vlx).volid = bvle.volid;

002546  aa  7 00016 2351 00	lda  	pr7|14		bvle.volid
002547  aa  3 00001 7551 06	sta  	pr3|1,ql		rldr_input_volume_list.volid
						STATEMENT 1 ON LINE 398
  end log_volume_name;

002550  aa  6 01134 6101 00	rtcd 	pr6|604
  END PROCEDURE log_volume_name
BEGIN PROCEDURE read_volume_record
ENTRY TO read_volume_record                                 STATEMENT 1 ON LINE 405
read_volume_record: proc;

002551  aa  6 01144 6501 00	spri4	pr6|612
						STATEMENT 1 ON LINE 412
    pattern_match_label = pattern_match;

002552  aa   000073 3520 04	epp2 	59,ic		002645 = 600123450100
002553  aa  6 00100 2521 00	spri2	pr6|64		pattern_match_label
002554  aa  6 00102 6521 00	spri6	pr6|66		pattern_match_label
						STATEMENT 1 ON LINE 413
    new_volume = "0"b;

002555  aa  6 00123 4501 00	stz  	pr6|83		new_volume
						STATEMENT 1 ON LINE 415
    if skip_next_header_check then do;

002556  aa  6 01122 3735 20	epp7 	pr6|594,*
002557  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
002560  aa  7 00000 00 0001	descb	pr7|0,1		skip_next_header_check
002561  aa   000000 00 0000	descb	0,0
002562  aa   000006 6000 04	tze  	6,ic		002570
						STATEMENT 1 ON LINE 416
        skip_next_header_check = "0"b;

002563  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
002564  aa   000000 00 0000	descb	0,0
002565  aa  7 00000 00 0001	descb	pr7|0,1		skip_next_header_check
						STATEMENT 1 ON LINE 417
        goto pattern_match_label;

002566  aa  6 00100 3521 00	epp2 	pr6|64		pattern_match_label
002567  aa  0 00660 7101 00	tra  	pr0|432		tra_ext_2
						STATEMENT 1 ON LINE 418
      end;

						STATEMENT 1 ON LINE 419
    nel = CHARS_PER_WORD * size (backup_volume_header);

002570  aa   000040 2360 07	ldq  	32,dl
002571  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 420
    call read (recordp, nel, nelt, ^DELIMITED, code);

002572  aa   400000 2350 03	lda  	131072,du
002573  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
002574  aa  6 01422 7551 00	sta  	pr6|786
002575  aa  6 00356 3521 00	epp2 	pr6|238		recordp
002576  aa  6 01426 2521 00	spri2	pr6|790
002577  aa  6 00301 3521 00	epp2 	pr6|193		nel
002600  aa  6 01430 2521 00	spri2	pr6|792
002601  aa  6 00302 3521 00	epp2 	pr6|194		nelt
002602  aa  6 01432 2521 00	spri2	pr6|794
002603  aa  6 01422 3521 00	epp2 	pr6|786
002604  aa  6 01434 2521 00	spri2	pr6|796
002605  aa  6 01124 3521 20	epp2 	pr6|596,*		code
002606  aa  6 01436 2521 00	spri2	pr6|798
002607  aa  6 01424 6211 00	eax1 	pr6|788
002610  aa   024000 4310 07	fld  	10240,dl
002611  aa   004513 3520 04	epp2 	2379,ic		007324 = 000140627000
002612  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 421
    call check_input_error;

002613  aa  6 00056 6211 00	eax1 	pr6|46
002614  aa   000000 4310 07	fld  	0,dl
002615  aa   000645 3520 04	epp2 	421,ic		003462 = 000500627000
002616  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 422
    if new_volume then return;

002617  aa  6 00123 2351 00	lda  	pr6|83		new_volume
002620  aa   000002 6000 04	tze  	2,ic		002622
002621  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 424
    if backup_volume_record.pattern1 ^= pattern1
         | backup_volume_record.pattern2 ^= pattern2
         | backup_volume_record.pattern3 ^= pattern3 then do;

002622  aa  6 00356 2351 20	lda  	pr6|238,*		backup_volume_record.pattern1
002623  aa   775157 1150 04	cmpa 	-1425,ic		000002 = 670314355245
002624  aa   000010 6010 04	tnz  	8,ic		002634
002625  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
002626  aa  7 00003 2351 00	lda  	pr7|3		backup_volume_record.pattern2
002627  aa   775152 1150 04	cmpa 	-1430,ic		000001 = 512556146073
002630  aa   000004 6010 04	tnz  	4,ic		002634
002631  aa  7 00006 2351 00	lda  	pr7|6		backup_volume_record.pattern3
002632  aa   775146 1150 04	cmpa 	-1434,ic		000000 = 107463422532
002633  aa   000012 6000 04	tze  	10,ic		002645
						STATEMENT 1 ON LINE 427
        code = -1;

002634  aa   000001 3360 07	lcq  	1,dl
002635  aa  6 01124 7561 20	stq  	pr6|596,*		code
						STATEMENT 1 ON LINE 428
        call check_input_error;

002636  aa  6 00056 6211 00	eax1 	pr6|46
002637  aa   000000 4310 07	fld  	0,dl
002640  aa   000622 3520 04	epp2 	402,ic		003462 = 000500627000
002641  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 429
        if new_volume then return;

002642  aa  6 00123 2351 00	lda  	pr6|83		new_volume
002643  aa   000002 6000 04	tze  	2,ic		002645
002644  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 430
      end;

						STATEMENT 1 ON LINE 432
pattern_match:
    new_volume = "0"b;

002645  aa  6 00123 4501 00	stz  	pr6|83		new_volume
						STATEMENT 1 ON LINE 435
    nel = backup_volume_record.rec1_len - size (backup_volume_header) * CHARS_PER_WORD;

002646  aa   000040 2360 07	ldq  	32,dl
002647  aa  6 01422 7561 00	stq  	pr6|786
002650  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
002651  aa  7 00002 2361 00	ldq  	pr7|2		backup_volume_record.rec1_len
002652  aa  6 01422 1761 00	sbq  	pr6|786
002653  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 436
    call read (ptr (recordp, size (backup_volume_header)),
         nel, nelt, ^DELIMITED, code);

002654  aa  7 00000 3521 00	epp2 	pr7|0
002655  aa   000010 3120 00	eawp2	8
002656  aa  6 01442 2521 00	spri2	pr6|802
002657  aa   400000 2350 03	lda  	131072,du
002660  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
002661  aa  6 01422 7551 00	sta  	pr6|786
002662  aa  6 01442 3521 00	epp2 	pr6|802
002663  aa  6 01426 2521 00	spri2	pr6|790
002664  aa  6 00301 3521 00	epp2 	pr6|193		nel
002665  aa  6 01430 2521 00	spri2	pr6|792
002666  aa  6 00302 3521 00	epp2 	pr6|194		nelt
002667  aa  6 01432 2521 00	spri2	pr6|794
002670  aa  6 01422 3521 00	epp2 	pr6|786
002671  aa  6 01434 2521 00	spri2	pr6|796
002672  aa  6 01124 3521 20	epp2 	pr6|596,*		code
002673  aa  6 01436 2521 00	spri2	pr6|798
002674  aa  6 01424 6211 00	eax1 	pr6|788
002675  aa   024000 4310 07	fld  	10240,dl
002676  aa   004426 3520 04	epp2 	2326,ic		007324 = 000140627000
002677  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 438
    call check_input_error;

002700  aa  6 00056 6211 00	eax1 	pr6|46
002701  aa   000000 4310 07	fld  	0,dl
002702  aa   000560 3520 04	epp2 	368,ic		003462 = 000500627000
002703  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 439
    if new_volume then return;

002704  aa  6 00123 2351 00	lda  	pr6|83		new_volume
002705  aa   000002 6000 04	tze  	2,ic		002707
002706  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 441
    if backup_volume_record.rec1_type = info_type then do;

002707  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
002710  aa  7 00001 2361 00	ldq  	pr7|1		backup_volume_record.rec1_type
002711  aa   000010 1160 07	cmpq 	8,dl
002712  aa   000005 6010 04	tnz  	5,ic		002717
						STATEMENT 1 ON LINE 442
        call record_info;

002713  aa   003462 6700 04	tsp4 	1842,ic		006375
						STATEMENT 1 ON LINE 443
        if code ^= 0 then return;

002714  aa  6 01124 2361 20	ldq  	pr6|596,*		code
002715  aa   000002 6000 04	tze  	2,ic		002717
002716  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 444
      end;

						STATEMENT 1 ON LINE 446
    if backup_volume_record.rec1_type ^= vtoce_type then do;

002717  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
002720  aa  7 00001 2361 00	ldq  	pr7|1		backup_volume_record.rec1_type
002721  aa   000001 1160 07	cmpq 	1,dl
002722  aa   000006 6000 04	tze  	6,ic		002730
						STATEMENT 1 ON LINE 447
        nel = backup_volume_record.rec2_len;

002723  aa  7 00005 2361 00	ldq  	pr7|5		backup_volume_record.rec2_len
002724  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 448
        if nel ^= 0 then call skip_chars;

002725  aa   000002 6000 04	tze  	2,ic		002727
002726  aa   000464 6700 04	tsp4 	308,ic		003412
						STATEMENT 1 ON LINE 449
        return;

002727  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 450
      end;

						STATEMENT 1 ON LINE 452
    if backup_volume_record.version ^= backup_volume_record_version_1 &
         backup_volume_record.version ^= backup_volume_record_version_2 then do;

002730  aa  7 00010 2361 00	ldq  	pr7|8		backup_volume_record.version
002731  aa   000001 1160 07	cmpq 	1,dl
002732  aa   000047 6000 04	tze  	39,ic		003001
002733  aa   000002 1160 07	cmpq 	2,dl
002734  aa   000045 6000 04	tze  	37,ic		003001
						STATEMENT 1 ON LINE 454
bad_record: call rldr_report_$error_output (rldr_datap, 0, myname, "Invalid volume record on dump volume",
	   volname);

002735  aa  6 01422 4501 00	stz  	pr6|786
002736  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002737  aa   775421 00 0044	desc9a	-1263,36		000357 = 111156166141
002740  aa  6 01424 00 0044	desc9a	pr6|788,36
002741  aa  6 00032 3715 20	epp5 	pr6|26,*
002742  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
002743  aa  6 01446 2521 00	spri2	pr6|806
002744  aa  6 01422 3521 00	epp2 	pr6|786
002745  aa  6 01450 2521 00	spri2	pr6|808
002746  aa   775036 3520 04	epp2 	-1506,ic		000004 = 162154144162
002747  aa  6 01452 2521 00	spri2	pr6|810
002750  aa  6 01424 3521 00	epp2 	pr6|788
002751  aa  6 01454 2521 00	spri2	pr6|812
002752  aa  6 00333 3521 00	epp2 	pr6|219		volname
002753  aa  6 01456 2521 00	spri2	pr6|814
002754  aa   775110 3520 04	epp2 	-1464,ic		000064 = 464000000000
002755  aa  6 01460 2521 00	spri2	pr6|816
002756  aa   775103 3520 04	epp2 	-1469,ic		000061 = 404000000005
002757  aa  6 01462 2521 00	spri2	pr6|818
002760  aa   775103 3520 04	epp2 	-1469,ic		000063 = 530000000040
002761  aa  6 01464 2521 00	spri2	pr6|820
002762  aa   775065 3520 04	epp2 	-1483,ic		000047 = 524000000044
002763  aa  6 01466 2521 00	spri2	pr6|822
002764  aa   775104 3520 04	epp2 	-1468,ic		000070 = 526000000040
002765  aa  6 01470 2521 00	spri2	pr6|824
002766  aa  6 01444 6211 00	eax1 	pr6|804
002767  aa   024000 4310 07	fld  	10240,dl
002770  aa  6 00044 3701 20	epp4 	pr6|36,*
002771  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
002772  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 456
        nel = backup_volume_record.rec2_len;

002773  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
002774  aa  7 00005 2361 00	ldq  	pr7|5		backup_volume_record.rec2_len
002775  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 457
        if nel ^= 0 then call skip_chars;

002776  aa   000002 6000 04	tze  	2,ic		003000
002777  aa   000413 6700 04	tsp4 	267,ic		003412
						STATEMENT 1 ON LINE 458
        return;

003000  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 459
      end;

						STATEMENT 1 ON LINE 461
    if backup_volume_record.uid ^= "0"b then do;

003001  aa  7 00014 2351 00	lda  	pr7|12		backup_volume_record.uid
003002  aa   000030 6000 04	tze  	24,ic		003032
						STATEMENT 1 ON LINE 462
        rldr_data_.last_valid_puid = backup_volume_record.uid_path;

003003  aa   000001 2360 07	ldq  	1,dl
003004  aa  6 01152 7561 00	stq  	pr6|618
003005  aa   000000 0110 03	nop  	0,du
003006  aa  6 01152 7271 00	lxl7 	pr6|618
003007  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
003010  aa  7 00252 2351 17	lda  	pr7|170,7		backup_volume_record.uid_path
003011  aa  6 00032 3715 20	epp5 	pr6|26,*
003012  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
003013  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
003014  aa  3 00004 7551 17	sta  	pr3|4,7		rldr_data_.last_valid_puid
003015  aa  6 01152 2361 00	ldq  	pr6|618
003016  aa  6 01152 0541 00	aos  	pr6|618
003017  aa   000020 1160 07	cmpq 	16,dl
003020  aa   777766 6040 04	tmi  	-10,ic		003006
						STATEMENT 1 ON LINE 463
        rldr_data_.last_valid_vtoce_ename = backup_volume_record.primary_name;

003021  aa  5 00002 3515 20	epp1 	pr5|2,*		rldr_datap
003022  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
003023  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003024  aa  7 00273 00 0040	desc9a	pr7|187,32	backup_volume_record.primary_name
003025  aa  1 00151 00 0040	desc9a	pr1|105,32	rldr_data_.last_valid_vtoce_ename
						STATEMENT 1 ON LINE 464
        rldr_data_.last_pvid = backup_volume_record.pvid;

003026  aa  7 00011 2351 00	lda  	pr7|9		backup_volume_record.pvid
003027  aa  1 00002 7551 00	sta  	pr1|2		rldr_data_.last_pvid
						STATEMENT 1 ON LINE 465
        rldr_data_.last_vtocx = backup_volume_record.vtocx;

003030  aa  7 00012 2361 00	ldq  	pr7|10		backup_volume_record.vtocx
003031  aa  1 00403 7561 00	stq  	pr1|259		rldr_data_.last_vtocx
						STATEMENT 1 ON LINE 466
      end;

						STATEMENT 1 ON LINE 468
    if resynching_completed & backup_volume_record.uid ^= "0"b then do;

003032  aa  6 00121 2351 00	lda  	pr6|81		resynching_completed
003033  aa   000160 6000 04	tze  	112,ic		003213
003034  aa  7 00014 2351 00	lda  	pr7|12		backup_volume_record.uid
003035  aa   000156 6000 04	tze  	110,ic		003213
						STATEMENT 1 ON LINE 469
        resynching_completed = "0"b;

003036  aa  6 00121 4501 00	stz  	pr6|81		resynching_completed
						STATEMENT 1 ON LINE 470
        call find_volname ((backup_volume_record.pvid), pvname, lvname, code);

003037  aa  7 00011 2351 00	lda  	pr7|9		backup_volume_record.pvid
003040  aa  6 01422 7551 00	sta  	pr6|786
003041  aa  6 01422 3521 00	epp2 	pr6|786
003042  aa  6 01426 2521 00	spri2	pr6|790
003043  aa  6 00313 3521 00	epp2 	pr6|203		pvname
003044  aa  6 01430 2521 00	spri2	pr6|792
003045  aa  6 00323 3521 00	epp2 	pr6|211		lvname
003046  aa  6 01432 2521 00	spri2	pr6|794
003047  aa  6 01124 3521 20	epp2 	pr6|596,*		code
003050  aa  6 01434 2521 00	spri2	pr6|796
003051  aa  6 01424 6211 00	eax1 	pr6|788
003052  aa   020000 4310 07	fld  	8192,dl
003053  aa   004174 3520 04	epp2 	2172,ic		007247 = 000140627000
003054  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 471
        if code = 0 then
	call rldr_report_$error_output (rldr_datap, 0, myname,
	     "first object after resynching ^a on pv ^a ^[(vtocx = ^d)^;^s^] of logical volume ^a",
	     convert_puid_ (), pvname, (backup_volume_record.pvid ^= (36)"0"b),
	     backup_volume_record.vtocx, lvname);

003055  aa  6 01124 2361 20	ldq  	pr6|596,*		code
003056  aa   000071 6010 04	tnz  	57,ic		003147
003057  aa  6 01422 4501 00	stz  	pr6|786
003060  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003061  aa   775511 00 0124	desc9a	-1207,84		000571 = 146151162163
003062  aa  6 01444 00 0124	desc9a	pr6|804,84
003063  aa  6 01472 3521 00	epp2 	pr6|826
003064  aa  6 01426 2521 00	spri2	pr6|790
003065  aa  6 01424 6211 00	eax1 	pr6|788
003066  aa   004000 4310 07	fld  	2048,dl
003067  aa   003761 3520 04	epp2 	2033,ic		007050 = 000340627000
003070  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
003071  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
003072  aa  7 00011 2351 00	lda  	pr7|9		backup_volume_record.pvid
003073  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
003074  aa  6 01423 7551 00	sta  	pr6|787
003075  aa  6 00032 3715 20	epp5 	pr6|26,*
003076  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003077  aa  6 01546 2521 00	spri2	pr6|870
003100  aa  6 01422 3521 00	epp2 	pr6|786
003101  aa  6 01550 2521 00	spri2	pr6|872
003102  aa   774702 3520 04	epp2 	-1598,ic		000004 = 162154144162
003103  aa  6 01552 2521 00	spri2	pr6|874
003104  aa  6 01444 3521 00	epp2 	pr6|804
003105  aa  6 01554 2521 00	spri2	pr6|876
003106  aa  6 01472 3521 00	epp2 	pr6|826
003107  aa  6 01556 2521 00	spri2	pr6|878
003110  aa  6 00313 3521 00	epp2 	pr6|203		pvname
003111  aa  6 01560 2521 00	spri2	pr6|880
003112  aa  6 01423 3521 00	epp2 	pr6|787
003113  aa  6 01562 2521 00	spri2	pr6|882
003114  aa  7 00012 3521 00	epp2 	pr7|10		backup_volume_record.vtocx
003115  aa  6 01564 2521 00	spri2	pr6|884
003116  aa  6 00323 3521 00	epp2 	pr6|211		lvname
003117  aa  6 01566 2521 00	spri2	pr6|886
003120  aa   774744 3520 04	epp2 	-1564,ic		000064 = 464000000000
003121  aa  6 01570 2521 00	spri2	pr6|888
003122  aa   774737 3520 04	epp2 	-1569,ic		000061 = 404000000005
003123  aa  6 01572 2521 00	spri2	pr6|890
003124  aa   774737 3520 04	epp2 	-1569,ic		000063 = 530000000040
003125  aa  6 01574 2521 00	spri2	pr6|892
003126  aa   774720 3520 04	epp2 	-1584,ic		000046 = 524000000123
003127  aa  6 01576 2521 00	spri2	pr6|894
003130  aa   774715 3520 04	epp2 	-1587,ic		000045 = 524000000250
003131  aa  6 01600 2521 00	spri2	pr6|896
003132  aa   774736 3520 04	epp2 	-1570,ic		000070 = 526000000040
003133  aa  6 01602 2521 00	spri2	pr6|898
003134  aa  6 01610 2521 00	spri2	pr6|904
003135  aa   774707 3520 04	epp2 	-1593,ic		000044 = 514000000001
003136  aa  6 01604 2521 00	spri2	pr6|900
003137  aa   774733 3520 04	epp2 	-1573,ic		000072 = 404000000021
003140  aa  6 01606 2521 00	spri2	pr6|902
003141  aa  6 01544 6211 00	eax1 	pr6|868
003142  aa   044000 4310 07	fld  	18432,dl
003143  aa  6 00044 3701 20	epp4 	pr6|36,*
003144  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003145  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
003146  aa   000045 7100 04	tra  	37,ic		003213
						STATEMENT 1 ON LINE 476
        else call rldr_report_$error_output (rldr_datap, 0, myname,
	        "first object after resynching ^a", convert_puid_ ());

003147  aa  6 01423 4501 00	stz  	pr6|787
003150  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003151  aa   775421 00 0040	desc9a	-1263,32		000571 = 146151162163
003152  aa  6 01424 00 0040	desc9a	pr6|788,32
003153  aa  6 01472 3521 00	epp2 	pr6|826
003154  aa  6 01446 2521 00	spri2	pr6|806
003155  aa  6 01444 6211 00	eax1 	pr6|804
003156  aa   004000 4310 07	fld  	2048,dl
003157  aa   003671 3520 04	epp2 	1977,ic		007050 = 000340627000
003160  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
003161  aa  6 00032 3735 20	epp7 	pr6|26,*
003162  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
003163  aa  6 01446 2521 00	spri2	pr6|806
003164  aa  6 01423 3521 00	epp2 	pr6|787
003165  aa  6 01450 2521 00	spri2	pr6|808
003166  aa   774616 3520 04	epp2 	-1650,ic		000004 = 162154144162
003167  aa  6 01452 2521 00	spri2	pr6|810
003170  aa  6 01424 3521 00	epp2 	pr6|788
003171  aa  6 01454 2521 00	spri2	pr6|812
003172  aa  6 01472 3521 00	epp2 	pr6|826
003173  aa  6 01456 2521 00	spri2	pr6|814
003174  aa   774670 3520 04	epp2 	-1608,ic		000064 = 464000000000
003175  aa  6 01460 2521 00	spri2	pr6|816
003176  aa   774663 3520 04	epp2 	-1613,ic		000061 = 404000000005
003177  aa  6 01462 2521 00	spri2	pr6|818
003200  aa   774663 3520 04	epp2 	-1613,ic		000063 = 530000000040
003201  aa  6 01464 2521 00	spri2	pr6|820
003202  aa   774646 3520 04	epp2 	-1626,ic		000050 = 524000000040
003203  aa  6 01466 2521 00	spri2	pr6|822
003204  aa   774641 3520 04	epp2 	-1631,ic		000045 = 524000000250
003205  aa  6 01470 2521 00	spri2	pr6|824
003206  aa  6 01444 6211 00	eax1 	pr6|804
003207  aa   024000 4310 07	fld  	10240,dl
003210  aa  6 00044 3701 20	epp4 	pr6|36,*
003211  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003212  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 478
      end;

						STATEMENT 1 ON LINE 479
    do pvindex = 1 to rldr_data_.npvs;

003213  aa  6 00032 3735 20	epp7 	pr6|26,*
003214  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
003215  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
003216  aa  5 00404 2361 00	ldq  	pr5|260		rldr_data_.npvs
003217  aa  6 01153 7561 00	stq  	pr6|619
003220  aa   000001 2360 07	ldq  	1,dl
003221  aa  6 00275 7561 00	stq  	pr6|189		pvindex
003222  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
003223  aa  6 01153 1161 00	cmpq 	pr6|619
003224  aa   000135 6054 04	tpnz 	93,ic		003361
						STATEMENT 1 ON LINE 481
      if backup_volume_record.pvid = rldr_data_.pvid (pvindex) then do;

003225  aa   000064 4020 07	mpy  	52,dl
003226  aa  6 01423 7561 00	stq  	pr6|787
003227  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
003230  aa  7 00011 2351 00	lda  	pr7|9		backup_volume_record.pvid
003231  aa  6 00032 3715 20	epp5 	pr6|26,*
003232  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
003233  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
003234  aa  3 00406 1151 06	cmpa 	pr3|262,ql	rldr_data_.pvid
003235  aa   000122 6010 04	tnz  	82,ic		003357
						STATEMENT 1 ON LINE 483
	if rldr_data_.abandoned (pvindex) then goto exit_pvid_check;

003236  aa  3 00350 2351 06	lda  	pr3|232,ql	rldr_data_.abandoned
003237  aa   400000 3150 03	cana 	131072,du
003240  aa   000121 6010 04	tnz  	81,ic		003361
						STATEMENT 1 ON LINE 485
	controlp = rldr_data_.controlp (pvindex);

003241  aa  3 00430 3515 26	epp1 	pr3|280,ql*	rldr_data_.controlp
003242  aa  6 01100 2515 00	spri1	pr6|576		controlp
						STATEMENT 1 ON LINE 486
	vtocx = backup_volume_record.vtocx;

003243  aa  7 00012 2361 00	ldq  	pr7|10		backup_volume_record.vtocx
003244  aa  5 00010 7561 20	stq  	pr5|8,*		vtocx
						STATEMENT 1 ON LINE 487
	if vtocx > rldr_control.n_vtoce - 1 then do;

003245  aa  1 10025 2361 00	ldq  	pr1|4117		rldr_control.n_vtoce
003246  aa   000001 1760 07	sbq  	1,dl
003247  aa  5 00010 1161 20	cmpq 	pr5|8,*		vtocx
003250  aa   000047 6050 04	tpl  	39,ic		003317
						STATEMENT 1 ON LINE 488
	    call rldr_report_$error_output (rldr_datap, 0, myname, "VTOCE index out of range on pv ^a",
	         rldr_data_.pvname (pvindex));

003251  aa   774577 2360 04	ldq  	-1665,ic		000050 = 524000000040
003252  aa  6 01422 7561 00	stq  	pr6|786
003253  aa  6 01612 4501 00	stz  	pr6|906
003254  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003255  aa   775072 00 0044	desc9a	-1478,36		000346 = 126124117103
003256  aa  6 01424 00 0044	desc9a	pr6|788,36
003257  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003260  aa  6 01446 2521 00	spri2	pr6|806
003261  aa  6 01612 3521 00	epp2 	pr6|906
003262  aa  6 01450 2521 00	spri2	pr6|808
003263  aa   774521 3520 04	epp2 	-1711,ic		000004 = 162154144162
003264  aa  6 01452 2521 00	spri2	pr6|810
003265  aa  6 01424 3521 00	epp2 	pr6|788
003266  aa  6 01454 2521 00	spri2	pr6|812
003267  aa  6 01423 7271 00	lxl7 	pr6|787
003270  aa  3 00353 3521 17	epp2 	pr3|235,7		rldr_data_.pvname
003271  aa  6 01456 2521 00	spri2	pr6|814
003272  aa   774572 3520 04	epp2 	-1670,ic		000064 = 464000000000
003273  aa  6 01460 2521 00	spri2	pr6|816
003274  aa   774565 3520 04	epp2 	-1675,ic		000061 = 404000000005
003275  aa  6 01462 2521 00	spri2	pr6|818
003276  aa   774565 3520 04	epp2 	-1675,ic		000063 = 530000000040
003277  aa  6 01464 2521 00	spri2	pr6|820
003300  aa   774543 3520 04	epp2 	-1693,ic		000043 = 524000000041
003301  aa  6 01466 2521 00	spri2	pr6|822
003302  aa  6 01422 3521 00	epp2 	pr6|786
003303  aa  6 01470 2521 00	spri2	pr6|824
003304  aa  6 01444 6211 00	eax1 	pr6|804
003305  aa   024000 4310 07	fld  	10240,dl
003306  aa  6 00044 3701 20	epp4 	pr6|36,*
003307  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003310  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 490
	    nel = backup_volume_record.rec2_len;

003311  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
003312  aa  7 00005 2361 00	ldq  	pr7|5		backup_volume_record.rec2_len
003313  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 491
	    if nel ^= 0 then call skip_chars;

003314  aa   000002 6000 04	tze  	2,ic		003316
003315  aa   000075 6700 04	tsp4 	61,ic		003412
						STATEMENT 1 ON LINE 492
	    return;

003316  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 493
	  end;

						STATEMENT 1 ON LINE 499
	already_there = "0"b;

003317  aa  5 00012 3535 20	epp3 	pr5|10,*
003320  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
003321  aa   000000 00 0000	descb	0,0
003322  aa  3 00000 00 0001	descb	pr3|0,1		already_there
						STATEMENT 1 ON LINE 500
	if rldr_control (vtocx).time_dumped < bin (backup_volume_record.time_dumped || (16)"0"b, 52) then do;

003323  aa  5 00010 2361 20	ldq  	pr5|8,*		vtocx
003324  aa   000006 4020 07	mpy  	6,dl
003325  aa  7 00007 2351 00	lda  	pr7|7		backup_volume_record.time_dumped
003326  aa   000000 6270 06	eax7 	0,ql
003327  aa   000000 2360 07	ldq  	0,dl
003330  aa   000024 7730 00	lrl  	20
003331  aa  1 14026 1171 17	cmpaq	pr1|6166,7	rldr_control.time_dumped
003332  aa   000027 6044 04	tmoz 	23,ic		003361
						STATEMENT 1 ON LINE 501
	    already_there = (rldr_control (vtocx).uid ^= "0"b & rldr_control (vtocx).time_dumped ^= 0);

003333  aa  1 14026 2371 17	ldaq 	pr1|6166,7	rldr_control.time_dumped
003334  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
003335  aa  6 01422 7551 00	sta  	pr6|786
003336  aa  1 14024 2351 17	lda  	pr1|6164,7	rldr_control.uid
003337  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
003340  aa  6 01422 3751 00	ana  	pr6|786
003341  aa  6 00056 7551 00	sta  	pr6|46
003342  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003343  aa  6 00056 00 0001	descb	pr6|46,1
003344  aa  3 00000 00 0001	descb	pr3|0,1		already_there
						STATEMENT 1 ON LINE 502
	    rldr_control (vtocx).time_dumped = bin (backup_volume_record.time_dumped || (16)"0"b, 52);

003345  aa  7 00007 2351 00	lda  	pr7|7		backup_volume_record.time_dumped
003346  aa   000000 2360 07	ldq  	0,dl
003347  aa   000024 7730 00	lrl  	20
003350  aa  1 14026 7571 17	staq 	pr1|6166,7	rldr_control.time_dumped
						STATEMENT 1 ON LINE 503
	    rldr_control (vtocx).uid = backup_volume_record.uid;

003351  aa  7 00014 2351 00	lda  	pr7|12		backup_volume_record.uid
003352  aa  1 14024 7551 17	sta  	pr1|6164,7	rldr_control.uid
						STATEMENT 1 ON LINE 504
	    new_info = "1"b;

003353  aa   400000 2350 03	lda  	131072,du
003354  aa  6 00125 7551 00	sta  	pr6|85		new_info
						STATEMENT 1 ON LINE 505
	    return;

003355  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 506
	  end;

						STATEMENT 1 ON LINE 507
	goto exit_pvid_check;

003356  aa   000003 7100 04	tra  	3,ic		003361
						STATEMENT 1 ON LINE 508
        end;

						STATEMENT 1 ON LINE 509
    end;

003357  aa  6 00275 0541 00	aos  	pr6|189		pvindex
003360  aa   777642 7100 04	tra  	-94,ic		003222
						STATEMENT 1 ON LINE 510
exit_pvid_check:
    do pvindex = 1 to rldr_data_.npvs;

003361  aa  6 00032 3735 20	epp7 	pr6|26,*
003362  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
003363  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
003364  aa  5 00404 2361 00	ldq  	pr5|260		rldr_data_.npvs
003365  aa  6 01154 7561 00	stq  	pr6|620
003366  aa   000001 2360 07	ldq  	1,dl
003367  aa  6 00275 7561 00	stq  	pr6|189		pvindex
003370  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
003371  aa  6 01154 1161 00	cmpq 	pr6|620
003372  aa   000012 6054 04	tpnz 	10,ic		003404
						STATEMENT 1 ON LINE 512
      controlp = rldr_data_.controlp (pvindex);

003373  aa   000064 4020 07	mpy  	52,dl
003374  aa  6 00032 3735 20	epp7 	pr6|26,*
003375  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
003376  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
003377  aa  5 00430 3535 26	epp3 	pr5|280,ql*	rldr_data_.controlp
003400  aa  6 01100 2535 00	spri3	pr6|576		controlp
						STATEMENT 1 ON LINE 513
      rldr_control.num_rejected = rldr_control.num_rejected + 1;

003401  aa  3 00021 0541 00	aos  	pr3|17		rldr_control.num_rejected
						STATEMENT 1 ON LINE 514
    end;

003402  aa  6 00275 0541 00	aos  	pr6|189		pvindex
003403  aa   777765 7100 04	tra  	-11,ic		003370
						STATEMENT 1 ON LINE 515
    pvindex = 0;

003404  aa  6 00275 4501 00	stz  	pr6|189		pvindex
						STATEMENT 1 ON LINE 516
    nel = backup_volume_record.rec2_len;

003405  aa  6 00356 3735 20	epp7 	pr6|238,*		recordp
003406  aa  7 00005 2361 00	ldq  	pr7|5		backup_volume_record.rec2_len
003407  aa  6 00301 7561 00	stq  	pr6|193		nel
						STATEMENT 1 ON LINE 517
    call skip_chars;

003410  aa   000002 6700 04	tsp4 	2,ic		003412
						STATEMENT 1 ON LINE 518
    return;

003411  aa  6 01144 6101 00	rtcd 	pr6|612
						STATEMENT 1 ON LINE 520
  end read_volume_record;

  END PROCEDURE read_volume_record
BEGIN PROCEDURE skip_chars
ENTRY TO skip_chars                                         STATEMENT 1 ON LINE 525
skip_chars: proc;

003412  aa  6 01156 6501 00	spri4	pr6|622
						STATEMENT 1 ON LINE 530
    nelt = nel;

003413  aa  6 00301 2361 00	ldq  	pr6|193		nel
003414  aa  6 00302 7561 00	stq  	pr6|194		nelt
						STATEMENT 1 ON LINE 531
    call read (null, nel, nelt, (backup_volume_record.rec1_type = vtoce_type & backup_volume_record.version > backup_volume_record_version_1), code);

003415  aa   774473 3734 24	epp7 	-1733,ic*
003416  aa  6 01614 6535 00	spri7	pr6|908
003417  aa  6 00356 3715 20	epp5 	pr6|238,*		recordp
003420  aa  5 00010 2361 00	ldq  	pr5|8		backup_volume_record.version
003421  aa   000001 1160 07	cmpq 	1,dl
003422  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
003423  aa  6 01613 7551 00	sta  	pr6|907
003424  aa  5 00001 2361 00	ldq  	pr5|1		backup_volume_record.rec1_type
003425  aa   000001 1160 07	cmpq 	1,dl
003426  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
003427  aa  6 01613 3751 00	ana  	pr6|907
003430  aa  6 01613 7551 00	sta  	pr6|907
003431  aa  6 01614 3521 00	epp2 	pr6|908
003432  aa  6 01620 2521 00	spri2	pr6|912
003433  aa  6 00301 3521 00	epp2 	pr6|193		nel
003434  aa  6 01622 2521 00	spri2	pr6|914
003435  aa  6 00302 3521 00	epp2 	pr6|194		nelt
003436  aa  6 01624 2521 00	spri2	pr6|916
003437  aa  6 01613 3521 00	epp2 	pr6|907
003440  aa  6 01626 2521 00	spri2	pr6|918
003441  aa  6 01124 3521 20	epp2 	pr6|596,*		code
003442  aa  6 01630 2521 00	spri2	pr6|920
003443  aa  6 01616 6211 00	eax1 	pr6|910
003444  aa   024000 4310 07	fld  	10240,dl
003445  aa   003657 3520 04	epp2 	1967,ic		007324 = 000140627000
003446  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 532
    call check_input_error;

003447  aa  6 00056 6211 00	eax1 	pr6|46
003450  aa   000000 4310 07	fld  	0,dl
003451  aa   000011 3520 04	epp2 	9,ic		003462 = 000500627000
003452  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 533
    if entry = get_object & new_volume then goto search_loop;

003453  aa  6 00273 2361 00	ldq  	pr6|187		entry
003454  aa   000001 1160 07	cmpq 	1,dl
003455  aa   000003 6010 04	tnz  	3,ic		003460
003456  aa  6 00123 2351 00	lda  	pr6|83		new_volume
003457  aa   775435 6010 04	tnz  	-1251,ic		001114
						STATEMENT 1 ON LINE 535
  end skip_chars;

003460  aa  6 01156 6101 00	rtcd 	pr6|622
  END PROCEDURE skip_chars
BEGIN PROCEDURE check_input_error
ENTRY TO check_input_error                                  STATEMENT 1 ON LINE 540
check_input_error: proc;

003461  da     000426200000
003462  aa   000500 6270 00	eax7 	320
003463  aa  7 00034 3521 20	epp2 	pr7|28,*
003464  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
003465  aa     000000000000
003466  aa     000000000000
						STATEMENT 1 ON LINE 550
    new_volume = "0"b;

003467  aa  6 00040 3735 20	epp7 	pr6|32,*
003470  aa  7 00123 4501 00	stz  	pr7|83		new_volume
						STATEMENT 1 ON LINE 551
    if code ^= 0 | nel ^= nelt then do;

003471  aa  7 01124 2361 20	ldq  	pr7|596,*		code
003472  aa   000004 6010 04	tnz  	4,ic		003476
003473  aa  7 00301 2361 00	ldq  	pr7|193		nel
003474  aa  7 00302 1161 00	cmpq 	pr7|194		nelt
003475  aa   000750 6000 04	tze  	488,ic		004445
						STATEMENT 1 ON LINE 552
        if (code = error_table_$end_of_info | code = error_table_$device_end) then do;

003476  aa  7 01124 2361 20	ldq  	pr7|596,*		code
003477  la  4 00070 1161 20	cmpq 	pr4|56,*		error_table_$end_of_info
003500  aa   000003 6000 04	tze  	3,ic		003503
003501  la  4 00062 1161 20	cmpq 	pr4|50,*		error_table_$device_end
003502  aa   000311 6010 04	tnz  	201,ic		004013
						STATEMENT 1 ON LINE 553
	  if resynching then do;

003503  aa  7 00122 2351 00	lda  	pr7|82		resynching
003504  aa   000072 6000 04	tze  	58,ic		003576
						STATEMENT 1 ON LINE 554
	      call rldr_report_$error_output (rldr_datap, 0, myname, "Resynchronization terminated by end of volume");

003505  aa  6 00111 4501 00	stz  	pr6|73
003506  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003507  aa   774764 00 0060	desc9a	-1548,48		000472 = 122145163171
003510  aa  6 00112 00 0060	desc9a	pr6|74,48
003511  aa  7 00032 3715 20	epp5 	pr7|26,*
003512  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003513  aa  6 00130 2521 00	spri2	pr6|88
003514  aa  6 00111 3521 00	epp2 	pr6|73
003515  aa  6 00132 2521 00	spri2	pr6|90
003516  aa   774266 3520 04	epp2 	-1866,ic		000004 = 162154144162
003517  aa  6 00134 2521 00	spri2	pr6|92
003520  aa  6 00112 3521 00	epp2 	pr6|74
003521  aa  6 00136 2521 00	spri2	pr6|94
003522  aa   774342 3520 04	epp2 	-1822,ic		000064 = 464000000000
003523  aa  6 00140 2521 00	spri2	pr6|96
003524  aa   774335 3520 04	epp2 	-1827,ic		000061 = 404000000005
003525  aa  6 00142 2521 00	spri2	pr6|98
003526  aa   774335 3520 04	epp2 	-1827,ic		000063 = 530000000040
003527  aa  6 00144 2521 00	spri2	pr6|100
003530  aa   774312 3520 04	epp2 	-1846,ic		000042 = 524000000055
003531  aa  6 00146 2521 00	spri2	pr6|102
003532  aa  6 00126 6211 00	eax1 	pr6|86
003533  aa   020000 4310 07	fld  	8192,dl
003534  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003535  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 555
	      call rldr_report_$error_output (rldr_datap, 0, myname, "^d words skipped", words_skipped);

003536  aa  6 00111 4501 00	stz  	pr6|73
003537  aa   774365 2370 04	ldaq 	-1803,ic		000124 = 136144040167 157162144163
003540  aa  6 00112 7571 00	staq 	pr6|74
003541  aa   774365 2370 04	ldaq 	-1803,ic		000126 = 040163153151 160160145144
003542  aa  6 00114 7571 00	staq 	pr6|76
003543  aa  6 00040 3735 20	epp7 	pr6|32,*
003544  aa  7 00032 3715 20	epp5 	pr7|26,*
003545  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003546  aa  6 00152 2521 00	spri2	pr6|106
003547  aa  6 00111 3521 00	epp2 	pr6|73
003550  aa  6 00154 2521 00	spri2	pr6|108
003551  aa   774233 3520 04	epp2 	-1893,ic		000004 = 162154144162
003552  aa  6 00156 2521 00	spri2	pr6|110
003553  aa  6 00112 3521 00	epp2 	pr6|74
003554  aa  6 00160 2521 00	spri2	pr6|112
003555  aa  7 00130 3521 00	epp2 	pr7|88		words_skipped
003556  aa  6 00162 2521 00	spri2	pr6|114
003557  aa   774305 3520 04	epp2 	-1851,ic		000064 = 464000000000
003560  aa  6 00164 2521 00	spri2	pr6|116
003561  aa   774300 3520 04	epp2 	-1856,ic		000061 = 404000000005
003562  aa  6 00166 2521 00	spri2	pr6|118
003563  aa   774300 3520 04	epp2 	-1856,ic		000063 = 530000000040
003564  aa  6 00170 2521 00	spri2	pr6|120
003565  aa   774254 3520 04	epp2 	-1876,ic		000041 = 524000000020
003566  aa  6 00172 2521 00	spri2	pr6|122
003567  aa   774304 3520 04	epp2 	-1852,ic		000073 = 404000000043
003570  aa  6 00174 2521 00	spri2	pr6|124
003571  aa  6 00150 6211 00	eax1 	pr6|104
003572  aa   024000 4310 07	fld  	10240,dl
003573  aa  6 00044 3701 20	epp4 	pr6|36,*
003574  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003575  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 556
	    end;

						STATEMENT 1 ON LINE 557
detach_and_continue:
	  call detach;

003576  aa   000001 7270 07	lxl7 	1,dl
003577  aa  6 00056 6211 00	eax1 	pr6|46
003600  aa   000000 4310 07	fld  	0,dl
003601  aa   001621 3520 04	epp2 	913,ic		005422 = 000260627000
003602  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 559
	  do i = 1 to rldr_data_.npvs;

003603  aa  6 00040 3735 20	epp7 	pr6|32,*
003604  aa  7 00032 3715 20	epp5 	pr7|26,*
003605  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
003606  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
003607  aa  3 00404 2361 00	ldq  	pr3|260		rldr_data_.npvs
003610  aa  6 00101 7561 00	stq  	pr6|65
003611  aa   000001 2360 07	ldq  	1,dl
003612  aa  6 00100 7561 00	stq  	pr6|64		i
003613  aa   000000 0110 03	nop  	0,du
003614  aa  6 00100 2361 00	ldq  	pr6|64		i
003615  aa  6 00101 1161 00	cmpq 	pr6|65
003616  aa   000164 6054 04	tpnz 	116,ic		004002
						STATEMENT 1 ON LINE 560
	    controlp = rldr_data_.controlp (i);

003617  aa   000064 4020 07	mpy  	52,dl
003620  aa  6 00040 3735 20	epp7 	pr6|32,*
003621  aa  7 00032 3715 20	epp5 	pr7|26,*
003622  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
003623  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
003624  aa  3 00430 3515 26	epp1 	pr3|280,ql*	rldr_data_.controlp
003625  aa  7 01100 2515 00	spri1	pr7|576		controlp
						STATEMENT 1 ON LINE 561
	    if (rldr_control.dir_rec ^= 0 | rldr_control.seg_rec ^= 0
	         | rldr_control.num_null_vtoce ^= 0) then do;

003626  aa  1 00011 2361 00	ldq  	pr1|9		rldr_control.dir_rec
003627  aa   000005 6010 04	tnz  	5,ic		003634
003630  aa  1 00013 2361 00	ldq  	pr1|11		rldr_control.seg_rec
003631  aa   000003 6010 04	tnz  	3,ic		003634
003632  aa  1 00020 2361 00	ldq  	pr1|16		rldr_control.num_null_vtoce
003633  aa   000145 6000 04	tze  	101,ic		004000
						STATEMENT 1 ON LINE 563
	        call rldr_vtoc_header_$update (rldr_datap, i, code);

003634  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003635  aa  6 00114 2521 00	spri2	pr6|76
003636  aa  6 00100 3521 00	epp2 	pr6|64		i
003637  aa  6 00116 2521 00	spri2	pr6|78
003640  aa  7 01124 3521 20	epp2 	pr7|596,*		code
003641  aa  6 00120 2521 00	spri2	pr6|80
003642  aa  6 00112 6211 00	eax1 	pr6|74
003643  aa   014000 4310 07	fld  	6144,dl
003644  aa  6 00044 3701 20	epp4 	pr6|36,*
003645  la  4 00046 3521 20	epp2 	pr4|38,*		rldr_vtoc_header_$update
003646  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 564
	        if code ^= 0 then
		call rldr_report_$error_output (rldr_datap, code, myname, "Error updating vtoc header on pv ^a",
		     rldr_data_.pvname (i));

003647  aa  6 00040 3735 20	epp7 	pr6|32,*
003650  aa  7 01124 2361 20	ldq  	pr7|596,*		code
003651  aa   000044 6000 04	tze  	36,ic		003715
003652  aa   774176 2360 04	ldq  	-1922,ic		000050 = 524000000040
003653  aa  6 00111 7561 00	stq  	pr6|73
003654  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003655  aa   774461 00 0044	desc9a	-1743,36		000335 = 105162162157
003656  aa  6 00112 00 0044	desc9a	pr6|74,36
003657  aa  6 00100 2361 00	ldq  	pr6|64		i
003660  aa   000064 4020 07	mpy  	52,dl
003661  aa  7 00032 3715 20	epp5 	pr7|26,*
003662  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003663  aa  6 00152 2521 00	spri2	pr6|106
003664  aa  7 01124 3521 20	epp2 	pr7|596,*		code
003665  aa  6 00154 2521 00	spri2	pr6|108
003666  aa   774116 3520 04	epp2 	-1970,ic		000004 = 162154144162
003667  aa  6 00156 2521 00	spri2	pr6|110
003670  aa  6 00112 3521 00	epp2 	pr6|74
003671  aa  6 00160 2521 00	spri2	pr6|112
003672  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
003673  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
003674  aa  3 00353 3521 06	epp2 	pr3|235,ql	rldr_data_.pvname
003675  aa  6 00162 2521 00	spri2	pr6|114
003676  aa   774166 3520 04	epp2 	-1930,ic		000064 = 464000000000
003677  aa  6 00164 2521 00	spri2	pr6|116
003700  aa   774173 3520 04	epp2 	-1925,ic		000073 = 404000000043
003701  aa  6 00166 2521 00	spri2	pr6|118
003702  aa   774161 3520 04	epp2 	-1935,ic		000063 = 530000000040
003703  aa  6 00170 2521 00	spri2	pr6|120
003704  aa   774134 3520 04	epp2 	-1956,ic		000040 = 524000000043
003705  aa  6 00172 2521 00	spri2	pr6|122
003706  aa  6 00111 3521 00	epp2 	pr6|73
003707  aa  6 00174 2521 00	spri2	pr6|124
003710  aa  6 00150 6211 00	eax1 	pr6|104
003711  aa   024000 4310 07	fld  	10240,dl
003712  aa  6 00044 3701 20	epp4 	pr6|36,*
003713  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003714  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 567
	        call rldr_volume_map_$update (rldr_datap, i, code);

003715  aa  6 00040 3735 20	epp7 	pr6|32,*
003716  aa  7 00032 3715 20	epp5 	pr7|26,*
003717  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003720  aa  6 00114 2521 00	spri2	pr6|76
003721  aa  6 00100 3521 00	epp2 	pr6|64		i
003722  aa  6 00116 2521 00	spri2	pr6|78
003723  aa  7 01124 3521 20	epp2 	pr7|596,*		code
003724  aa  6 00120 2521 00	spri2	pr6|80
003725  aa  6 00112 6211 00	eax1 	pr6|74
003726  aa   014000 4310 07	fld  	6144,dl
003727  aa  6 00044 3701 20	epp4 	pr6|36,*
003730  la  4 00050 3521 20	epp2 	pr4|40,*		rldr_volume_map_$update
003731  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 568
	        if code ^= 0 then
		call rldr_report_$error_output (rldr_datap, code, myname, "Error updating volume map on pv ^a",
		     rldr_data_.pvname (i));

003732  aa  6 00040 3735 20	epp7 	pr6|32,*
003733  aa  7 01124 2361 20	ldq  	pr7|596,*		code
003734  aa   000044 6000 04	tze  	36,ic		004000
003735  aa   774113 2360 04	ldq  	-1973,ic		000050 = 524000000040
003736  aa  6 00111 7561 00	stq  	pr6|73
003737  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003740  aa   774365 00 0044	desc9a	-1803,36		000324 = 105162162157
003741  aa  6 00112 00 0044	desc9a	pr6|74,36
003742  aa  6 00100 2361 00	ldq  	pr6|64		i
003743  aa   000064 4020 07	mpy  	52,dl
003744  aa  7 00032 3715 20	epp5 	pr7|26,*
003745  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
003746  aa  6 00152 2521 00	spri2	pr6|106
003747  aa  7 01124 3521 20	epp2 	pr7|596,*		code
003750  aa  6 00154 2521 00	spri2	pr6|108
003751  aa   774033 3520 04	epp2 	-2021,ic		000004 = 162154144162
003752  aa  6 00156 2521 00	spri2	pr6|110
003753  aa  6 00112 3521 00	epp2 	pr6|74
003754  aa  6 00160 2521 00	spri2	pr6|112
003755  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
003756  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
003757  aa  3 00353 3521 06	epp2 	pr3|235,ql	rldr_data_.pvname
003760  aa  6 00162 2521 00	spri2	pr6|114
003761  aa   774103 3520 04	epp2 	-1981,ic		000064 = 464000000000
003762  aa  6 00164 2521 00	spri2	pr6|116
003763  aa   774110 3520 04	epp2 	-1976,ic		000073 = 404000000043
003764  aa  6 00166 2521 00	spri2	pr6|118
003765  aa   774076 3520 04	epp2 	-1986,ic		000063 = 530000000040
003766  aa  6 00170 2521 00	spri2	pr6|120
003767  aa   774050 3520 04	epp2 	-2008,ic		000037 = 524000000042
003770  aa  6 00172 2521 00	spri2	pr6|122
003771  aa  6 00111 3521 00	epp2 	pr6|73
003772  aa  6 00174 2521 00	spri2	pr6|124
003773  aa  6 00150 6211 00	eax1 	pr6|104
003774  aa   024000 4310 07	fld  	10240,dl
003775  aa  6 00044 3701 20	epp4 	pr6|36,*
003776  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
003777  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 571
	      end;

						STATEMENT 1 ON LINE 572
	  end;

004000  aa  6 00100 0541 00	aos  	pr6|64		i
004001  aa   777613 7100 04	tra  	-117,ic		003614
						STATEMENT 1 ON LINE 573
	  call attach;

004002  aa   000001 7270 07	lxl7 	1,dl
004003  aa  6 00056 6211 00	eax1 	pr6|46
004004  aa   000000 4310 07	fld  	0,dl
004005  aa   000442 3520 04	epp2 	290,ic		004447 = 000300627000
004006  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 574
	  new_volume = "1"b;

004007  aa   400000 2350 03	lda  	131072,du
004010  aa  6 00040 3735 20	epp7 	pr6|32,*
004011  aa  7 00123 7551 00	sta  	pr7|83		new_volume
						STATEMENT 1 ON LINE 575
	  return;

004012  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 576
	end;

						STATEMENT 1 ON LINE 577
        else do;

						STATEMENT 1 ON LINE 578
	  if ^resynching then do;

004013  aa  7 00122 2351 00	lda  	pr7|82		resynching
004014  aa   000366 6010 04	tnz  	246,ic		004402
						STATEMENT 1 ON LINE 579
	      if nel ^= nelt then
	        call rldr_report_$error_output (rldr_datap, 0, myname, "Read did not complete on ^a",
		   rldr_data_.controlp (1) -> rldr_control.curn_volname);

004015  aa  7 00301 2361 00	ldq  	pr7|193		nel
004016  aa  7 00302 1161 00	cmpq 	pr7|194		nelt
004017  aa   000040 6000 04	tze  	32,ic		004057
004020  aa  6 00111 4501 00	stz  	pr6|73
004021  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004022  aa   774151 00 0034	desc9a	-1943,28		000172 = 122145141144
004023  aa  6 00112 00 0034	desc9a	pr6|74,28
004024  aa  7 00032 3715 20	epp5 	pr7|26,*
004025  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
004026  aa  6 00152 2521 00	spri2	pr6|106
004027  aa  6 00111 3521 00	epp2 	pr6|73
004030  aa  6 00154 2521 00	spri2	pr6|108
004031  aa   773753 3520 04	epp2 	-2069,ic		000004 = 162154144162
004032  aa  6 00156 2521 00	spri2	pr6|110
004033  aa  6 00112 3521 00	epp2 	pr6|74
004034  aa  6 00160 2521 00	spri2	pr6|112
004035  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004036  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004037  aa  3 00514 3521 20	epp2 	pr3|332,*		rldr_control.curn_volname
004040  aa  6 00162 2521 00	spri2	pr6|114
004041  aa   774023 3520 04	epp2 	-2029,ic		000064 = 464000000000
004042  aa  6 00164 2521 00	spri2	pr6|116
004043  aa   774016 3520 04	epp2 	-2034,ic		000061 = 404000000005
004044  aa  6 00166 2521 00	spri2	pr6|118
004045  aa   774016 3520 04	epp2 	-2034,ic		000063 = 530000000040
004046  aa  6 00170 2521 00	spri2	pr6|120
004047  aa   773767 3520 04	epp2 	-2057,ic		000036 = 524000000033
004050  aa  6 00172 2521 00	spri2	pr6|122
004051  aa   773777 3520 04	epp2 	-2049,ic		000050 = 524000000040
004052  aa  6 00174 2521 00	spri2	pr6|124
004053  aa  6 00150 6211 00	eax1 	pr6|104
004054  aa   024000 4310 07	fld  	10240,dl
004055  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
004056  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 582
	      if code = -1 then
	        call rldr_report_$error_output (rldr_datap, 0, myname, "Invalid dump record header on ^a",
		   rldr_data_.controlp (1) -> rldr_control.curn_volname);

004057  aa  6 00040 3735 20	epp7 	pr6|32,*
004060  aa  7 01124 2361 20	ldq  	pr7|596,*		code
004061  aa   004101 1160 04	cmpq 	2113,ic		010162 = 777777777777
004062  aa   000041 6010 04	tnz  	33,ic		004123
004063  aa  6 00111 4501 00	stz  	pr6|73
004064  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004065  aa   774165 00 0040	desc9a	-1931,32		000251 = 111156166141
004066  aa  6 00112 00 0040	desc9a	pr6|74,32
004067  aa  7 00032 3715 20	epp5 	pr7|26,*
004070  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
004071  aa  6 00152 2521 00	spri2	pr6|106
004072  aa  6 00111 3521 00	epp2 	pr6|73
004073  aa  6 00154 2521 00	spri2	pr6|108
004074  aa   773710 3520 04	epp2 	-2104,ic		000004 = 162154144162
004075  aa  6 00156 2521 00	spri2	pr6|110
004076  aa  6 00112 3521 00	epp2 	pr6|74
004077  aa  6 00160 2521 00	spri2	pr6|112
004100  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004101  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004102  aa  3 00514 3521 20	epp2 	pr3|332,*		rldr_control.curn_volname
004103  aa  6 00162 2521 00	spri2	pr6|114
004104  aa   773760 3520 04	epp2 	-2064,ic		000064 = 464000000000
004105  aa  6 00164 2521 00	spri2	pr6|116
004106  aa   773753 3520 04	epp2 	-2069,ic		000061 = 404000000005
004107  aa  6 00166 2521 00	spri2	pr6|118
004110  aa   773753 3520 04	epp2 	-2069,ic		000063 = 530000000040
004111  aa  6 00170 2521 00	spri2	pr6|120
004112  aa   773736 3520 04	epp2 	-2082,ic		000050 = 524000000040
004113  aa  6 00172 2521 00	spri2	pr6|122
004114  aa  6 00174 2521 00	spri2	pr6|124
004115  aa  6 00150 6211 00	eax1 	pr6|104
004116  aa   024000 4310 07	fld  	10240,dl
004117  aa  6 00044 3701 20	epp4 	pr6|36,*
004120  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
004121  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
004122  aa   000040 7100 04	tra  	32,ic		004162
						STATEMENT 1 ON LINE 585
	      else call rldr_report_$error_output (rldr_datap, code, myname, "I/O error reading input volume ^a",
		      rldr_data_.controlp (1) -> rldr_control.curn_volname);

004123  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004124  aa   774170 00 0044	desc9a	-1928,36		000313 = 111057117040
004125  aa  6 00112 00 0044	desc9a	pr6|74,36
004126  aa  7 00032 3715 20	epp5 	pr7|26,*
004127  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
004130  aa  6 00152 2521 00	spri2	pr6|106
004131  aa  7 01124 3521 20	epp2 	pr7|596,*		code
004132  aa  6 00154 2521 00	spri2	pr6|108
004133  aa   773651 3520 04	epp2 	-2135,ic		000004 = 162154144162
004134  aa  6 00156 2521 00	spri2	pr6|110
004135  aa  6 00112 3521 00	epp2 	pr6|74
004136  aa  6 00160 2521 00	spri2	pr6|112
004137  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004140  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004141  aa  3 00514 3521 20	epp2 	pr3|332,*		rldr_control.curn_volname
004142  aa  6 00162 2521 00	spri2	pr6|114
004143  aa   773721 3520 04	epp2 	-2095,ic		000064 = 464000000000
004144  aa  6 00164 2521 00	spri2	pr6|116
004145  aa   773726 3520 04	epp2 	-2090,ic		000073 = 404000000043
004146  aa  6 00166 2521 00	spri2	pr6|118
004147  aa   773714 3520 04	epp2 	-2100,ic		000063 = 530000000040
004150  aa  6 00170 2521 00	spri2	pr6|120
004151  aa   773672 3520 04	epp2 	-2118,ic		000043 = 524000000041
004152  aa  6 00172 2521 00	spri2	pr6|122
004153  aa   773675 3520 04	epp2 	-2115,ic		000050 = 524000000040
004154  aa  6 00174 2521 00	spri2	pr6|124
004155  aa  6 00150 6211 00	eax1 	pr6|104
004156  aa   024000 4310 07	fld  	10240,dl
004157  aa  6 00044 3701 20	epp4 	pr6|36,*
004160  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
004161  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 587
	      call find_volname ((rldr_data_.last_pvid), pvname, lvname, code);

004162  aa  6 00040 3735 20	epp7 	pr6|32,*
004163  aa  7 00032 3715 20	epp5 	pr7|26,*
004164  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004165  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004166  aa  3 00002 2351 00	lda  	pr3|2		rldr_data_.last_pvid
004167  aa  6 00111 7551 00	sta  	pr6|73
004170  aa  6 00111 3521 00	epp2 	pr6|73
004171  aa  6 00114 2521 00	spri2	pr6|76
004172  aa  7 00313 3521 00	epp2 	pr7|203		pvname
004173  aa  6 00116 2521 00	spri2	pr6|78
004174  aa  7 00323 3521 00	epp2 	pr7|211		lvname
004175  aa  6 00120 2521 00	spri2	pr6|80
004176  aa  7 01124 3521 20	epp2 	pr7|596,*		code
004177  aa  6 00122 2521 00	spri2	pr6|82
004200  aa   000001 7270 07	lxl7 	1,dl
004201  aa  6 00112 6211 00	eax1 	pr6|74
004202  aa   020000 4310 07	fld  	8192,dl
004203  aa   003044 3520 04	epp2 	1572,ic		007247 = 000140627000
004204  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 588
	      if code ^= 0 then
	        call rldr_report_$error_output (rldr_datap, 0, myname, "bad input record after ^a - resynching started",
		   convert_puid_ ());

004205  aa  6 00040 3735 20	epp7 	pr6|32,*
004206  aa  7 01124 2361 20	ldq  	pr7|596,*		code
004207  aa   000050 6000 04	tze  	40,ic		004257
004210  aa  6 00111 4501 00	stz  	pr6|73
004211  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004212  aa   774245 00 0060	desc9a	-1883,48		000456 = 142141144040
004213  aa  6 00112 00 0060	desc9a	pr6|74,48
004214  aa  6 00176 3521 00	epp2 	pr6|126
004215  aa  6 00130 2521 00	spri2	pr6|88
004216  aa   000001 7270 07	lxl7 	1,dl
004217  aa  6 00126 6211 00	eax1 	pr6|86
004220  aa   004000 4310 07	fld  	2048,dl
004221  aa   002627 3520 04	epp2 	1431,ic		007050 = 000340627000
004222  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
004223  aa  6 00040 3735 20	epp7 	pr6|32,*
004224  aa  7 00032 3715 20	epp5 	pr7|26,*
004225  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
004226  aa  6 00152 2521 00	spri2	pr6|106
004227  aa  6 00111 3521 00	epp2 	pr6|73
004230  aa  6 00154 2521 00	spri2	pr6|108
004231  aa   773553 3520 04	epp2 	-2197,ic		000004 = 162154144162
004232  aa  6 00156 2521 00	spri2	pr6|110
004233  aa  6 00112 3521 00	epp2 	pr6|74
004234  aa  6 00160 2521 00	spri2	pr6|112
004235  aa  6 00176 3521 00	epp2 	pr6|126
004236  aa  6 00162 2521 00	spri2	pr6|114
004237  aa   773625 3520 04	epp2 	-2155,ic		000064 = 464000000000
004240  aa  6 00164 2521 00	spri2	pr6|116
004241  aa   773620 3520 04	epp2 	-2160,ic		000061 = 404000000005
004242  aa  6 00166 2521 00	spri2	pr6|118
004243  aa   773620 3520 04	epp2 	-2160,ic		000063 = 530000000040
004244  aa  6 00170 2521 00	spri2	pr6|120
004245  aa   773570 3520 04	epp2 	-2184,ic		000035 = 524000000056
004246  aa  6 00172 2521 00	spri2	pr6|122
004247  aa   773576 3520 04	epp2 	-2178,ic		000045 = 524000000250
004250  aa  6 00174 2521 00	spri2	pr6|124
004251  aa  6 00150 6211 00	eax1 	pr6|104
004252  aa   024000 4310 07	fld  	10240,dl
004253  aa  6 00044 3701 20	epp4 	pr6|36,*
004254  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
004255  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
004256  aa   000073 7100 04	tra  	59,ic		004351
						STATEMENT 1 ON LINE 591
	      else call rldr_report_$error_output (rldr_datap, 0, myname,
		      "bad input record after ^a on pv ^a ^[(vtocx = ^d)^;^s^] of logical volume ^a - resynching started",
		      convert_puid_ (), pvname, (rldr_data_.last_pvid ^= (36)"0"b),
		      rldr_data_.last_vtocx, lvname);

004257  aa  6 00111 4501 00	stz  	pr6|73
004260  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004261  aa   774367 00 0144	desc9a	-1801,100		000647 = 142141144040
004262  aa  6 00176 00 0144	desc9a	pr6|126,100
004263  aa  6 00250 3521 00	epp2 	pr6|168
004264  aa  6 00114 2521 00	spri2	pr6|76
004265  aa   000001 7270 07	lxl7 	1,dl
004266  aa  6 00112 6211 00	eax1 	pr6|74
004267  aa   004000 4310 07	fld  	2048,dl
004270  aa   002560 3520 04	epp2 	1392,ic		007050 = 000340627000
004271  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
004272  aa  6 00040 3735 20	epp7 	pr6|32,*
004273  aa  7 00032 3715 20	epp5 	pr7|26,*
004274  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004275  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004276  aa  3 00002 2351 00	lda  	pr3|2		rldr_data_.last_pvid
004277  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
004300  aa  6 00322 7551 00	sta  	pr6|210
004301  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
004302  aa  6 00326 2521 00	spri2	pr6|214
004303  aa  6 00111 3521 00	epp2 	pr6|73
004304  aa  6 00330 2521 00	spri2	pr6|216
004305  aa   773477 3520 04	epp2 	-2241,ic		000004 = 162154144162
004306  aa  6 00332 2521 00	spri2	pr6|218
004307  aa  6 00176 3521 00	epp2 	pr6|126
004310  aa  6 00334 2521 00	spri2	pr6|220
004311  aa  6 00250 3521 00	epp2 	pr6|168
004312  aa  6 00336 2521 00	spri2	pr6|222
004313  aa  7 00313 3521 00	epp2 	pr7|203		pvname
004314  aa  6 00340 2521 00	spri2	pr6|224
004315  aa  6 00322 3521 00	epp2 	pr6|210
004316  aa  6 00342 2521 00	spri2	pr6|226
004317  aa  3 00403 3521 00	epp2 	pr3|259		rldr_data_.last_vtocx
004320  aa  6 00344 2521 00	spri2	pr6|228
004321  aa  7 00323 3521 00	epp2 	pr7|211		lvname
004322  aa  6 00346 2521 00	spri2	pr6|230
004323  aa   773541 3520 04	epp2 	-2207,ic		000064 = 464000000000
004324  aa  6 00350 2521 00	spri2	pr6|232
004325  aa   773534 3520 04	epp2 	-2212,ic		000061 = 404000000005
004326  aa  6 00352 2521 00	spri2	pr6|234
004327  aa   773534 3520 04	epp2 	-2212,ic		000063 = 530000000040
004330  aa  6 00354 2521 00	spri2	pr6|236
004331  aa   773503 3520 04	epp2 	-2237,ic		000034 = 524000000141
004332  aa  6 00356 2521 00	spri2	pr6|238
004333  aa   773512 3520 04	epp2 	-2230,ic		000045 = 524000000250
004334  aa  6 00360 2521 00	spri2	pr6|240
004335  aa   773533 3520 04	epp2 	-2213,ic		000070 = 526000000040
004336  aa  6 00362 2521 00	spri2	pr6|242
004337  aa  6 00370 2521 00	spri2	pr6|248
004340  aa   773504 3520 04	epp2 	-2236,ic		000044 = 514000000001
004341  aa  6 00364 2521 00	spri2	pr6|244
004342  aa   773530 3520 04	epp2 	-2216,ic		000072 = 404000000021
004343  aa  6 00366 2521 00	spri2	pr6|246
004344  aa  6 00324 6211 00	eax1 	pr6|212
004345  aa   044000 4310 07	fld  	18432,dl
004346  aa  6 00044 3701 20	epp4 	pr6|36,*
004347  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
004350  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 595
	      resynch_retry_count = 0;

004351  aa  6 00040 3735 20	epp7 	pr6|32,*
004352  aa  7 00231 4501 00	stz  	pr7|153		resynch_retry_count
						STATEMENT 1 ON LINE 596
	      call resynch_input_volume;

004353  aa   001433 6700 04	tsp4 	795,ic		006006
						STATEMENT 1 ON LINE 598
	      if entry = get_object then do;

004354  aa  6 00040 3735 20	epp7 	pr6|32,*
004355  aa  7 00273 2361 00	ldq  	pr7|187		entry
004356  aa   000001 1160 07	cmpq 	1,dl
004357  aa   000015 6010 04	tnz  	13,ic		004374
						STATEMENT 1 ON LINE 599
		if resynching_completed then goto pattern_match_label;

004360  aa  7 00121 2351 00	lda  	pr7|81		resynching_completed
004361  aa   000004 6000 04	tze  	4,ic		004365
004362  aa  6 00040 3735 20	epp7 	pr6|32,*
004363  aa  7 00100 3521 00	epp2 	pr7|64		pattern_match_label
004364  aa  0 00660 7101 00	tra  	pr0|432		tra_ext_2
						STATEMENT 1 ON LINE 600
		else if new_volume then goto search_loop;

004365  aa  6 00040 3735 20	epp7 	pr6|32,*
004366  aa  7 00123 2351 00	lda  	pr7|83		new_volume
004367  aa   000004 6000 04	tze  	4,ic		004373
004370  aa   774524 3520 04	epp2 	-1708,ic		001114 = 600121450100
004371  aa   000001 7270 07	lxl7 	1,dl
004372  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 601
	        end;

004373  aa   000052 7100 04	tra  	42,ic		004445
						STATEMENT 1 ON LINE 602
	      else if entry = read_object then do;

004374  aa   000002 1160 07	cmpq 	2,dl
004375  aa   000050 6010 04	tnz  	40,ic		004445
						STATEMENT 1 ON LINE 603
		code = -1;

004376  aa   000001 3360 07	lcq  	1,dl
004377  aa  7 01124 7561 20	stq  	pr7|596,*		code
						STATEMENT 1 ON LINE 604
		return;

004400  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 605
	        end;

						STATEMENT 1 ON LINE 606
	    end;

004401  aa   000044 7100 04	tra  	36,ic		004445
						STATEMENT 1 ON LINE 607
	  else do;

						STATEMENT 1 ON LINE 608
	      resynch_retry_count = resynch_retry_count + 1;

004402  aa  7 00231 0541 00	aos  	pr7|153		resynch_retry_count
						STATEMENT 1 ON LINE 610
	      if resynch_retry_count > 64 then do;

004403  aa  7 00231 2361 00	ldq  	pr7|153		resynch_retry_count
004404  aa   000100 1160 07	cmpq 	64,dl
004405  aa   000040 6044 04	tmoz 	32,ic		004445
						STATEMENT 1 ON LINE 611
		call rldr_report_$error_output (rldr_datap, code, myname,
		     "Resynchronization failed due to I/O error during resynching on volume ^a.",
		     rldr_data_.controlp (1) -> rldr_control.curn_volname);

004406  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004407  aa   774140 00 0114	desc9a	-1952,76		000546 = 122145163171
004410  aa  6 00150 00 0114	desc9a	pr6|104,76
004411  aa  7 00032 3715 20	epp5 	pr7|26,*
004412  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
004413  aa  6 00326 2521 00	spri2	pr6|214
004414  aa  7 01124 3521 20	epp2 	pr7|596,*		code
004415  aa  6 00330 2521 00	spri2	pr6|216
004416  aa   773366 3520 04	epp2 	-2314,ic		000004 = 162154144162
004417  aa  6 00332 2521 00	spri2	pr6|218
004420  aa  6 00150 3521 00	epp2 	pr6|104
004421  aa  6 00334 2521 00	spri2	pr6|220
004422  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004423  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004424  aa  3 00514 3521 20	epp2 	pr3|332,*		rldr_control.curn_volname
004425  aa  6 00336 2521 00	spri2	pr6|222
004426  aa   773436 3520 04	epp2 	-2274,ic		000064 = 464000000000
004427  aa  6 00340 2521 00	spri2	pr6|224
004430  aa   773443 3520 04	epp2 	-2269,ic		000073 = 404000000043
004431  aa  6 00342 2521 00	spri2	pr6|226
004432  aa   773431 3520 04	epp2 	-2279,ic		000063 = 530000000040
004433  aa  6 00344 2521 00	spri2	pr6|228
004434  aa   773377 3520 04	epp2 	-2305,ic		000033 = 524000000111
004435  aa  6 00346 2521 00	spri2	pr6|230
004436  aa   773412 3520 04	epp2 	-2294,ic		000050 = 524000000040
004437  aa  6 00350 2521 00	spri2	pr6|232
004440  aa  6 00324 6211 00	eax1 	pr6|212
004441  aa   024000 4310 07	fld  	10240,dl
004442  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
004443  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 614
		goto detach_and_continue;

004444  aa   777132 7100 04	tra  	-422,ic		003576
						STATEMENT 1 ON LINE 615
	        end;

						STATEMENT 1 ON LINE 616
	    end;

						STATEMENT 1 ON LINE 617
	end;

						STATEMENT 1 ON LINE 618
      end;

						STATEMENT 1 ON LINE 620
  end check_input_error;

004445  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE check_input_error
BEGIN PROCEDURE attach
ENTRY TO attach                                             STATEMENT 1 ON LINE 627
attach: proc;

004446  da     000433200000
004447  aa   000300 6270 00	eax7 	192
004450  aa  7 00034 3521 20	epp2 	pr7|28,*
004451  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
004452  aa     000000000000
004453  aa     000000000000
						STATEMENT 1 ON LINE 636
retry_attach:
    retry_attach_label = retry_attach;

004454  aa  6 00040 3735 20	epp7 	pr6|32,*
004455  aa   777777 3520 04	epp2 	-1,ic		004454 = 600040373520
004456  aa  7 00104 2521 00	spri2	pr7|68		retry_attach_label
004457  aa  7 00106 6521 00	spri6	pr7|70		retry_attach_label
						STATEMENT 1 ON LINE 639
    if ^rldr_data_.manual then do;

004460  aa  7 00032 3715 20	epp5 	pr7|26,*
004461  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004462  aa  3 00000 2351 20	lda  	pr3|0,*		rldr_data_.manual
004463  aa   000200 3150 03	cana 	128,du
004464  aa   000056 6010 04	tnz  	46,ic		004542
						STATEMENT 1 ON LINE 640
        rldr_input_volume_list.curn_entry = rldr_input_volume_list.curn_entry + 1;

004465  aa  3 00000 3515 20	epp1 	pr3|0,*		rldr_datap
004466  aa  1 00430 3735 20	epp7 	pr1|280,*		rldr_data_.input_vol_lstp
004467  aa  7 00001 0541 00	aos  	pr7|1		rldr_input_volume_list.curn_entry
						STATEMENT 1 ON LINE 641
        if rldr_input_volume_list.curn_entry > rldr_input_volume_list.num_entries then do;

004470  aa  7 00001 2361 00	ldq  	pr7|1		rldr_input_volume_list.curn_entry
004471  aa  7 00000 1161 00	cmpq 	pr7|0		rldr_input_volume_list.num_entries
004472  aa   000010 6044 04	tmoz 	8,ic		004502
						STATEMENT 1 ON LINE 642
no_more:	  code = error_table_$end_of_info;

004473  aa  6 00044 3701 20	epp4 	pr6|36,*
004474  la  4 00070 2361 20	ldq  	pr4|56,*		error_table_$end_of_info
004475  aa  6 00040 3735 20	epp7 	pr6|32,*
004476  aa  7 01124 7561 20	stq  	pr7|596,*		code
						STATEMENT 1 ON LINE 643
	  goto get_object_ret;

004477  aa   774450 3520 04	epp2 	-1752,ic		001147 = 000631710100
004500  aa   000001 7270 07	lxl7 	1,dl
004501  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 644
	end;

						STATEMENT 1 ON LINE 645
        volid = rldr_input_volume_list (rldr_input_volume_list.curn_entry).volid;

004502  aa   000011 4020 07	mpy  	9,dl
004503  aa  7 00001 2351 06	lda  	pr7|1,ql		rldr_input_volume_list.volid
004504  aa  6 00040 3715 20	epp5 	pr6|32,*
004505  aa  5 00272 7551 00	sta  	pr5|186		volid
						STATEMENT 1 ON LINE 646
        volname = rldr_input_volume_list (rldr_input_volume_list.curn_entry).volname;

004506  aa  7 77771 3715 06	epp5 	pr7|-7,ql		rldr_input_volume_list.volname
004507  aa  6 00040 3735 20	epp7 	pr6|32,*
004510  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004511  aa  5 00000 00 0040	desc9a	pr5|0,32		rldr_input_volume_list.volname
004512  aa  7 00333 00 0040	desc9a	pr7|219,32	volname
						STATEMENT 1 ON LINE 648
        do i = 1 to rldr_data_.npvs;

004513  aa  1 00404 2361 00	ldq  	pr1|260		rldr_data_.npvs
004514  aa  6 00101 7561 00	stq  	pr6|65
004515  aa   000001 2360 07	ldq  	1,dl
004516  aa  6 00100 7561 00	stq  	pr6|64		i
004517  aa   000000 0110 03	nop  	0,du
004520  aa  6 00100 2361 00	ldq  	pr6|64		i
004521  aa  6 00101 1161 00	cmpq 	pr6|65
004522  aa   000200 6054 04	tpnz 	128,ic		004722
						STATEMENT 1 ON LINE 649
	controlp = rldr_data_.controlp (i);

004523  aa   000064 4020 07	mpy  	52,dl
004524  aa  6 00040 3735 20	epp7 	pr6|32,*
004525  aa  7 00032 3715 20	epp5 	pr7|26,*
004526  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004527  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004530  aa  3 00430 3515 26	epp1 	pr3|280,ql*	rldr_data_.controlp
004531  aa  7 01100 2515 00	spri1	pr7|576		controlp
						STATEMENT 1 ON LINE 650
	rldr_control.curn_volname = volname;

004532  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004533  aa  7 00333 00 0040	desc9a	pr7|219,32	volname
004534  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_control.curn_volname
						STATEMENT 1 ON LINE 651
	rldr_control.curn_volid = volid;

004535  aa  7 00272 2351 00	lda  	pr7|186		volid
004536  aa  1 00022 7551 00	sta  	pr1|18		rldr_control.curn_volid
						STATEMENT 1 ON LINE 652
        end;

004537  aa  6 00100 0541 00	aos  	pr6|64		i
004540  aa   777760 7100 04	tra  	-16,ic		004520
						STATEMENT 1 ON LINE 653
      end;

004541  aa   000161 7100 04	tra  	113,ic		004722
						STATEMENT 1 ON LINE 654
    else do;

						STATEMENT 1 ON LINE 655
        query_info.yes_or_no_sw = "0"b;

004542  aa   003413 2350 04	lda  	1803,ic		010155 = 377777777777
004543  aa  7 01105 3551 00	ansa 	pr7|581		query_info.yes_or_no_sw
						STATEMENT 1 ON LINE 656
request: call command_query_ (addr (query_info), avolname, myname, "Type input volume name: ");

004544  aa  6 00040 3735 20	epp7 	pr6|32,*
004545  aa  7 01104 3735 00	epp7 	pr7|580		query_info
004546  aa  6 00114 6535 00	spri7	pr6|76
004547  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004550  aa   773406 00 0030	desc9a	-2298,24		000155 = 124171160145
004551  aa  6 00116 00 0030	desc9a	pr6|78,24
004552  aa  6 00114 3521 00	epp2 	pr6|76
004553  aa  6 00126 2521 00	spri2	pr6|86
004554  aa  6 00040 3715 20	epp5 	pr6|32,*
004555  aa  5 00111 3521 00	epp2 	pr5|73		avolname
004556  aa  6 00130 2521 00	spri2	pr6|88
004557  aa   773225 3520 04	epp2 	-2411,ic		000004 = 162154144162
004560  aa  6 00132 2521 00	spri2	pr6|90
004561  aa  6 00116 3521 00	epp2 	pr6|78
004562  aa  6 00134 2521 00	spri2	pr6|92
004563  aa   773301 3520 04	epp2 	-2367,ic		000064 = 464000000000
004564  aa  6 00136 2521 00	spri2	pr6|94
004565  aa   773276 3520 04	epp2 	-2370,ic		000063 = 530000000040
004566  aa  6 00140 2521 00	spri2	pr6|96
004567  aa  6 00142 2521 00	spri2	pr6|98
004570  aa   773242 3520 04	epp2 	-2398,ic		000032 = 524000000030
004571  aa  6 00144 2521 00	spri2	pr6|100
004572  aa  6 00124 6211 00	eax1 	pr6|84
004573  aa   020000 4310 07	fld  	8192,dl
004574  aa  6 00044 3701 20	epp4 	pr6|36,*
004575  la  4 00036 3521 20	epp2 	pr4|30,*		command_query_
004576  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 657
        volname = avolname;

004577  aa  6 00040 3735 20	epp7 	pr6|32,*
004600  aa  7 00110 7271 00	lxl7 	pr7|72		avolname
004601  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
004602  aa  7 00111 00 0017	desc9a	pr7|73,x7		avolname
004603  aa  7 00333 00 0040	desc9a	pr7|219,32	volname
						STATEMENT 1 ON LINE 658
        if volname = "" then goto request;

004604  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004605  aa  7 00333 00 0040	desc9a	pr7|219,32	volname
004606  aa   003353 00 0000	desc9a	1771,0		010157 = 076000000000
004607  aa   777735 6000 04	tze  	-35,ic		004544
						STATEMENT 1 ON LINE 659
        if volname = "." then goto no_more;

004610  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004611  aa  7 00333 00 0040	desc9a	pr7|219,32	volname
004612  aa   003350 00 0001	desc9a	1768,1		010160 = 056000000000
004613  aa   777660 6000 04	tze  	-80,ic		004473
						STATEMENT 1 ON LINE 660
        volid = get_volid_ (volname);

004614  aa  7 00333 3521 00	epp2 	pr7|219		volname
004615  aa  6 00126 2521 00	spri2	pr6|86
004616  aa  7 00272 3521 00	epp2 	pr7|186		volid
004617  aa  6 00130 2521 00	spri2	pr6|88
004620  aa  6 00124 3521 00	epp2 	pr6|84
004621  aa   010000 4310 07	fld  	4096,dl
004622  aa  2 00000 7571 00	staq 	pr2|0
004623  aa   001771 6700 04	tsp4 	1017,ic		006614
						STATEMENT 1 ON LINE 661
        if code ^= 0 then do;

004624  aa  6 00040 3735 20	epp7 	pr6|32,*
004625  aa  7 01124 2361 20	ldq  	pr7|596,*		code
004626  aa   000022 6000 04	tze  	18,ic		004650
						STATEMENT 1 ON LINE 662
	  call ioa_ ("invalid volume identifier ^a", volname);

004627  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004630  aa   773334 00 0034	desc9a	-2340,28		000163 = 151156166141
004631  aa  6 00124 00 0034	desc9a	pr6|84,28
004632  aa  6 00124 3521 00	epp2 	pr6|84
004633  aa  6 00150 2521 00	spri2	pr6|104
004634  aa  7 00333 3521 00	epp2 	pr7|219		volname
004635  aa  6 00152 2521 00	spri2	pr6|106
004636  aa   773173 3520 04	epp2 	-2437,ic		000031 = 524000000034
004637  aa  6 00154 2521 00	spri2	pr6|108
004640  aa   773230 3520 04	epp2 	-2408,ic		000070 = 526000000040
004641  aa  6 00156 2521 00	spri2	pr6|110
004642  aa  6 00146 6211 00	eax1 	pr6|102
004643  aa   010000 4310 07	fld  	4096,dl
004644  aa  6 00044 3701 20	epp4 	pr6|36,*
004645  la  4 00032 3521 20	epp2 	pr4|26,*		ioa_
004646  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 663
	  goto request;

004647  aa   777675 7100 04	tra  	-67,ic		004544
						STATEMENT 1 ON LINE 664
	end;

						STATEMENT 1 ON LINE 665
        query_info.yes_or_no_sw = "1"b;

004650  aa   400000 2350 03	lda  	131072,du
004651  aa  7 01105 2551 00	orsa 	pr7|581		query_info.yes_or_no_sw
						STATEMENT 1 ON LINE 666
        do i = 1 to rldr_data_.npvs;

004652  aa  7 00032 3715 20	epp5 	pr7|26,*
004653  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004654  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004655  aa  3 00404 2361 00	ldq  	pr3|260		rldr_data_.npvs
004656  aa  6 00102 7561 00	stq  	pr6|66
004657  aa   000001 2360 07	ldq  	1,dl
004660  aa  6 00100 7561 00	stq  	pr6|64		i
004661  aa   000000 0110 03	nop  	0,du
004662  aa  6 00100 2361 00	ldq  	pr6|64		i
004663  aa  6 00102 1161 00	cmpq 	pr6|66
004664  aa   000017 6054 04	tpnz 	15,ic		004703
						STATEMENT 1 ON LINE 667
	controlp = rldr_data_.controlp (i);

004665  aa   000064 4020 07	mpy  	52,dl
004666  aa  6 00040 3735 20	epp7 	pr6|32,*
004667  aa  7 00032 3715 20	epp5 	pr7|26,*
004670  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004671  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004672  aa  3 00430 3515 26	epp1 	pr3|280,ql*	rldr_data_.controlp
004673  aa  7 01100 2515 00	spri1	pr7|576		controlp
						STATEMENT 1 ON LINE 668
	rldr_control.curn_volname = volname;

004674  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004675  aa  7 00333 00 0040	desc9a	pr7|219,32	volname
004676  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_control.curn_volname
						STATEMENT 1 ON LINE 669
	rldr_control.curn_volid = volid;

004677  aa  7 00272 2351 00	lda  	pr7|186		volid
004700  aa  1 00022 7551 00	sta  	pr1|18		rldr_control.curn_volid
						STATEMENT 1 ON LINE 670
        end;

004701  aa  6 00100 0541 00	aos  	pr6|64		i
004702  aa   777760 7100 04	tra  	-16,ic		004662
						STATEMENT 1 ON LINE 671
        rldr_input_volume_list.curn_entry = 1;

004703  aa   000001 2360 07	ldq  	1,dl
004704  aa  6 00040 3735 20	epp7 	pr6|32,*
004705  aa  7 00032 3715 20	epp5 	pr7|26,*
004706  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004707  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004710  aa  3 00430 3515 20	epp1 	pr3|280,*		rldr_data_.input_vol_lstp
004711  aa  1 00001 7561 00	stq  	pr1|1		rldr_input_volume_list.curn_entry
						STATEMENT 1 ON LINE 672
        rldr_input_volume_list (rldr_input_volume_list.curn_entry).volname = volname;

004712  aa   000011 4020 07	mpy  	9,dl
004713  aa  1 77771 3735 06	epp7 	pr1|-7,ql		rldr_input_volume_list.volname
004714  aa  6 00040 3715 20	epp5 	pr6|32,*
004715  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004716  aa  5 00333 00 0040	desc9a	pr5|219,32	volname
004717  aa  7 00000 00 0040	desc9a	pr7|0,32		rldr_input_volume_list.volname
						STATEMENT 1 ON LINE 673
        rldr_input_volume_list (rldr_input_volume_list.curn_entry).volid = volid;

004720  aa  5 00272 2351 00	lda  	pr5|186		volid
004721  aa  1 00001 7551 06	sta  	pr1|1,ql		rldr_input_volume_list.volid
						STATEMENT 1 ON LINE 674
      end;

						STATEMENT 1 ON LINE 676
    if rldr_data_.input_volume_desc ^= "" then
      call ioa_$rsnnl (rldr_data_.input_volume_desc, att_desc, (0), volname);

004722  aa  6 00040 3735 20	epp7 	pr6|32,*
004723  aa  7 00032 3715 20	epp5 	pr7|26,*
004724  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
004725  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
004726  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004727  aa  3 00201 00 0400	desc9a	pr3|129,256	rldr_data_.input_volume_desc
004730  aa   003231 00 0000	desc9a	1689,0		010157 = 076000000000
004731  aa   000030 6000 04	tze  	24,ic		004761
004732  aa  6 00113 4501 00	stz  	pr6|75
004733  aa  3 00201 3521 00	epp2 	pr3|129		rldr_data_.input_volume_desc
004734  aa  6 00126 2521 00	spri2	pr6|86
004735  aa  7 00131 3521 00	epp2 	pr7|89		att_desc
004736  aa  6 00130 2521 00	spri2	pr6|88
004737  aa  6 00113 3521 00	epp2 	pr6|75
004740  aa  6 00132 2521 00	spri2	pr6|90
004741  aa  7 00333 3521 00	epp2 	pr7|219		volname
004742  aa  6 00134 2521 00	spri2	pr6|92
004743  aa   773065 3520 04	epp2 	-2507,ic		000030 = 524000000400
004744  aa  6 00136 2521 00	spri2	pr6|94
004745  aa   773062 3520 04	epp2 	-2510,ic		000027 = 526000000400
004746  aa  6 00140 2521 00	spri2	pr6|96
004747  aa   773112 3520 04	epp2 	-2486,ic		000061 = 404000000005
004750  aa  6 00142 2521 00	spri2	pr6|98
004751  aa   773117 3520 04	epp2 	-2481,ic		000070 = 526000000040
004752  aa  6 00144 2521 00	spri2	pr6|100
004753  aa  6 00124 6211 00	eax1 	pr6|84
004754  aa   020000 4310 07	fld  	8192,dl
004755  aa  6 00044 3701 20	epp4 	pr6|36,*
004756  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_$rsnnl
004757  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
004760  aa   000032 7100 04	tra  	26,ic		005012
						STATEMENT 1 ON LINE 678
    else call ioa_$rsnnl ("tape_mult_ ^a -system", att_desc, (0), volname);

004761  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004762  aa   773166 00 0030	desc9a	-2442,24		000147 = 164141160145
004763  aa  6 00116 00 0030	desc9a	pr6|78,24
004764  aa  6 00113 4501 00	stz  	pr6|75
004765  aa  6 00116 3521 00	epp2 	pr6|78
004766  aa  6 00126 2521 00	spri2	pr6|86
004767  aa  7 00131 3521 00	epp2 	pr7|89		att_desc
004770  aa  6 00130 2521 00	spri2	pr6|88
004771  aa  6 00113 3521 00	epp2 	pr6|75
004772  aa  6 00132 2521 00	spri2	pr6|90
004773  aa  7 00333 3521 00	epp2 	pr7|219		volname
004774  aa  6 00134 2521 00	spri2	pr6|92
004775  aa   773031 3520 04	epp2 	-2535,ic		000026 = 524000000025
004776  aa  6 00136 2521 00	spri2	pr6|94
004777  aa   773030 3520 04	epp2 	-2536,ic		000027 = 526000000400
005000  aa  6 00140 2521 00	spri2	pr6|96
005001  aa   773060 3520 04	epp2 	-2512,ic		000061 = 404000000005
005002  aa  6 00142 2521 00	spri2	pr6|98
005003  aa   773065 3520 04	epp2 	-2507,ic		000070 = 526000000040
005004  aa  6 00144 2521 00	spri2	pr6|100
005005  aa  6 00124 6211 00	eax1 	pr6|84
005006  aa   020000 4310 07	fld  	8192,dl
005007  aa  6 00044 3701 20	epp4 	pr6|36,*
005010  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_$rsnnl
005011  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 680
    if get_group_id_ () = "Initializer.SysDaemon.z" & hcs_$level_get () = 1 then ring_1 = "1"b;

005012  aa  6 00113 3521 00	epp2 	pr6|75
005013  aa  6 00120 2521 00	spri2	pr6|80
005014  aa  6 00116 6211 00	eax1 	pr6|78
005015  aa   004000 4310 07	fld  	2048,dl
005016  aa  6 00044 3701 20	epp4 	pr6|36,*
005017  la  4 00020 3521 20	epp2 	pr4|16,*		hcs_$level_get
005020  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
005021  aa  6 00113 2361 00	ldq  	pr6|75
005022  aa   000001 1160 07	cmpq 	1,dl
005023  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
005024  aa  6 00113 7551 00	sta  	pr6|75
005025  aa  6 00146 3521 00	epp2 	pr6|102
005026  aa  6 00120 2521 00	spri2	pr6|80
005027  aa  6 00116 6211 00	eax1 	pr6|78
005030  aa   004000 4310 07	fld  	2048,dl
005031  aa  6 00044 3701 20	epp4 	pr6|36,*
005032  la  4 00016 3521 20	epp2 	pr4|14,*		get_group_id_
005033  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
005034  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
005035  aa  6 00146 00 0040	desc9a	pr6|102,32
005036  aa   773105 00 0027	desc9a	-2491,23		000141 = 111156151164
005037  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
005040  aa  6 00113 3151 00	cana 	pr6|75
005041  aa   000005 6000 04	tze  	5,ic		005046
005042  aa   400000 2350 03	lda  	131072,du
005043  aa  6 00040 3735 20	epp7 	pr6|32,*
005044  aa  7 00126 7551 00	sta  	pr7|86		ring_1
005045  aa   000003 7100 04	tra  	3,ic		005050
						STATEMENT 1 ON LINE 681
    else ring_1 = "0"b;

005046  aa  6 00040 3735 20	epp7 	pr6|32,*
005047  aa  7 00126 4501 00	stz  	pr7|86		ring_1
						STATEMENT 1 ON LINE 682
retry: if ring_1 then call timer_manager_$alarm_call (180, "11"b, attach_timer);

005050  aa  6 00040 3735 20	epp7 	pr6|32,*
005051  aa  7 00126 2351 00	lda  	pr7|86		ring_1
005052  aa   000025 6000 04	tze  	21,ic		005077
005053  aa   773027 2370 04	ldaq 	-2537,ic		000102 = 000000000000 000000000264
005054  aa  6 00114 7571 00	staq 	pr6|76
005055  aa   600000 2350 03	lda  	196608,du
005056  aa  6 00113 7551 00	sta  	pr6|75
005057  aa   001706 3520 04	epp2 	966,ic		006765 = 000160627000
005060  aa   000001 2360 07	ldq  	1,dl
005061  aa  0 00653 7001 00	tsx0 	pr0|427		make_label_var
005062  aa  6 00116 3521 00	epp2 	pr6|78		cp.926
005063  aa  0 00652 7001 00	tsx0 	pr0|426		move_label_var
005064  aa  6 00114 3521 00	epp2 	pr6|76
005065  aa  6 00150 2521 00	spri2	pr6|104
005066  aa  6 00113 3521 00	epp2 	pr6|75
005067  aa  6 00152 2521 00	spri2	pr6|106
005070  aa  6 00116 3521 00	epp2 	pr6|78		cp.926
005071  aa  6 00154 2521 00	spri2	pr6|108
005072  aa  6 00146 6211 00	eax1 	pr6|102
005073  aa   014000 4310 07	fld  	6144,dl
005074  aa  6 00044 3701 20	epp4 	pr6|36,*
005075  la  4 00022 3521 20	epp2 	pr4|18,*		timer_manager_$alarm_call
005076  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 683
    call iox_$attach_name ("input_volume", rldr_data_.inputvol_iocbp, att_desc, null, code);

005077  aa   773016 2350 04	lda  	-2546,ic		000115 = 151156160165
005100  aa   773016 2360 04	ldq  	-2546,ic		000116 = 164137166157
005101  aa  6 00116 7571 00	staq 	pr6|78
005102  aa   773015 2350 04	lda  	-2547,ic		000117 = 154165155145
005103  aa  6 00120 7551 00	sta  	pr6|80
005104  aa   773004 3734 24	epp7 	-2556,ic*
005105  aa  6 00114 6535 00	spri7	pr6|76
005106  aa  6 00116 3521 00	epp2 	pr6|78
005107  aa  6 00162 2521 00	spri2	pr6|114
005110  aa  6 00040 3715 20	epp5 	pr6|32,*
005111  aa  5 00032 3535 20	epp3 	pr5|26,*
005112  aa  3 00002 3515 20	epp1 	pr3|2,*		rldr_datap
005113  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
005114  aa  1 00414 3521 00	epp2 	pr1|268		rldr_data_.inputvol_iocbp
005115  aa  6 00164 2521 00	spri2	pr6|116
005116  aa  5 00131 3521 00	epp2 	pr5|89		att_desc
005117  aa  6 00166 2521 00	spri2	pr6|118
005120  aa  6 00114 3521 00	epp2 	pr6|76
005121  aa  6 00170 2521 00	spri2	pr6|120
005122  aa  5 01124 3521 20	epp2 	pr5|596,*		code
005123  aa  6 00172 2521 00	spri2	pr6|122
005124  aa   772701 3520 04	epp2 	-2623,ic		000025 = 524000000014
005125  aa  6 00174 2521 00	spri2	pr6|124
005126  aa   772736 3520 04	epp2 	-2594,ic		000064 = 464000000000
005127  aa  6 00176 2521 00	spri2	pr6|126
005130  aa  6 00202 2521 00	spri2	pr6|130
005131  aa   772676 3520 04	epp2 	-2626,ic		000027 = 526000000400
005132  aa  6 00200 2521 00	spri2	pr6|128
005133  aa   772740 3520 04	epp2 	-2592,ic		000073 = 404000000043
005134  aa  6 00204 2521 00	spri2	pr6|132
005135  aa  6 00160 6211 00	eax1 	pr6|112
005136  aa   024000 4310 07	fld  	10240,dl
005137  aa  6 00044 3701 20	epp4 	pr6|36,*
005140  la  4 00074 3521 20	epp2 	pr4|60,*		iox_$attach_name
005141  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 684
    if ring_1 then call timer_manager_$reset_alarm_call (attach_timer);

005142  aa  6 00040 3735 20	epp7 	pr6|32,*
005143  aa  7 00126 2351 00	lda  	pr7|86		ring_1
005144  aa   000015 6000 04	tze  	13,ic		005161
005145  aa   001620 3520 04	epp2 	912,ic		006765 = 000160627000
005146  aa   000001 2360 07	ldq  	1,dl
005147  aa  0 00653 7001 00	tsx0 	pr0|427		make_label_var
005150  aa  6 00116 3521 00	epp2 	pr6|78		cp.926
005151  aa  0 00652 7001 00	tsx0 	pr0|426		move_label_var
005152  aa  6 00116 3521 00	epp2 	pr6|78		cp.926
005153  aa  6 00150 2521 00	spri2	pr6|104
005154  aa  6 00146 6211 00	eax1 	pr6|102
005155  aa   004000 4310 07	fld  	2048,dl
005156  aa  6 00044 3701 20	epp4 	pr6|36,*
005157  la  4 00024 3521 20	epp2 	pr4|20,*		timer_manager_$reset_alarm_call
005160  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 685
    if code ^= 0 then do;

005161  aa  6 00040 3735 20	epp7 	pr6|32,*
005162  aa  7 01124 2361 20	ldq  	pr7|596,*		code
005163  aa   000106 6000 04	tze  	70,ic		005271
						STATEMENT 1 ON LINE 686
        if code = error_table_$resource_unavailable then do;

005164  aa  6 00044 3701 20	epp4 	pr6|36,*
005165  la  4 00066 1161 20	cmpq 	pr4|54,*		error_table_$resource_unavailable
005166  aa   000043 6010 04	tnz  	35,ic		005231
						STATEMENT 1 ON LINE 687
	  query_info.version = query_info_version_5;

005167  aa   000005 2360 07	ldq  	5,dl
005170  aa  7 01104 7561 00	stq  	pr7|580		query_info.version
						STATEMENT 1 ON LINE 688
	  call command_query_$yes_no (YES, 0, myname, "", "
The physical drive or dump volume is not available or is in use by an other process.
Do you wish to retry the attachment");

005171  aa  6 00113 4501 00	stz  	pr6|75
005172  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005173  aa   773506 00 0174	desc9a	-2234,124		000700 = 012124150145
005174  aa  6 00210 00 0174	desc9a	pr6|136,124
005175  aa  7 00124 3521 00	epp2 	pr7|84		YES
005176  aa  6 00162 2521 00	spri2	pr6|114
005177  aa  6 00113 3521 00	epp2 	pr6|75
005200  aa  6 00164 2521 00	spri2	pr6|116
005201  aa   772603 3520 04	epp2 	-2685,ic		000004 = 162154144162
005202  aa  6 00166 2521 00	spri2	pr6|118
005203  aa  6 00206 3521 00	epp2 	pr6|134
005204  aa  6 00170 2521 00	spri2	pr6|120
005205  aa  6 00210 3521 00	epp2 	pr6|136
005206  aa  6 00172 2521 00	spri2	pr6|122
005207  aa   772666 3520 04	epp2 	-2634,ic		000075 = 516000000001
005210  aa  6 00174 2521 00	spri2	pr6|124
005211  aa   772650 3520 04	epp2 	-2648,ic		000061 = 404000000005
005212  aa  6 00176 2521 00	spri2	pr6|126
005213  aa   772650 3520 04	epp2 	-2648,ic		000063 = 530000000040
005214  aa  6 00200 2521 00	spri2	pr6|128
005215  aa   772636 3520 04	epp2 	-2658,ic		000053 = 524000000000
005216  aa  6 00202 2521 00	spri2	pr6|130
005217  aa   772605 3520 04	epp2 	-2683,ic		000024 = 524000000171
005220  aa  6 00204 2521 00	spri2	pr6|132
005221  aa  6 00160 6211 00	eax1 	pr6|112
005222  aa   024000 4310 07	fld  	10240,dl
005223  la  4 00040 3521 20	epp2 	pr4|32,*		command_query_$yes_no
005224  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 691
	  if YES then goto retry;

005225  aa  6 00040 3735 20	epp7 	pr6|32,*
005226  aa  7 00124 2351 00	lda  	pr7|84		YES
005227  aa   400000 3150 03	cana 	131072,du
005230  aa   777620 6010 04	tnz  	-112,ic		005050
						STATEMENT 1 ON LINE 692
	end;

						STATEMENT 1 ON LINE 693
        call rldr_report_$error_output (rldr_datap, code, myname, "Unable to attach dump volume ^a", volname);

005231  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005232  aa   773010 00 0040	desc9a	-2552,32		000241 = 125156141142
005233  aa  6 00146 00 0040	desc9a	pr6|102,32
005234  aa  7 00032 3715 20	epp5 	pr7|26,*
005235  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
005236  aa  6 00162 2521 00	spri2	pr6|114
005237  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005240  aa  6 00164 2521 00	spri2	pr6|116
005241  aa   772543 3520 04	epp2 	-2717,ic		000004 = 162154144162
005242  aa  6 00166 2521 00	spri2	pr6|118
005243  aa  6 00146 3521 00	epp2 	pr6|102
005244  aa  6 00170 2521 00	spri2	pr6|120
005245  aa  7 00333 3521 00	epp2 	pr7|219		volname
005246  aa  6 00172 2521 00	spri2	pr6|122
005247  aa   772615 3520 04	epp2 	-2675,ic		000064 = 464000000000
005250  aa  6 00174 2521 00	spri2	pr6|124
005251  aa   772622 3520 04	epp2 	-2670,ic		000073 = 404000000043
005252  aa  6 00176 2521 00	spri2	pr6|126
005253  aa   772610 3520 04	epp2 	-2680,ic		000063 = 530000000040
005254  aa  6 00200 2521 00	spri2	pr6|128
005255  aa   772546 3520 04	epp2 	-2714,ic		000023 = 524000000037
005256  aa  6 00202 2521 00	spri2	pr6|130
005257  aa   772611 3520 04	epp2 	-2679,ic		000070 = 526000000040
005260  aa  6 00204 2521 00	spri2	pr6|132
005261  aa  6 00160 6211 00	eax1 	pr6|112
005262  aa   024000 4310 07	fld  	10240,dl
005263  aa  6 00044 3701 20	epp4 	pr6|36,*
005264  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
005265  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 694
        goto retry_attach_label;

005266  aa  6 00040 3735 20	epp7 	pr6|32,*
005267  aa  7 00104 3521 00	epp2 	pr7|68		retry_attach_label
005270  aa  0 00660 7101 00	tra  	pr0|432		tra_ext_2
						STATEMENT 1 ON LINE 695
      end;

						STATEMENT 1 ON LINE 697
    call iox_$open (rldr_data_.inputvol_iocbp, Stream_input, "0"b, code);

005271  aa   000000 2350 07	lda  	0,dl
005272  aa  6 00206 7551 00	sta  	pr6|134
005273  aa  7 00032 3715 20	epp5 	pr7|26,*
005274  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005275  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005276  aa  3 00414 3521 00	epp2 	pr3|268		rldr_data_.inputvol_iocbp
005277  aa  6 00150 2521 00	spri2	pr6|104
005300  aa   772571 3520 04	epp2 	-2695,ic		000071 = 000000000001
005301  aa  6 00152 2521 00	spri2	pr6|106
005302  aa  6 00206 3521 00	epp2 	pr6|134
005303  aa  6 00154 2521 00	spri2	pr6|108
005304  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005305  aa  6 00156 2521 00	spri2	pr6|110
005306  aa  6 00146 6211 00	eax1 	pr6|102
005307  aa   020000 4310 07	fld  	8192,dl
005310  aa  6 00044 3701 20	epp4 	pr6|36,*
005311  la  4 00104 3521 20	epp2 	pr4|68,*		iox_$open
005312  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 698
    if code ^= 0 then do;

005313  aa  6 00040 3735 20	epp7 	pr6|32,*
005314  aa  7 01124 2361 20	ldq  	pr7|596,*		code
005315  aa   000054 6000 04	tze  	44,ic		005371
						STATEMENT 1 ON LINE 699
        call rldr_report_$error_output (rldr_datap, code, myname, "Error on opening dump volume ^a", volname);

005316  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005317  aa   772713 00 0040	desc9a	-2613,32		000231 = 105162162157
005320  aa  6 00146 00 0040	desc9a	pr6|102,32
005321  aa  7 00032 3715 20	epp5 	pr7|26,*
005322  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
005323  aa  6 00162 2521 00	spri2	pr6|114
005324  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005325  aa  6 00164 2521 00	spri2	pr6|116
005326  aa   772456 3520 04	epp2 	-2770,ic		000004 = 162154144162
005327  aa  6 00166 2521 00	spri2	pr6|118
005330  aa  6 00146 3521 00	epp2 	pr6|102
005331  aa  6 00170 2521 00	spri2	pr6|120
005332  aa  7 00333 3521 00	epp2 	pr7|219		volname
005333  aa  6 00172 2521 00	spri2	pr6|122
005334  aa   772530 3520 04	epp2 	-2728,ic		000064 = 464000000000
005335  aa  6 00174 2521 00	spri2	pr6|124
005336  aa   772535 3520 04	epp2 	-2723,ic		000073 = 404000000043
005337  aa  6 00176 2521 00	spri2	pr6|126
005340  aa   772523 3520 04	epp2 	-2733,ic		000063 = 530000000040
005341  aa  6 00200 2521 00	spri2	pr6|128
005342  aa   772461 3520 04	epp2 	-2767,ic		000023 = 524000000037
005343  aa  6 00202 2521 00	spri2	pr6|130
005344  aa   772524 3520 04	epp2 	-2732,ic		000070 = 526000000040
005345  aa  6 00204 2521 00	spri2	pr6|132
005346  aa  6 00160 6211 00	eax1 	pr6|112
005347  aa   024000 4310 07	fld  	10240,dl
005350  aa  6 00044 3701 20	epp4 	pr6|36,*
005351  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
005352  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 700
        call iox_$detach_iocb (rldr_data_.inputvol_iocbp, ignore);

005353  aa  6 00040 3735 20	epp7 	pr6|32,*
005354  aa  7 00032 3715 20	epp5 	pr7|26,*
005355  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005356  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005357  aa  3 00414 3521 00	epp2 	pr3|268		rldr_data_.inputvol_iocbp
005360  aa  6 00120 2521 00	spri2	pr6|80
005361  aa  7 00127 3521 00	epp2 	pr7|87		ignore
005362  aa  6 00122 2521 00	spri2	pr6|82
005363  aa  6 00116 6211 00	eax1 	pr6|78
005364  aa   010000 4310 07	fld  	4096,dl
005365  aa  6 00044 3701 20	epp4 	pr6|36,*
005366  la  4 00100 3521 20	epp2 	pr4|64,*		iox_$detach_iocb
005367  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 701
        goto retry_attach;

005370  aa   777064 7100 04	tra  	-460,ic		004454
						STATEMENT 1 ON LINE 702
      end;

						STATEMENT 1 ON LINE 703
    do i = 1 to rldr_data_.npvs;

005371  aa  7 00032 3715 20	epp5 	pr7|26,*
005372  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005373  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005374  aa  3 00404 2361 00	ldq  	pr3|260		rldr_data_.npvs
005375  aa  6 00103 7561 00	stq  	pr6|67
005376  aa   000001 2360 07	ldq  	1,dl
005377  aa  6 00100 7561 00	stq  	pr6|64		i
005400  aa  6 00100 2361 00	ldq  	pr6|64		i
005401  aa  6 00103 1161 00	cmpq 	pr6|67
005402  aa   000016 6054 04	tpnz 	14,ic		005420
						STATEMENT 1 ON LINE 704
      controlp = rldr_data_.controlp (i);

005403  aa   000064 4020 07	mpy  	52,dl
005404  aa  6 00040 3735 20	epp7 	pr6|32,*
005405  aa  7 00032 3715 20	epp5 	pr7|26,*
005406  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005407  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005410  aa  3 00430 3515 26	epp1 	pr3|280,ql*	rldr_data_.controlp
005411  aa  7 01100 2515 00	spri1	pr7|576		controlp
						STATEMENT 1 ON LINE 705
      rldr_control.input_vol_seg_num = 0;

005412  aa  1 00016 4501 00	stz  	pr1|14		rldr_control.input_vol_seg_num
						STATEMENT 1 ON LINE 706
      rldr_control.input_vol_seg_rec = 0;

005413  aa  1 00017 4501 00	stz  	pr1|15		rldr_control.input_vol_seg_rec
						STATEMENT 1 ON LINE 707
      rldr_control.input_vol_dir_num = 0;

005414  aa  1 00014 4501 00	stz  	pr1|12		rldr_control.input_vol_dir_num
						STATEMENT 1 ON LINE 708
      rldr_control.input_vol_dir_rec = 0;

005415  aa  1 00015 4501 00	stz  	pr1|13		rldr_control.input_vol_dir_rec
						STATEMENT 1 ON LINE 709
    end;

005416  aa  6 00100 0541 00	aos  	pr6|64		i
005417  aa   777761 7100 04	tra  	-15,ic		005400
						STATEMENT 1 ON LINE 710
    return;

005420  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 712
  end attach;

  END PROCEDURE attach
BEGIN PROCEDURE detach
ENTRY TO detach                                             STATEMENT 1 ON LINE 719
detach: proc;

005421  da     000440200000
005422  aa   000260 6270 00	eax7 	176
005423  aa  7 00034 3521 20	epp2 	pr7|28,*
005424  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
005425  aa     000000000000
005426  aa     000000000000
						STATEMENT 1 ON LINE 724
    call iox_$close (rldr_data_.inputvol_iocbp, code);

005427  aa  6 00040 3735 20	epp7 	pr6|32,*
005430  aa  7 00032 3715 20	epp5 	pr7|26,*
005431  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005432  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005433  aa  3 00414 3521 00	epp2 	pr3|268		rldr_data_.inputvol_iocbp
005434  aa  6 00104 2521 00	spri2	pr6|68
005435  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005436  aa  6 00106 2521 00	spri2	pr6|70
005437  aa  6 00102 6211 00	eax1 	pr6|66
005440  aa   010000 4310 07	fld  	4096,dl
005441  la  4 00076 3521 20	epp2 	pr4|62,*		iox_$close
005442  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 725
    if code ^= 0 then
      call rldr_report_$error_output (rldr_datap, code, myname, "Unable to close dump volume ^a", volname);

005443  aa  6 00040 3735 20	epp7 	pr6|32,*
005444  aa  7 01124 2361 20	ldq  	pr7|596,*		code
005445  aa   000036 6000 04	tze  	30,ic		005503
005446  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005447  aa   772553 00 0040	desc9a	-2709,32		000221 = 125156141142
005450  aa  6 00110 00 0040	desc9a	pr6|72,32
005451  aa  7 00032 3715 20	epp5 	pr7|26,*
005452  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
005453  aa  6 00122 2521 00	spri2	pr6|82
005454  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005455  aa  6 00124 2521 00	spri2	pr6|84
005456  aa   772326 3520 04	epp2 	-2858,ic		000004 = 162154144162
005457  aa  6 00126 2521 00	spri2	pr6|86
005460  aa  6 00110 3521 00	epp2 	pr6|72
005461  aa  6 00130 2521 00	spri2	pr6|88
005462  aa  7 00333 3521 00	epp2 	pr7|219		volname
005463  aa  6 00132 2521 00	spri2	pr6|90
005464  aa   772400 3520 04	epp2 	-2816,ic		000064 = 464000000000
005465  aa  6 00134 2521 00	spri2	pr6|92
005466  aa   772405 3520 04	epp2 	-2811,ic		000073 = 404000000043
005467  aa  6 00136 2521 00	spri2	pr6|94
005470  aa   772373 3520 04	epp2 	-2821,ic		000063 = 530000000040
005471  aa  6 00140 2521 00	spri2	pr6|96
005472  aa   772330 3520 04	epp2 	-2856,ic		000022 = 524000000036
005473  aa  6 00142 2521 00	spri2	pr6|98
005474  aa   772374 3520 04	epp2 	-2820,ic		000070 = 526000000040
005475  aa  6 00144 2521 00	spri2	pr6|100
005476  aa  6 00120 6211 00	eax1 	pr6|80
005477  aa   024000 4310 07	fld  	10240,dl
005500  aa  6 00044 3701 20	epp4 	pr6|36,*
005501  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
005502  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 728
    call iox_$detach_iocb (rldr_data_.inputvol_iocbp, code);

005503  aa  6 00040 3735 20	epp7 	pr6|32,*
005504  aa  7 00032 3715 20	epp5 	pr7|26,*
005505  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005506  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005507  aa  3 00414 3521 00	epp2 	pr3|268		rldr_data_.inputvol_iocbp
005510  aa  6 00104 2521 00	spri2	pr6|68
005511  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005512  aa  6 00106 2521 00	spri2	pr6|70
005513  aa  6 00102 6211 00	eax1 	pr6|66
005514  aa   010000 4310 07	fld  	4096,dl
005515  aa  6 00044 3701 20	epp4 	pr6|36,*
005516  la  4 00100 3521 20	epp2 	pr4|64,*		iox_$detach_iocb
005517  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 729
    if code ^= 0 then
      call rldr_report_$error_output (rldr_datap, code, myname, "Unable to detach dump volume ^a", volname);

005520  aa  6 00040 3735 20	epp7 	pr6|32,*
005521  aa  7 01124 2361 20	ldq  	pr7|596,*		code
005522  aa   000036 6000 04	tze  	30,ic		005560
005523  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005524  aa   772466 00 0040	desc9a	-2762,32		000211 = 125156141142
005525  aa  6 00110 00 0040	desc9a	pr6|72,32
005526  aa  7 00032 3715 20	epp5 	pr7|26,*
005527  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
005530  aa  6 00122 2521 00	spri2	pr6|82
005531  aa  7 01124 3521 20	epp2 	pr7|596,*		code
005532  aa  6 00124 2521 00	spri2	pr6|84
005533  aa   772251 3520 04	epp2 	-2903,ic		000004 = 162154144162
005534  aa  6 00126 2521 00	spri2	pr6|86
005535  aa  6 00110 3521 00	epp2 	pr6|72
005536  aa  6 00130 2521 00	spri2	pr6|88
005537  aa  7 00333 3521 00	epp2 	pr7|219		volname
005540  aa  6 00132 2521 00	spri2	pr6|90
005541  aa   772323 3520 04	epp2 	-2861,ic		000064 = 464000000000
005542  aa  6 00134 2521 00	spri2	pr6|92
005543  aa   772330 3520 04	epp2 	-2856,ic		000073 = 404000000043
005544  aa  6 00136 2521 00	spri2	pr6|94
005545  aa   772316 3520 04	epp2 	-2866,ic		000063 = 530000000040
005546  aa  6 00140 2521 00	spri2	pr6|96
005547  aa   772254 3520 04	epp2 	-2900,ic		000023 = 524000000037
005550  aa  6 00142 2521 00	spri2	pr6|98
005551  aa   772317 3520 04	epp2 	-2865,ic		000070 = 526000000040
005552  aa  6 00144 2521 00	spri2	pr6|100
005553  aa  6 00120 6211 00	eax1 	pr6|80
005554  aa   024000 4310 07	fld  	10240,dl
005555  aa  6 00044 3701 20	epp4 	pr6|36,*
005556  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
005557  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 731
    rldr_data_.inputvol_iocbp = null;

005560  aa   772330 2370 04	ldaq 	-2856,ic		000110 = 077777000043 000001000000
005561  aa  6 00040 3735 20	epp7 	pr6|32,*
005562  aa  7 00032 3715 20	epp5 	pr7|26,*
005563  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005564  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005565  aa  3 00414 7571 00	staq 	pr3|268		rldr_data_.inputvol_iocbp
						STATEMENT 1 ON LINE 733
    call rldr_vtoc_buffer_$write (rldr_datap, ignore);

005566  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
005567  aa  6 00104 2521 00	spri2	pr6|68
005570  aa  7 00127 3521 00	epp2 	pr7|87		ignore
005571  aa  6 00106 2521 00	spri2	pr6|70
005572  aa  6 00102 6211 00	eax1 	pr6|66
005573  aa   010000 4310 07	fld  	4096,dl
005574  aa  6 00044 3701 20	epp4 	pr6|36,*
005575  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_vtoc_buffer_$write
005576  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 734
    do i = 1 to rldr_data_.npvs;

005577  aa  6 00040 3735 20	epp7 	pr6|32,*
005600  aa  7 00032 3715 20	epp5 	pr7|26,*
005601  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005602  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005603  aa  3 00404 2361 00	ldq  	pr3|260		rldr_data_.npvs
005604  aa  6 00101 7561 00	stq  	pr6|65
005605  aa   000001 2360 07	ldq  	1,dl
005606  aa  6 00100 7561 00	stq  	pr6|64		i
005607  aa   000000 0110 03	nop  	0,du
005610  aa  6 00100 2361 00	ldq  	pr6|64		i
005611  aa  6 00101 1161 00	cmpq 	pr6|65
005612  aa   000106 6054 04	tpnz 	70,ic		005720
						STATEMENT 1 ON LINE 735
      controlp = rldr_data_.controlp (i);

005613  aa   000064 4020 07	mpy  	52,dl
005614  aa  6 00040 3735 20	epp7 	pr6|32,*
005615  aa  7 00032 3715 20	epp5 	pr7|26,*
005616  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
005617  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
005620  aa  3 00430 3515 26	epp1 	pr3|280,ql*	rldr_data_.controlp
005621  aa  7 01100 2515 00	spri1	pr7|576		controlp
						STATEMENT 1 ON LINE 736
      if (rldr_control.input_vol_dir_rec ^= 0 | rldr_control.input_vol_seg_rec ^= 0) then do;

005622  aa  6 00146 7561 00	stq  	pr6|102
005623  aa  1 00015 2361 00	ldq  	pr1|13		rldr_control.input_vol_dir_rec
005624  aa   000003 6010 04	tnz  	3,ic		005627
005625  aa  1 00017 2361 00	ldq  	pr1|15		rldr_control.input_vol_seg_rec
005626  aa   000070 6000 04	tze  	56,ic		005716
						STATEMENT 1 ON LINE 737
	call rldr_report_$online_output (rldr_datap, 0, myname,
	     "reloaded from input volume ^a ^d records of ^d directories and ^d records of ^d segments on pv ^a",
	     rldr_control.curn_volname, rldr_control.input_vol_dir_rec, rldr_control.input_vol_dir_num,
	     rldr_control.input_vol_seg_rec, rldr_control.input_vol_seg_num, rldr_data_.pvname (i));

005627  aa   772221 2360 04	ldq  	-2927,ic		000050 = 524000000040
005630  aa  6 00147 7561 00	stq  	pr6|103
005631  aa  6 00150 4501 00	stz  	pr6|104
005632  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005633  aa   772764 00 0144	desc9a	-2572,100		000616 = 162145154157
005634  aa  6 00152 00 0144	desc9a	pr6|106,100
005635  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
005636  aa  6 00206 2521 00	spri2	pr6|134
005637  aa  6 00150 3521 00	epp2 	pr6|104
005640  aa  6 00210 2521 00	spri2	pr6|136
005641  aa   772143 3520 04	epp2 	-2973,ic		000004 = 162154144162
005642  aa  6 00212 2521 00	spri2	pr6|138
005643  aa  6 00152 3521 00	epp2 	pr6|106
005644  aa  6 00214 2521 00	spri2	pr6|140
005645  aa  1 00000 3521 00	epp2 	pr1|0		rldr_control.curn_volname
005646  aa  6 00216 2521 00	spri2	pr6|142
005647  aa  1 00015 3521 00	epp2 	pr1|13		rldr_control.input_vol_dir_rec
005650  aa  6 00220 2521 00	spri2	pr6|144
005651  aa  1 00014 3521 00	epp2 	pr1|12		rldr_control.input_vol_dir_num
005652  aa  6 00222 2521 00	spri2	pr6|146
005653  aa  1 00017 3521 00	epp2 	pr1|15		rldr_control.input_vol_seg_rec
005654  aa  6 00224 2521 00	spri2	pr6|148
005655  aa  1 00016 3521 00	epp2 	pr1|14		rldr_control.input_vol_seg_num
005656  aa  6 00226 2521 00	spri2	pr6|150
005657  aa  6 00146 7271 00	lxl7 	pr6|102
005660  aa  3 00353 3521 17	epp2 	pr3|235,7		rldr_data_.pvname
005661  aa  6 00230 2521 00	spri2	pr6|152
005662  aa   772202 3520 04	epp2 	-2942,ic		000064 = 464000000000
005663  aa  6 00232 2521 00	spri2	pr6|154
005664  aa   772175 3520 04	epp2 	-2947,ic		000061 = 404000000005
005665  aa  6 00234 2521 00	spri2	pr6|156
005666  aa   772175 3520 04	epp2 	-2947,ic		000063 = 530000000040
005667  aa  6 00236 2521 00	spri2	pr6|158
005670  aa   772144 3520 04	epp2 	-2972,ic		000034 = 524000000141
005671  aa  6 00240 2521 00	spri2	pr6|160
005672  aa   772156 3520 04	epp2 	-2962,ic		000050 = 524000000040
005673  aa  6 00242 2521 00	spri2	pr6|162
005674  aa   772176 3520 04	epp2 	-2946,ic		000072 = 404000000021
005675  aa  6 00244 2521 00	spri2	pr6|164
005676  aa  6 00246 2521 00	spri2	pr6|166
005677  aa  6 00250 2521 00	spri2	pr6|168
005700  aa  6 00252 2521 00	spri2	pr6|170
005701  aa  6 00147 3521 00	epp2 	pr6|103
005702  aa  6 00254 2521 00	spri2	pr6|172
005703  aa  6 00204 6211 00	eax1 	pr6|132
005704  aa   050000 4310 07	fld  	20480,dl
005705  aa  6 00044 3701 20	epp4 	pr6|36,*
005706  la  4 00054 3521 20	epp2 	pr4|44,*		rldr_report_$online_output
005707  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 743
	rldr_control.input_vol_seg_num = 0;

005710  aa  6 00040 3735 20	epp7 	pr6|32,*
005711  aa  7 01100 3715 20	epp5 	pr7|576,*		controlp
005712  aa  5 00016 4501 00	stz  	pr5|14		rldr_control.input_vol_seg_num
						STATEMENT 1 ON LINE 744
	rldr_control.input_vol_seg_rec = 0;

005713  aa  5 00017 4501 00	stz  	pr5|15		rldr_control.input_vol_seg_rec
						STATEMENT 1 ON LINE 745
	rldr_control.input_vol_dir_num = 0;

005714  aa  5 00014 4501 00	stz  	pr5|12		rldr_control.input_vol_dir_num
						STATEMENT 1 ON LINE 746
	rldr_control.input_vol_dir_rec = 0;

005715  aa  5 00015 4501 00	stz  	pr5|13		rldr_control.input_vol_dir_rec
						STATEMENT 1 ON LINE 747
        end;

						STATEMENT 1 ON LINE 748
    end;

005716  aa  6 00100 0541 00	aos  	pr6|64		i
005717  aa   777671 7100 04	tra  	-71,ic		005610
						STATEMENT 1 ON LINE 750
    return;

005720  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 752
  end detach;

  END PROCEDURE detach
BEGIN PROCEDURE lock_volume_log
ENTRY TO lock_volume_log                                    STATEMENT 1 ON LINE 757
lock_volume_log: proc;

005721  aa  6 01164 6501 00	spri4	pr6|628
						STATEMENT 1 ON LINE 761
    call set_lock_$lock (backup_volume_log.lock, -1, code);

005722  aa   000001 3360 07	lcq  	1,dl
005723  aa  6 01634 7561 00	stq  	pr6|924
005724  aa  6 00346 3735 20	epp7 	pr6|230,*		bvlp
005725  aa  7 02016 3521 00	epp2 	pr7|1038		backup_volume_log.lock
005726  aa  6 01640 2521 00	spri2	pr6|928
005727  aa  6 01634 3521 00	epp2 	pr6|924
005730  aa  6 01642 2521 00	spri2	pr6|930
005731  aa  6 01124 3521 20	epp2 	pr6|596,*		code
005732  aa  6 01644 2521 00	spri2	pr6|932
005733  aa  6 01636 6211 00	eax1 	pr6|926
005734  aa   014000 4310 07	fld  	6144,dl
005735  aa  6 00044 3701 20	epp4 	pr6|36,*
005736  la  4 00042 3521 20	epp2 	pr4|34,*		set_lock_$lock
005737  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 762
    if code ^= 0 then
      call rldr_report_$error_output (rldr_datap, code, myname, "Error locking volume log ^a.volog",
	 rldr_data_.pvname (pvindex));

005740  aa  6 01124 2361 20	ldq  	pr6|596,*		code
005741  aa   000044 6000 04	tze  	36,ic		006005
005742  aa   772106 2360 04	ldq  	-3002,ic		000050 = 524000000040
005743  aa  6 01634 7561 00	stq  	pr6|924
005744  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005745  aa   772336 00 0044	desc9a	-2850,36		000302 = 105162162157
005746  aa  6 01646 00 0044	desc9a	pr6|934,36
005747  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
005750  aa   000064 4020 07	mpy  	52,dl
005751  aa  6 00032 3735 20	epp7 	pr6|26,*
005752  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
005753  aa  6 01662 2521 00	spri2	pr6|946
005754  aa  6 01124 3521 20	epp2 	pr6|596,*		code
005755  aa  6 01664 2521 00	spri2	pr6|948
005756  aa   772026 3520 04	epp2 	-3050,ic		000004 = 162154144162
005757  aa  6 01666 2521 00	spri2	pr6|950
005760  aa  6 01646 3521 00	epp2 	pr6|934
005761  aa  6 01670 2521 00	spri2	pr6|952
005762  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
005763  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
005764  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
005765  aa  6 01672 2521 00	spri2	pr6|954
005766  aa   772076 3520 04	epp2 	-3010,ic		000064 = 464000000000
005767  aa  6 01674 2521 00	spri2	pr6|956
005770  aa   772103 3520 04	epp2 	-3005,ic		000073 = 404000000043
005771  aa  6 01676 2521 00	spri2	pr6|958
005772  aa   772071 3520 04	epp2 	-3015,ic		000063 = 530000000040
005773  aa  6 01700 2521 00	spri2	pr6|960
005774  aa   772047 3520 04	epp2 	-3033,ic		000043 = 524000000041
005775  aa  6 01702 2521 00	spri2	pr6|962
005776  aa  6 01634 3521 00	epp2 	pr6|924
005777  aa  6 01704 2521 00	spri2	pr6|964
006000  aa  6 01660 6211 00	eax1 	pr6|944
006001  aa   024000 4310 07	fld  	10240,dl
006002  aa  6 00044 3701 20	epp4 	pr6|36,*
006003  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
006004  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 765
    return;

006005  aa  6 01164 6101 00	rtcd 	pr6|628
						STATEMENT 1 ON LINE 767
  end lock_volume_log;

  END PROCEDURE lock_volume_log
BEGIN PROCEDURE resynch_input_volume
ENTRY TO resynch_input_volume                               STATEMENT 1 ON LINE 774
resynch_input_volume: proc;

006006  aa  6 00102 6501 00	spri4	pr6|66
						STATEMENT 1 ON LINE 781
    resynching = "1"b;

006007  aa   400000 2350 03	lda  	131072,du
006010  aa  6 00040 3735 20	epp7 	pr6|32,*
006011  aa  7 00122 7551 00	sta  	pr7|82		resynching
						STATEMENT 1 ON LINE 782
    resynching_completed = "0"b;

006012  aa  7 00121 4501 00	stz  	pr7|81		resynching_completed
						STATEMENT 1 ON LINE 784
    input_buf (*) = "0"b;

006013  aa  7 00302 2361 00	ldq  	pr7|194		nelt
006014  aa   000004 5060 07	div  	4,dl
006015  aa  6 00372 7561 00	stq  	pr6|250
006016  aa   000001 2360 07	ldq  	1,dl
006017  aa  6 00110 7561 00	stq  	pr6|72
006020  aa  6 00040 3735 20	epp7 	pr6|32,*
006021  aa  6 00110 7271 00	lxl7 	pr6|72
006022  aa  7 00356 3715 20	epp5 	pr7|238,*		recordp
006023  aa  5 77777 3735 17	epp7 	pr5|-1,7		input_buf
006024  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
006025  aa   000000 00 0000	descb	0,0
006026  aa  7 00000 00 0044	descb	pr7|0,36		input_buf
006027  aa  6 00110 2361 00	ldq  	pr6|72
006030  aa  6 00110 0541 00	aos  	pr6|72
006031  aa  6 00372 1161 00	cmpq 	pr6|250
006032  aa   777766 6040 04	tmi  	-10,ic		006020
						STATEMENT 1 ON LINE 785
    new_volume = "0"b;

006033  aa  6 00040 3535 20	epp3 	pr6|32,*
006034  aa  3 00123 4501 00	stz  	pr3|83		new_volume
						STATEMENT 1 ON LINE 787
    nel = CHARS_PER_WORD * size (backup_volume_header);

006035  aa   000040 2360 07	ldq  	32,dl
006036  aa  3 00301 7561 00	stq  	pr3|193		nel
						STATEMENT 1 ON LINE 788
    call read (recordp, nel, nelt, ^DELIMITED, code);

006037  aa   400000 2350 03	lda  	131072,du
006040  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
006041  aa  6 00372 7551 00	sta  	pr6|250
006042  aa  3 00356 3521 00	epp2 	pr3|238		recordp
006043  aa  6 00376 2521 00	spri2	pr6|254
006044  aa  3 00301 3521 00	epp2 	pr3|193		nel
006045  aa  6 00400 2521 00	spri2	pr6|256
006046  aa  3 00302 3521 00	epp2 	pr3|194		nelt
006047  aa  6 00402 2521 00	spri2	pr6|258
006050  aa  6 00372 3521 00	epp2 	pr6|250
006051  aa  6 00404 2521 00	spri2	pr6|260
006052  aa  3 01124 3521 20	epp2 	pr3|596,*		code
006053  aa  6 00406 2521 00	spri2	pr6|262
006054  aa   000001 7270 07	lxl7 	1,dl
006055  aa  6 00374 6211 00	eax1 	pr6|252
006056  aa   024000 4310 07	fld  	10240,dl
006057  aa   001245 3520 04	epp2 	677,ic		007324 = 000140627000
006060  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 789
    call check_input_error;

006061  aa   000001 7270 07	lxl7 	1,dl
006062  aa  6 00056 6211 00	eax1 	pr6|46
006063  aa   000000 4310 07	fld  	0,dl
006064  aa   775376 3520 04	epp2 	-1282,ic		003462 = 000500627000
006065  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 791
    if new_volume then return;

006066  aa  6 00040 3735 20	epp7 	pr6|32,*
006067  aa  7 00123 2351 00	lda  	pr7|83		new_volume
006070  aa   000002 6000 04	tze  	2,ic		006072
006071  aa  6 00102 6101 00	rtcd 	pr6|66
						STATEMENT 1 ON LINE 793
    words_skipped = 0;

006072  aa  7 00130 4501 00	stz  	pr7|88		words_skipped
						STATEMENT 1 ON LINE 795
test: if word (1) = pattern1 & word (4) = pattern2 & word (7) = pattern3 then do;

006073  aa  6 00040 3735 20	epp7 	pr6|32,*
006074  aa  7 00356 3715 20	epp5 	pr7|238,*		recordp
006075  aa  000 004 066 500	cmpb 	(pr),(ic),fill(0)
006076  aa  5 00000 00 0044	descb	pr5|0,36		word
006077  aa   771705 00 0044	descb	-3131,36		000002 = 670314355245
006100  aa   000062 6010 04	tnz  	50,ic		006162
006101  aa  000 004 066 500	cmpb 	(pr),(ic),fill(0)
006102  aa  5 00003 00 0044	descb	pr5|3,36		word
006103  aa   771700 00 0044	descb	-3136,36		000001 = 512556146073
006104  aa   000056 6010 04	tnz  	46,ic		006162
006105  aa  000 004 066 500	cmpb 	(pr),(ic),fill(0)
006106  aa  5 00006 00 0044	descb	pr5|6,36		word
006107  aa   771673 00 0044	descb	-3141,36		000000 = 107463422532
006110  aa   000052 6010 04	tnz  	42,ic		006162
						STATEMENT 1 ON LINE 796
        call rldr_report_$error_output (rldr_datap, 0, myname, "Synchronization completed ^d words skipped on dump volume ^a",
	   words_skipped, rldr_data_.controlp (1) -> rldr_control.curn_volname);

006111  aa  6 00372 4501 00	stz  	pr6|250
006112  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006113  aa   772374 00 0074	desc9a	-2820,60		000506 = 123171156143
006114  aa  6 00412 00 0074	desc9a	pr6|266,60
006115  aa  7 00032 3535 20	epp3 	pr7|26,*
006116  aa  3 00002 3521 20	epp2 	pr3|2,*		rldr_datap
006117  aa  6 00434 2521 00	spri2	pr6|284
006120  aa  6 00372 3521 00	epp2 	pr6|250
006121  aa  6 00436 2521 00	spri2	pr6|286
006122  aa   771662 3520 04	epp2 	-3150,ic		000004 = 162154144162
006123  aa  6 00440 2521 00	spri2	pr6|288
006124  aa  6 00412 3521 00	epp2 	pr6|266
006125  aa  6 00442 2521 00	spri2	pr6|290
006126  aa  7 00130 3521 00	epp2 	pr7|88		words_skipped
006127  aa  6 00444 2521 00	spri2	pr6|292
006130  aa  3 00002 3515 20	epp1 	pr3|2,*		rldr_datap
006131  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
006132  aa  1 00514 3521 20	epp2 	pr1|332,*		rldr_control.curn_volname
006133  aa  6 00446 2521 00	spri2	pr6|294
006134  aa   771730 3520 04	epp2 	-3112,ic		000064 = 464000000000
006135  aa  6 00450 2521 00	spri2	pr6|296
006136  aa   771723 3520 04	epp2 	-3117,ic		000061 = 404000000005
006137  aa  6 00452 2521 00	spri2	pr6|298
006140  aa   771723 3520 04	epp2 	-3117,ic		000063 = 530000000040
006141  aa  6 00454 2521 00	spri2	pr6|300
006142  aa   771657 3520 04	epp2 	-3153,ic		000021 = 524000000074
006143  aa  6 00456 2521 00	spri2	pr6|302
006144  aa   771727 3520 04	epp2 	-3113,ic		000073 = 404000000043
006145  aa  6 00460 2521 00	spri2	pr6|304
006146  aa   771702 3520 04	epp2 	-3134,ic		000050 = 524000000040
006147  aa  6 00462 2521 00	spri2	pr6|306
006150  aa  6 00432 6211 00	eax1 	pr6|282
006151  aa   030000 4310 07	fld  	12288,dl
006152  aa  6 00044 3701 20	epp4 	pr6|36,*
006153  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
006154  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 798
        resynching = "0"b;

006155  aa  6 00040 3735 20	epp7 	pr6|32,*
006156  aa  7 00122 4501 00	stz  	pr7|82		resynching
						STATEMENT 1 ON LINE 799
        resynching_completed = "1"b;

006157  aa   400000 2350 03	lda  	131072,du
006160  aa  7 00121 7551 00	sta  	pr7|81		resynching_completed
						STATEMENT 1 ON LINE 800
        return;

006161  aa  6 00102 6101 00	rtcd 	pr6|66
						STATEMENT 1 ON LINE 801
      end;

						STATEMENT 1 ON LINE 803
    string = substr (string, 37, (size (backup_volume_header) - 1) * BITS_PER_WORD);

006162  aa   000440 2360 07	ldq  	288,dl
006163  aa  6 00372 7561 00	stq  	pr6|250
006164  aa   000374 2360 07	ldq  	252,dl
006165  aa  6 00372 2351 00	lda  	pr6|250
006166  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
006167  aa  5 00001 00 0006	descb	pr5|1,ql		string
006170  aa  5 00000 00 0005	descb	pr5|0,al		string
						STATEMENT 1 ON LINE 804
    new_volume = "0"b;

006171  aa  7 00123 4501 00	stz  	pr7|83		new_volume
						STATEMENT 1 ON LINE 805
    nel = CHARS_PER_WORD;

006172  aa   000004 2360 07	ldq  	4,dl
006173  aa  7 00301 7561 00	stq  	pr7|193		nel
						STATEMENT 1 ON LINE 806
    call read (addr (word (size (backup_volume_header))),
         nel, nelt, ^DELIMITED, code);

006174  aa  5 00007 3521 00	epp2 	pr5|7		word
006175  aa  6 00464 2521 00	spri2	pr6|308
006176  aa   400000 2350 03	lda  	131072,du
006177  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
006200  aa  6 00372 7551 00	sta  	pr6|250
006201  aa  6 00464 3521 00	epp2 	pr6|308
006202  aa  6 00376 2521 00	spri2	pr6|254
006203  aa  7 00301 3521 00	epp2 	pr7|193		nel
006204  aa  6 00400 2521 00	spri2	pr6|256
006205  aa  7 00302 3521 00	epp2 	pr7|194		nelt
006206  aa  6 00402 2521 00	spri2	pr6|258
006207  aa  6 00372 3521 00	epp2 	pr6|250
006210  aa  6 00404 2521 00	spri2	pr6|260
006211  aa  7 01124 3521 20	epp2 	pr7|596,*		code
006212  aa  6 00406 2521 00	spri2	pr6|262
006213  aa   000001 7270 07	lxl7 	1,dl
006214  aa  6 00374 6211 00	eax1 	pr6|252
006215  aa   024000 4310 07	fld  	10240,dl
006216  aa   001106 3520 04	epp2 	582,ic		007324 = 000140627000
006217  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 808
    call check_input_error;

006220  aa   000001 7270 07	lxl7 	1,dl
006221  aa  6 00056 6211 00	eax1 	pr6|46
006222  aa   000000 4310 07	fld  	0,dl
006223  aa   775237 3520 04	epp2 	-1377,ic		003462 = 000500627000
006224  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 809
    if new_volume then return;

006225  aa  6 00040 3735 20	epp7 	pr6|32,*
006226  aa  7 00123 2351 00	lda  	pr7|83		new_volume
006227  aa   000002 6000 04	tze  	2,ic		006231
006230  aa  6 00102 6101 00	rtcd 	pr6|66
						STATEMENT 1 ON LINE 811
    words_skipped = words_skipped + 1;

006231  aa  7 00130 2351 00	lda  	pr7|88		words_skipped
006232  aa   000044 7330 00	lrs  	36
006233  aa   000001 0330 07	adl  	1,dl
006234  aa  7 00130 7561 00	stq  	pr7|88		words_skipped
						STATEMENT 1 ON LINE 812
    if words_skipped > 256 * WORDS_PER_PAGE then do;

006235  aa   002000 2360 07	ldq  	1024,dl
006236  aa   000010 7360 00	qls  	8
006237  aa  7 00130 1161 00	cmpq 	pr7|88		words_skipped
006240  aa   777633 6050 04	tpl  	-101,ic		006073
						STATEMENT 1 ON LINE 813
        call rldr_report_$error_output (rldr_datap, 0, myname, "Resynchronization failed on dump volume ^a",
	   rldr_data_.controlp (1) -> rldr_control.curn_volname);

006241  aa  6 00372 4501 00	stz  	pr6|250
006242  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006243  aa   772166 00 0054	desc9a	-2954,44		000430 = 122145163171
006244  aa  6 00374 00 0054	desc9a	pr6|252,44
006245  aa  7 00032 3715 20	epp5 	pr7|26,*
006246  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
006247  aa  6 00434 2521 00	spri2	pr6|284
006250  aa  6 00372 3521 00	epp2 	pr6|250
006251  aa  6 00436 2521 00	spri2	pr6|286
006252  aa   771532 3520 04	epp2 	-3238,ic		000004 = 162154144162
006253  aa  6 00440 2521 00	spri2	pr6|288
006254  aa  6 00374 3521 00	epp2 	pr6|252
006255  aa  6 00442 2521 00	spri2	pr6|290
006256  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
006257  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
006260  aa  3 00514 3521 20	epp2 	pr3|332,*		rldr_control.curn_volname
006261  aa  6 00444 2521 00	spri2	pr6|292
006262  aa   771602 3520 04	epp2 	-3198,ic		000064 = 464000000000
006263  aa  6 00446 2521 00	spri2	pr6|294
006264  aa   771575 3520 04	epp2 	-3203,ic		000061 = 404000000005
006265  aa  6 00450 2521 00	spri2	pr6|296
006266  aa   771575 3520 04	epp2 	-3203,ic		000063 = 530000000040
006267  aa  6 00452 2521 00	spri2	pr6|298
006270  aa   771530 3520 04	epp2 	-3240,ic		000020 = 524000000052
006271  aa  6 00454 2521 00	spri2	pr6|300
006272  aa   771556 3520 04	epp2 	-3218,ic		000050 = 524000000040
006273  aa  6 00456 2521 00	spri2	pr6|302
006274  aa  6 00432 6211 00	eax1 	pr6|282
006275  aa   024000 4310 07	fld  	10240,dl
006276  aa  6 00044 3701 20	epp4 	pr6|36,*
006277  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
006300  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 815
        code = error_table_$end_of_info;

006301  aa  6 00044 3701 20	epp4 	pr6|36,*
006302  la  4 00070 2361 20	ldq  	pr4|56,*		error_table_$end_of_info
006303  aa  6 00040 3735 20	epp7 	pr6|32,*
006304  aa  7 01124 7561 20	stq  	pr7|596,*		code
						STATEMENT 1 ON LINE 816
        call check_input_error;

006305  aa   000001 7270 07	lxl7 	1,dl
006306  aa  6 00056 6211 00	eax1 	pr6|46
006307  aa   000000 4310 07	fld  	0,dl
006310  aa   775152 3520 04	epp2 	-1430,ic		003462 = 000500627000
006311  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 817
        return;

006312  aa  6 00102 6101 00	rtcd 	pr6|66
						STATEMENT 1 ON LINE 818
      end;

						STATEMENT 1 ON LINE 819
    goto test;

006313  aa   777560 7100 04	tra  	-144,ic		006073
						STATEMENT 1 ON LINE 821
  end resynch_input_volume;

  END PROCEDURE resynch_input_volume
BEGIN PROCEDURE unlock_volume_log
ENTRY TO unlock_volume_log                                  STATEMENT 1 ON LINE 827
unlock_volume_log: proc;

006314  aa  6 01172 6501 00	spri4	pr6|634
						STATEMENT 1 ON LINE 831
    call set_lock_$unlock (backup_volume_log.lock, code);

006315  aa  6 00346 3735 20	epp7 	pr6|230,*		bvlp
006316  aa  7 02016 3521 00	epp2 	pr7|1038		backup_volume_log.lock
006317  aa  6 01710 2521 00	spri2	pr6|968
006320  aa  6 01124 3521 20	epp2 	pr6|596,*		code
006321  aa  6 01712 2521 00	spri2	pr6|970
006322  aa  6 01706 6211 00	eax1 	pr6|966
006323  aa   010000 4310 07	fld  	4096,dl
006324  aa  6 00044 3701 20	epp4 	pr6|36,*
006325  la  4 00044 3521 20	epp2 	pr4|36,*		set_lock_$unlock
006326  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 832
    if code ^= 0 then
      call rldr_report_$error_output (rldr_datap, code, myname, "Error unlocking volume log ^a.volog",
	 rldr_data_.pvname (pvindex));

006327  aa  6 01124 2361 20	ldq  	pr6|596,*		code
006330  aa   000044 6000 04	tze  	36,ic		006374
006331  aa   771517 2360 04	ldq  	-3249,ic		000050 = 524000000040
006332  aa  6 01714 7561 00	stq  	pr6|972
006333  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006334  aa   771736 00 0044	desc9a	-3106,36		000271 = 105162162157
006335  aa  6 01716 00 0044	desc9a	pr6|974,36
006336  aa  6 00275 2361 00	ldq  	pr6|189		pvindex
006337  aa   000064 4020 07	mpy  	52,dl
006340  aa  6 00032 3735 20	epp7 	pr6|26,*
006341  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
006342  aa  6 01732 2521 00	spri2	pr6|986
006343  aa  6 01124 3521 20	epp2 	pr6|596,*		code
006344  aa  6 01734 2521 00	spri2	pr6|988
006345  aa   771437 3520 04	epp2 	-3297,ic		000004 = 162154144162
006346  aa  6 01736 2521 00	spri2	pr6|990
006347  aa  6 01716 3521 00	epp2 	pr6|974
006350  aa  6 01740 2521 00	spri2	pr6|992
006351  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
006352  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
006353  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
006354  aa  6 01742 2521 00	spri2	pr6|994
006355  aa   771507 3520 04	epp2 	-3257,ic		000064 = 464000000000
006356  aa  6 01744 2521 00	spri2	pr6|996
006357  aa   771514 3520 04	epp2 	-3252,ic		000073 = 404000000043
006360  aa  6 01746 2521 00	spri2	pr6|998
006361  aa   771502 3520 04	epp2 	-3262,ic		000063 = 530000000040
006362  aa  6 01750 2521 00	spri2	pr6|1000
006363  aa   771455 3520 04	epp2 	-3283,ic		000040 = 524000000043
006364  aa  6 01752 2521 00	spri2	pr6|1002
006365  aa  6 01714 3521 00	epp2 	pr6|972
006366  aa  6 01754 2521 00	spri2	pr6|1004
006367  aa  6 01730 6211 00	eax1 	pr6|984
006370  aa   024000 4310 07	fld  	10240,dl
006371  aa  6 00044 3701 20	epp4 	pr6|36,*
006372  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
006373  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 835
  end unlock_volume_log;

006374  aa  6 01172 6101 00	rtcd 	pr6|634
  END PROCEDURE unlock_volume_log
BEGIN PROCEDURE record_info
ENTRY TO record_info                                        STATEMENT 1 ON LINE 839
record_info: proc;

006375  aa  6 01200 6501 00	spri4	pr6|640
						STATEMENT 1 ON LINE 847
    reattach = "0"b;

006376  aa  6 01206 4501 00	stz  	pr6|646		reattach
						STATEMENT 1 ON LINE 848
    infop = rldr_data_.infop;

006377  aa  6 00032 3735 20	epp7 	pr6|26,*
006400  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
006401  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
006402  aa  5 00424 3535 20	epp3 	pr5|276,*		rldr_data_.infop
006403  aa  6 00344 2535 00	spri3	pr6|228		infop
						STATEMENT 1 ON LINE 849
    infop -> backup_info = recordp -> backup_info;

006404  aa  6 00356 3515 20	epp1 	pr6|238,*		recordp
006405  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
006406  aa  1 00000 00 0504	desc9a	pr1|0,324		backup_info
006407  aa  3 00000 00 0504	desc9a	pr3|0,324		backup_info
						STATEMENT 1 ON LINE 850
    if backup_info.version = backup_info_version_2 &
         rldr_data_.controlp (1) -> rldr_control.curn_volname ^= backup_info.dump_volname
    then do;

006410  aa  3 00010 2361 00	ldq  	pr3|8		backup_info.version
006411  aa   000002 1160 07	cmpq 	2,dl
006412  aa   000053 6010 04	tnz  	43,ic		006465
006413  aa  5 00514 3515 20	epp1 	pr5|332,*		rldr_data_.controlp
006414  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
006415  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_control.curn_volname
006416  aa  3 00017 00 0040	desc9a	pr3|15,32		backup_info.dump_volname
006417  aa   000046 6000 04	tze  	38,ic		006465
						STATEMENT 1 ON LINE 853
        call rldr_report_$error_output (rldr_datap, 0, myname, "Attempt to mount unrequested dump volume ^a",
	   backup_info.dump_volname);

006420  aa  6 01756 4501 00	stz  	pr6|1006
006421  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006422  aa   771774 00 0054	desc9a	-3076,44		000415 = 101164164145
006423  aa  6 01760 00 0054	desc9a	pr6|1008,44
006424  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
006425  aa  6 01776 2521 00	spri2	pr6|1022
006426  aa  6 01756 3521 00	epp2 	pr6|1006
006427  aa  6 02000 2521 00	spri2	pr6|1024
006430  aa   771354 3520 04	epp2 	-3348,ic		000004 = 162154144162
006431  aa  6 02002 2521 00	spri2	pr6|1026
006432  aa  6 01760 3521 00	epp2 	pr6|1008
006433  aa  6 02004 2521 00	spri2	pr6|1028
006434  aa  3 00017 3521 00	epp2 	pr3|15		backup_info.dump_volname
006435  aa  6 02006 2521 00	spri2	pr6|1030
006436  aa   771426 3520 04	epp2 	-3306,ic		000064 = 464000000000
006437  aa  6 02010 2521 00	spri2	pr6|1032
006440  aa   771421 3520 04	epp2 	-3311,ic		000061 = 404000000005
006441  aa  6 02012 2521 00	spri2	pr6|1034
006442  aa   771421 3520 04	epp2 	-3311,ic		000063 = 530000000040
006443  aa  6 02014 2521 00	spri2	pr6|1036
006444  aa   771353 3520 04	epp2 	-3349,ic		000017 = 524000000053
006445  aa  6 02016 2521 00	spri2	pr6|1038
006446  aa   771402 3520 04	epp2 	-3326,ic		000050 = 524000000040
006447  aa  6 02020 2521 00	spri2	pr6|1040
006450  aa  6 01774 6211 00	eax1 	pr6|1020
006451  aa   024000 4310 07	fld  	10240,dl
006452  aa  6 00044 3701 20	epp4 	pr6|36,*
006453  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
006454  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 855
        reattach = "1"b;

006455  aa   400000 2350 03	lda  	131072,du
006456  aa  6 01206 7551 00	sta  	pr6|646		reattach
						STATEMENT 1 ON LINE 856
        rldr_input_volume_list.curn_entry = rldr_input_volume_list.curn_entry - 1;

006457  aa   000001 3360 07	lcq  	1,dl
006460  aa  6 00032 3735 20	epp7 	pr6|26,*
006461  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
006462  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
006463  aa  5 00430 3535 20	epp3 	pr5|280,*		rldr_data_.input_vol_lstp
006464  aa  3 00001 0561 00	asq  	pr3|1		rldr_input_volume_list.curn_entry
						STATEMENT 1 ON LINE 857
      end;

						STATEMENT 1 ON LINE 858
    if rldr_data_.rpv then do;

006465  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
006466  aa  5 00000 2351 20	lda  	pr5|0,*		rldr_data_.rpv
006467  aa   100000 3150 03	cana 	32768,du
006470  aa   000044 6000 04	tze  	36,ic		006534
						STATEMENT 1 ON LINE 859
        if (rldr_data_.rpv_disk_type ^= backup_info.rpv_disk_type) & ^warning_printed then do;

006471  aa  5 00000 3535 20	epp3 	pr5|0,*		rldr_datap
006472  aa  3 00405 2361 00	ldq  	pr3|261		rldr_data_.rpv_disk_type
006473  aa  6 00344 3515 20	epp1 	pr6|228,*		infop
006474  aa  1 00013 1161 00	cmpq 	pr1|11		backup_info.rpv_disk_type
006475  aa   000103 6000 04	tze  	67,ic		006600
006476  aa  6 00044 3701 20	epp4 	pr6|36,*
006477  ia  4 00010 2351 00	lda  	pr4|8		warning_printed
006500  aa   000100 6010 04	tnz  	64,ic		006600
						STATEMENT 1 ON LINE 860
	  warning_printed = "1"b;

006501  aa   400000 2350 03	lda  	131072,du
006502  ia  4 00010 7551 00	sta  	pr4|8		warning_printed
						STATEMENT 1 ON LINE 861
	  call rldr_report_$online_output (rldr_datap, 0, myname, "Warning - new disk type for rpv");

006503  aa  6 01756 4501 00	stz  	pr6|1006
006504  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006505  aa   771475 00 0040	desc9a	-3267,32		000201 = 127141162156
006506  aa  6 01760 00 0040	desc9a	pr6|1008,32
006507  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
006510  aa  6 01776 2521 00	spri2	pr6|1022
006511  aa  6 01756 3521 00	epp2 	pr6|1006
006512  aa  6 02000 2521 00	spri2	pr6|1024
006513  aa   771271 3520 04	epp2 	-3399,ic		000004 = 162154144162
006514  aa  6 02002 2521 00	spri2	pr6|1026
006515  aa  6 01760 3521 00	epp2 	pr6|1008
006516  aa  6 02004 2521 00	spri2	pr6|1028
006517  aa   771345 3520 04	epp2 	-3355,ic		000064 = 464000000000
006520  aa  6 02006 2521 00	spri2	pr6|1030
006521  aa   771340 3520 04	epp2 	-3360,ic		000061 = 404000000005
006522  aa  6 02010 2521 00	spri2	pr6|1032
006523  aa   771340 3520 04	epp2 	-3360,ic		000063 = 530000000040
006524  aa  6 02012 2521 00	spri2	pr6|1034
006525  aa   771276 3520 04	epp2 	-3394,ic		000023 = 524000000037
006526  aa  6 02014 2521 00	spri2	pr6|1036
006527  aa  6 01774 6211 00	eax1 	pr6|1020
006530  aa   020000 4310 07	fld  	8192,dl
006531  la  4 00054 3521 20	epp2 	pr4|44,*		rldr_report_$online_output
006532  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 862
	end;

						STATEMENT 1 ON LINE 863
      end;

006533  aa   000045 7100 04	tra  	37,ic		006600
						STATEMENT 1 ON LINE 864
    else do;

						STATEMENT 1 ON LINE 865
        if (rldr_data_.rpv_pvid ^= backup_info.rpv_pvid) then do;

006534  aa  5 00000 3535 20	epp3 	pr5|0,*		rldr_datap
006535  aa  3 00003 2351 00	lda  	pr3|3		rldr_data_.rpv_pvid
006536  aa  6 00344 3515 20	epp1 	pr6|228,*		infop
006537  aa  1 00011 1151 00	cmpa 	pr1|9		backup_info.rpv_pvid
006540  aa   000040 6000 04	tze  	32,ic		006600
						STATEMENT 1 ON LINE 866
	  call rldr_report_$error_output (rldr_datap, 0, myname,
	       "Attempt to use non local site dump volume ^a", backup_info.dump_volname);

006541  aa  6 01756 4501 00	stz  	pr6|1006
006542  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006543  aa   771640 00 0054	desc9a	-3168,44		000402 = 101164164145
006544  aa  6 01760 00 0054	desc9a	pr6|1008,44
006545  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
006546  aa  6 01776 2521 00	spri2	pr6|1022
006547  aa  6 01756 3521 00	epp2 	pr6|1006
006550  aa  6 02000 2521 00	spri2	pr6|1024
006551  aa   771233 3520 04	epp2 	-3429,ic		000004 = 162154144162
006552  aa  6 02002 2521 00	spri2	pr6|1026
006553  aa  6 01760 3521 00	epp2 	pr6|1008
006554  aa  6 02004 2521 00	spri2	pr6|1028
006555  aa  1 00017 3521 00	epp2 	pr1|15		backup_info.dump_volname
006556  aa  6 02006 2521 00	spri2	pr6|1030
006557  aa   771305 3520 04	epp2 	-3387,ic		000064 = 464000000000
006560  aa  6 02010 2521 00	spri2	pr6|1032
006561  aa   771300 3520 04	epp2 	-3392,ic		000061 = 404000000005
006562  aa  6 02012 2521 00	spri2	pr6|1034
006563  aa   771300 3520 04	epp2 	-3392,ic		000063 = 530000000040
006564  aa  6 02014 2521 00	spri2	pr6|1036
006565  aa   771231 3520 04	epp2 	-3431,ic		000016 = 524000000054
006566  aa  6 02016 2521 00	spri2	pr6|1038
006567  aa   771261 3520 04	epp2 	-3407,ic		000050 = 524000000040
006570  aa  6 02020 2521 00	spri2	pr6|1040
006571  aa  6 01774 6211 00	eax1 	pr6|1020
006572  aa   024000 4310 07	fld  	10240,dl
006573  aa  6 00044 3701 20	epp4 	pr6|36,*
006574  la  4 00052 3521 20	epp2 	pr4|42,*		rldr_report_$error_output
006575  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 868
	  reattach = "1"b;

006576  aa   400000 2350 03	lda  	131072,du
006577  aa  6 01206 7551 00	sta  	pr6|646		reattach
						STATEMENT 1 ON LINE 869
	end;

						STATEMENT 1 ON LINE 870
      end;

						STATEMENT 1 ON LINE 871
    if reattach then do;

006600  aa  6 01206 2351 00	lda  	pr6|646		reattach
006601  aa   000012 6000 04	tze  	10,ic		006613
						STATEMENT 1 ON LINE 872
        call detach;

006602  aa  6 00056 6211 00	eax1 	pr6|46
006603  aa   000000 4310 07	fld  	0,dl
006604  aa   776616 3520 04	epp2 	-626,ic		005422 = 000260627000
006605  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 873
        call attach;

006606  aa  6 00056 6211 00	eax1 	pr6|46
006607  aa   000000 4310 07	fld  	0,dl
006610  aa   775637 3520 04	epp2 	-1121,ic		004447 = 000300627000
006611  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 874
        goto search_loop;

006612  aa   772302 7100 04	tra  	-2878,ic		001114
						STATEMENT 1 ON LINE 875
      end;

						STATEMENT 1 ON LINE 876
    return;

006613  aa  6 01200 6101 00	rtcd 	pr6|640
						STATEMENT 1 ON LINE 877
  end record_info;

  END PROCEDURE record_info
BEGIN PROCEDURE get_volid_
ENTRY TO get_volid_                                         STATEMENT 1 ON LINE 884
get_volid_: proc (name) returns (bit (36));

006614  aa  6 00104 6501 00	spri4	pr6|68
006615  aa  6 00106 2521 00	spri2	pr6|70
						STATEMENT 1 ON LINE 902
    volid.char = "";

006616  aa   040040 2350 03	lda  	16416,du
006617  aa  6 00112 5511 60	stba 	pr6|74,60		volid.char
						STATEMENT 1 ON LINE 903
    num_pos = search (name, "0123456789");

006620  aa  2 00002 3735 20	epp7 	pr2|2,*
006621  aa  000 000 164 500	tct  	(pr)
006622  aa  7 00000 00 0040	desc9a	pr7|0,32		name
006623  aa   001112 0000 04	arg  	586,ic		007733 = 000000000000
006624  aa  6 00056 0001 00	arg  	pr6|46
006625  aa  6 00056 2361 00	ldq  	pr6|46
006626  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
006627  aa   000002 6070 04	ttf  	2,ic		006631
006630  aa   000001 3360 07	lcq  	1,dl
006631  aa   000001 0760 07	adq  	1,dl
006632  aa  6 00040 3715 20	epp5 	pr6|32,*
006633  aa  5 00300 7561 00	stq  	pr5|192		num_pos
						STATEMENT 1 ON LINE 904
    if num_pos > 3 | num_pos = 0 then do;

006634  aa   000003 1160 07	cmpq 	3,dl
006635  aa   000003 6054 04	tpnz 	3,ic		006640
006636  aa  5 00300 2361 00	ldq  	pr5|192		num_pos
006637  aa   000013 6010 04	tnz  	11,ic		006652
						STATEMENT 1 ON LINE 905
bad_volid: code = error_table_$bad_volid;

006640  aa  6 00044 3701 20	epp4 	pr6|36,*
006641  la  4 00072 2361 20	ldq  	pr4|58,*		error_table_$bad_volid
006642  aa  6 00040 3735 20	epp7 	pr6|32,*
006643  aa  7 01124 7561 20	stq  	pr7|596,*		code
						STATEMENT 1 ON LINE 906
        return (""b);

006644  aa  6 00106 3715 20	epp5 	pr6|70,*
006645  aa  5 00004 3535 20	epp3 	pr5|4,*
006646  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
006647  aa   000000 00 0000	descb	0,0
006650  aa  3 00000 00 0044	descb	pr3|0,36
006651  aa  6 00104 6101 00	rtcd 	pr6|68
						STATEMENT 1 ON LINE 907
      end;

						STATEMENT 1 ON LINE 908
    else do;

						STATEMENT 1 ON LINE 909
        if num_pos = 2 then substr (volid.char, 2, 1) = substr (name, 1, 1);

006652  aa   000002 1160 07	cmpq 	2,dl
006653  aa   000005 6010 04	tnz  	5,ic		006660
006654  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006655  aa  7 00000 00 0001	desc9a	pr7|0,1		name
006656  aa  6 00112 20 0001	desc9a	pr6|74(1),1	volid.char
006657  aa   000004 7100 04	tra  	4,ic		006663
						STATEMENT 1 ON LINE 910
        else volid.char = substr (name, 1, 2);

006660  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006661  aa  7 00000 00 0002	desc9a	pr7|0,2		name
006662  aa  6 00112 00 0002	desc9a	pr6|74,2		volid.char
						STATEMENT 1 ON LINE 911
        char_num = substr (name, num_pos, length (name) - num_pos);

006663  aa   000040 2360 07	ldq  	32,dl
006664  aa  5 00300 1761 00	sbq  	pr5|192		num_pos
006665  aa  5 00300 7271 00	lxl7 	pr5|192		num_pos
006666  aa  040 100 100 557	mlr  	(pr,rl,x7),(pr),fill(040)
006667  aa  7 77777 60 0006	desc9a	pr7|-1(3),ql	name
006670  aa  5 00303 00 0040	desc9a	pr5|195,32	char_num
						STATEMENT 1 ON LINE 912
        num = cv_dec_check_ (char_num, code);

006671  aa  5 00303 3521 00	epp2 	pr5|195		char_num
006672  aa  6 00252 2521 00	spri2	pr6|170
006673  aa  5 01124 3521 20	epp2 	pr5|596,*		code
006674  aa  6 00254 2521 00	spri2	pr6|172
006675  aa  6 00247 3521 00	epp2 	pr6|167
006676  aa  6 00256 2521 00	spri2	pr6|174
006677  aa   771171 3520 04	epp2 	-3463,ic		000070 = 526000000040
006700  aa  6 00260 2521 00	spri2	pr6|176
006701  aa   771172 3520 04	epp2 	-3462,ic		000073 = 404000000043
006702  aa  6 00262 2521 00	spri2	pr6|178
006703  aa   771167 3520 04	epp2 	-3465,ic		000072 = 404000000021
006704  aa  6 00264 2521 00	spri2	pr6|180
006705  aa  6 00250 6211 00	eax1 	pr6|168
006706  aa   014000 4310 07	fld  	6144,dl
006707  aa  6 00044 3701 20	epp4 	pr6|36,*
006710  la  4 00030 3521 20	epp2 	pr4|24,*		cv_dec_check_
006711  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
006712  aa  6 00247 2361 00	ldq  	pr6|167
006713  aa  6 00112 5521 14	stbq 	pr6|74,14		volid.num
						STATEMENT 1 ON LINE 913
        if code ^= 0 then goto bad_volid;

006714  aa  6 00040 3735 20	epp7 	pr6|32,*
006715  aa  7 01124 2361 20	ldq  	pr7|596,*		code
006716  aa   777722 6010 04	tnz  	-46,ic		006640
						STATEMENT 1 ON LINE 914
        volid.num = num;

006717  aa  6 00112 2351 00	lda  	pr6|74		volid.num
006720  aa  6 00112 5511 14	stba 	pr6|74,14		volid.num
						STATEMENT 1 ON LINE 915
      end;

						STATEMENT 1 ON LINE 916
    return (unspec (volid));

006721  aa  6 00106 3715 20	epp5 	pr6|70,*
006722  aa  5 00004 3535 20	epp3 	pr5|4,*
006723  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
006724  aa  6 00112 00 0044	descb	pr6|74,36
006725  aa  3 00000 00 0044	descb	pr3|0,36
006726  aa  6 00104 6101 00	rtcd 	pr6|68
						STATEMENT 1 ON LINE 918
  end get_volid_;

  END PROCEDURE get_volid_
BEGIN PROCEDURE open_time
ENTRY TO open_time                                          STATEMENT 1 ON LINE 923
open_time: proc returns (fixed bin (71));

006727  aa  6 01210 6501 00	spri4	pr6|648
006730  aa  6 01212 2521 00	spri2	pr6|650
						STATEMENT 1 ON LINE 929
    if bvle.dump_type = incr then return (bvle.open_time);

006731  aa  6 00350 3735 20	epp7 	pr6|232,*		bvlep
006732  aa  7 00001 2361 00	ldq  	pr7|1		bvle.dump_type
006733  aa   000001 1160 07	cmpq 	1,dl
006734  aa   000004 6010 04	tnz  	4,ic		006740
006735  aa  7 00012 2371 00	ldaq 	pr7|10		bvle.open_time
006736  aa  2 00002 7571 20	staq 	pr2|2,*
006737  aa  6 01210 6101 00	rtcd 	pr6|648
						STATEMENT 1 ON LINE 930
    do jdx = idx to 1 by -1;

006740  aa  6 00276 2361 00	ldq  	pr6|190		idx
006741  aa  6 01220 7561 00	stq  	pr6|656		jdx
006742  aa  6 01220 2361 00	ldq  	pr6|656		jdx
006743  aa   000001 1160 07	cmpq 	1,dl
006744  aa   000014 6040 04	tmi  	12,ic		006760
						STATEMENT 1 ON LINE 931
      if backup_volume_log.array (jdx).cycle_uid = bvle.cycle_uid then
        temp = backup_volume_log.array (jdx).open_time;

006745  aa   000042 4020 07	mpy  	34,dl
006746  aa  6 02022 7561 00	stq  	pr6|1042
006747  aa  6 00346 3735 20	epp7 	pr6|230,*		bvlp
006750  aa  7 02036 2351 06	lda  	pr7|1054,ql	backup_volume_log.cycle_uid
006751  aa  6 00350 1151 20	cmpa 	pr6|232,*		bvle.cycle_uid
006752  aa   000003 6010 04	tnz  	3,ic		006755
006753  aa  7 02050 2371 06	ldaq 	pr7|1064,ql	backup_volume_log.open_time
006754  aa  6 01216 7571 00	staq 	pr6|654		temp
						STATEMENT 1 ON LINE 933
    end;

006755  aa   000001 3360 07	lcq  	1,dl
006756  aa  6 01220 0561 00	asq  	pr6|656		jdx
006757  aa   777763 7100 04	tra  	-13,ic		006742
						STATEMENT 1 ON LINE 934
    return (temp);

006760  aa  6 01216 2371 00	ldaq 	pr6|654		temp
006761  aa  6 01212 3735 20	epp7 	pr6|650,*
006762  aa  7 00002 7571 20	staq 	pr7|2,*
006763  aa  6 01210 6101 00	rtcd 	pr6|648
						STATEMENT 1 ON LINE 936
  end open_time;

  END PROCEDURE open_time
BEGIN PROCEDURE attach_timer
ENTRY TO attach_timer                                       STATEMENT 1 ON LINE 943
attach_timer: proc;

006764  da     000447200000
006765  aa   000160 6270 00	eax7 	112
006766  aa  7 00034 3521 20	epp2 	pr7|28,*
006767  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
006770  aa     000000000000
006771  aa     000000000000
						STATEMENT 1 ON LINE 947
    call command_query_$yes_no (YES, 0, myname, "", "Attachment of dump volume ^a not completed. Do you wish to retry ?",
         rldr_control.curn_volname);

006772  aa  6 00100 4501 00	stz  	pr6|64
006773  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006774  aa   771532 00 0104	desc9a	-3238,68		000525 = 101164164141
006775  aa  6 00102 00 0104	desc9a	pr6|66,68
006776  aa  6 00040 3735 20	epp7 	pr6|32,*
006777  aa  7 00124 3521 00	epp2 	pr7|84		YES
007000  aa  6 00126 2521 00	spri2	pr6|86
007001  aa  6 00100 3521 00	epp2 	pr6|64
007002  aa  6 00130 2521 00	spri2	pr6|88
007003  aa   771001 3520 04	epp2 	-3583,ic		000004 = 162154144162
007004  aa  6 00132 2521 00	spri2	pr6|90
007005  aa  6 00101 3521 00	epp2 	pr6|65
007006  aa  6 00134 2521 00	spri2	pr6|92
007007  aa  6 00102 3521 00	epp2 	pr6|66
007010  aa  6 00136 2521 00	spri2	pr6|94
007011  aa  7 01100 3521 20	epp2 	pr7|576,*		rldr_control.curn_volname
007012  aa  6 00140 2521 00	spri2	pr6|96
007013  aa   771062 3520 04	epp2 	-3534,ic		000075 = 516000000001
007014  aa  6 00142 2521 00	spri2	pr6|98
007015  aa   771044 3520 04	epp2 	-3548,ic		000061 = 404000000005
007016  aa  6 00144 2521 00	spri2	pr6|100
007017  aa   771044 3520 04	epp2 	-3548,ic		000063 = 530000000040
007020  aa  6 00146 2521 00	spri2	pr6|102
007021  aa   771032 3520 04	epp2 	-3558,ic		000053 = 524000000000
007022  aa  6 00150 2521 00	spri2	pr6|104
007023  aa   770772 3520 04	epp2 	-3590,ic		000015 = 524000000102
007024  aa  6 00152 2521 00	spri2	pr6|106
007025  aa   771023 3520 04	epp2 	-3565,ic		000050 = 524000000040
007026  aa  6 00154 2521 00	spri2	pr6|108
007027  aa  6 00124 6211 00	eax1 	pr6|84
007030  aa   030000 4310 07	fld  	12288,dl
007031  la  4 00040 3521 20	epp2 	pr4|32,*		command_query_$yes_no
007032  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 949
    if YES then rldr_input_volume_list.curn_entry = rldr_input_volume_list.curn_entry - 1;

007033  aa  6 00040 3735 20	epp7 	pr6|32,*
007034  aa  7 00124 2351 00	lda  	pr7|84		YES
007035  aa   400000 3150 03	cana 	131072,du
007036  aa   000007 6000 04	tze  	7,ic		007045
007037  aa   000001 3360 07	lcq  	1,dl
007040  aa  7 00032 3715 20	epp5 	pr7|26,*
007041  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
007042  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
007043  aa  3 00430 3515 20	epp1 	pr3|280,*		rldr_data_.input_vol_lstp
007044  aa  1 00001 0561 00	asq  	pr1|1		rldr_input_volume_list.curn_entry
						STATEMENT 1 ON LINE 950
    goto retry_attach_label;

007045  aa  7 00104 3521 00	epp2 	pr7|68		retry_attach_label
007046  aa  0 00660 7101 00	tra  	pr0|432		tra_ext_2
						STATEMENT 1 ON LINE 951
  end attach_timer;

  END PROCEDURE attach_timer
BEGIN PROCEDURE convert_puid_
ENTRY TO convert_puid_                                      STATEMENT 1 ON LINE 956
convert_puid_: proc returns (char (168));

007047  da     000456220000
007050  aa   000340 6270 00	eax7 	224
007051  aa  7 00034 3521 20	epp2 	pr7|28,*
007052  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
007053  aa     000002000000
007054  aa     000000000000
						STATEMENT 1 ON LINE 965
    if rldr_data_.stranger then goto ret_unk;

007055  aa  6 00040 3735 20	epp7 	pr6|32,*
007056  aa  7 00032 3715 20	epp5 	pr7|26,*
007057  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
007060  aa  3 00000 2351 20	lda  	pr3|0,*		rldr_data_.stranger
007061  aa   000040 3150 03	cana 	32,du
007062  aa   000060 6010 04	tnz  	48,ic		007142
						STATEMENT 1 ON LINE 966
    on seg_fault_error goto ret_unk;

007063  aa   000017 7260 07	lxl6 	15,dl
007064  aa   771044 3520 04	epp2 	-3548,ic		000130 = 163145147137
007065  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
007066  aa   000004 7100 04	tra  	4,ic		007072
007067  aa     000236000000
007070  aa   000012 7100 04	tra  	10,ic		007102
BEGIN CONDITION seg_fault_error.1
ENTRY TO seg_fault_error.1                                  STATEMENT 1 ON LINE 966
    on seg_fault_error goto ret_unk;

007071  da     000466200000
007072  aa   000100 6270 00	eax7 	64
007073  aa  7 00034 3521 20	epp2 	pr7|28,*
007074  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
007075  aa     000000000000
007076  aa     000000000000
007077  aa   000043 3520 04	epp2 	35,ic		007142 = 600032373520
007100  aa   000001 7270 07	lxl7 	1,dl
007101  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
  END CONDITION seg_fault_error.1
						STATEMENT 1 ON LINE 967
    call hc_backup_$decode_uidpath (rldr_data_.last_valid_puid, dn, en, ec);

007102  aa  6 00040 3735 20	epp7 	pr6|32,*
007103  aa  7 00032 3715 20	epp5 	pr7|26,*
007104  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
007105  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
007106  aa  3 00005 3521 00	epp2 	pr3|5		rldr_data_.last_valid_puid
007107  aa  6 00246 2521 00	spri2	pr6|166
007110  aa  6 00100 3521 00	epp2 	pr6|64		dn
007111  aa  6 00250 2521 00	spri2	pr6|168
007112  aa  6 00152 3521 00	epp2 	pr6|106		en
007113  aa  6 00252 2521 00	spri2	pr6|170
007114  aa  6 00234 3521 00	epp2 	pr6|156		ec
007115  aa  6 00254 2521 00	spri2	pr6|172
007116  aa   771002 3520 04	epp2 	-3582,ic		000120 = 514100000044
007117  aa  6 00256 2521 00	spri2	pr6|174
007120  aa   770745 3520 04	epp2 	-3611,ic		000065 = 526000000250
007121  aa  6 00260 2521 00	spri2	pr6|176
007122  aa   770746 3520 04	epp2 	-3610,ic		000070 = 526000000040
007123  aa  6 00262 2521 00	spri2	pr6|178
007124  aa   770747 3520 04	epp2 	-3609,ic		000073 = 404000000043
007125  aa  6 00264 2521 00	spri2	pr6|180
007126  aa  6 00244 6211 00	eax1 	pr6|164
007127  aa   020000 4310 07	fld  	8192,dl
007130  aa  6 00044 3701 20	epp4 	pr6|36,*
007131  la  4 00014 3521 20	epp2 	pr4|12,*		hc_backup_$decode_uidpath
007132  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 968
    if ec = error_table_$root then ;

007133  aa  6 00234 2361 00	ldq  	pr6|156		ec
007134  aa  6 00044 3701 20	epp4 	pr6|36,*
007135  la  4 00064 1161 20	cmpq 	pr4|52,*		error_table_$root
007136  aa   000002 6010 04	tnz  	2,ic		007140
007137  aa   000011 7100 04	tra  	9,ic		007150
						STATEMENT 1 ON LINE 969
    else if ec ^= 0 then
ret_unk: return ("UNKNOWN");

007140  aa  6 00234 2361 00	ldq  	pr6|156		ec
007141  aa   000007 6000 04	tze  	7,ic		007150
007142  aa  6 00032 3735 20	epp7 	pr6|26,*
007143  aa  7 00002 3715 20	epp5 	pr7|2,*
007144  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
007145  aa   770734 00 0007	desc9a	-3620,7		000100 = 125116113116
007146  aa  5 00000 00 0250	desc9a	pr5|0,168
007147  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 971
    call ioa_$rsnnl ("^a^[>^]^[^a>^;^s^]^a", ret_dn, (0), dn, dn ^= ">", en ^= "", en, rldr_data_.last_valid_vtoce_ename);

007150  aa   770764 2370 04	ldaq 	-3596,ic		000134 = 136141136133 076136135136
007151  aa  6 00244 7571 00	staq 	pr6|164
007152  aa   770764 2370 04	ldaq 	-3596,ic		000136 = 133136141076 136073136163
007153  aa  6 00246 7571 00	staq 	pr6|166
007154  aa   770764 2350 04	lda  	-3596,ic		000140 = 136135136141
007155  aa  6 00250 7551 00	sta  	pr6|168
007156  aa  6 00266 4501 00	stz  	pr6|182
007157  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
007160  aa  6 00100 00 0250	desc9a	pr6|64,168	dn
007161  aa   001000 00 0001	desc9a	512,1		010157 = 076000000000
007162  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
007163  aa  6 00267 7551 00	sta  	pr6|183
007164  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
007165  aa  6 00152 00 0040	desc9a	pr6|106,32	en
007166  aa   000773 00 0000	desc9a	507,0		010157 = 076000000000
007167  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
007170  aa  6 00270 7551 00	sta  	pr6|184
007171  aa  6 00244 3521 00	epp2 	pr6|164
007172  aa  6 00274 2521 00	spri2	pr6|188
007173  aa  6 00162 3521 00	epp2 	pr6|114		ret_dn
007174  aa  6 00276 2521 00	spri2	pr6|190
007175  aa  6 00266 3521 00	epp2 	pr6|182
007176  aa  6 00300 2521 00	spri2	pr6|192
007177  aa  6 00100 3521 00	epp2 	pr6|64		dn
007200  aa  6 00302 2521 00	spri2	pr6|194
007201  aa  6 00267 3521 00	epp2 	pr6|183
007202  aa  6 00304 2521 00	spri2	pr6|196
007203  aa  6 00270 3521 00	epp2 	pr6|184
007204  aa  6 00306 2521 00	spri2	pr6|198
007205  aa  6 00152 3521 00	epp2 	pr6|106		en
007206  aa  6 00310 2521 00	spri2	pr6|200
007207  aa  6 00040 3735 20	epp7 	pr6|32,*
007210  aa  7 00032 3715 20	epp5 	pr7|26,*
007211  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
007212  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
007213  aa  3 00151 3521 00	epp2 	pr3|105		rldr_data_.last_valid_vtoce_ename
007214  aa  6 00312 2521 00	spri2	pr6|202
007215  aa   770577 3520 04	epp2 	-3713,ic		000014 = 524000000024
007216  aa  6 00314 2521 00	spri2	pr6|204
007217  aa   770646 3520 04	epp2 	-3674,ic		000065 = 526000000250
007220  aa  6 00316 2521 00	spri2	pr6|206
007221  aa  6 00322 2521 00	spri2	pr6|210
007222  aa   770637 3520 04	epp2 	-3681,ic		000061 = 404000000005
007223  aa  6 00320 2521 00	spri2	pr6|208
007224  aa   770620 3520 04	epp2 	-3696,ic		000044 = 514000000001
007225  aa  6 00324 2521 00	spri2	pr6|212
007226  aa  6 00326 2521 00	spri2	pr6|214
007227  aa   770641 3520 04	epp2 	-3679,ic		000070 = 526000000040
007230  aa  6 00330 2521 00	spri2	pr6|216
007231  aa   770617 3520 04	epp2 	-3697,ic		000050 = 524000000040
007232  aa  6 00332 2521 00	spri2	pr6|218
007233  aa  6 00272 6211 00	eax1 	pr6|186
007234  aa   040000 4310 07	fld  	16384,dl
007235  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_$rsnnl
007236  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 972
    revert seg_fault_error;

007237  aa  6 00242 4501 00	stz  	pr6|162
						STATEMENT 1 ON LINE 973
    return (ret_dn);

007240  aa  6 00032 3735 20	epp7 	pr6|26,*
007241  aa  7 00002 3715 20	epp5 	pr7|2,*
007242  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007243  aa  6 00162 00 0250	desc9a	pr6|114,168	ret_dn
007244  aa  5 00000 00 0250	desc9a	pr5|0,168
007245  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 974
  end convert_puid_;

  END PROCEDURE convert_puid_
BEGIN PROCEDURE find_volname
ENTRY TO find_volname                                       STATEMENT 1 ON LINE 978
find_volname:
  proc (apvid, apvname, alvname, acode);

007246  da     000471200000
007247  aa   000140 6270 00	eax7 	96
007250  aa  7 00034 3521 20	epp2 	pr7|28,*
007251  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
007252  aa     000010000000
007253  aa     000000000000
						STATEMENT 1 ON LINE 984
    acode = 0;

007254  aa  6 00032 3735 20	epp7 	pr6|26,*
007255  aa  7 00010 4501 20	stz  	pr7|8,*		acode
						STATEMENT 1 ON LINE 985
    apvname, alvname = "UNKNOWN";

007256  aa  7 00004 3715 20	epp5 	pr7|4,*
007257  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
007260  aa   770621 00 0007	desc9a	-3695,7		000100 = 125116113116
007261  aa  5 00000 00 0040	desc9a	pr5|0,32		apvname
007262  aa  7 00006 3535 20	epp3 	pr7|6,*
007263  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
007264  aa   770615 00 0007	desc9a	-3699,7		000100 = 125116113116
007265  aa  3 00000 00 0040	desc9a	pr3|0,32		alvname
						STATEMENT 1 ON LINE 986
    if rldr_data_.stranger then acode = -1;

007266  aa  6 00040 3515 20	epp1 	pr6|32,*
007267  aa  1 00032 3715 20	epp5 	pr1|26,*
007270  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
007271  aa  3 00000 2351 20	lda  	pr3|0,*		rldr_data_.stranger
007272  aa   000040 3150 03	cana 	32,du
007273  aa   000004 6000 04	tze  	4,ic		007277
007274  aa   000001 3360 07	lcq  	1,dl
007275  aa  7 00010 7561 20	stq  	pr7|8,*		acode
007276  aa   000024 7100 04	tra  	20,ic		007322
						STATEMENT 1 ON LINE 987
    else call mdc_$find_volname (apvid, apvname, alvname, acode);

007277  aa  7 00002 3521 20	epp2 	pr7|2,*		apvid
007300  aa  6 00102 2521 00	spri2	pr6|66
007301  aa  7 00004 3521 20	epp2 	pr7|4,*		apvname
007302  aa  6 00104 2521 00	spri2	pr6|68
007303  aa  7 00006 3521 20	epp2 	pr7|6,*		alvname
007304  aa  6 00106 2521 00	spri2	pr6|70
007305  aa  7 00010 3521 20	epp2 	pr7|8,*		acode
007306  aa  6 00110 2521 00	spri2	pr6|72
007307  aa   770560 3520 04	epp2 	-3728,ic		000067 = 516000000044
007310  aa  6 00112 2521 00	spri2	pr6|74
007311  aa   770557 3520 04	epp2 	-3729,ic		000070 = 526000000040
007312  aa  6 00114 2521 00	spri2	pr6|76
007313  aa  6 00116 2521 00	spri2	pr6|78
007314  aa   770557 3520 04	epp2 	-3729,ic		000073 = 404000000043
007315  aa  6 00120 2521 00	spri2	pr6|80
007316  aa  6 00100 6211 00	eax1 	pr6|64
007317  aa   020000 4310 07	fld  	8192,dl
007320  la  4 00026 3521 20	epp2 	pr4|22,*		mdc_$find_volname
007321  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 989
  end find_volname;

007322  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE find_volname
BEGIN PROCEDURE read
ENTRY TO read                                               STATEMENT 1 ON LINE 993
read: proc (return_buffer_ptr,
       Nrequested_chars,
       Nreturned_chars,
       Sdelimited,
       code);

007323  da     000476200000
007324  aa   000140 6270 00	eax7 	96
007325  aa  7 00034 3521 20	epp2 	pr7|28,*
007326  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
007327  aa     000012000000
007330  aa     000000000000
						STATEMENT 1 ON LINE 1017
    Nreturned_chars, Nread_chars, code = 0;

007331  aa  6 00032 3735 20	epp7 	pr6|26,*
007332  aa  7 00006 4501 20	stz  	pr7|6,*		Nreturned_chars
007333  aa  6 00101 4501 00	stz  	pr6|65		Nread_chars
007334  aa  7 00012 4501 20	stz  	pr7|10,*		code
						STATEMENT 1 ON LINE 1019
    do while (Nreturned_chars < Nrequested_chars & code = 0);

007335  aa   000000 0110 03	nop  	0,du
007336  aa  6 00032 3735 20	epp7 	pr6|26,*
007337  aa  7 00006 2361 20	ldq  	pr7|6,*		Nreturned_chars
007340  aa  7 00004 1161 20	cmpq 	pr7|4,*		Nrequested_chars
007341  aa   000371 6050 04	tpl  	249,ic		007732
007342  aa  7 00012 2361 20	ldq  	pr7|10,*		code
007343  aa   000367 6010 04	tnz  	247,ic		007732
						STATEMENT 1 ON LINE 1020
      if rldr_data_.input_buffer_len = 0 then do;

007344  aa  6 00040 3715 20	epp5 	pr6|32,*
007345  aa  5 00032 3535 20	epp3 	pr5|26,*
007346  aa  3 00002 3515 20	epp1 	pr3|2,*		rldr_datap
007347  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
007350  aa  1 00412 2361 00	ldq  	pr1|266		rldr_data_.input_buffer_len
007351  aa   000212 6010 04	tnz  	138,ic		007563
						STATEMENT 1 ON LINE 1021
	rldr_data_.input_buffer_start = 1;

007352  aa   000001 2360 07	ldq  	1,dl
007353  aa  1 00413 7561 00	stq  	pr1|267		rldr_data_.input_buffer_start
						STATEMENT 1 ON LINE 1023
	if Sdelimited & Nreturned_chars = 0 then do;

007354  aa  7 00010 2351 20	lda  	pr7|8,*		Sdelimited
007355  aa   400000 3150 03	cana 	131072,du
007356  aa   000031 6000 04	tze  	25,ic		007407
007357  aa  7 00006 2361 20	ldq  	pr7|6,*		Nreturned_chars
007360  aa   000027 6010 04	tnz  	23,ic		007407
						STATEMENT 1 ON LINE 1024
	    call iox_$get_chars (rldr_data_.inputvol_iocbp,
	         addr (tape_check1), length (tape_check1), Nread_chars, code);

007361  aa  6 00104 3715 00	epp5 	pr6|68		tape_check1
007362  aa  6 00110 6515 00	spri5	pr6|72
007363  aa   000010 2360 07	ldq  	8,dl
007364  aa  6 00112 7561 00	stq  	pr6|74
007365  aa  1 00414 3521 00	epp2 	pr1|268		rldr_data_.inputvol_iocbp
007366  aa  6 00116 2521 00	spri2	pr6|78
007367  aa  6 00110 3521 00	epp2 	pr6|72
007370  aa  6 00120 2521 00	spri2	pr6|80
007371  aa  6 00112 3521 00	epp2 	pr6|74
007372  aa  6 00122 2521 00	spri2	pr6|82
007373  aa  6 00101 3521 00	epp2 	pr6|65		Nread_chars
007374  aa  6 00124 2521 00	spri2	pr6|84
007375  aa  7 00012 3521 20	epp2 	pr7|10,*		code
007376  aa  6 00126 2521 00	spri2	pr6|86
007377  aa  6 00114 6211 00	eax1 	pr6|76
007400  aa   024000 4310 07	fld  	10240,dl
007401  aa  6 00044 3701 20	epp4 	pr6|36,*
007402  la  4 00102 3521 20	epp2 	pr4|66,*		iox_$get_chars
007403  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1026
	    if code ^= 0 then return;

007404  aa  6 00032 3735 20	epp7 	pr6|26,*
007405  aa  7 00012 2361 20	ldq  	pr7|10,*		code
007406  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1027
	  end;

						STATEMENT 1 ON LINE 1029
	if return_buffer_ptr = null then do;

007407  aa  7 00002 2371 20	ldaq 	pr7|2,*		return_buffer_ptr
007410  aa   770500 6770 04	eraq 	-3776,ic		000110 = 077777000043 000001000000
007411  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007412  aa   000031 6010 04	tnz  	25,ic		007443
						STATEMENT 1 ON LINE 1030
	    call iox_$position (rldr_data_.inputvol_iocbp, FORWARD_CHAR_POSITIONING,
	         Nrequested_chars - Nreturned_chars, code);

007413  aa  7 00004 2361 20	ldq  	pr7|4,*		Nrequested_chars
007414  aa  7 00006 1761 20	sbq  	pr7|6,*		Nreturned_chars
007415  aa  6 00112 7561 00	stq  	pr6|74
007416  aa  6 00040 3715 20	epp5 	pr6|32,*
007417  aa  5 00032 3535 20	epp3 	pr5|26,*
007420  aa  3 00002 3515 20	epp1 	pr3|2,*		rldr_datap
007421  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
007422  aa  1 00414 3521 00	epp2 	pr1|268		rldr_data_.inputvol_iocbp
007423  aa  6 00116 2521 00	spri2	pr6|78
007424  aa   770450 3520 04	epp2 	-3800,ic		000074 = 000000000003
007425  aa  6 00120 2521 00	spri2	pr6|80
007426  aa  6 00112 3521 00	epp2 	pr6|74
007427  aa  6 00122 2521 00	spri2	pr6|82
007430  aa  7 00012 3521 20	epp2 	pr7|10,*		code
007431  aa  6 00124 2521 00	spri2	pr6|84
007432  aa  6 00114 6211 00	eax1 	pr6|76
007433  aa   020000 4310 07	fld  	8192,dl
007434  aa  6 00044 3701 20	epp4 	pr6|36,*
007435  la  4 00106 3521 20	epp2 	pr4|70,*		iox_$position
007436  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1032
	    Nreturned_chars = Nreturned_chars + Nrequested_chars;

007437  aa  6 00032 3735 20	epp7 	pr6|26,*
007440  aa  7 00004 2361 20	ldq  	pr7|4,*		Nrequested_chars
007441  aa  7 00006 0561 20	asq  	pr7|6,*		Nreturned_chars
						STATEMENT 1 ON LINE 1033
	  end;

007442  aa   000037 7100 04	tra  	31,ic		007501
						STATEMENT 1 ON LINE 1034
	else do;

						STATEMENT 1 ON LINE 1035
	    call iox_$get_chars (rldr_data_.inputvol_iocbp,
	         addcharno (return_buffer_ptr, Nreturned_chars),
	         Nrequested_chars - Nreturned_chars, Nread_chars, code);

007443  aa  7 00002 3521 20	epp2 	pr7|2,*		return_buffer_ptr
007444  aa  2 00000 3521 20	epp2 	pr2|0,*		return_buffer_ptr
007445  aa  7 00006 2361 20	ldq  	pr7|6,*		Nreturned_chars
007446  aa  2 00000 5005 06	a9bd 	pr2|0,ql
007447  aa  6 00110 2521 00	spri2	pr6|72
007450  aa  7 00004 2361 20	ldq  	pr7|4,*		Nrequested_chars
007451  aa  7 00006 1761 20	sbq  	pr7|6,*		Nreturned_chars
007452  aa  6 00112 7561 00	stq  	pr6|74
007453  aa  6 00040 3715 20	epp5 	pr6|32,*
007454  aa  5 00032 3535 20	epp3 	pr5|26,*
007455  aa  3 00002 3515 20	epp1 	pr3|2,*		rldr_datap
007456  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
007457  aa  1 00414 3521 00	epp2 	pr1|268		rldr_data_.inputvol_iocbp
007460  aa  6 00116 2521 00	spri2	pr6|78
007461  aa  6 00110 3521 00	epp2 	pr6|72
007462  aa  6 00120 2521 00	spri2	pr6|80
007463  aa  6 00112 3521 00	epp2 	pr6|74
007464  aa  6 00122 2521 00	spri2	pr6|82
007465  aa  6 00101 3521 00	epp2 	pr6|65		Nread_chars
007466  aa  6 00124 2521 00	spri2	pr6|84
007467  aa  7 00012 3521 20	epp2 	pr7|10,*		code
007470  aa  6 00126 2521 00	spri2	pr6|86
007471  aa  6 00114 6211 00	eax1 	pr6|76
007472  aa   024000 4310 07	fld  	10240,dl
007473  aa  6 00044 3701 20	epp4 	pr6|36,*
007474  la  4 00102 3521 20	epp2 	pr4|66,*		iox_$get_chars
007475  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1038
	    Nreturned_chars = Nreturned_chars + Nread_chars;

007476  aa  6 00101 2361 00	ldq  	pr6|65		Nread_chars
007477  aa  6 00032 3735 20	epp7 	pr6|26,*
007500  aa  7 00006 0561 20	asq  	pr7|6,*		Nreturned_chars
						STATEMENT 1 ON LINE 1039
	  end;

						STATEMENT 1 ON LINE 1040
	if code ^= 0 then return;

007501  aa  7 00012 2361 20	ldq  	pr7|10,*		code
007502  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1042
	if Sdelimited then do;

007503  aa  7 00010 2351 20	lda  	pr7|8,*		Sdelimited
007504  aa   400000 3150 03	cana 	131072,du
007505  aa   000074 6000 04	tze  	60,ic		007601
						STATEMENT 1 ON LINE 1043
	    call iox_$get_chars (rldr_data_.inputvol_iocbp,
	         addr (tape_check2), length (tape_check2), Nread_chars, code);

007506  aa  6 00106 3715 00	epp5 	pr6|70		tape_check2
007507  aa  6 00110 6515 00	spri5	pr6|72
007510  aa   000010 2360 07	ldq  	8,dl
007511  aa  6 00112 7561 00	stq  	pr6|74
007512  aa  6 00040 3535 20	epp3 	pr6|32,*
007513  aa  3 00032 3515 20	epp1 	pr3|26,*
007514  aa  1 00002 3735 20	epp7 	pr1|2,*		rldr_datap
007515  aa  7 00000 3735 20	epp7 	pr7|0,*		rldr_datap
007516  aa  7 00414 3521 00	epp2 	pr7|268		rldr_data_.inputvol_iocbp
007517  aa  6 00116 2521 00	spri2	pr6|78
007520  aa  6 00110 3521 00	epp2 	pr6|72
007521  aa  6 00120 2521 00	spri2	pr6|80
007522  aa  6 00112 3521 00	epp2 	pr6|74
007523  aa  6 00122 2521 00	spri2	pr6|82
007524  aa  6 00101 3521 00	epp2 	pr6|65		Nread_chars
007525  aa  6 00124 2521 00	spri2	pr6|84
007526  aa  6 00032 3735 20	epp7 	pr6|26,*
007527  aa  7 00012 3521 20	epp2 	pr7|10,*		code
007530  aa  6 00126 2521 00	spri2	pr6|86
007531  aa  6 00114 6211 00	eax1 	pr6|76
007532  aa   024000 4310 07	fld  	10240,dl
007533  aa  6 00044 3701 20	epp4 	pr6|36,*
007534  la  4 00102 3521 20	epp2 	pr4|66,*		iox_$get_chars
007535  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1045
	    if code ^= 0 then
	      return;

007536  aa  6 00032 3735 20	epp7 	pr6|26,*
007537  aa  7 00012 2361 20	ldq  	pr7|10,*		code
007540  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1048
	    if tape_check1 ^= tape_check2 then do;

007541  aa  6 00104 2371 00	ldaq 	pr6|68		tape_check1
007542  aa  6 00106 1171 00	cmpaq	pr6|70		tape_check2
007543  aa   000036 6000 04	tze  	30,ic		007601
						STATEMENT 1 ON LINE 1052
	        rldr_data_.input_buffer_len = Nreturned_chars;

007544  aa  7 00006 2361 20	ldq  	pr7|6,*		Nreturned_chars
007545  aa  6 00040 3715 20	epp5 	pr6|32,*
007546  aa  5 00032 3535 20	epp3 	pr5|26,*
007547  aa  3 00002 3515 20	epp1 	pr3|2,*		rldr_datap
007550  aa  1 00000 3515 20	epp1 	pr1|0,*		rldr_datap
007551  aa  1 00412 7561 00	stq  	pr1|266		rldr_data_.input_buffer_len
						STATEMENT 1 ON LINE 1053
	        substr (input_buffer, 1, rldr_data_.input_buffer_len) =
		   return_string;

007552  aa  1 00432 3735 20	epp7 	pr1|282,*		rldr_data_.input_buffer_ptr
007553  aa  6 00032 3715 20	epp5 	pr6|26,*
007554  aa  5 00002 3535 20	epp3 	pr5|2,*		return_buffer_ptr
007555  aa  3 00000 3535 20	epp3 	pr3|0,*		return_buffer_ptr
007556  aa  5 00004 2351 20	lda  	pr5|4,*		Nrequested_chars
007557  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
007560  aa  3 00000 00 0005	desc9a	pr3|0,al		return_string
007561  aa  7 00000 00 0006	desc9a	pr7|0,ql		input_buffer
						STATEMENT 1 ON LINE 1055
	      end;

						STATEMENT 1 ON LINE 1056
	  end;

						STATEMENT 1 ON LINE 1057
        end;

007562  aa   000017 7100 04	tra  	15,ic		007601
						STATEMENT 1 ON LINE 1059
      else
	 if Sdelimited then do;

007563  aa  7 00010 2351 20	lda  	pr7|8,*		Sdelimited
007564  aa   400000 3150 03	cana 	131072,du
007565  aa   000014 6000 04	tze  	12,ic		007601
						STATEMENT 1 ON LINE 1061
	tape_check1 = substr (input_buffer,
	     rldr_data_.input_buffer_start, length (tape_check1));

007566  aa  1 00413 2361 00	ldq  	pr1|267		rldr_data_.input_buffer_start
007567  aa  1 00432 3715 20	epp5 	pr1|282,*		rldr_data_.input_buffer_ptr
007570  aa  040 100 100 506	mlr  	(pr,ql),(pr),fill(040)
007571  aa  5 77777 60 0010	desc9a	pr5|-1(3),8	input_buffer
007572  aa  6 00104 00 0010	desc9a	pr6|68,8		tape_check1
						STATEMENT 1 ON LINE 1063
	tape_check2 = "";

007573  aa   770303 2370 04	ldaq 	-3901,ic		000076 = 040040040040 040040040040
007574  aa  6 00106 7571 00	staq 	pr6|70		tape_check2
						STATEMENT 1 ON LINE 1064
	rldr_data_.input_buffer_start =
	     rldr_data_.input_buffer_start + length (tape_check1);

007575  aa   000010 2360 07	ldq  	8,dl
007576  aa  1 00413 0561 00	asq  	pr1|267		rldr_data_.input_buffer_start
						STATEMENT 1 ON LINE 1066
	rldr_data_.input_buffer_len =
	     rldr_data_.input_buffer_len - length (tape_check1);

007577  aa   000010 3360 07	lcq  	8,dl
007600  aa  1 00412 0561 00	asq  	pr1|266		rldr_data_.input_buffer_len
						STATEMENT 1 ON LINE 1068
        end;

						STATEMENT 1 ON LINE 1070
      if rldr_data_.input_buffer_len > 0 then do;

007601  aa  6 00040 3735 20	epp7 	pr6|32,*
007602  aa  7 00032 3715 20	epp5 	pr7|26,*
007603  aa  5 00002 3535 20	epp3 	pr5|2,*		rldr_datap
007604  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
007605  aa  3 00412 2361 00	ldq  	pr3|266		rldr_data_.input_buffer_len
007606  aa   777530 6044 04	tmoz 	-168,ic		007336
						STATEMENT 1 ON LINE 1071
	Nassign_chars =
	     min (rldr_data_.input_buffer_len, Nrequested_chars);

007607  aa  6 00032 3515 20	epp1 	pr6|26,*
007610  aa  1 00004 1161 20	cmpq 	pr1|4,*		Nrequested_chars
007611  aa   000002 6040 04	tmi  	2,ic		007613
007612  aa  1 00004 2361 20	ldq  	pr1|4,*		Nrequested_chars
007613  aa  6 00100 7561 00	stq  	pr6|64		Nassign_chars
						STATEMENT 1 ON LINE 1074
	if Sdelimited then do;

007614  aa  1 00010 2351 20	lda  	pr1|8,*		Sdelimited
007615  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
007616  aa  6 00112 7551 00	sta  	pr6|74		Sdelimited
007617  aa   000027 6000 04	tze  	23,ic		007646
						STATEMENT 1 ON LINE 1075
	    if tape_check1 ^= tape_check2 then do;

007620  aa  6 00104 2371 00	ldaq 	pr6|68		tape_check1
007621  aa  6 00106 1171 00	cmpaq	pr6|70		tape_check2
007622  aa   000024 6000 04	tze  	20,ic		007646
						STATEMENT 1 ON LINE 1076
	        end_of_record = index (substr (input_buffer, rldr_data_.input_buffer_start,
		   rldr_data_.input_buffer_len), tape_check1);

007623  aa  3 00412 2361 00	ldq  	pr3|266		rldr_data_.input_buffer_len
007624  aa  3 00413 2351 00	lda  	pr3|267		rldr_data_.input_buffer_start
007625  aa   000003 0750 07	ada  	3,dl
007626  aa  3 00432 3735 20	epp7 	pr3|282,*		rldr_data_.input_buffer_ptr
007627  aa  7 77777 3521 00	epp2 	pr7|-1		input_buffer
007630  aa  2 00000 5005 05	a9bd 	pr2|0,al
007631  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
007632  aa   000010 2360 07	ldq  	8,dl
007633  aa  6 00104 3521 00	epp2 	pr6|68		tape_check1
007634  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
007635  aa  6 00102 7561 00	stq  	pr6|66		end_of_record
						STATEMENT 1 ON LINE 1078
	        if end_of_record > 0 then do;

007636  aa   000010 6044 04	tmoz 	8,ic		007646
						STATEMENT 1 ON LINE 1079
		  Nassign_chars = end_of_record - 1;

007637  aa   000001 1760 07	sbq  	1,dl
007640  aa  6 00100 7561 00	stq  	pr6|64		Nassign_chars
						STATEMENT 1 ON LINE 1080
		  if Nrequested_chars ^= Nassign_chars then
		    code = error_table_$data_loss;

007641  aa  1 00004 1161 20	cmpq 	pr1|4,*		Nrequested_chars
007642  aa   000004 6000 04	tze  	4,ic		007646
007643  aa  6 00044 3701 20	epp4 	pr6|36,*
007644  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$data_loss
007645  aa  1 00012 7561 20	stq  	pr1|10,*		code
						STATEMENT 1 ON LINE 1082
		end;

						STATEMENT 1 ON LINE 1083
	      end;

						STATEMENT 1 ON LINE 1084
	  end;

						STATEMENT 1 ON LINE 1086
	if return_buffer_ptr ^= null then
	  return_string = substr (input_buffer,
	       rldr_data_.input_buffer_start, Nassign_chars);

007646  aa  1 00002 2371 20	ldaq 	pr1|2,*		return_buffer_ptr
007647  aa   770241 6770 04	eraq 	-3935,ic		000110 = 077777000043 000001000000
007650  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007651  aa   000015 6000 04	tze  	13,ic		007666
007652  aa  1 00002 3735 20	epp7 	pr1|2,*		return_buffer_ptr
007653  aa  7 00000 3735 20	epp7 	pr7|0,*		return_buffer_ptr
007654  aa  3 00413 2351 00	lda  	pr3|267		rldr_data_.input_buffer_start
007655  aa  3 00432 3715 20	epp5 	pr3|282,*		rldr_data_.input_buffer_ptr
007656  aa  1 00004 2361 20	ldq  	pr1|4,*		Nrequested_chars
007657  aa   000003 0750 07	ada  	3,dl
007660  aa  5 77777 3515 00	epp1 	pr5|-1		input_buffer
007661  aa  1 00000 5005 05	a9bd 	pr1|0,al
007662  aa  6 00100 2351 00	lda  	pr6|64		Nassign_chars
007663  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
007664  aa  1 00000 00 0005	desc9a	pr1|0,al		input_buffer
007665  aa  7 00000 00 0006	desc9a	pr7|0,ql		return_string
						STATEMENT 1 ON LINE 1089
	Nreturned_chars = Nassign_chars;

007666  aa  6 00100 2361 00	ldq  	pr6|64		Nassign_chars
007667  aa  6 00032 3735 20	epp7 	pr6|26,*
007670  aa  7 00006 7561 20	stq  	pr7|6,*		Nreturned_chars
						STATEMENT 1 ON LINE 1091
	rldr_data_.input_buffer_start =
	     rldr_data_.input_buffer_start + Nassign_chars;

007671  aa  3 00413 0561 00	asq  	pr3|267		rldr_data_.input_buffer_start
						STATEMENT 1 ON LINE 1093
	rldr_data_.input_buffer_len =
	     rldr_data_.input_buffer_len - Nassign_chars;

007672  aa  6 00100 3361 00	lcq  	pr6|64		Nassign_chars
007673  aa  3 00412 0561 00	asq  	pr3|266		rldr_data_.input_buffer_len
						STATEMENT 1 ON LINE 1096
	if Sdelimited & rldr_data_.input_buffer_len > 0 then do;

007674  aa  6 00112 2351 00	lda  	pr6|74		Sdelimited
007675  aa   777441 6000 04	tze  	-223,ic		007336
007676  aa  3 00412 2361 00	ldq  	pr3|266		rldr_data_.input_buffer_len
007677  aa   777437 6044 04	tmoz 	-225,ic		007336
						STATEMENT 1 ON LINE 1097
	    rldr_data_.input_buffer_start =
	         rldr_data_.input_buffer_start + length (tape_check2);

007700  aa   000010 2360 07	ldq  	8,dl
007701  aa  3 00413 0561 00	asq  	pr3|267		rldr_data_.input_buffer_start
						STATEMENT 1 ON LINE 1099
	    substr (input_buffer, 1, rldr_data_.input_buffer_len) =
	         substr (input_buffer, rldr_data_.input_buffer_start,
	         rldr_data_.input_buffer_len - length (tape_check2))
	         || tape_check2;

007702  aa  3 00412 2361 00	ldq  	pr3|266		rldr_data_.input_buffer_len
007703  aa   000010 1760 07	sbq  	8,dl
007704  aa  6 00112 7561 00	stq  	pr6|74
007705  aa   000010 0760 07	adq  	8,dl
007706  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
007707  aa  3 00413 2351 00	lda  	pr3|267		rldr_data_.input_buffer_start
007710  aa  3 00432 3715 20	epp5 	pr3|282,*		rldr_data_.input_buffer_ptr
007711  aa  6 00113 7561 00	stq  	pr6|75
007712  aa  6 00112 2361 00	ldq  	pr6|74
007713  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
007714  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	input_buffer
007715  aa  2 00000 00 0006	desc9a	pr2|0,ql
007716  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
007717  aa  6 00106 00 0010	desc9a	pr6|70,8		tape_check2
007720  aa  2 00000 00 0010	desc9a	pr2|0,8
007721  aa  3 00412 2351 00	lda  	pr3|266		rldr_data_.input_buffer_len
007722  aa  6 00113 2361 00	ldq  	pr6|75
007723  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
007724  aa  2 00000 00 0006	desc9a	pr2|0,ql
007725  aa  5 00000 00 0005	desc9a	pr5|0,al		input_buffer
						STATEMENT 1 ON LINE 1103
	    rldr_data_.input_buffer_start = 1;

007726  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
007727  aa   000001 2360 07	ldq  	1,dl
007730  aa  3 00413 7561 00	stq  	pr3|267		rldr_data_.input_buffer_start
						STATEMENT 1 ON LINE 1104
	  end;

						STATEMENT 1 ON LINE 1105
        end;

						STATEMENT 1 ON LINE 1106
    end;

007731  aa   777405 7100 04	tra  	-251,ic		007336
						STATEMENT 1 ON LINE 1108
    return;

007732  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1109
  end read;

  END PROCEDURE read
  END PROCEDURE rldr_input_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
