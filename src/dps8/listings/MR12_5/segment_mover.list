	COMPILATION LISTING OF SEGMENT segment_mover
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/23/92  1025.0 mdt Fri
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(88-03-28,Parisek), approve(88-05-27,MCR7907),
       19*     audit(88-06-02,Fawcett), install(88-09-27,MR12.2-1122):
       20*     Free the pvtx and pvid binding (done by get_pvtx$hold_pvtx to keep other
       21*     processes from allocating the potential target pv during VTOCE move) when
       22*     that target pv is found to be full, thus making it unusable for the VTOCE
       23*     move. (phx20920).
       24*  2) change(92-09-11,Zimmerman), approve(92-09-11,MCR8259), audit(92-09-22,Vu),
       25*     install(92-10-23,MR12.5-1040):
       26*     Change to include names of sub_volumes in error messages.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 
       30 /* format: style2,indcomtxt */
       31 segment_mover:
       32      proc (a_refaddr, a_astep, a_ep, a_segno, a_code);
       33 
       34 /**** This procedure is invoked from the segment fault handler when the latter finds
       35*      a flag (aste.pack_ovfl) on in an ASTE to which a process is trying to connect.
       36*      This flag is turned on when the page fault handler finds that no page of the
       37*      segment's Physical Volume of residence is availble for allocation.
       38*
       39*      Segment_mover tries to allocate a vtoce for the segment on some
       40*      other physical volume of the logical volume. The PVT is scanned once,
       41*      via a coroutine with create_vtoce$createv_for_segmove. The target
       42*      physical volume must have at least as many free records as the current requirement
       43*      of the segment, plus the one extra sought. If no allocation can be made, segment_mover
       44*      returns the logical volume full error code.
       45*
       46*      In the case of a demand segment move (hphcs_ call to move a segment),
       47*      optimization of physical volume selection is allowed for create_vtoce.
       48*      This optimization will place segments on devices with the most space,
       49*      over a sufficiently large number of segment creations.
       50*
       51*      segment_mover relies upon page_control detected out-of-physical-volume
       52*      conditions on the target physical volume. If the segment fault handler
       53*      notices a fault on the illegal low segment number, an error is signalled, which
       54*      is caught by a condition handler in this program, and interpreted appropriately.
       55*
       56*      The basic strategy is to move all pages into memory, wired,
       57*      and then change the record addresses. For synchronized segments,
       58*      it is neccessary to guarantee that no held pages exist, since
       59*      the disk records for held pages would have to be preserved and
       60*      their contents moved. Thus, for synchronized segments,
       61*      pc force writes the journal pages, and then can use the usual
       62*      strategy.
       63*
       64*      Designed and coded by Bernard Greenberg, 9-10/75
       65*
       66*      Last modified:
       67*
       68*      02/19/76 by Richard Bratt to change coroutine coordination with create_vtoce
       69*      05/76    by BSG for demounter, hphcs_ seg mover
       70*      06/76	by D. Vinograd to copy volume dump info to new aste and to set volume dump bit map for old vtoce.
       71*      12/1/78 by BSG for +-1 bugs in pc calls and special-case of 1 PV LV
       72*      10/03/79 by J. A. Bush to copy terminal quota attributes out of old vtoce, into new one
       73*      03/10/80 by Mike Grady to code around a compiler bug
       74*      04/08/80 by Mike Grady to fix a bug in releasing of held pvtx's.
       75*      03/20/81, W. Olin Sibert, to change for ADP PTW formats
       76*      03/22/81, WOS, to only complain about illegal deactivations in segment fault case (not hphcs_)
       77*      04/19/81, W. Olin Sibert, to stop maintaining aste.ic
       78*      02/28/82, J. Bongiovanni, to eliminate obsolete vtoce.infqcnt, rework pvte refs,
       79*      add demand_segmove entry and optimization of PV allocation
       80*      08/18/82, J. Bongiovanni, for new pc$list_deposited_add and
       81*      pc$deposit_list calling sequences
       82*      10/26/82, J. Bongiovanni, for fm_damaged and synchronized segments
       83*      831211, E. N. Kittlitz, for EHS moves, demand moves within a PV.
       84*      84-01-03 BIM to finish the above.
       85*      84-07-01 BIM to unthread one aste from get_aste before getting
       86*      the other. Otherwise, you can get the same aste twice.
       87*      1984-10-15 BIM to release pvtx's on failure.
       88*      1984-12-18 BIM: to zero special SDW for synch segment (it has no trailer,
       89*      so cannot be left around), and to sum$dirmod.
       90*      1985-04-01, BIM: only rethread the ASTE once on failure.
       91**/
       92 
       93 	dcl     a_astep		 ptr;		/* for efficiency */
       94 	dcl     a_code		 fixed bin (35);	/* return error code */
       95 	dcl     a_ep		 ptr;
       96 	dcl     a_refaddr		 fixed bin (18);	/* referenced address, <0 if hphcs_ */
       97 	dcl     a_segno		 fixed bin;	/* arg segno of reference */
       98 
       99 	dcl     aste_uid		 bit (36) aligned;
      100 	dcl     aste_tqsw		 (0:1) bit (1) aligned;
      101 	dcl     cleanup_must_zero_sdw	 bit (1) aligned;
      102 	dcl     code		 fixed bin (35);	/* temp var for that */
      103 	dcl     corout_pvtx		 fixed bin;	/* control point for create_vtoce$createv_for_segmove */
      104 
      105 	dcl     demand_segmove	 bit (1);
      106 	dcl     depolist		 (0:255) bit (36) aligned;
      107 						/* deposit array */
      108 	dcl     dlp		 ptr;
      109 	dcl     move_astep		 ptr;		/* Target ASTE if ehs segmove */
      110 	dcl     held_pvtx		 bit (1);		/* flag, on if we held new pvtx */
      111 	dcl     ignore		 fixed bin (35);	/* what it says */
      112 	dcl     mod_status		 bit (1);		/* old seg fms status */
      113 	dcl     n_nulled_pages	 fixed bin;
      114 	dcl     new_pts		 fixed bin;
      115 	dcl     new_ptsi		 fixed bin;
      116 	dcl     new_pvid		 bit (36) aligned;
      117 	dcl     new_pvtx		 fixed bin;
      118 	dcl     new_vtocx		 fixed bin;
      119 	dcl     old_nqsw		 bit (1);		/* setting of no quota sw */
      120 	dcl     old_pts		 fixed bin;	/* old seg page table size */
      121 	dcl     old_ptsi		 fixed bin;	/* old seg page table size index */
      122 	dcl     old_pvid		 bit (36) aligned;
      123 	dcl     old_pvtx		 fixed bin;
      124 	dcl     old_vtocx		 fixed bin;
      125 	dcl     optimizing		 bit (1) aligned;
      126 	dcl     pageno_list		 (256) fixed bin;	/* Page number list */
      127 	dcl     pvid		 bit (36);	/* New pvid, to go in branch when ready */
      128 	dcl     pw1		 fixed bin;
      129 	dcl     pw2		 fixed bin;
      130 	dcl     qtype		 fixed bin;	/* seg/dir quota index */
      131 	dcl     recs_needed		 fixed bin;	/* Target vol must have this many */
      132 	dcl     ref_addr		 fixed bin (18);	/* address of fault */
      133 	dcl     refpage		 fixed bin;	/* page of fault */
      134 	dcl     same_pvtx		 bit (1);		/* flag, on new PVTX is same as old */
      135 	dcl     segno		 fixed bin;	/* temp for segno of reference */
      136 	dcl     size_needed		 fixed bin;	/* Size of new aste */
      137 	dcl     skip_pvtx		 fixed bin;	/* pvtx for cv to skip */
      138 	dcl     temp_ename		 char (32);
      139 	dcl     time1		 fixed bin (71);
      140 	dcl     time2		 fixed bin (71);
      141 	dcl     tsdw		 fixed bin (71) aligned;
      142 						/* Temp SDW stash */
      143 
      144 	dcl     1 aq_cell		 like quota_cell aligned;
      145 						/* auto copy of quota cell */
      146 	dcl     1 atq_info		 like tq_info aligned;
      147 						/* auto copy of tq_info */
      148 
      149 	dcl     MAGIC_NPAGES	 fixed bin static init (10);
      150 						/* if more than this many pages are nulled (found zero by PC), we will deposit them and retry the fault. */
      151 
      152 	dcl     create_vtoce$createv_for_segmove
      153 				 entry (ptr, bit (36), fixed bin, fixed bin (35), fixed bin, fixed bin, fixed bin,
      154 				 ptr, bit (1) aligned);
      155 	dcl     dbm_man$set_incr	 entry (fixed bin, fixed bin, fixed bin (35));
      156 	dcl     get_aste		 entry (fixed bin) returns (ptr);
      157 	dcl     get_ptrs_$given_astep	 entry (ptr) returns (fixed bin (71) aligned);
      158 	dcl     get_pvtx$hold_pvtx	 entry (bit (36) aligned, fixed bin, fixed bin (35));
      159 	dcl     get_pvtx$release_pvtx	 entry (bit (36) aligned, fixed bin);
      160 	dcl     lock$lock_ast	 ext entry;
      161 	dcl     lock$unlock_ast	 ext entry;
      162 	dcl     logical_volume_manager$lvtep
      163 				 entry (bit (36) aligned, ptr, fixed bin (35));
      164 	dcl     pc$deposit_list	 entry (fixed bin, fixed bin, ptr, fixed bin, ptr);
      165 	dcl     pc$list_deposited_add	 entry (ptr, fixed bin, fixed bin, fixed bin, ptr, ptr);
      166 	dcl     pc$segmove		 entry (ptr, ptr, ptr, fixed bin, fixed bin, fixed bin, ptr, ptr, fixed bin (35));
      167 	dcl     pds$process_group_id	 ext char (32) aligned;
      168 	dcl     pmut$swap_sdw	 entry (ptr, ptr);
      169 	dcl     put_aste		 entry (ptr);
      170 	dcl     setfaults		 entry (ptr, bit (1) aligned);
      171 	dcl     sum$dirmod		 entry (pointer);
      172 
      173 	dcl     syserr		 entry options (variable);
      174 	dcl     syserr$error_code	 entry options (variable);
      175 	dcl     (
      176 	        search_ast$hash_in,
      177 	        search_ast$hash_out
      178 	        )			 entry (pointer);
      179 	dcl     thread$cin		 entry (ptr, bit (18));
      180 	dcl     thread$out		 entry (ptr, bit (18));
      181 	dcl     usage_values	 entry (fixed bin (17), fixed bin (71));
      182 	dcl     vtoc_attributes$get_quota
      183 				 entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin,
      184 				 fixed bin (35));
      185 	dcl     vtoc_man$await_vtoce	 entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
      186 	dcl     vtoc_man$free_vtoce	 entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
      187 
      188 	dcl     sys_info$page_size	 fixed bin external static;
      189 	dcl     error_table_$log_vol_full
      190 				 fixed bin (35) ext static;
      191 	dcl     error_table_$illegal_deactivation
      192 				 fixed bin (35) external;
      193 						/* Sent if illegal seg for move */
      194 
      195 	dcl     (addr, baseptr, divide, fixed, null, setwordno, unspec, wordno)
      196 				 builtin;
      197 
      198 
      199 
      200 /**** Entry conditions:
      201*
      202*      DIRECTORY WRITE LOCKED
      203*      AST LOCKED
      204*
      205**/
      206 
      207 	demand_segmove = "0"b;			/* Called from seg_fault */
      208 	ref_addr = a_refaddr;
      209 	goto COMMON;
      210 
      211 demand_segmove:
      212      entry (a_astep, a_ep, a_segno, a_code);
      213 
      214 	demand_segmove = "1"b;			/* Called via hphcs_ */
      215 	ref_addr = -1;
      216 
      217 COMMON:
      218 	call usage_values (pw1, time1);		/* Meter */
      219 	code = 0;
      220 	segno = a_segno;
      221 	ep = a_ep;
      222 	astep = null ();				/* temporary use only */
      223 	move_astep = a_astep;			/* Current astep */
      224 
      225 	dlp = addr (depolist);			/* in general, use automatic table for deposits */
      226 	pvt_arrayp = addr (pvt$array);		/* for disk names and pvids */
      227 	sstp = addr (sst_seg$);
      228 
      229 	if move_astep -> aste.hc_sdw | move_astep -> aste.hc | move_astep -> aste.par_astep = "0"b
      230 	then do;
      231 		a_code = error_table_$illegal_deactivation;
      232 						/* Only complain for seg-fault invocation, not hphcs_ */
      233 		if ^demand_segmove
      234 		then /* theory is that these will go away next bootload, anyway */
      235 		     call syserr (LOG, "segment_mover: critical segment out of disk on ^a, segno/astep = ^o ^o",
      236 			diskname ((move_astep -> aste.pvtx)), segno, wordno (move_astep));
      237 		call lock$unlock_ast;
      238 		return;				/* leave pack_ovfl bit on */
      239 	     end;
      240 
      241 /**** Don't attempt non-demand segmoves on single PV case.
      242*      In the demand case, someone may have changed the sons_lvid to force a cross-LV move.
      243*      If we happen to take an oopv after this sons_lvid has changed but before a demand
      244*      move on the segment, we will move it within the old LV first. Oh well. */
      245 
      246 	call logical_volume_manager$lvtep ((pvt_array (move_astep -> aste.pvtx).lvid), lvtep, code);
      247 	if code = 0 & ^demand_segmove
      248 	then if move_astep -> aste.pvtx = lvte.pvtex & pvt_array (move_astep -> aste.pvtx).brother_pvtx = 0
      249 	     then do;
      250 		     call lock$unlock_ast;
      251 		     a_code = error_table_$log_vol_full;
      252 		     return;
      253 		end;
      254 
      255 	/*** For synchronized segs, we must prevent any new held pages.
      256*	     to do this, we must prevent any other process from modifying
      257*	     a page of this segment. To do that, we cut its trailer with setfaults.
      258*	     Once the trailer is cut, the segment is inaccessable until we release
      259*	     the directory lock. */
      260 
      261 
      262 	if move_astep -> aste.synchronized
      263 	then do;
      264 		call setfaults (move_astep, "0"b);	/* revoke all sdws */
      265 		tsdw = get_ptrs_$given_astep (move_astep);
      266 						/* but regenerate ours */
      267 		call pmut$swap_sdw (baseptr (segno), addr (tsdw));
      268 						/* back to normal */
      269 		cleanup_must_zero_sdw = "1"b;		/* an SDW without a trailer is not permissible */
      270 	     end;
      271 	else cleanup_must_zero_sdw = "0"b;
      272 
      273 	/*** Now we thread the segment out. Strictly speaking, only ^ehs
      274*	     segments need this. However, we can race with other processes
      275*	     on the ehs bit. It is simpler to always thread out.
      276*
      277*	     The segment is threaded out to prevent deactivation. Deactivation,
      278*	     while unlikely, would break the strategy. */
      279 
      280 	call thread$out (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));
      281 	call search_ast$hash_out (move_astep);		/* we have to rethread on new vtocx */
      282 
      283 /* Get modified/not modified status of old segment, and needed pages. */
      284 
      285 	old_ptsi = fixed (move_astep -> aste.ptsi, 9);
      286 	old_pts = sst.pts (old_ptsi);
      287 	old_vtocx = move_astep -> aste.vtocx;
      288 	old_pvtx = move_astep -> aste.pvtx;
      289 	old_pvid = pvt_array (old_pvtx).pvid;
      290 
      291 	call get_pvtx$hold_pvtx (old_pvid, old_pvtx, code);
      292 	if code ^= 0
      293 	then call syserr (CRASH, "segment_mover: get_pvtx(^o) fails under ast lock", old_pvtx);
      294 	held_pvtx = "0"b;				/* Didn't grab second pvtx yet */
      295 
      296 	mod_status = move_astep -> aste.fms;
      297 
      298 	n_nulled_pages = 0;
      299 	if ^move_astep -> aste.ddnp & ^(move_astep -> aste.fm_damaged & (sst.checksum_filemap ^= 0))
      300 	then do;
      301 		call pc$list_deposited_add (move_astep, 0, old_pts - 1, n_nulled_pages, dlp, addr (pageno_list));
      302 						/* He means those nulled's */
      303 		if n_nulled_pages > 0 & ^demand_segmove
      304 		then do;
      305 			call vtoc_man$await_vtoce (old_pvid, old_pvtx, old_vtocx, code);
      306 						/* Wait out before deposit */
      307 			if code ^= 0
      308 			then go to retake_fault;
      309 			call pc$deposit_list (fixed (move_astep -> aste.pvtx, 17), n_nulled_pages, dlp, old_vtocx,
      310 			     addr (pageno_list));	/* Free the addresses */
      311 			if n_nulled_pages > MAGIC_NPAGES & ^demand_segmove
      312 			then do;			/* Avoid this hack for sweep_pv */
      313 retake_fault:
      314 				call thread$cin (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));
      315 				call search_ast$hash_in (move_astep);
      316 				call cleanup_dseg_and_meter;
      317 				if move_astep -> aste.uid = aste_uid
      318 				then move_astep -> aste.pack_ovfl = "0"b;
      319 				call release_pvtxs; /* wallow in his own soup */
      320 				call lock$unlock_ast;
      321 				a_code = code;	/* success or failure, depending ... */
      322 				return;
      323 			     end;
      324 		     end;
      325 	     end;
      326 
      327 	recs_needed = n_nulled_pages + fixed (move_astep -> aste.records, 9);
      328 						/* Assume he will regen those pages */
      329 	refpage = divide (ref_addr, sys_info$page_size, 18, 0);
      330 	size_needed = old_pts;			/* Cannot be oob, seg_fault would have caught it */
      331 	aste_uid = move_astep -> aste.uid;		/* copy before AST unlock */
      332 	aste_tqsw (*) = move_astep -> aste.tqsw (*);	/* ... */
      333 	old_nqsw = move_astep -> aste.nqsw;		/* Get old nqsw */
      334 
      335 
      336 	move_astep -> aste.nqsw = "1"b;		/* no quota checking whilst we play */
      337 
      338 	new_ptsi, new_pts = -1;
      339 
      340 
      341 	call lock$unlock_ast;			/* *** AST UNLOCKED *** */
      342 
      343 	if aste_tqsw (0) | aste_tqsw (1)
      344 	then do;					/* any terminal quota? */
      345 		unspec (atq_info) = "0"b;		/* initialize structure */
      346 		tq_infop = addr (atq_info);		/* and set ptr */
      347 		qcp = addr (aq_cell);		/* set ptr for vtoc_attributes */
      348 		do qtype = 0 to 1;			/* check for both seg and dir quota */
      349 		     if aste_tqsw (qtype)
      350 		     then do;			/* if terminal quota of this type.. */
      351 			     call vtoc_attributes$get_quota (aste_uid, old_pvid, old_vtocx, qcp, qtype, code);
      352 			     if code ^= 0
      353 			     then /* we lose, log the error */
      354 				call syserr$error_code (LOG, code,
      355 				     "segment_mover: Moving ^[segment^;directory^] quota account from pvtx ^o, vtocx ^o^/",
      356 				     qtype + 1, old_pvtx, old_vtocx);
      357 			     else do;
      358 				     tq_info.trp (qtype) = quota_cell.trp;
      359 						/* copy pertinent info */
      360 				     tq_info.tup (qtype) = quota_cell.tup;
      361 				     tq_info.received (qtype) = quota_cell.received;
      362 				end;
      363 			end;
      364 		end;
      365 	     end;
      366 	else tq_infop = null;			/* no terminal quota */
      367 
      368 	temp_ename = addr (ep -> entry.primary_name) -> names.name;
      369 	corout_pvtx = 0;				/* Prime corutine */
      370 	optimizing = demand_segmove;			/* If hphcs_ call, attempt optimization */
      371 	if demand_segmove
      372 	then skip_pvtx = 0;				/* allow use of same pv if cv pleases */
      373 	else skip_pvtx = old_pvtx;			/* if oopv then skip this pv */
      374 
      375 next_pv:						/* RESTART POINT */
      376 /**** ASSERT:  aste is thread$out'ed
      377*      aste is search_ast$hash_out'ed
      378**/
      379 	same_pvtx, held_pvtx = "0"b;
      380 	call create_vtoce$createv_for_segmove (ep, pvid, new_vtocx, code, corout_pvtx, skip_pvtx, recs_needed, tq_infop,
      381 	     optimizing);
      382 
      383 /**** + Debug
      384*      call syserr$error_code (ANNOUNCE, code, "sgm: pvid: ^w new_vtocx ^o corout_pvtx ^d skip_pvtx ^d recs_needed ^d ^[optimizing^].",
      385*      pvid, new_vtocx, corout_pvtx, skip_pvtx, recs_needed, optimizing);
      386**/
      387 
      388 	if code ^= 0
      389 	then go to move_fails;
      390 	new_pvtx = corout_pvtx;			/* This is selected place */
      391 	if optimizing
      392 	then do;					/* in case this PV fails, punt further optimization */
      393 		optimizing = "0"b;			/* no more of this stuff */
      394 		corout_pvtx = 0;			/* start from the beginning again */
      395 	     end;
      396 	new_pvid = pvid;				/* alignment */
      397 	if new_pvtx = old_pvtx
      398 	then same_pvtx = "1"b;
      399 	else do;
      400 		call get_pvtx$hold_pvtx (new_pvid, new_pvtx, code);
      401 		if code = 0
      402 		then held_pvtx = "1"b;
      403 		else go to next_pv;
      404 	     end;
      405 
      406 
      407 	call MOVE_THE_SEGMENT;
      408 
      409 	sstp -> sst.good_sgms = sstp -> sst.good_sgms + 1;
      410 	if ^demand_segmove
      411 	then /* Only for seg_fault calls */
      412 	     call syserr (LOG, "segment_mover: Moved ^w(^a) from ^a to ^a for ^a", move_astep -> aste.uid, temp_ename,
      413 		diskname (old_pvtx), diskname (new_pvtx), pds$process_group_id);
      414 	move_astep = null ();
      415 	call release_pvtxs;
      416 	call cleanup_dseg_and_meter;
      417 	a_code = 0;				/* That was easy, wasn't it !? */
      418 	return;
      419 
      420 move_fails:					/* Code is set appropriately */
      421 	sstp -> sst.bad_sgms = sstp -> sst.bad_sgms + 1;	/* meter */
      422 	if ^demand_segmove
      423 	then call syserr$error_code (LOG, code, "segment_mover: Failed to seg move ^w(^a) from ^a for ^a",
      424 		move_astep -> aste.uid, temp_ename, diskname (old_pvtx), pds$process_group_id);
      425 	call lock$lock_ast;				/* AST LOCKED */
      426 	call thread$cin (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));
      427 						/* put ASTE back the way we found it. */
      428 	move_astep -> aste.pack_ovfl = "0"b;
      429 	move_astep -> aste.nqsw = old_nqsw;
      430 	call search_ast$hash_in (move_astep);
      431 	call release_pvtxs;
      432 	call lock$unlock_ast;			/* AST UNLOCKED */
      433 	call cleanup_dseg_and_meter;
      434 	a_code = code;
      435 
      436 
      437 
      438 MOVE_THE_SEGMENT:
      439      procedure;
      440 	dcl     astes		 (2) pointer;
      441 	dcl     px		 fixed bin;
      442 
      443 	code = 0;
      444 	call lock$lock_ast;				/* *** AST LOCKED *** */
      445 
      446 	do px = 1, 2;				/* old and new */
      447 	     astep, astes (px) = get_aste (size_needed);
      448 	     if astes (px) = null ()
      449 	     then do;
      450 		     code = error_table_$log_vol_full;	/* lie */
      451 		     go to retake_fault;
      452 		end;
      453 
      454 	     call thread$out (astep, sst.ausedp (fixed (astep -> aste.ptsi, 2)));
      455 						/* Thread out on 1 BEFORE getting 2. */
      456 	end;
      457 	astep = null ();
      458 
      459 	call lock$unlock_ast;			/* seg is now protected from deactivation */
      460 
      461 	astes (1) -> aste.nqsw, astes (1) -> aste.gtms, astes (1) -> aste.gtus = "1"b;
      462 	astes (2) -> aste.nqsw, astes (2) -> aste.gtms, astes (2) -> aste.gtus = "1"b;
      463 	astes (2) -> aste.pvtx = new_pvtx;		/* for pc_check_tables_ */
      464 
      465 /**** depolist, n_nulled_pages, pageno_list describe the addresses from
      466*      the old vtoce. */
      467 
      468 	n_nulled_pages = 0;
      469 	depolist = ""b;
      470 	pageno_list = 0;
      471 	code = 0;
      472 
      473 	call pc$segmove (move_astep, astes (1), astes (2), new_pvtx, new_vtocx, n_nulled_pages, dlp, addr (pageno_list),
      474 	     code);
      475 
      476 /**** + Debug
      477*      call syserr$error_code (ANNOUNCE, code, "sgm: new_pvtx ^d new_vtocx ^o n_to_deposit ^d.", new_pvtx, new_vtocx, n_nulled_pages);
      478**/
      479 
      480 	call lock$lock_ast;				/* pc returns unlocked. */
      481 	if code ^= 0
      482 	then do;
      483 		call put_aste (astes (1));
      484 		astes (1) = null;
      485 		call put_aste (astes (2));
      486 		astes (2) = null ();
      487 		call lock$unlock_ast;
      488 		if code = error_table_$log_vol_full	/* try another pv */
      489 		then do;
      490 			call release_pvtxs;		/* free ptvx/pvid binding */
      491 			go to next_pv;
      492 		     end;
      493 		else go to move_fails;		/* fatal error */
      494 	     end;
      495 
      496 	call thread$cin (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));
      497 						/* Okay, it goes back into replacement. Since move_fails and next_pv both expect it out, we delay this call to here. */
      498 
      499 	move_astep -> aste.pack_ovfl = "0"b;		/* as good as it will ever be */
      500 	move_astep -> aste.nqsw = old_nqsw;
      501 	call search_ast$hash_in (move_astep);
      502 
      503 	do astep = astes (1), astes (2);
      504 	     call put_aste (astep);
      505 	end;
      506 
      507 	astep, astes (1), astes (2) = null;
      508 
      509 	call lock$unlock_ast;			/* *** AST UNLOCKED *** */
      510 	ep -> entry.pvid = pvid;			/* Make directory point right */
      511 	ep -> entry.vtocx = new_vtocx;		/* Both these must complete */
      512 	if ep -> entry.dirsw
      513 	then do;
      514 		dp = baseptr (segno);
      515 		dp -> dir.vtocx = new_vtocx;
      516 		dp -> dir.pvid = pvid;
      517 		call sum$dirmod (dp);
      518 	     end;
      519 	else call sum$dirmod (setwordno (ep, 0));	/* Since this walks up, the above call includes this call */
      520 	call release_old_vtoce;
      521 
      522      end MOVE_THE_SEGMENT;
      523 
      524 
      525 cleanup_dseg_and_meter:
      526      procedure;
      527 
      528 	if cleanup_must_zero_sdw
      529 	then do;
      530 		tsdw = 0;
      531 		call pmut$swap_sdw (baseptr (segno), addr (tsdw));
      532 						/* remove our SDW for this */
      533 	     end;
      534 	call usage_values (pw2, time2);		/* meter */
      535 	sstp -> sst.sgm_time = sstp -> sst.sgm_time + time2 - time1;
      536 	sstp -> sst.sgm_pf = sstp -> sst.sgm_pf + pw2 - pw1;
      537 
      538      end cleanup_dseg_and_meter;
      539 
      540 
      541 diskname:
      542      proc (pvtx1) returns (char (9));
      543 	dcl     pic99		 pic "99";
      544 	dcl     pvtx1		 fixed bin;
      545 
      546 	pvtep = addr (pvt_array (pvtx1));
      547 	pic99 = pvte.logical_area_number;
      548 	if ^pvte.is_sv
      549 	then return (pvte.devname || "_" || pic99);
      550 	else return (pvte.devname || "_" || pic99 || pvte.sv_name);
      551 
      552      end diskname;
      553 
      554 
      555 release_old_vtoce:
      556      procedure;
      557 	call dbm_man$set_incr (old_pvtx, old_vtocx, ignore);
      558 	call vtoc_man$free_vtoce (old_pvid, old_pvtx, old_vtocx, code);
      559 	if code = 0
      560 	then call truncator (old_pvid, old_pvtx, old_vtocx);
      561 	else do;
      562 		call syserr$error_code (0, code, "segment_mover: freeing vtocx ^o on old pvtx ^o", old_vtocx,
      563 		     old_pvtx);
      564 		pvt_array (old_pvtx).vol_trouble_count = pvt_array (old_pvtx).vol_trouble_count + 1;
      565 	     end;
      566 
      567      end release_old_vtoce;
      568 
      569 
      570 release_pvtxs:
      571      proc;
      572 	call get_pvtx$release_pvtx (old_pvid, old_pvtx);
      573 	if held_pvtx
      574 	then call get_pvtx$release_pvtx (new_pvid, new_pvtx);
      575 
      576      end release_pvtxs;
      577 
      578 
      579 /**** Procedure to release the records from the old vtoce. */
      580 
      581 truncator:
      582      procedure (a_pvid, a_pvtx, a_vtocx);
      583 
      584 	dcl     (a_pvtx, a_vtocx)	 fixed bin;
      585 	dcl     a_pvid		 bit (36) aligned;
      586 
      587 	call vtoc_man$await_vtoce (a_pvid, a_pvtx, a_vtocx, code);
      588 						/* make sure the free "took". */
      589 	if code = 0
      590 	then call pc$deposit_list (a_pvtx, n_nulled_pages, dlp, a_vtocx, addr (pageno_list));
      591 	else do;
      592 		call syserr$error_code (0, code, "segment_mover: finishing truncation of pvtx ^o vtocx ^o.", a_pvtx,
      593 		     a_vtocx);
      594 		pvt_array (a_pvtx).vol_trouble_count = pvt_array (a_pvtx).vol_trouble_count + 1;
      595 	     end;
      596 
      597      end truncator;
      598 
      599 
      600 
      601 /* format: off */
      602  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      602 
      603  
  2     2 	/* BEGIN INCLUDE FILE add_type.incl.pl1 */
  2     3 	/* 02/26/75 by Bernard S. Greenberg */
  2     4 
  2     5 	/* This file provides a structure for checking
  2     6*		PTW/CME address type fields in PL/I */
  2     7 
  2     8 dcl 1 add_type unaligned static internal,
  2     9 	2 core bit (4) init ("1000"b),		/* in core- S/B only in PTW */
  2    10 	2 disk bit (4) init ("0100"b),		/* Disk address */
  2    11 	2 pd   bit (4) init ("0010"b),		/* Paging Device */
  2    12 	2 reserved bit (4) init ("0001"b),		/* Reserved */
  2    13 	2 non_null bit (4) init ("1111"b);		/* Not null address */
  2    14 
  2    15 dcl 1 badd_type unaligned based,
  2    16     2 (core, disk, pd, reserved) bit (1) unaligned;
  2    17 
  2    18 	/* END INCLUDE FILE add_type.incl.pl1 */
      603 
      604  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  3     2 
  3     3 
  3     4 /* Template for an entry. Length = 38 words */
  3     5 
  3     6 dcl  ep ptr;
  3     7 
  3     8 dcl 1 entry based (ep) aligned,
  3     9 
  3    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  3    12 
  3    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  3    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  3    15 
  3    16     2 uid bit (36),					/* unique id of entry */
  3    17 
  3    18     2 dtem bit (36),				/* date-time entry modified */
  3    19 
  3    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  3    21     2 pad0 bit (17),
  3    22     2 nnames fixed bin (17),				/* number of names for this entry */
  3    23 
  3    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    26 
  3    27     2 author,					/* user who created branch */
  3    28       3 pers_rp bit (18),				/* name of user who created branch */
  3    29       3 proj_rp bit (18),				/* project of user who created branch */
  3    30 
  3    31       3 tag char (1),				/* tag of user who created branch */
  3    32       3 pad1 char (3),
  3    33 
  3    34     2 primary_name bit (504),				/* first name on name list */
  3    35 
  3    36     2 dtd bit (36),					/* date time dumped */
  3    37 
  3    38     2 pad2 bit (36),
  3    39 
  3    40 
  3    41 /* the declarations below are for branch only */
  3    42 
  3    43 
  3    44     2 pvid bit (36),				/* physical volume id */
  3    45 
  3    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    47     2 pad3 bit (18),
  3    48 
  3    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  3    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  3    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  3    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  3    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  3    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  3    55     2 audit_flag bit (1),				/* segment must be audited for security */
  3    56     2 security_oosw bit (1),				/* security out of service switch */
  3    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  3    58     2 master_dir bit (1),				/* TRUE for master directory */
  3    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  3    60     2 pad4 bit (11),
  3    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  3    62 
  3    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  3    64 
  3    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  3    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  3    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  3    68 
  3    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  3    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  3    71 
  3    72     2 bc_author,					/* user who last set the bit count */
  3    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  3    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  3    75 
  3    76       3 tag char (1),				/* tag of user who set the bit count */
  3    77       3 pad5 bit (2),
  3    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  3    79 
  3    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  3    81 
  3    82     2 pad6 bit (36),
  3    83 
  3    84     2 checksum bit (36),				/* checksum from dtd */
  3    85 
  3    86     2 owner bit (36);				/* uid of containing directory */
  3    87 
  3    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      604 
  4     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  4     2 /* Modified 8/74 for NSS */
  4     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  4     4 /* Modified 3/82 BIM for change pclock */
  4     5 /* format: style3 */
  4     6 
  4     7 /* Template for the directory header. Length = 64 words. */
  4     8 
  4     9 dcl  dp ptr;
  4    10 
  4    11 dcl 1 dir based (dp) aligned,
  4    12 
  4    13    2 modify bit (36),				/* Process ID of last modifier */
  4    14    2 type bit (18) unaligned,			/* type of object = dir header */
  4    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  4    16     2 dtc (3),					/* date-time checked by salvager array */
  4    17       3 date bit (36),				/* the date */
  4    18       3 error bit (36),				/* what errors were discovered */
  4    19 
  4    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  4    21 
  4    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  4    23 
  4    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  4    25 
  4    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  4    27 
  4    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  4    29     2 version_number fixed bin (17),			/* version number of header */
  4    30 
  4    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  4    32     2 pad2 bit (18),
  4    33 
  4    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  4    35     2 pad3 bit (18),
  4    36 
  4    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  4    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  4    39 
  4    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  4    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  4    42 
  4    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  4    44     2 dir_count fixed bin (17),			/* number of directory branches */
  4    45 
  4    46     2 lcount fixed bin (17),				/* number of links */
  4    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  4    48 
  4    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  4    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  4    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  4    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  4    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  4    54     2 pad4 bit (14),
  4    55 
  4    56     2 iacl_count (0:7),
  4    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  4    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  4    59 
  4    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  4    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  4    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  4    63 
  4    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  4    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  4    66 
  4    67     2 htsize fixed bin (17),				/* size of hash table */
  4    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  4    69 
  4    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  4    71     2 pad6 fixed bin (17),
  4    72 
  4    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  4    74     2 pad7 bit (18)) unaligned,
  4    75 
  4    76     2 dts bit (36),					/* date-time directory last salvaged */
  4    77 
  4    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  4    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  4    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  4    81     2 checksum bit (36),				/* checksummed from uid on */
  4    82     2 owner bit (36);				/* uid of parent dir */
  4    83 
  4    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  4    85 
  4    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      605 
      606 
  5     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  5     2 
  5     3 /* Template for names of branches or links. Length = 14 words. */
  5     4 
  5     5 dcl np ptr;
  5     6 
  5     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  5     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  5     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  5    10 
  5    11     2 type bit (18) unaligned,			/* type = dir name */
  5    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  5    13 
  5    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  5    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  5    16 
  5    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  5    18     2 pad3 bit (18) unal,
  5    19 
  5    20     2 name char(32) aligned,
  5    21 
  5    22     2 checksum bit (36),				/* checksum from entry_rp */
  5    23 
  5    24     2 owner bit (36);				/* uid of entry */
  5    25 
  5    26 
  5    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      607 
      608  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  6     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  6     8*     Add the support for subvolumes
  6     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  6    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  6    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  6    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  6    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  6    14*     Added inconsistent_dbm bit for determining the status of volume
  6    15*     dumper bit maps.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18      dcl	   pvt$array	      aligned external;
  6    19      dcl	   pvt$max_n_entries      fixed bin external;
  6    20 
  6    21      dcl	   pvt_arrayp	      ptr;
  6    22      dcl	   pvtep		      ptr;
  6    23 
  6    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  6    25 
  6    26      dcl	   1 pvte		      based (pvtep) aligned,
  6    27 
  6    28 	     2 pvid	      bit (36),		/* physical volume ID */
  6    29 
  6    30 	     2 lvid	      bit (36),		/* logical volume ID */
  6    31 
  6    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  6    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  6    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  6    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  6    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  6    37 	     2 pad3	      bit (2) unaligned,
  6    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  6    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  6    40 
  6    41 
  6    42 
  6    43 	     2 devname	      char (4),		/* device name */
  6    44 
  6    45 	     (2 device_type	      fixed bin (8),	/* device type */
  6    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  6    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  6    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  6    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  6    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  6    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  6    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  6    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  6    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  6    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  6    56 	     2 scav_check_address
  6    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  6    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  6    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  6    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  6    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  6    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  6    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  6    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  6    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  6    66 
  6    67 
  6    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  6    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  6    70 
  6    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  6    72 
  6    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  6    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  6    75 
  6    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  6    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  6    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  6    79 	     2 records_per_cyl    fixed bin,
  6    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  6    81 	     2 sv_name            char (2) aligned,
  6    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  6    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  6    84 
  6    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  6    86 	     2 pad2	      bit (18) unaligned,
  6    87 
  6    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  6    89 
  6    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  6    91 
  6    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  6    93 
  6    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  6    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  6    96 
  6    97 
  6    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  6    99 
  6   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  6   101 
  6   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  6   103 
  6   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  6   105 
  6   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  6   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  6   108 
  6   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  6   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  6   111 
  6   112 
  6   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  6   114 	   VOLMAP_ASYNC_READ      init (1),
  6   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  6   116 
  6   117 
  6   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      608 
      609  /* BEGIN INCLUDE FILE lvt.incl.pl1 -- Written Jan. 1976 by R. Bratt       */
  7     2 /*
  7     3*   This include file defines the format of the hardcore L_ogical V_olume T_able (LVT).
  7     4**/
  7     5 
  7     6 dcl  lvt$ ext;
  7     7 dcl  lvtp ptr;
  7     8 dcl  lvtep ptr;
  7     9 
  7    10 dcl 1 lvt aligned based (lvtp),
  7    11     2 max_lvtex fixed bin (17),			/* maximum number of LVs describable */
  7    12     2 high_water_lvtex fixed bin (17),			/* highest LVT index assigned */
  7    13     2 free_lvtep ptr,				/* pointer to  first free lvte  */
  7    14     2 pad1 (4) bit (36),
  7    15     2 ht (0:63) ptr unal,				/* lvid hash table */
  7    16     2 lvtes (1:1 refer (lvt.max_lvtex)) like lvte;	/* LVT entries */
  7    17 
  7    18 dcl 1 lvte aligned based (lvtep),			/* logical volume table entry */
  7    19     2 lvtep ptr unaligned,				/* lvid hash thread */
  7    20     2 pvtex fixed bin (17),				/* thread of mounted PVs */
  7    21     2 lvid bit (36),				/* logical volume id */
  7    22     2 access_class aligned,				/* access isolation mechanism stuff */
  7    23       3 min bit (72),				/* minimum access class allowed on LV */
  7    24       3 max bit (72),				/* maximum access class allowed on volume */
  7    25     2 flags unaligned,				/* flags */
  7    26       3 public bit (1),				/* => anyone can connect to this LV */
  7    27       3 read_only bit (1),				/* => no writes on this LV */
  7    28       3 pad bit (16),
  7    29       3 cycle_pvtx fixed bin (17);			/* pvtx for next per_process seg */
  7    30 
  7    31 /* END INCLUDE FILE lvt.incl.pl1                                                    */
      609 
      610  /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  8     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  8     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  8     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  8     5 
  8     6 dcl  sst_seg$ external;
  8     7 dcl  sstp ptr;
  8     8 
  8     9 dcl 1 sst based (sstp) aligned,
  8    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  8    11 
  8    12 /* SST HEADER */
  8    13 
  8    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  8    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  8    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  8    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  8    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  8    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  8    20 
  8    21     2 ptl bit (36),					/* global page table loop lock */
  8    22     2 astl bit (36),				/* global ast allocation block lock */
  8    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  8    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  8    25     2 nused fixed bin,				/* number of pages on used list */
  8    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  8    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  8    28 
  8    29     2 astap ptr,					/* aste array pointer */
  8    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  8    31     2 astsize fixed bin,				/* size of an AST entry */
  8    32     2 cmesize fixed bin,				/* size of a CME entry */
  8    33     2 root_astep ptr,				/* pointer to the root AST entry */
  8    34 
  8    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  8    36     2 level (0:3),					/* per-list information about ASTE's */
  8    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  8    38 
  8    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  8    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  8    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  8    42     2 strsize fixed bin,				/* Trailer size in words. */
  8    43 
  8    44 /* CORE MAP HEADER */
  8    45 
  8    46     2 cmp ptr,					/* pointer to start of core map */
  8    47     2 usedp bit (18),				/* pointer to first used core block */
  8    48     2 wtct fixed bin,				/* count of pages being written */
  8    49 
  8    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  8    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  8    52 						/* MISC */
  8    53 
  8    54     2 double_write fixed bin,				/* trigger for store through scheme */
  8    55 						/* 0 = no double writes,
  8    56*						   1 = all non-pd pages get written,
  8    57*						   2 = all directories get written */
  8    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  8    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  8    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  8    61 
  8    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  8    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  8    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  8    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  8    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  8    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  8    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  8    69 
  8    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  8    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  8    72 
  8    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  8    74 
  8    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  8    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  8    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  8    78 
  8    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  8    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  8    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  8    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  8    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  8    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  8    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  8    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  8    87 
  8    88 
  8    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  8    90 
  8    91     2 steps fixed bin,				/* number of steps taken around used list */
  8    92     2 needc fixed bin,				/* number of times core page needed */
  8    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  8    94     2 ctwait fixed bin,				/* number of times write counter was full */
  8    95     2 wired fixed bin,				/* number of pages wired by pc */
  8    96     2 laps fixed bin,				/* number of times around used list */
  8    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  8    98     2 skipu fixed bin,				/* because of being used */
  8    99 
  8   100     2 skipm fixed bin,				/* because of being modified */
  8   101     2 skipos fixed bin,				/* because out of service */
  8   102     2 aused fixed bin,				/* number of AST entries on used list */
  8   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  8   104     2 deact_count fixed bin,				/* count of deactivations */
  8   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  8   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  8   107 
  8   108     2 reads (8) fixed bin,				/* number of reads for each did */
  8   109     2 writes (8) fixed bin,				/* number of writes for each did */
  8   110 
  8   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  8   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  8   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  8   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  8   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  8   116     2 total_sf fixed bin,				/* total number of seg_faults */
  8   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  8   118     2 post_list_size fixed bin,
  8   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  8   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  8   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  8   122     2 pre_page_list_size fixed bin,
  8   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  8   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  8   125 
  8   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  8   127 
  8   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  8   129 
  8   130 /* MAIN MEMORY USAGE INFORMATION */
  8   131 
  8   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  8   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  8   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  8   135     2 recopies fixed bin,				/* number of times recopied because modified */
  8   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  8   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  8   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  8   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  8   140 
  8   141 /*  AST METERS  */
  8   142 
  8   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  8   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  8   145 
  8   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  8   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  8   148     2 asearches fixed bin,				/* count of full searches made */
  8   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  8   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  8   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  8   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  8   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  8   154 
  8   155     2 alaps fixed bin,				/* lap counter for AST list */
  8   156     2 updates fixed bin,				/* calls to updateb */
  8   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  8   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  8   159     2 total_bf fixed bin,				/* count of bound faults */
  8   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  8   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  8   162 
  8   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  8   164 
  8   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  8   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  8   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  8   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  8   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  8   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  8   171 
  8   172 /* PRE-PAGE METERS */
  8   173 
  8   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  8   175 
  8   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  8   177 
  8   178 
  8   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  8   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  8   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  8   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  8   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  8   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  8   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  8   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  8   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  8   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  8   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  8   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  8   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  8   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  8   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  8   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  8   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  8   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  8   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  8   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  8   199     2 activations fixed bin,				/* total count of activations */
  8   200     2 dir_activations fixed bin,			/* count of directory activations */
  8   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  8   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  8   203     2 evict_recover_data,				/* see evict_page.alm */
  8   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  8   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  8   206 
  8   207 /* Data for metering force_write facility 08/19/78 */
  8   208 
  8   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  8   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  8   211     2 fw_none fixed bin,				/* Force write wrote none */
  8   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  8   213 
  8   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  8   215     2 pf_unlock_ptl_meterings fixed bin,
  8   216 
  8   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  8   218     2 backup_activations fixed bin (35),		/* activations for backup */
  8   219     2 metering_flags aligned,				/* small chunks of misc. information */
  8   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  8   221       3 pad bit (35) unal,
  8   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  8   223 
  8   224 /* METERS FOR STACK TRUNCATION */
  8   225 
  8   226     2 (stk_truncate_should_didnt,			/* counts */
  8   227        stk_truncate_should_did,
  8   228        stk_truncate_shouldnt_didnt,
  8   229        stk_truncate_shouldnt_did) fixed bin (35),
  8   230     2 stk_pages_truncated fixed bin (35),
  8   231     2 stk_pages_truncated_in_core fixed bin (35),
  8   232 
  8   233 /* SUPPORT FOR PC SEGMOVES */
  8   234 
  8   235     2 segmove_lock aligned,
  8   236       3 pid bit (36) aligned,
  8   237       3 event bit (36) aligned,
  8   238       3 notify bit (1) aligned,
  8   239     2 segmove_io_limit fixed bin, /* max read aheads */
  8   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  8   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  8   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  8   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  8   244 
  8   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  8   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  8   247     2 segmove_vtocx fixed bin,			/* ditto */
  8   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  8   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  8   250 
  8   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  8   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  8   253     2 trace_sw aligned,				/* tracing control flags */
  8   254       3 pad_trace bit (32) unaligned,
  8   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  8   256       3 tty_trace bit (1) unaligned,
  8   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  8   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  8   259     2 new_pages fixed bin,				/* newly created pages */
  8   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  8   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  8   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  8   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  8   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  8   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  8   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  8   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  8   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  8   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  8   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  8   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  8   272 
  8   273 /* END INCLUDE FILE sst.incl.pl1 */
      610 
      611  /* BEGIN INCLUDE FILE ... tq_info.incl.pl1 */
  9     2 /* created by J. A. Bush 10/03/79 */
  9     3 
  9     4 dcl  tq_infop ptr;					/* ptr to structure below */
  9     5 
  9     6 dcl 1 tq_info based (tq_infop) aligned,			/* structure defining terminal quota attributes */
  9     7     2 trp (0:1) fixed bin (71),			/* time record product (0 is seg quota) */
  9     8     2 tup (0:1) bit (36),				/* clock time of update */
  9     9     2 received (0:1) fixed bin (35),			/* quota moved down */
  9    10     2 pad (0:1) fixed bin;				/* inferier quota count */
  9    11 
  9    12 /* END INCLUDE FILE ... tq_info.incl.pl1 */
      611 
      612  /* BEGIN INCLUDE FILE ... quota_cell.incl.pl1 ... February 1982 */
 10     2 
 10     3 dcl 1 quota_cell based (qcp) aligned,			/* Argument used by vtoc_attributes$(get set)_quota */
 10     4     2 quota fixed bin (35),				/* Record quota */
 10     5     2 used fixed bin (35),				/* Current use */
 10     6     2 received fixed bin (35),			/* Quota moved down */
 10     7     2 tup bit (36),					/* Clock time of update */
 10     8     2 trp fixed bin (71),				/* Time-page-product, in page-seconds */
 10     9     2 pad fixed bin,
 10    10     2 terminal_quota_sw bit (1);			/* TRUE if terminal quota */
 10    11 
 10    12 dcl  qcp ptr;
 10    13 
 10    14 /* END INCLUDE FILE ... quota_cell */
      612 
      613  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 11     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 11     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 11     4 
 11     5 /* This include file has an ALM version.  Keep 'em in sync! */
 11     6 
 11     7 dcl (
 11     8 
 11     9 /* The following constants define the message action codes.  This indicates
 11    10*how a message is to be handled.  */
 11    11 
 11    12      SYSERR_CRASH_SYSTEM	init (1),			
 11    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 11    14 
 11    15      SYSERR_TERMINATE_PROCESS	init (2),
 11    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 11    17 
 11    18      SYSERR_PRINT_WITH_ALARM	init (3),
 11    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 11    20 
 11    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 11    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 11    23 
 11    24      SYSERR_LOG_OR_PRINT	init (4),
 11    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 11    26 
 11    27      SYSERR_LOG_OR_DISCARD	init (5),
 11    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 11    29 
 11    30 
 11    31 /* The following constants are added to the normal severities to indicate
 11    32*different sorting classes of messages.  */
 11    33 
 11    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 11    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 11    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 11    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 11    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 11    39 	) fixed bin internal static options (constant);
 11    40 
 11    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      613 
      614 
      615 
      616 /* BEGIN MESSAGE DOCUMENTATION
      617*
      618*   Message:
      619*   segment_mover: critical segment out of disk on DRIVENAME, segno/astep = sss/aaa
      620*
      621*   S: $info
      622*
      623*   T: $run
      624*
      625*   M: There are no more free pages on the physical volume where a critical
      626*   segment resides, and an extra page can not be found for that segment.
      627*   Such a critical segment may be a physical buffer segment for a
      628*   peripheral device attached via IOI.
      629*   The user process receives a seg_fault_error signal.
      630*
      631*   A: The logical volume containing the pack residing on DRIVENAME
      632*   may be too full, or may need rebalancing with the sweep_pv tool.
      633*   $notify_sa
      634*
      635*   Message:
      636*   segment_mover: get_pvtx (PPP) fails under ast lock
      637*
      638*   S: $crash
      639*
      640*   T: $run
      641*
      642*   M: The segment mover found that a physical volume appears to have been
      643*   demounted during the time that the segment mover has had the active segment
      644*   table locked. $err
      645*
      646*   A: $recover
      647*
      648*   Message:
      649*   segment_mover: unexpected segfault
      650*
      651*   S: $crash
      652*
      653*   T: $run
      654*
      655*   M: A segment fault occured during the cross-pack moving of a segment, but
      656*   this segment fault was not on the segment on which the segment mover was
      657*   expecting one. $err
      658*
      659*   A: $recover
      660*   There may be inconsistencies in the physical volumes involved. These can
      661*   be corrected by a physical volume salvage.
      662*
      663*   Message:
      664*   segment_mover: freeing vtocx VVV on new pvtx PPP. ERRORMESSAGE
      665*
      666*   S: $info
      667*
      668*   T: $run
      669*
      670*   M: The segment mover encountered an unexpected error in freeing
      671*   the VTOC entry of a segment being moved on a volume to which an abortive
      672*   attempt to move the segment was made.
      673*   This may be a physical device error.
      674*
      675*   A: $inform
      676*
      677*   Message:
      678*   segment_mover: threading error
      679*
      680*   S: $crash
      681*
      682*   T: $run
      683*
      684*   M: The segment mover encountered bad threads while rethreading the old or new AST entries
      685*   of  a segment involved in a cross-pack segment move.
      686*   $err
      687*
      688*   A: $recover
      689*
      690*   Message:
      691*   segment_mover: freeing vtocx VVV on old pvtx PPP ERRORMESSAGE
      692*
      693*   S: $info
      694*
      695*   T: $run
      696*
      697*   M: During a cross-pack segment move, the system encountered an unexpected
      698*   error in freeing the VTOC entry of the segment on the old pack
      699*   This may be a physical device error, or
      700*   may be indicative of a logic problem in the supervisor, or main memory or
      701*   CPU problems.
      702*
      703*   A: $inform
      704*
      705*   Message:
      706*   segment_mover: Moved UUUU(ENTRYNAME) from DRIVENAME1 to DRIVENAME2 for USERNAME
      707*
      708*   S: $log
      709*
      710*   T: $run
      711*
      712*   M: The system has successfully moved a segment from the pack
      713*   on DRIVENAME1 to the pack on DRIVENAME2, on a request for a new page on
      714*   behalf of the user whose process group ID is USERNAME. UUUU is the
      715*   unique ID of the segment, and ENTRYNAME its primary name.
      716*
      717*   A: If a large number of these messages occur, the logical volume containing
      718*   the packs specified by the drive names may be nearly full or
      719*   poorly balanced. If these messages persist, contact the system
      720*   administrator.
      721*
      722*   Message:
      723*   segment_mover: Failed to seg move UUU(ENTRYNAME) from DRIVENAME1 to DRIVENAME2 for USERNAME
      724*
      725*   S: $log
      726*
      727*   T: $run
      728*
      729*   M: The system could not perform a cross-pack segment move because no pack
      730*   in the logical volume had enough space to hold the segment. UUUU is the
      731*   unique ID of the segment, and ENTRYNAME its primary name.
      732*
      733*   A: If this message persists, the logical volume containing the packs
      734*   on the drives noted is near full. In this case, contact the system
      735*   administrator.
      736*
      737*   Message:
      738*   segment_mover: finishing truncation of pvtx PPP vtocx VVV
      739*
      740*   S: $info
      741*
      742*   T: $run
      743*
      744*   M: The segment mover encountered an unexpected error in truncating
      745*   either the old copy of a segment being moved cross-packs or in
      746*   a new copy which was aborted for lack of space. This may be a physical
      747*   device error, or may be indicative of a logic problem in the
      748*   supervisor, or may be symptomatic of main memory or CPU problems.
      749*
      750*   A: $inform
      751*
      752*   Message:
      753*   segment_mover: Moving QUOTA-TYPE quota account from pvtx PPP, vtocx VVV
      754*   ERRORMESSAGE
      755*
      756*   S: $log
      757*
      758*   T: $run
      759*
      760*   M: An error code was returned from the entry vtoc_attributes$get_quota when attempting to
      761*   get terminal quota information from the old vtoce before new vtoce is created. In this case
      762*   the terminal quota attributes for this QUOTA-TYPE  (either segment or directory) quota account
      763*   is lost.
      764*
      765*   A: If this occurs, the quota account for the segment that has been moved must be corrected
      766*   manually by the System Administrator or other qualified site personell.
      767*
      768*
      769*   END MESSAGE DOCUMENTATION */
      770 
      771 
      772      end segment_mover;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/23/92  1025.1  segment_mover.pl1                 >spec>install>1040>segment_mover.pl1
602          1    01/30/85  1623.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
603          2    09/29/77  1602.7  add_type.incl.pl1                 >ldd>include>add_type.incl.pl1
604          3    04/29/76  1200.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
605          4    05/24/82  1105.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
607          5    11/02/76  1514.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
608          6    07/21/88  2136.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
609          7    11/30/76  1655.4  lvt.incl.pl1                      >ldd>include>lvt.incl.pl1
610          8    01/30/85  1623.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
611          9    05/27/82  1625.9  tq_info.incl.pl1                  >ldd>include>tq_info.incl.pl1
612         10    05/27/82  1625.9  quota_cell.incl.pl1               >ldd>include>quota_cell.incl.pl1
613         11    05/17/85  0715.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000020 constant        fixed bin(17,0)          initial dcl 11-7 set ref 292*
LOG                             000014 constant        fixed bin(17,0)          initial dcl 11-7 set ref 233* 352* 410* 422*
MAGIC_NPAGES                           constant        fixed bin(17,0)          initial dcl 149 ref 311
a_astep                                parameter       pointer                  dcl 93 ref 31 211 223
a_code                                 parameter       fixed bin(35,0)          dcl 94 set ref 31 211 231* 251* 321* 417* 434*
a_ep                                   parameter       pointer                  dcl 95 ref 31 211 221
a_pvid                                 parameter       bit(36)                  dcl 585 set ref 581 587*
a_pvtx                                 parameter       fixed bin(17,0)          dcl 584 set ref 581 587* 589* 592* 594 594
a_refaddr                              parameter       fixed bin(18,0)          dcl 96 ref 31 208
a_segno                                parameter       fixed bin(17,0)          dcl 97 ref 31 211 220
a_vtocx                                parameter       fixed bin(17,0)          dcl 584 set ref 581 587* 589* 592*
addr                                                   builtin function         dcl 195 ref 225 226 227 267 267 301 301 309 309 346
                                                                                  347 368 473 473 531 531 546 589 589
aq_cell                         001166 automatic       structure                level 1 dcl 144 set ref 347
aste                                   based           structure                level 1 dcl 1-11
aste_tqsw                       000102 automatic       bit(1)                   array dcl 100 set ref 332* 343 343 349
aste_uid                        000100 automatic       bit(36)                  dcl 99 set ref 317 331* 351*
astep                           001210 automatic       pointer                  dcl 1-9 set ref 222* 447* 454* 454 457* 503* 504*
                                                                                  507*
astes                           001252 automatic       pointer                  array dcl 440 set ref 447* 448 461 461 461 462 462
                                                                                  462 463 473* 473* 483* 484* 485* 486* 503 503 507*
                                                                                  507*
atq_info                        001176 automatic       structure                level 1 dcl 146 set ref 345* 346
ausedp                   44            based           bit(18)                  array level 3 packed packed unaligned dcl 8-9 set
                                                                                  ref 280* 313* 426* 454* 496*
bad_sgms                513            based           fixed bin(17,0)          level 2 dcl 8-9 set ref 420* 420
baseptr                                                builtin function         dcl 195 ref 267 267 514 531 531
brother_pvtx              2(09)        based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 6-24 set
                                                                                  ref 247
checksum_filemap         75            based           fixed bin(17,0)          level 2 dcl 8-9 ref 299
cleanup_must_zero_sdw           000104 automatic       bit(1)                   dcl 101 set ref 269* 271* 528
code                            000105 automatic       fixed bin(35,0)          dcl 102 set ref 219* 246* 247 291* 292 305* 307 321
                                                                                  351* 352 352* 380* 388 400* 401 422* 434 443* 450*
                                                                                  471* 473* 481 488 558* 559 562* 587* 589 592*
corout_pvtx                     000106 automatic       fixed bin(17,0)          dcl 103 set ref 369* 380* 390 394*
create_vtoce$createv_for_segmove
                                000010 constant        entry                    external dcl 152 ref 380
dbm_man$set_incr                000012 constant        entry                    external dcl 155 ref 557
ddnp                     12(15)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 299
demand_segmove                  000107 automatic       bit(1)                   packed unaligned dcl 105 set ref 207* 214* 233 247
                                                                                  303 311 370 371 410 422
depolist                        000110 automatic       bit(36)                  array dcl 106 set ref 225 469*
devname                   3            based           char(4)                  level 2 dcl 6-26 ref 548 550
dir                                    based           structure                level 1 dcl 4-11
dirsw                    32            based           bit(1)                   level 2 packed packed unaligned dcl 3-8 ref 512
divide                                                 builtin function         dcl 195 ref 329
dlp                             000510 automatic       pointer                  dcl 108 set ref 225* 301* 309* 473* 589*
dp                              001214 automatic       pointer                  dcl 4-9 set ref 514* 515 516 517*
entry                                  based           structure                level 1 dcl 3-8
ep                              001212 automatic       pointer                  dcl 3-6 set ref 221* 368 380* 510 511 512 519 519
error_table_$illegal_deactivation
                                000102 external static fixed bin(35,0)          dcl 191 ref 231
error_table_$log_vol_full       000100 external static fixed bin(35,0)          dcl 189 ref 251 450 488
fixed                                                  builtin function         dcl 195 ref 280 285 309 309 313 327 426 454 496
fm_damaged                5(12)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 299
fms                      12(10)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 296
get_aste                        000014 constant        entry                    external dcl 156 ref 447
get_ptrs_$given_astep           000016 constant        entry                    external dcl 157 ref 265
get_pvtx$hold_pvtx              000020 constant        entry                    external dcl 158 ref 291 400
get_pvtx$release_pvtx           000022 constant        entry                    external dcl 159 ref 572 573
good_sgms               515            based           fixed bin(17,0)          level 2 dcl 8-9 set ref 409* 409
gtms                      5(03)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  461* 462*
gtus                      5(02)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  461* 462*
hc                        5(04)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 229
hc_sdw                    5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 229
held_pvtx                       000514 automatic       bit(1)                   packed unaligned dcl 110 set ref 294* 375* 401* 573
ignore                          000515 automatic       fixed bin(35,0)          dcl 111 set ref 557*
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 ref 548
level                    44            based           structure                array level 2 dcl 8-9
lock$lock_ast                   000024 constant        entry                    external dcl 160 ref 425 444 480
lock$unlock_ast                 000026 constant        entry                    external dcl 161 ref 237 250 320 341 432 459 487 509
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 6-26 ref 547
logical_volume_manager$lvtep    000030 constant        entry                    external dcl 162 ref 246
lvid                      1            based           bit(36)                  array level 2 dcl 6-24 set ref 246
lvte                                   based           structure                level 1 dcl 7-18
lvtep                           001222 automatic       pointer                  dcl 7-8 set ref 246* 247
mod_status                      000516 automatic       bit(1)                   packed unaligned dcl 112 set ref 296*
move_astep                      000512 automatic       pointer                  dcl 109 set ref 223* 229 229 229 233 233 233 233 246
                                                                                  247 247 262 264* 265* 280* 280 281* 285 287 288
                                                                                  296 299 299 301* 309 309 313* 313 315* 317 317 327
                                                                                  331 332 333 336 410 414* 422 426* 426 428 429 430*
                                                                                  473* 496* 496 499 500 501*
n_nulled_pages                  000517 automatic       fixed bin(17,0)          dcl 113 set ref 298* 301* 303 309* 311 327 468* 473*
                                                                                  589*
name                      4            based           char(32)                 level 2 dcl 5-7 ref 368
names                                  based           structure                level 1 dcl 5-7
new_pts                         000520 automatic       fixed bin(17,0)          dcl 114 set ref 338*
new_ptsi                        000521 automatic       fixed bin(17,0)          dcl 115 set ref 338*
new_pvid                        000522 automatic       bit(36)                  dcl 116 set ref 396* 400* 573*
new_pvtx                        000523 automatic       fixed bin(17,0)          dcl 117 set ref 390* 397 400* 410* 410* 463 473*
                                                                                  573*
new_vtocx                       000524 automatic       fixed bin(17,0)          dcl 118 set ref 380* 473* 511 515
nqsw                      5(20)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref 333
                                                                                  336* 429* 461* 462* 500*
null                                                   builtin function         dcl 195 ref 222 366 414 448 457 484 486 507
old_nqsw                        000525 automatic       bit(1)                   packed unaligned dcl 119 set ref 333* 429 500
old_pts                         000526 automatic       fixed bin(17,0)          dcl 120 set ref 286* 301 330
old_ptsi                        000527 automatic       fixed bin(17,0)          dcl 121 set ref 285* 286
old_pvid                        000530 automatic       bit(36)                  dcl 122 set ref 289* 291* 305* 351* 558* 559* 572*
old_pvtx                        000531 automatic       fixed bin(17,0)          dcl 123 set ref 288* 289 291* 292* 305* 352* 373 397
                                                                                  410* 410* 422* 422* 557* 558* 559* 562* 564 564
                                                                                  572*
old_vtocx                       000532 automatic       fixed bin(17,0)          dcl 124 set ref 287* 305* 309* 351* 352* 557* 558*
                                                                                  559* 562*
optimizing                      000533 automatic       bit(1)                   dcl 125 set ref 370* 380* 391 393*
pack_ovfl                13(20)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  317* 428* 499*
pageno_list                     000534 automatic       fixed bin(17,0)          array dcl 126 set ref 301 301 309 309 470* 473 473
                                                                                  589 589
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 229
pc$deposit_list                 000032 constant        entry                    external dcl 164 ref 309 589
pc$list_deposited_add           000034 constant        entry                    external dcl 165 ref 301
pc$segmove                      000036 constant        entry                    external dcl 166 ref 473
pds$process_group_id            000040 external static char(32)                 dcl 167 set ref 410* 422*
pic99                           001302 automatic       picture(2)               packed unaligned dcl 543 set ref 547* 548 550
pmut$swap_sdw                   000042 constant        entry                    external dcl 168 ref 267 531
primary_name             10            based           bit(504)                 level 2 packed packed unaligned dcl 3-8 set ref 368
pts                      40            based           fixed bin(17,0)          array level 2 dcl 8-9 ref 286
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 1-11 ref 280 285
                                                                                  313 426 454 496
put_aste                        000044 constant        entry                    external dcl 169 ref 483 485 504
pvid                     11            based           bit(36)                  level 2 in structure "dir" dcl 4-11 in procedure
                                                                                  "segment_mover" set ref 516*
pvid                            001134 automatic       bit(36)                  packed unaligned dcl 127 in procedure
                                                                                  "segment_mover" set ref 380* 396 510 516
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "segment_mover" set ref 510*
pvid                                   based           bit(36)                  array level 2 in structure "pvt_array" dcl 6-24
                                                                                  in procedure "segment_mover" set ref 289
pvt$array                       000104 external static fixed bin(17,0)          dcl 6-18 set ref 226
pvt_array                              based           structure                array level 1 dcl 6-24 set ref 546
pvt_arrayp                      001216 automatic       pointer                  dcl 6-21 set ref 226* 246 247 289 546 564 564 594
                                                                                  594
pvte                                   based           structure                level 1 dcl 6-26
pvtep                           001220 automatic       pointer                  dcl 6-22 set ref 546* 547 548 548 550 550
pvtex                     1            based           fixed bin(17,0)          level 2 dcl 7-18 ref 247
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1-11 set ref 233
                                                                                  233 246 247 247 288 309 309 463*
pvtx1                                  parameter       fixed bin(17,0)          dcl 544 ref 541 546
pw1                             001135 automatic       fixed bin(17,0)          dcl 128 set ref 217* 536
pw2                             001136 automatic       fixed bin(17,0)          dcl 129 set ref 534* 536
px                              001256 automatic       fixed bin(17,0)          dcl 441 set ref 446* 447 448*
qcp                             001230 automatic       pointer                  dcl 10-12 set ref 347* 351* 358 360 361
qtype                           001137 automatic       fixed bin(17,0)          dcl 130 set ref 348* 349 351* 352 358 360 361*
quota_cell                             based           structure                level 1 dcl 10-3
received                  6            based           fixed bin(35,0)          array level 2 in structure "tq_info" dcl 9-6
                                                                                  in procedure "segment_mover" set ref 361*
received                  2            based           fixed bin(35,0)          level 2 in structure "quota_cell" dcl 10-3
                                                                                  in procedure "segment_mover" ref 361
records                  12(18)        based           bit(9)                   level 2 packed packed unaligned dcl 1-11 ref 327
recs_needed                     001140 automatic       fixed bin(17,0)          dcl 131 set ref 327* 380*
ref_addr                        001141 automatic       fixed bin(18,0)          dcl 132 set ref 208* 215* 329
refpage                         001142 automatic       fixed bin(17,0)          dcl 133 set ref 329*
same_pvtx                       001143 automatic       bit(1)                   packed unaligned dcl 134 set ref 375* 397*
search_ast$hash_in              000056 constant        entry                    external dcl 175 ref 315 430 501
search_ast$hash_out             000060 constant        entry                    external dcl 175 ref 281
segno                           001144 automatic       fixed bin(17,0)          dcl 135 set ref 220* 233* 267 267 514 531 531
setfaults                       000046 constant        entry                    external dcl 170 ref 264
setwordno                                              builtin function         dcl 195 ref 519 519
sgm_pf                  512            based           fixed bin(17,0)          level 2 dcl 8-9 set ref 536* 536
sgm_time                510            based           fixed bin(71,0)          level 2 dcl 8-9 set ref 535* 535
size_needed                     001145 automatic       fixed bin(17,0)          dcl 136 set ref 330* 447*
skip_pvtx                       001146 automatic       fixed bin(17,0)          dcl 137 set ref 371* 373* 380*
sst                                    based           structure                level 1 dcl 8-9
sst_seg$                        000106 external static fixed bin(17,0)          dcl 8-6 set ref 227
sstp                            001224 automatic       pointer                  dcl 8-7 set ref 227* 280 286 299 313 409 409 420 420
                                                                                  426 454 496 535 535 536 536
sum$dirmod                      000050 constant        entry                    external dcl 171 ref 517 519
sv_name                  15            based           char(2)                  level 2 dcl 6-26 ref 550
synchronized             13(21)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 262
sys_info$page_size              000076 external static fixed bin(17,0)          dcl 188 ref 329
syserr                          000052 constant        entry                    external dcl 173 ref 233 292 410
syserr$error_code               000054 constant        entry                    external dcl 174 ref 352 422 562 592
temp_ename                      001147 automatic       char(32)                 packed unaligned dcl 138 set ref 368* 410* 422*
thread$cin                      000062 constant        entry                    external dcl 179 ref 313 426 496
thread$out                      000064 constant        entry                    external dcl 180 ref 280 454
time1                           001160 automatic       fixed bin(71,0)          dcl 139 set ref 217* 535
time2                           001162 automatic       fixed bin(71,0)          dcl 140 set ref 534* 535
tq_info                                based           structure                level 1 dcl 9-6
tq_infop                        001226 automatic       pointer                  dcl 9-4 set ref 346* 358 360 361 366* 380*
tqsw                      5(24)        based           bit(1)                   array level 2 packed packed unaligned dcl 1-11 ref
                                                                                  332
trp                       4            based           fixed bin(71,0)          level 2 in structure "quota_cell" dcl 10-3
                                                                                  in procedure "segment_mover" ref 358
trp                                    based           fixed bin(71,0)          array level 2 in structure "tq_info" dcl 9-6
                                                                                  in procedure "segment_mover" set ref 358*
tsdw                            001164 automatic       fixed bin(71,0)          dcl 141 set ref 265* 267 267 530* 531 531
tup                       3            based           bit(36)                  level 2 in structure "quota_cell" dcl 10-3
                                                                                  in procedure "segment_mover" ref 360
tup                       4            based           bit(36)                  array level 2 in structure "tq_info" dcl 9-6
                                                                                  in procedure "segment_mover" set ref 360*
uid                       3            based           bit(36)                  level 2 packed packed unaligned dcl 1-11 set ref 317
                                                                                  331 410* 422*
unspec                                                 builtin function         dcl 195 set ref 345*
usage_values                    000066 constant        entry                    external dcl 181 ref 217 534
vol_trouble_count        33            based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 6-24 set
                                                                                  ref 564* 564 594* 594
vtoc_attributes$get_quota       000070 constant        entry                    external dcl 182 ref 351
vtoc_man$await_vtoce            000072 constant        entry                    external dcl 185 ref 305 587
vtoc_man$free_vtoce             000074 constant        entry                    external dcl 186 ref 558
vtocx                     4(18)        based           fixed bin(17,0)          level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "segment_mover" ref 287
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 4-11 in procedure "segment_mover" set ref 515*
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "segment_mover" set ref 511*
wordno                                                 builtin function         dcl 195 ref 233 233

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 11-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 11-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 11-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 11-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 6-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 6-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 6-113
add_type                               internal static structure                level 1 packed packed unaligned dcl 2-8
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
badd_type                              based           structure                level 1 packed packed unaligned dcl 2-15
lvt                                    based           structure                level 1 dcl 7-10
lvt$                                   external static fixed bin(17,0)          dcl 7-6
lvtp                                   automatic       pointer                  dcl 7-7
np                                     automatic       pointer                  dcl 5-5
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 6-19
seg_aste                               based           structure                level 1 dcl 1-96
version_number_2                       internal static fixed bin(17,0)          initial dcl 4-84

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000255 constant        label                    dcl 217 set ref 209
MOVE_THE_SEGMENT                001547 constant        entry                    internal dcl 438 ref 407
cleanup_dseg_and_meter          002140 constant        entry                    internal dcl 525 ref 316 416 433
demand_segmove                  000233 constant        entry                    external dcl 211
diskname                        002207 constant        entry                    internal dcl 541 ref 233 233 410 410 410 410 422 422
move_fails                      001420 constant        label                    dcl 420 set ref 388 488
next_pv                         001245 constant        label                    dcl 375 ref 401 491
release_old_vtoce               002301 constant        entry                    internal dcl 555 ref 520
release_pvtxs                   002406 constant        entry                    internal dcl 570 ref 319 415 431 490
retake_fault                    000763 constant        label                    dcl 313 ref 307 451
segment_mover                   000204 constant        entry                    external dcl 31
truncator                       002434 constant        entry                    internal dcl 581 ref 559

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3224        3334    2610        3234
Length      4010    2610       110         437     413           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
segment_mover                      1004 external procedure  is an external procedure.  
MOVE_THE_SEGMENT                        internal procedure  shares stack frame of external procedure segment_mover.  
cleanup_dseg_and_meter                  internal procedure  shares stack frame of external procedure segment_mover.  
diskname                                internal procedure  shares stack frame of external procedure segment_mover.  
release_old_vtoce                       internal procedure  shares stack frame of external procedure segment_mover.  
release_pvtxs                           internal procedure  shares stack frame of external procedure segment_mover.  
truncator                               internal procedure  shares stack frame of external procedure segment_mover.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
segment_mover            000100 aste_uid                    segment_mover
                         000102 aste_tqsw                   segment_mover
                         000104 cleanup_must_zero_sdw       segment_mover
                         000105 code                        segment_mover
                         000106 corout_pvtx                 segment_mover
                         000107 demand_segmove              segment_mover
                         000110 depolist                    segment_mover
                         000510 dlp                         segment_mover
                         000512 move_astep                  segment_mover
                         000514 held_pvtx                   segment_mover
                         000515 ignore                      segment_mover
                         000516 mod_status                  segment_mover
                         000517 n_nulled_pages              segment_mover
                         000520 new_pts                     segment_mover
                         000521 new_ptsi                    segment_mover
                         000522 new_pvid                    segment_mover
                         000523 new_pvtx                    segment_mover
                         000524 new_vtocx                   segment_mover
                         000525 old_nqsw                    segment_mover
                         000526 old_pts                     segment_mover
                         000527 old_ptsi                    segment_mover
                         000530 old_pvid                    segment_mover
                         000531 old_pvtx                    segment_mover
                         000532 old_vtocx                   segment_mover
                         000533 optimizing                  segment_mover
                         000534 pageno_list                 segment_mover
                         001134 pvid                        segment_mover
                         001135 pw1                         segment_mover
                         001136 pw2                         segment_mover
                         001137 qtype                       segment_mover
                         001140 recs_needed                 segment_mover
                         001141 ref_addr                    segment_mover
                         001142 refpage                     segment_mover
                         001143 same_pvtx                   segment_mover
                         001144 segno                       segment_mover
                         001145 size_needed                 segment_mover
                         001146 skip_pvtx                   segment_mover
                         001147 temp_ename                  segment_mover
                         001160 time1                       segment_mover
                         001162 time2                       segment_mover
                         001164 tsdw                        segment_mover
                         001166 aq_cell                     segment_mover
                         001176 atq_info                    segment_mover
                         001210 astep                       segment_mover
                         001212 ep                          segment_mover
                         001214 dp                          segment_mover
                         001216 pvt_arrayp                  segment_mover
                         001220 pvtep                       segment_mover
                         001222 lvtep                       segment_mover
                         001224 sstp                        segment_mover
                         001226 tq_infop                    segment_mover
                         001230 qcp                         segment_mover
                         001252 astes                       MOVE_THE_SEGMENT
                         001256 px                          MOVE_THE_SEGMENT
                         001302 pic99                       diskname

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
create_vtoce$createv_for_segmove                            dbm_man$set_incr              get_aste
get_ptrs_$given_astep         get_pvtx$hold_pvtx            get_pvtx$release_pvtx         lock$lock_ast
lock$unlock_ast               logical_volume_manager$lvtep  pc$deposit_list               pc$list_deposited_add
pc$segmove                    pmut$swap_sdw                 put_aste                      search_ast$hash_in
search_ast$hash_out           setfaults                     sum$dirmod                    syserr
syserr$error_code             thread$cin                    thread$out                    usage_values
vtoc_attributes$get_quota     vtoc_man$await_vtoce          vtoc_man$free_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$illegal_deactivation                           error_table_$log_vol_full     pds$process_group_id
pvt$array                     sst_seg$                      sys_info$page_size


CONSTANTS
002552  aa     000006000000
002553  aa     000000000000
002554  aa     600000000041
002555  aa     000530000000
002556  aa     600000000041
002557  aa     000531000000
002560  aa     600000000041
002561  aa     000532000000

002562  aa  070 322 000 000	8

002564  aa     000004000000
002565  aa     000000000000
002566  aa     600000000041
002567  aa     000523000000
002570  aa     600000000041
002571  aa     001360000000

002572  aa     000004000000
002573  aa     000000000000
002574  aa     600000000041
002575  aa     000531000000
002576  aa     600000000041
002577  aa     001326000000

002600  aa     777777677777

002602  aa     000004000000
002603  aa     000000000000
002604  aa     600000000041
002605  aa     001356000000
002606  aa     600000000041
002607  aa     001326000000

000000  aa     524000000070

000001  aa     514000000044

000002  aa     524000000056

000003  aa     404000000005

000004  aa     524000000067

000005  aa     524000000040

000006  aa     526000000040

000007  aa     516000000044

000010  aa     524000000123

000011  aa     524000000060

000012  aa     524000000011

000013  aa     524000000106

000014  aa     000000000004

000015  aa     526000000011

000016  aa     410000000107

000017  aa     404000000021

000020  aa     000000000001

000021  aa     404000000022

000022  aa     404000000043

000023  aa     464000000000

000024  aa     000000000000
000025  aa     000000000000

000026  aa     077777000043
000027  aa     000001000000

000030  aa  163 145 147 155	segm
000031  aa  145 156 164 137	ent_
000032  aa  155 157 166 145	move
000033  aa  162 072 040 146	r: f
000034  aa  162 145 145 151	reei
000035  aa  156 147 040 166	ng v
000036  aa  164 157 143 170	tocx
000037  aa  040 136 157 040	 ^o 
000040  aa  157 156 040 157	on o
000041  aa  154 144 040 160	ld p
000042  aa  166 164 170 040	vtx 
000043  aa  136 157 000 000	^o

000044  aa  163 145 147 155	segm
000045  aa  145 156 164 137	ent_
000046  aa  155 157 166 145	move
000047  aa  162 072 040 115	r: M
000050  aa  157 166 145 144	oved
000051  aa  040 136 167 050	 ^w(
000052  aa  136 141 051 040	^a) 
000053  aa  146 162 157 155	from
000054  aa  040 136 141 040	 ^a 
000055  aa  164 157 040 136	to ^
000056  aa  141 040 146 157	a fo
000057  aa  162 040 136 141	r ^a

000060  aa  163 145 147 155	segm
000061  aa  145 156 164 137	ent_
000062  aa  155 157 166 145	move
000063  aa  162 072 040 147	r: g
000064  aa  145 164 137 160	et_p
000065  aa  166 164 170 050	vtx(
000066  aa  136 157 051 040	^o) 
000067  aa  146 141 151 154	fail
000070  aa  163 040 165 156	s un
000071  aa  144 145 162 040	der 
000072  aa  141 163 164 040	ast 
000073  aa  154 157 143 153	lock

000074  aa  163 145 147 155	segm
000075  aa  145 156 164 137	ent_
000076  aa  155 157 166 145	move
000077  aa  162 072 040 146	r: f
000100  aa  151 156 151 163	inis
000101  aa  150 151 156 147	hing
000102  aa  040 164 162 165	 tru
000103  aa  156 143 141 164	ncat
000104  aa  151 157 156 040	ion 
000105  aa  157 146 040 160	of p
000106  aa  166 164 170 040	vtx 
000107  aa  136 157 040 166	^o v
000110  aa  164 157 143 170	tocx
000111  aa  040 136 157 056	 ^o.

000112  aa  163 145 147 155	segm
000113  aa  145 156 164 137	ent_
000114  aa  155 157 166 145	move
000115  aa  162 072 040 106	r: F
000116  aa  141 151 154 145	aile
000117  aa  144 040 164 157	d to
000120  aa  040 163 145 147	 seg
000121  aa  040 155 157 166	 mov
000122  aa  145 040 136 167	e ^w
000123  aa  050 136 141 051	(^a)
000124  aa  040 146 162 157	 fro
000125  aa  155 040 136 141	m ^a
000126  aa  040 146 157 162	 for
000127  aa  040 136 141 000	 ^a

000130  aa  163 145 147 155	segm
000131  aa  145 156 164 137	ent_
000132  aa  155 157 166 145	move
000133  aa  162 072 040 143	r: c
000134  aa  162 151 164 151	riti
000135  aa  143 141 154 040	cal 
000136  aa  163 145 147 155	segm
000137  aa  145 156 164 040	ent 
000140  aa  157 165 164 040	out 
000141  aa  157 146 040 144	of d
000142  aa  151 163 153 040	isk 
000143  aa  157 156 040 136	on ^
000144  aa  141 054 040 163	a, s
000145  aa  145 147 156 157	egno
000146  aa  057 141 163 164	/ast
000147  aa  145 160 040 075	ep =
000150  aa  040 136 157 040	 ^o 
000151  aa  136 157 000 000	^o

000152  aa  163 145 147 155	segm
000153  aa  145 156 164 137	ent_
000154  aa  155 157 166 145	move
000155  aa  162 072 040 115	r: M
000156  aa  157 166 151 156	ovin
000157  aa  147 040 136 133	g ^[
000160  aa  163 145 147 155	segm
000161  aa  145 156 164 136	ent^
000162  aa  073 144 151 162	;dir
000163  aa  145 143 164 157	ecto
000164  aa  162 171 136 135	ry^]
000165  aa  040 161 165 157	 quo
000166  aa  164 141 040 141	ta a
000167  aa  143 143 157 165	ccou
000170  aa  156 164 040 146	nt f
000171  aa  162 157 155 040	rom 
000172  aa  160 166 164 170	pvtx
000173  aa  040 136 157 054	 ^o,
000174  aa  040 166 164 157	 vto
000175  aa  143 170 040 136	cx ^
000176  aa  157 136 057 000	o^/

BEGIN PROCEDURE segment_mover
ENTRY TO segment_mover                                      STATEMENT 1 ON LINE 31
segment_mover:
     proc (a_refaddr, a_astep, a_ep, a_segno, a_code);

000177  at     000005000021
000200  tt     000023000023
000201  tt     000017000022
000202  ta     000177000000
000203  da     000400300000
000204  aa   001760 6270 00	eax7 	1008
000205  aa  7 00034 3521 20	epp2 	pr7|28,*
000206  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000207  aa     000012000000
000210  aa     000000000000
000211  aa  6 00032 3735 20	epp7 	pr6|26,*
000212  aa  7 00004 3715 20	epp5 	pr7|4,*
000213  aa  6 01232 6515 00	spri5	pr6|666
000214  aa  7 00006 3535 20	epp3 	pr7|6,*
000215  aa  6 01236 2535 00	spri3	pr6|670
000216  aa  7 00010 3515 20	epp1 	pr7|8,*
000217  aa  6 01240 2515 00	spri1	pr6|672
000220  aa  7 00012 3715 20	epp5 	pr7|10,*
000221  aa  6 01234 6515 00	spri5	pr6|668
						STATEMENT 1 ON LINE 207
	demand_segmove = "0"b;

000222  aa  6 00107 4501 00	stz  	pr6|71		demand_segmove
						STATEMENT 1 ON LINE 208
	ref_addr = a_refaddr;

000223  aa  7 00002 2361 20	ldq  	pr7|2,*		a_refaddr
000224  aa  6 01141 7561 00	stq  	pr6|609		ref_addr
						STATEMENT 1 ON LINE 209
	goto COMMON;

000225  aa   000030 7100 04	tra  	24,ic		000255
ENTRY TO demand_segmove                                     STATEMENT 1 ON LINE 211
demand_segmove:
     entry (a_astep, a_ep, a_segno, a_code);

000226  at     000004000023
000227  tt     000023000017
000230  ta     000022000000
000231  ta     000226000000
000232  da     000407300000
000233  aa   001760 6270 00	eax7 	1008
000234  aa  7 00034 3521 20	epp2 	pr7|28,*
000235  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000236  aa     000010000000
000237  aa     000000000000
000240  aa  6 00032 3735 20	epp7 	pr6|26,*
000241  aa  7 00002 3715 20	epp5 	pr7|2,*
000242  aa  6 01232 6515 00	spri5	pr6|666
000243  aa  7 00004 3535 20	epp3 	pr7|4,*
000244  aa  6 01236 2535 00	spri3	pr6|670
000245  aa  7 00006 3515 20	epp1 	pr7|6,*
000246  aa  6 01240 2515 00	spri1	pr6|672
000247  aa  7 00010 3715 20	epp5 	pr7|8,*
000250  aa  6 01234 6515 00	spri5	pr6|668
						STATEMENT 1 ON LINE 214
	demand_segmove = "1"b;

000251  aa   400000 2350 03	lda  	131072,du
000252  aa  6 00107 7551 00	sta  	pr6|71		demand_segmove
						STATEMENT 1 ON LINE 215
	ref_addr = -1;

000253  aa   000001 3360 07	lcq  	1,dl
000254  aa  6 01141 7561 00	stq  	pr6|609		ref_addr
						STATEMENT 1 ON LINE 217
COMMON:
	call usage_values (pw1, time1);

000255  aa  6 01135 3521 00	epp2 	pr6|605		pw1
000256  aa  6 01330 2521 00	spri2	pr6|728
000257  aa  6 01160 3521 00	epp2 	pr6|624		time1
000260  aa  6 01332 2521 00	spri2	pr6|730
000261  aa  6 01326 6211 00	eax1 	pr6|726
000262  aa   010000 4310 07	fld  	4096,dl
000263  aa  6 00044 3701 20	epp4 	pr6|36,*
000264  la  4 00066 3521 20	epp2 	pr4|54,*		usage_values
000265  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 219
	code = 0;

000266  aa  6 00105 4501 00	stz  	pr6|69		code
						STATEMENT 1 ON LINE 220
	segno = a_segno;

000267  aa  6 01240 2361 20	ldq  	pr6|672,*		a_segno
000270  aa  6 01144 7561 00	stq  	pr6|612		segno
						STATEMENT 1 ON LINE 221
	ep = a_ep;

000271  aa  6 01236 3735 20	epp7 	pr6|670,*		a_ep
000272  aa  7 00000 3735 20	epp7 	pr7|0,*		a_ep
000273  aa  6 01212 6535 00	spri7	pr6|650		ep
						STATEMENT 1 ON LINE 222
	astep = null ();

000274  aa   777532 2370 04	ldaq 	-166,ic		000026 = 077777000043 000001000000
000275  aa  6 01210 7571 00	staq 	pr6|648		astep
						STATEMENT 1 ON LINE 223
	move_astep = a_astep;

000276  aa  6 01232 3715 20	epp5 	pr6|666,*		a_astep
000277  aa  5 00000 3715 20	epp5 	pr5|0,*		a_astep
000300  aa  6 00512 6515 00	spri5	pr6|330		move_astep
						STATEMENT 1 ON LINE 225
	dlp = addr (depolist);

000301  aa  6 00110 3535 00	epp3 	pr6|72		depolist
000302  aa  6 00510 2535 00	spri3	pr6|328		dlp
						STATEMENT 1 ON LINE 226
	pvt_arrayp = addr (pvt$array);

000303  aa  6 00044 3701 20	epp4 	pr6|36,*
000304  la  4 00104 3515 20	epp1 	pr4|68,*		pvt$array
000305  aa  6 01216 2515 00	spri1	pr6|654		pvt_arrayp
						STATEMENT 1 ON LINE 227
	sstp = addr (sst_seg$);

000306  la  4 00106 3735 20	epp7 	pr4|70,*		sst_seg$
000307  aa  6 01224 6535 00	spri7	pr6|660		sstp
						STATEMENT 1 ON LINE 229
	if move_astep -> aste.hc_sdw | move_astep -> aste.hc | move_astep -> aste.par_astep = "0"b
	then do;

000310  aa  5 00005 2351 00	lda  	pr5|5		aste.hc
000311  aa   030000 3150 03	cana 	12288,du
000312  aa   000004 6010 04	tnz  	4,ic		000316
000313  aa  5 00002 2351 00	lda  	pr5|2		aste.par_astep
000314  aa   777777 3150 07	cana 	262143,dl
000315  aa   000057 6010 04	tnz  	47,ic		000374
						STATEMENT 1 ON LINE 231
		a_code = error_table_$illegal_deactivation;

000316  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$illegal_deactivation
000317  aa  6 01234 7561 20	stq  	pr6|668,*		a_code
						STATEMENT 1 ON LINE 233
		if ^demand_segmove
		then /* theory is that these will go away next bootload, anyway */
		     call syserr (LOG, "segment_mover: critical segment out of disk on ^a, segno/astep = ^o ^o",
			diskname ((move_astep -> aste.pvtx)), segno, wordno (move_astep));

000320  aa  6 00107 2351 00	lda  	pr6|71		demand_segmove
000321  aa   000045 6010 04	tnz  	37,ic		000366
000322  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000323  aa   777606 00 0110	desc9a	-122,72		000130 = 163145147155
000324  aa  6 01334 00 0110	desc9a	pr6|732,72
000325  aa  5 00004 2351 00	lda  	pr5|4		aste.pvtx
000326  aa   000011 7350 00	als  	9
000327  aa   000077 7330 00	lrs  	63
000330  aa  6 01356 7561 00	stq  	pr6|750
000331  aa   002251 3520 04	epp2 	1193,ic		002602 = 000004000000
000332  aa   001655 6700 04	tsp4 	941,ic		002207
000333  aa  6 00512 6361 20	eaq  	pr6|330,*		move_astep
000334  aa   000022 7720 00	qrl  	18
000335  aa  6 01356 7561 00	stq  	pr6|750
000336  aa   777456 3520 04	epp2 	-210,ic		000014 = 000000000004
000337  aa  6 01362 2521 00	spri2	pr6|754
000340  aa  6 01334 3521 00	epp2 	pr6|732
000341  aa  6 01364 2521 00	spri2	pr6|756
000342  aa  6 01326 3521 00	epp2 	pr6|726
000343  aa  6 01366 2521 00	spri2	pr6|758
000344  aa  6 01144 3521 00	epp2 	pr6|612		segno
000345  aa  6 01370 2521 00	spri2	pr6|760
000346  aa  6 01356 3521 00	epp2 	pr6|750
000347  aa  6 01372 2521 00	spri2	pr6|762
000350  aa   777447 3520 04	epp2 	-217,ic		000017 = 404000000021
000351  aa  6 01374 2521 00	spri2	pr6|764
000352  aa  6 01402 2521 00	spri2	pr6|770
000353  aa   777440 3520 04	epp2 	-224,ic		000013 = 524000000106
000354  aa  6 01376 2521 00	spri2	pr6|766
000355  aa   777435 3520 04	epp2 	-227,ic		000012 = 524000000011
000356  aa  6 01400 2521 00	spri2	pr6|768
000357  aa   777442 3520 04	epp2 	-222,ic		000021 = 404000000022
000360  aa  6 01404 2521 00	spri2	pr6|772
000361  aa  6 01360 6211 00	eax1 	pr6|752
000362  aa   024000 4310 07	fld  	10240,dl
000363  aa  6 00044 3701 20	epp4 	pr6|36,*
000364  la  4 00052 3521 20	epp2 	pr4|42,*		syserr
000365  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 237
		call lock$unlock_ast;

000366  aa  6 00056 6211 00	eax1 	pr6|46
000367  aa   000000 4310 07	fld  	0,dl
000370  aa  6 00044 3701 20	epp4 	pr6|36,*
000371  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
000372  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 238
		return;

000373  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 239
	     end;

						STATEMENT 1 ON LINE 246
	call logical_volume_manager$lvtep ((pvt_array (move_astep -> aste.pvtx).lvid), lvtep, code);

000374  aa  5 00004 2351 00	lda  	pr5|4		aste.pvtx
000375  aa   000011 7350 00	als  	9
000376  aa   000077 7330 00	lrs  	63
000377  aa   000034 4020 07	mpy  	28,dl
000400  aa  1 77745 2351 06	lda  	pr1|-27,ql	pvt_array.lvid
000401  aa  6 01356 7551 00	sta  	pr6|750
000402  aa  6 01356 3521 00	epp2 	pr6|750
000403  aa  6 01336 2521 00	spri2	pr6|734
000404  aa  6 01222 3521 00	epp2 	pr6|658		lvtep
000405  aa  6 01340 2521 00	spri2	pr6|736
000406  aa  6 00105 3521 00	epp2 	pr6|69		code
000407  aa  6 01342 2521 00	spri2	pr6|738
000410  aa  6 01334 6211 00	eax1 	pr6|732
000411  aa   014000 4310 07	fld  	6144,dl
000412  la  4 00030 3521 20	epp2 	pr4|24,*		logical_volume_manager$lvtep
000413  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 247
	if code = 0 & ^demand_segmove
	then if move_astep -> aste.pvtx = lvte.pvtex & pvt_array (move_astep -> aste.pvtx).brother_pvtx = 0
	     then do;

000414  aa  6 00107 2351 00	lda  	pr6|71		demand_segmove
000415  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000416  aa  6 01356 7551 00	sta  	pr6|750
000417  aa   000033 6000 04	tze  	27,ic		000452
000420  aa  6 00105 2361 00	ldq  	pr6|69		code
000421  aa   000031 6010 04	tnz  	25,ic		000452
000422  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000423  aa  7 00004 2351 00	lda  	pr7|4		aste.pvtx
000424  aa   000011 7350 00	als  	9
000425  aa   000077 7330 00	lrs  	63
000426  aa  6 01357 7561 00	stq  	pr6|751		aste.pvtx
000427  aa  6 01222 3715 20	epp5 	pr6|658,*		lvtep
000430  aa  5 00001 1161 00	cmpq 	pr5|1		lvte.pvtex
000431  aa   000021 6010 04	tnz  	17,ic		000452
000432  aa   000034 4020 07	mpy  	28,dl
000433  aa  6 01357 7561 00	stq  	pr6|751
000434  aa  6 01216 3535 20	epp3 	pr6|654,*		pvt_arrayp
000435  aa  3 77746 2351 06	lda  	pr3|-26,ql	pvt_array.brother_pvtx
000436  aa   000011 7350 00	als  	9
000437  aa   000077 7330 00	lrs  	63
000440  aa   000012 6010 04	tnz  	10,ic		000452
						STATEMENT 1 ON LINE 250
		     call lock$unlock_ast;

000441  aa  6 00056 6211 00	eax1 	pr6|46
000442  aa   000000 4310 07	fld  	0,dl
000443  aa  6 00044 3701 20	epp4 	pr6|36,*
000444  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
000445  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 251
		     a_code = error_table_$log_vol_full;

000446  aa  6 00044 3701 20	epp4 	pr6|36,*
000447  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$log_vol_full
000450  aa  6 01234 7561 20	stq  	pr6|668,*		a_code
						STATEMENT 1 ON LINE 252
		     return;

000451  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 253
		end;

						STATEMENT 1 ON LINE 262
	if move_astep -> aste.synchronized
	then do;

000452  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000453  aa  7 00013 2351 00	lda  	pr7|11		aste.synchronized
000454  aa   040000 3150 07	cana 	16384,dl
000455  aa   000047 6000 04	tze  	39,ic		000524
						STATEMENT 1 ON LINE 264
		call setfaults (move_astep, "0"b);

000456  aa   000000 2350 07	lda  	0,dl
000457  aa  6 01357 7551 00	sta  	pr6|751
000460  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
000461  aa  6 01330 2521 00	spri2	pr6|728
000462  aa  6 01357 3521 00	epp2 	pr6|751
000463  aa  6 01332 2521 00	spri2	pr6|730
000464  aa  6 01326 6211 00	eax1 	pr6|726
000465  aa   010000 4310 07	fld  	4096,dl
000466  aa  6 00044 3701 20	epp4 	pr6|36,*
000467  la  4 00046 3521 20	epp2 	pr4|38,*		setfaults
000470  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 265
		tsdw = get_ptrs_$given_astep (move_astep);

000471  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
000472  aa  6 01330 2521 00	spri2	pr6|728
000473  aa  6 01164 3521 00	epp2 	pr6|628		tsdw
000474  aa  6 01332 2521 00	spri2	pr6|730
000475  aa  6 01326 6211 00	eax1 	pr6|726
000476  aa   010000 4310 07	fld  	4096,dl
000477  aa  6 00044 3701 20	epp4 	pr6|36,*
000500  la  4 00016 3521 20	epp2 	pr4|14,*		get_ptrs_$given_astep
000501  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 267
		call pmut$swap_sdw (baseptr (segno), addr (tsdw));

000502  aa  6 01144 2361 00	ldq  	pr6|612		segno
000503  aa  6 00000 3525 00	epbp2	pr6|0
000504  aa   000000 3130 06	easp2	0,ql
000505  aa  6 01406 2521 00	spri2	pr6|774
000506  aa  6 01164 3735 00	epp7 	pr6|628		tsdw
000507  aa  6 01410 6535 00	spri7	pr6|776
000510  aa  6 01406 3521 00	epp2 	pr6|774
000511  aa  6 01330 2521 00	spri2	pr6|728
000512  aa  6 01410 3521 00	epp2 	pr6|776
000513  aa  6 01332 2521 00	spri2	pr6|730
000514  aa  6 01326 6211 00	eax1 	pr6|726
000515  aa   010000 4310 07	fld  	4096,dl
000516  aa  6 00044 3701 20	epp4 	pr6|36,*
000517  la  4 00042 3521 20	epp2 	pr4|34,*		pmut$swap_sdw
000520  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 269
		cleanup_must_zero_sdw = "1"b;

000521  aa   400000 2350 03	lda  	131072,du
000522  aa  6 00104 7551 00	sta  	pr6|68		cleanup_must_zero_sdw
						STATEMENT 1 ON LINE 270
	     end;

000523  aa   000002 7100 04	tra  	2,ic		000525
						STATEMENT 1 ON LINE 271
	else cleanup_must_zero_sdw = "0"b;

000524  aa  6 00104 4501 00	stz  	pr6|68		cleanup_must_zero_sdw
						STATEMENT 1 ON LINE 280
	call thread$out (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));

000525  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000526  aa  7 00013 2351 00	lda  	pr7|11		aste.ptsi
000527  aa   000034 7350 00	als  	28
000530  aa   000106 7730 00	lrl  	70
000531  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
000532  aa  6 01330 2521 00	spri2	pr6|728
000533  aa  6 01224 3715 20	epp5 	pr6|660,*		sstp
000534  aa  5 00044 3521 06	epp2 	pr5|36,ql		sst.ausedp
000535  aa  6 01332 2521 00	spri2	pr6|730
000536  aa  6 01326 6211 00	eax1 	pr6|726
000537  aa   010000 4310 07	fld  	4096,dl
000540  aa  6 00044 3701 20	epp4 	pr6|36,*
000541  la  4 00064 3521 20	epp2 	pr4|52,*		thread$out
000542  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 281
	call search_ast$hash_out (move_astep);

000543  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
000544  aa  6 01330 2521 00	spri2	pr6|728
000545  aa  6 01326 6211 00	eax1 	pr6|726
000546  aa   004000 4310 07	fld  	2048,dl
000547  aa  6 00044 3701 20	epp4 	pr6|36,*
000550  la  4 00060 3521 20	epp2 	pr4|48,*		search_ast$hash_out
000551  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 285
	old_ptsi = fixed (move_astep -> aste.ptsi, 9);

000552  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000553  aa  7 00013 2351 00	lda  	pr7|11		aste.ptsi
000554  aa   000034 7350 00	als  	28
000555  aa   000106 7730 00	lrl  	70
000556  aa  6 00527 7561 00	stq  	pr6|343		old_ptsi
						STATEMENT 1 ON LINE 286
	old_pts = sst.pts (old_ptsi);

000557  aa  6 01224 3715 20	epp5 	pr6|660,*		sstp
000560  aa  5 00040 2361 06	ldq  	pr5|32,ql		sst.pts
000561  aa  6 00526 7561 00	stq  	pr6|342		old_pts
						STATEMENT 1 ON LINE 287
	old_vtocx = move_astep -> aste.vtocx;

000562  aa  7 00004 2351 00	lda  	pr7|4		aste.vtocx
000563  aa   000022 7350 00	als  	18
000564  aa   000066 7330 00	lrs  	54
000565  aa  6 00532 7561 00	stq  	pr6|346		old_vtocx
						STATEMENT 1 ON LINE 288
	old_pvtx = move_astep -> aste.pvtx;

000566  aa  7 00004 2351 00	lda  	pr7|4		aste.pvtx
000567  aa   000011 7350 00	als  	9
000570  aa   000077 7330 00	lrs  	63
000571  aa  6 00531 7561 00	stq  	pr6|345		old_pvtx
						STATEMENT 1 ON LINE 289
	old_pvid = pvt_array (old_pvtx).pvid;

000572  aa   000034 4020 07	mpy  	28,dl
000573  aa  6 01216 3535 20	epp3 	pr6|654,*		pvt_arrayp
000574  aa  3 77744 2351 06	lda  	pr3|-28,ql	pvt_array.pvid
000575  aa  6 00530 7551 00	sta  	pr6|344		old_pvid
						STATEMENT 1 ON LINE 291
	call get_pvtx$hold_pvtx (old_pvid, old_pvtx, code);

000576  aa  6 00530 3521 00	epp2 	pr6|344		old_pvid
000577  aa  6 01336 2521 00	spri2	pr6|734
000600  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
000601  aa  6 01340 2521 00	spri2	pr6|736
000602  aa  6 00105 3521 00	epp2 	pr6|69		code
000603  aa  6 01342 2521 00	spri2	pr6|738
000604  aa  6 01334 6211 00	eax1 	pr6|732
000605  aa   014000 4310 07	fld  	6144,dl
000606  aa  6 00044 3701 20	epp4 	pr6|36,*
000607  la  4 00020 3521 20	epp2 	pr4|16,*		get_pvtx$hold_pvtx
000610  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 292
	if code ^= 0
	then call syserr (CRASH, "segment_mover: get_pvtx(^o) fails under ast lock", old_pvtx);

000611  aa  6 00105 2361 00	ldq  	pr6|69		code
000612  aa   000024 6000 04	tze  	20,ic		000636
000613  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000614  aa   777245 00 0060	desc9a	-347,48		000060 = 163145147155
000615  aa  6 01334 00 0060	desc9a	pr6|732,48
000616  aa   777202 3520 04	epp2 	-382,ic		000020 = 000000000001
000617  aa  6 01362 2521 00	spri2	pr6|754
000620  aa  6 01334 3521 00	epp2 	pr6|732
000621  aa  6 01364 2521 00	spri2	pr6|756
000622  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
000623  aa  6 01366 2521 00	spri2	pr6|758
000624  aa   777173 3520 04	epp2 	-389,ic		000017 = 404000000021
000625  aa  6 01370 2521 00	spri2	pr6|760
000626  aa  6 01374 2521 00	spri2	pr6|764
000627  aa   777162 3520 04	epp2 	-398,ic		000011 = 524000000060
000630  aa  6 01372 2521 00	spri2	pr6|762
000631  aa  6 01360 6211 00	eax1 	pr6|752
000632  aa   014000 4310 07	fld  	6144,dl
000633  aa  6 00044 3701 20	epp4 	pr6|36,*
000634  la  4 00052 3521 20	epp2 	pr4|42,*		syserr
000635  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 294
	held_pvtx = "0"b;

000636  aa  6 00514 4501 00	stz  	pr6|332		held_pvtx
						STATEMENT 1 ON LINE 296
	mod_status = move_astep -> aste.fms;

000637  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000640  aa  7 00012 2351 00	lda  	pr7|10		aste.fms
000641  aa   000012 7350 00	als  	10
000642  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000643  aa  6 00516 7551 00	sta  	pr6|334		mod_status
						STATEMENT 1 ON LINE 298
	n_nulled_pages = 0;

000644  aa  6 00517 4501 00	stz  	pr6|335		n_nulled_pages
						STATEMENT 1 ON LINE 299
	if ^move_astep -> aste.ddnp & ^(move_astep -> aste.fm_damaged & (sst.checksum_filemap ^= 0))
	then do;

000645  aa  7 00012 2351 00	lda  	pr7|10		aste.ddnp
000646  aa   000004 3150 03	cana 	4,du
000647  aa   000161 6010 04	tnz  	113,ic		001030
000650  aa  7 00005 2351 00	lda  	pr7|5		aste.fm_damaged
000651  aa   000040 3150 03	cana 	32,du
000652  aa   000004 6000 04	tze  	4,ic		000656
000653  aa  6 01224 3715 20	epp5 	pr6|660,*		sstp
000654  aa  5 00075 2361 00	ldq  	pr5|61		sst.checksum_filemap
000655  aa   000153 6010 04	tnz  	107,ic		001030
						STATEMENT 1 ON LINE 301
		call pc$list_deposited_add (move_astep, 0, old_pts - 1, n_nulled_pages, dlp, addr (pageno_list));

000656  aa  6 01357 4501 00	stz  	pr6|751
000657  aa  6 00526 2361 00	ldq  	pr6|342		old_pts
000660  aa   000001 1760 07	sbq  	1,dl
000661  aa  6 01412 7561 00	stq  	pr6|778
000662  aa  6 00534 3715 00	epp5 	pr6|348		pageno_list
000663  aa  6 01410 6515 00	spri5	pr6|776
000664  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
000665  aa  6 01336 2521 00	spri2	pr6|734
000666  aa  6 01357 3521 00	epp2 	pr6|751
000667  aa  6 01340 2521 00	spri2	pr6|736
000670  aa  6 01412 3521 00	epp2 	pr6|778
000671  aa  6 01342 2521 00	spri2	pr6|738
000672  aa  6 00517 3521 00	epp2 	pr6|335		n_nulled_pages
000673  aa  6 01344 2521 00	spri2	pr6|740
000674  aa  6 00510 3521 00	epp2 	pr6|328		dlp
000675  aa  6 01346 2521 00	spri2	pr6|742
000676  aa  6 01410 3521 00	epp2 	pr6|776
000677  aa  6 01350 2521 00	spri2	pr6|744
000700  aa  6 01334 6211 00	eax1 	pr6|732
000701  aa   030000 4310 07	fld  	12288,dl
000702  aa  6 00044 3701 20	epp4 	pr6|36,*
000703  la  4 00034 3521 20	epp2 	pr4|28,*		pc$list_deposited_add
000704  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 303
		if n_nulled_pages > 0 & ^demand_segmove
		then do;

000705  aa  6 00517 2361 00	ldq  	pr6|335		n_nulled_pages
000706  aa   000122 6044 04	tmoz 	82,ic		001030
000707  aa  6 01356 2351 00	lda  	pr6|750
000710  aa   000120 6000 04	tze  	80,ic		001030
						STATEMENT 1 ON LINE 305
			call vtoc_man$await_vtoce (old_pvid, old_pvtx, old_vtocx, code);

000711  aa  6 00530 3521 00	epp2 	pr6|344		old_pvid
000712  aa  6 01336 2521 00	spri2	pr6|734
000713  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
000714  aa  6 01340 2521 00	spri2	pr6|736
000715  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
000716  aa  6 01342 2521 00	spri2	pr6|738
000717  aa  6 00105 3521 00	epp2 	pr6|69		code
000720  aa  6 01344 2521 00	spri2	pr6|740
000721  aa  6 01334 6211 00	eax1 	pr6|732
000722  aa   020000 4310 07	fld  	8192,dl
000723  aa  6 00044 3701 20	epp4 	pr6|36,*
000724  la  4 00072 3521 20	epp2 	pr4|58,*		vtoc_man$await_vtoce
000725  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 307
			if code ^= 0
			then go to retake_fault;

000726  aa  6 00105 2361 00	ldq  	pr6|69		code
000727  aa   000034 6010 04	tnz  	28,ic		000763
						STATEMENT 1 ON LINE 309
			call pc$deposit_list (fixed (move_astep -> aste.pvtx, 17), n_nulled_pages, dlp, old_vtocx,
			     addr (pageno_list));

000730  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000731  aa  7 00004 2351 00	lda  	pr7|4		aste.pvtx
000732  aa   000011 7350 00	als  	9
000733  aa   000077 7330 00	lrs  	63
000734  aa  6 01412 7561 00	stq  	pr6|778
000735  aa  6 00534 3715 00	epp5 	pr6|348		pageno_list
000736  aa  6 01410 6515 00	spri5	pr6|776
000737  aa  6 01412 3521 00	epp2 	pr6|778
000740  aa  6 01336 2521 00	spri2	pr6|734
000741  aa  6 00517 3521 00	epp2 	pr6|335		n_nulled_pages
000742  aa  6 01340 2521 00	spri2	pr6|736
000743  aa  6 00510 3521 00	epp2 	pr6|328		dlp
000744  aa  6 01342 2521 00	spri2	pr6|738
000745  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
000746  aa  6 01344 2521 00	spri2	pr6|740
000747  aa  6 01410 3521 00	epp2 	pr6|776
000750  aa  6 01346 2521 00	spri2	pr6|742
000751  aa  6 01334 6211 00	eax1 	pr6|732
000752  aa   024000 4310 07	fld  	10240,dl
000753  aa  6 00044 3701 20	epp4 	pr6|36,*
000754  la  4 00032 3521 20	epp2 	pr4|26,*		pc$deposit_list
000755  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 311
			if n_nulled_pages > MAGIC_NPAGES & ^demand_segmove
			then do;

000756  aa  6 00517 2361 00	ldq  	pr6|335		n_nulled_pages
000757  aa   000012 1160 07	cmpq 	10,dl
000760  aa   000050 6044 04	tmoz 	40,ic		001030
000761  aa  6 01356 2351 00	lda  	pr6|750
000762  aa   000046 6000 04	tze  	38,ic		001030
						STATEMENT 1 ON LINE 313
retake_fault:
				call thread$cin (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));

000763  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
000764  aa  7 00013 2351 00	lda  	pr7|11		aste.ptsi
000765  aa   000034 7350 00	als  	28
000766  aa   000106 7730 00	lrl  	70
000767  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
000770  aa  6 01330 2521 00	spri2	pr6|728
000771  aa  6 01224 3715 20	epp5 	pr6|660,*		sstp
000772  aa  5 00044 3521 06	epp2 	pr5|36,ql		sst.ausedp
000773  aa  6 01332 2521 00	spri2	pr6|730
000774  aa  6 01326 6211 00	eax1 	pr6|726
000775  aa   010000 4310 07	fld  	4096,dl
000776  aa  6 00044 3701 20	epp4 	pr6|36,*
000777  la  4 00062 3521 20	epp2 	pr4|50,*		thread$cin
001000  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 315
				call search_ast$hash_in (move_astep);

001001  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
001002  aa  6 01330 2521 00	spri2	pr6|728
001003  aa  6 01326 6211 00	eax1 	pr6|726
001004  aa   004000 4310 07	fld  	2048,dl
001005  aa  6 00044 3701 20	epp4 	pr6|36,*
001006  la  4 00056 3521 20	epp2 	pr4|46,*		search_ast$hash_in
001007  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 316
				call cleanup_dseg_and_meter;

001010  aa   001130 6700 04	tsp4 	600,ic		002140
						STATEMENT 1 ON LINE 317
				if move_astep -> aste.uid = aste_uid
				then move_astep -> aste.pack_ovfl = "0"b;

001011  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
001012  aa  7 00003 2351 00	lda  	pr7|3		aste.uid
001013  aa  6 00100 1151 00	cmpa 	pr6|64		aste_uid
001014  aa   000003 6010 04	tnz  	3,ic		001017
001015  aa   001563 2350 04	lda  	883,ic		002600 = 777777677777
001016  aa  7 00013 3551 00	ansa 	pr7|11		aste.pack_ovfl
						STATEMENT 1 ON LINE 319
				call release_pvtxs;

001017  aa   001367 6700 04	tsp4 	759,ic		002406
						STATEMENT 1 ON LINE 320
				call lock$unlock_ast;

001020  aa  6 00056 6211 00	eax1 	pr6|46
001021  aa   000000 4310 07	fld  	0,dl
001022  aa  6 00044 3701 20	epp4 	pr6|36,*
001023  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
001024  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 321
				a_code = code;

001025  aa  6 00105 2361 00	ldq  	pr6|69		code
001026  aa  6 01234 7561 20	stq  	pr6|668,*		a_code
						STATEMENT 1 ON LINE 322
				return;

001027  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 323
			     end;

						STATEMENT 1 ON LINE 324
		     end;

						STATEMENT 1 ON LINE 325
	     end;

						STATEMENT 1 ON LINE 327
	recs_needed = n_nulled_pages + fixed (move_astep -> aste.records, 9);

001030  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
001031  aa  7 00012 2351 00	lda  	pr7|10		aste.records
001032  aa   000022 7350 00	als  	18
001033  aa   000077 7730 00	lrl  	63
001034  aa  6 00517 0761 00	adq  	pr6|335		n_nulled_pages
001035  aa  6 01140 7561 00	stq  	pr6|608		recs_needed
						STATEMENT 1 ON LINE 329
	refpage = divide (ref_addr, sys_info$page_size, 18, 0);

001036  aa  6 01141 2361 00	ldq  	pr6|609		ref_addr
001037  aa  6 00044 3701 20	epp4 	pr6|36,*
001040  la  4 00076 5061 20	div  	pr4|62,*		sys_info$page_size
001041  aa  6 01142 7561 00	stq  	pr6|610		refpage
						STATEMENT 1 ON LINE 330
	size_needed = old_pts;

001042  aa  6 00526 2361 00	ldq  	pr6|342		old_pts
001043  aa  6 01145 7561 00	stq  	pr6|613		size_needed
						STATEMENT 1 ON LINE 331
	aste_uid = move_astep -> aste.uid;

001044  aa  7 00003 2351 00	lda  	pr7|3		aste.uid
001045  aa  6 00100 7551 00	sta  	pr6|64		aste_uid
						STATEMENT 1 ON LINE 332
	aste_tqsw (*) = move_astep -> aste.tqsw (*);

001046  aa   000001 2360 07	ldq  	1,dl
001047  aa  6 01242 7561 00	stq  	pr6|674
001050  aa  6 01242 7271 00	lxl7 	pr6|674
001051  aa  6 00101 4501 17	stz  	pr6|65,7		aste_tqsw
001052  aa  6 00101 3735 17	epp7 	pr6|65,7		aste_tqsw
001053  aa  6 00512 3715 20	epp5 	pr6|330,*		move_astep
001054  aa  003 100 060 517	csl  	(pr,x7),(pr),fill(0),bool(move)
001055  aa  5 00005 45 0001	descb	pr5|5(23),1	aste.tqsw
001056  aa  7 00000 00 0001	descb	pr7|0,1		aste_tqsw
001057  aa  6 01242 2361 00	ldq  	pr6|674
001060  aa  6 01242 0541 00	aos  	pr6|674
001061  aa   000002 1160 07	cmpq 	2,dl
001062  aa   777766 6040 04	tmi  	-10,ic		001050
						STATEMENT 1 ON LINE 333
	old_nqsw = move_astep -> aste.nqsw;

001063  aa  5 00005 2351 00	lda  	pr5|5		aste.nqsw
001064  aa   000024 7350 00	als  	20
001065  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001066  aa  6 00525 7551 00	sta  	pr6|341		old_nqsw
						STATEMENT 1 ON LINE 336
	move_astep -> aste.nqsw = "1"b;

001067  aa   100000 2350 07	lda  	32768,dl
001070  aa  5 00005 2551 00	orsa 	pr5|5		aste.nqsw
						STATEMENT 1 ON LINE 338
	new_ptsi, new_pts = -1;

001071  aa   000001 3360 07	lcq  	1,dl
001072  aa  6 00521 7561 00	stq  	pr6|337		new_ptsi
001073  aa  6 00520 7561 00	stq  	pr6|336		new_pts
						STATEMENT 1 ON LINE 341
	call lock$unlock_ast;

001074  aa  6 00056 6211 00	eax1 	pr6|46
001075  aa   000000 4310 07	fld  	0,dl
001076  aa  6 00044 3701 20	epp4 	pr6|36,*
001077  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
001100  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 343
	if aste_tqsw (0) | aste_tqsw (1)
	then do;

001101  aa  6 00102 2351 00	lda  	pr6|66		aste_tqsw
001102  aa   000003 6010 04	tnz  	3,ic		001105
001103  aa  6 00103 2351 00	lda  	pr6|67		aste_tqsw
001104  aa   000123 6000 04	tze  	83,ic		001227
						STATEMENT 1 ON LINE 345
		unspec (atq_info) = "0"b;

001105  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001106  aa   000000 00 0000	desc9a	0,0
001107  aa  6 01176 00 0050	desc9a	pr6|638,40
						STATEMENT 1 ON LINE 346
		tq_infop = addr (atq_info);

001110  aa  6 01176 3735 00	epp7 	pr6|638		atq_info
001111  aa  6 01226 6535 00	spri7	pr6|662		tq_infop
						STATEMENT 1 ON LINE 347
		qcp = addr (aq_cell);

001112  aa  6 01166 3715 00	epp5 	pr6|630		aq_cell
001113  aa  6 01230 6515 00	spri5	pr6|664		qcp
						STATEMENT 1 ON LINE 348
		do qtype = 0 to 1;

001114  aa  6 01137 4501 00	stz  	pr6|607		qtype
001115  aa   000000 0110 03	nop  	0,du
001116  aa  6 01137 2361 00	ldq  	pr6|607		qtype
001117  aa   000001 1160 07	cmpq 	1,dl
001120  aa   000111 6054 04	tpnz 	73,ic		001231
						STATEMENT 1 ON LINE 349
		     if aste_tqsw (qtype)
		     then do;

001121  aa  6 00102 2351 06	lda  	pr6|66,ql		aste_tqsw
001122  aa   000102 6000 04	tze  	66,ic		001224
						STATEMENT 1 ON LINE 351
			     call vtoc_attributes$get_quota (aste_uid, old_pvid, old_vtocx, qcp, qtype, code);

001123  aa  6 00100 3521 00	epp2 	pr6|64		aste_uid
001124  aa  6 01336 2521 00	spri2	pr6|734
001125  aa  6 00530 3521 00	epp2 	pr6|344		old_pvid
001126  aa  6 01340 2521 00	spri2	pr6|736
001127  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
001130  aa  6 01342 2521 00	spri2	pr6|738
001131  aa  6 01230 3521 00	epp2 	pr6|664		qcp
001132  aa  6 01344 2521 00	spri2	pr6|740
001133  aa  6 01137 3521 00	epp2 	pr6|607		qtype
001134  aa  6 01346 2521 00	spri2	pr6|742
001135  aa  6 00105 3521 00	epp2 	pr6|69		code
001136  aa  6 01350 2521 00	spri2	pr6|744
001137  aa  6 01334 6211 00	eax1 	pr6|732
001140  aa   030000 4310 07	fld  	12288,dl
001141  aa  6 00044 3701 20	epp4 	pr6|36,*
001142  la  4 00070 3521 20	epp2 	pr4|56,*		vtoc_attributes$get_quota
001143  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 352
			     if code ^= 0
			     then /* we lose, log the error */
				call syserr$error_code (LOG, code,
				     "segment_mover: Moving ^[segment^;directory^] quota account from pvtx ^o, vtocx ^o^/",
				     qtype + 1, old_pvtx, old_vtocx);

001144  aa  6 00105 2361 00	ldq  	pr6|69		code
001145  aa   000043 6000 04	tze  	35,ic		001210
001146  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001147  aa   777004 00 0124	desc9a	-508,84		000152 = 163145147155
001150  aa  6 01360 00 0124	desc9a	pr6|752,84
001151  aa  6 01137 2361 00	ldq  	pr6|607		qtype
001152  aa   000001 0760 07	adq  	1,dl
001153  aa  6 01356 7561 00	stq  	pr6|750
001154  aa   776640 3520 04	epp2 	-608,ic		000014 = 000000000004
001155  aa  6 01416 2521 00	spri2	pr6|782
001156  aa  6 00105 3521 00	epp2 	pr6|69		code
001157  aa  6 01420 2521 00	spri2	pr6|784
001160  aa  6 01360 3521 00	epp2 	pr6|752
001161  aa  6 01422 2521 00	spri2	pr6|786
001162  aa  6 01356 3521 00	epp2 	pr6|750
001163  aa  6 01424 2521 00	spri2	pr6|788
001164  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
001165  aa  6 01426 2521 00	spri2	pr6|790
001166  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
001167  aa  6 01430 2521 00	spri2	pr6|792
001170  aa   776627 3520 04	epp2 	-617,ic		000017 = 404000000021
001171  aa  6 01432 2521 00	spri2	pr6|794
001172  aa  6 01442 2521 00	spri2	pr6|802
001173  aa  6 01444 2521 00	spri2	pr6|804
001174  aa   776626 3520 04	epp2 	-618,ic		000022 = 404000000043
001175  aa  6 01434 2521 00	spri2	pr6|796
001176  aa   776612 3520 04	epp2 	-630,ic		000010 = 524000000123
001177  aa  6 01436 2521 00	spri2	pr6|798
001200  aa   776621 3520 04	epp2 	-623,ic		000021 = 404000000022
001201  aa  6 01440 2521 00	spri2	pr6|800
001202  aa  6 01414 6211 00	eax1 	pr6|780
001203  aa   030000 4310 07	fld  	12288,dl
001204  aa  6 00044 3701 20	epp4 	pr6|36,*
001205  la  4 00054 3521 20	epp2 	pr4|44,*		syserr$error_code
001206  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
001207  aa   000015 7100 04	tra  	13,ic		001224
						STATEMENT 1 ON LINE 357
			     else do;

						STATEMENT 1 ON LINE 358
				     tq_info.trp (qtype) = quota_cell.trp;

001210  aa  6 01137 2361 00	ldq  	pr6|607		qtype
001211  aa   000001 7360 00	qls  	1
001212  aa  6 01230 3735 20	epp7 	pr6|664,*		qcp
001213  aa   000000 6270 06	eax7 	0,ql
001214  aa  7 00004 2371 00	ldaq 	pr7|4		quota_cell.trp
001215  aa  6 01226 7571 77	staq 	pr6|662,*7	tq_info.trp
						STATEMENT 1 ON LINE 360
				     tq_info.tup (qtype) = quota_cell.tup;

001216  aa  7 00003 2351 00	lda  	pr7|3		quota_cell.tup
001217  aa  6 01137 7261 00	lxl6 	pr6|607		qtype
001220  aa  6 01226 3715 20	epp5 	pr6|662,*		tq_infop
001221  aa  5 00004 7551 16	sta  	pr5|4,6		tq_info.tup
						STATEMENT 1 ON LINE 361
				     tq_info.received (qtype) = quota_cell.received;

001222  aa  7 00002 2361 00	ldq  	pr7|2		quota_cell.received
001223  aa  5 00006 7561 16	stq  	pr5|6,6		tq_info.received
						STATEMENT 1 ON LINE 362
				end;

						STATEMENT 1 ON LINE 363
			end;

						STATEMENT 1 ON LINE 364
		end;

001224  aa  6 01137 0541 00	aos  	pr6|607		qtype
001225  aa   777671 7100 04	tra  	-71,ic		001116
						STATEMENT 1 ON LINE 365
	     end;

001226  aa   000003 7100 04	tra  	3,ic		001231
						STATEMENT 1 ON LINE 366
	else tq_infop = null;

001227  aa   776577 2370 04	ldaq 	-641,ic		000026 = 077777000043 000001000000
001230  aa  6 01226 7571 00	staq 	pr6|662		tq_infop
						STATEMENT 1 ON LINE 368
	temp_ename = addr (ep -> entry.primary_name) -> names.name;

001231  aa  6 01212 3735 20	epp7 	pr6|650,*		ep
001232  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001233  aa  7 00014 00 0040	desc9a	pr7|12,32		names.name
001234  aa  6 01147 00 0040	desc9a	pr6|615,32	temp_ename
						STATEMENT 1 ON LINE 369
	corout_pvtx = 0;

001235  aa  6 00106 4501 00	stz  	pr6|70		corout_pvtx
						STATEMENT 1 ON LINE 370
	optimizing = demand_segmove;

001236  aa  6 00107 2351 00	lda  	pr6|71		demand_segmove
001237  aa  6 00533 7551 00	sta  	pr6|347		optimizing
						STATEMENT 1 ON LINE 371
	if demand_segmove
	then skip_pvtx = 0;

001240  aa   000003 6000 04	tze  	3,ic		001243
001241  aa  6 01146 4501 00	stz  	pr6|614		skip_pvtx
001242  aa   000003 7100 04	tra  	3,ic		001245
						STATEMENT 1 ON LINE 373
	else skip_pvtx = old_pvtx;

001243  aa  6 00531 2361 00	ldq  	pr6|345		old_pvtx
001244  aa  6 01146 7561 00	stq  	pr6|614		skip_pvtx
						STATEMENT 1 ON LINE 375
next_pv:						/* RESTART POINT */
/**** ASSERT:  aste is thread$out'ed
      aste is search_ast$hash_out'ed
*/
	same_pvtx, held_pvtx = "0"b;

001245  aa  6 01143 4501 00	stz  	pr6|611		same_pvtx
001246  aa  6 00514 4501 00	stz  	pr6|332		held_pvtx
						STATEMENT 1 ON LINE 380
	call create_vtoce$createv_for_segmove (ep, pvid, new_vtocx, code, corout_pvtx, skip_pvtx, recs_needed, tq_infop,
	     optimizing);

001247  aa  6 01212 3521 00	epp2 	pr6|650		ep
001250  aa  6 01362 2521 00	spri2	pr6|754
001251  aa  6 01134 3521 00	epp2 	pr6|604		pvid
001252  aa  6 01364 2521 00	spri2	pr6|756
001253  aa  6 00524 3521 00	epp2 	pr6|340		new_vtocx
001254  aa  6 01366 2521 00	spri2	pr6|758
001255  aa  6 00105 3521 00	epp2 	pr6|69		code
001256  aa  6 01370 2521 00	spri2	pr6|760
001257  aa  6 00106 3521 00	epp2 	pr6|70		corout_pvtx
001260  aa  6 01372 2521 00	spri2	pr6|762
001261  aa  6 01146 3521 00	epp2 	pr6|614		skip_pvtx
001262  aa  6 01374 2521 00	spri2	pr6|764
001263  aa  6 01140 3521 00	epp2 	pr6|608		recs_needed
001264  aa  6 01376 2521 00	spri2	pr6|766
001265  aa  6 01226 3521 00	epp2 	pr6|662		tq_infop
001266  aa  6 01400 2521 00	spri2	pr6|768
001267  aa  6 00533 3521 00	epp2 	pr6|347		optimizing
001270  aa  6 01402 2521 00	spri2	pr6|770
001271  aa  6 01360 6211 00	eax1 	pr6|752
001272  aa   044000 4310 07	fld  	18432,dl
001273  aa  6 00044 3701 20	epp4 	pr6|36,*
001274  la  4 00010 3521 20	epp2 	pr4|8,*		create_vtoce$createv_for_segmove
001275  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 388
	if code ^= 0
	then go to move_fails;

001276  aa  6 00105 2361 00	ldq  	pr6|69		code
001277  aa   000121 6010 04	tnz  	81,ic		001420
						STATEMENT 1 ON LINE 390
	new_pvtx = corout_pvtx;

001300  aa  6 00106 2361 00	ldq  	pr6|70		corout_pvtx
001301  aa  6 00523 7561 00	stq  	pr6|339		new_pvtx
						STATEMENT 1 ON LINE 391
	if optimizing
	then do;

001302  aa  6 00533 2351 00	lda  	pr6|347		optimizing
001303  aa   400000 3150 03	cana 	131072,du
001304  aa   000003 6000 04	tze  	3,ic		001307
						STATEMENT 1 ON LINE 393
		optimizing = "0"b;

001305  aa  6 00533 4501 00	stz  	pr6|347		optimizing
						STATEMENT 1 ON LINE 394
		corout_pvtx = 0;

001306  aa  6 00106 4501 00	stz  	pr6|70		corout_pvtx
						STATEMENT 1 ON LINE 395
	     end;

						STATEMENT 1 ON LINE 396
	new_pvid = pvid;

001307  aa  6 01134 2351 00	lda  	pr6|604		pvid
001310  aa  6 00522 7551 00	sta  	pr6|338		new_pvid
						STATEMENT 1 ON LINE 397
	if new_pvtx = old_pvtx
	then same_pvtx = "1"b;

001311  aa  6 00531 1161 00	cmpq 	pr6|345		old_pvtx
001312  aa   000004 6010 04	tnz  	4,ic		001316
001313  aa   400000 2350 03	lda  	131072,du
001314  aa  6 01143 7551 00	sta  	pr6|611		same_pvtx
001315  aa   000020 7100 04	tra  	16,ic		001335
						STATEMENT 1 ON LINE 399
	else do;

						STATEMENT 1 ON LINE 400
		call get_pvtx$hold_pvtx (new_pvid, new_pvtx, code);

001316  aa  6 00522 3521 00	epp2 	pr6|338		new_pvid
001317  aa  6 01336 2521 00	spri2	pr6|734
001320  aa  6 00523 3521 00	epp2 	pr6|339		new_pvtx
001321  aa  6 01340 2521 00	spri2	pr6|736
001322  aa  6 00105 3521 00	epp2 	pr6|69		code
001323  aa  6 01342 2521 00	spri2	pr6|738
001324  aa  6 01334 6211 00	eax1 	pr6|732
001325  aa   014000 4310 07	fld  	6144,dl
001326  aa  6 00044 3701 20	epp4 	pr6|36,*
001327  la  4 00020 3521 20	epp2 	pr4|16,*		get_pvtx$hold_pvtx
001330  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 401
		if code = 0
		then held_pvtx = "1"b;

001331  aa  6 00105 2361 00	ldq  	pr6|69		code
001332  aa   777713 6010 04	tnz  	-53,ic		001245
001333  aa   400000 2350 03	lda  	131072,du
001334  aa  6 00514 7551 00	sta  	pr6|332		held_pvtx
						STATEMENT 1 ON LINE 404
	     end;

						STATEMENT 1 ON LINE 407
	call MOVE_THE_SEGMENT;

001335  aa   000212 6700 04	tsp4 	138,ic		001547
						STATEMENT 1 ON LINE 409
	sstp -> sst.good_sgms = sstp -> sst.good_sgms + 1;

001336  aa  6 01224 3735 20	epp7 	pr6|660,*		sstp
001337  aa  7 00515 0541 00	aos  	pr7|333		sst.good_sgms
						STATEMENT 1 ON LINE 410
	if ^demand_segmove
	then /* Only for seg_fault calls */
	     call syserr (LOG, "segment_mover: Moved ^w(^a) from ^a to ^a for ^a", move_astep -> aste.uid, temp_ename,
		diskname (old_pvtx), diskname (new_pvtx), pds$process_group_id);

001340  aa  6 00107 2351 00	lda  	pr6|71		demand_segmove
001341  aa   000051 6010 04	tnz  	41,ic		001412
001342  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001343  aa   776502 00 0060	desc9a	-702,48		000044 = 163145147155
001344  aa  6 01334 00 0060	desc9a	pr6|732,48
001345  aa   001225 3520 04	epp2 	661,ic		002572 = 000004000000
001346  aa   000641 6700 04	tsp4 	417,ic		002207
001347  aa   001215 3520 04	epp2 	653,ic		002564 = 000004000000
001350  aa   000637 6700 04	tsp4 	415,ic		002207
001351  aa   776443 3520 04	epp2 	-733,ic		000014 = 000000000004
001352  aa  6 01450 2521 00	spri2	pr6|808
001353  aa  6 01334 3521 00	epp2 	pr6|732
001354  aa  6 01452 2521 00	spri2	pr6|810
001355  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
001356  aa  7 00003 3521 00	epp2 	pr7|3		aste.uid
001357  aa  6 01454 2521 00	spri2	pr6|812
001360  aa  6 01147 3521 00	epp2 	pr6|615		temp_ename
001361  aa  6 01456 2521 00	spri2	pr6|814
001362  aa  6 01326 3521 00	epp2 	pr6|726
001363  aa  6 01460 2521 00	spri2	pr6|816
001364  aa  6 01360 3521 00	epp2 	pr6|752
001365  aa  6 01462 2521 00	spri2	pr6|818
001366  aa  6 00044 3701 20	epp4 	pr6|36,*
001367  la  4 00040 3521 20	epp2 	pr4|32,*		pds$process_group_id
001370  aa  6 01464 2521 00	spri2	pr6|820
001371  aa   776426 3520 04	epp2 	-746,ic		000017 = 404000000021
001372  aa  6 01466 2521 00	spri2	pr6|822
001373  aa   776416 3520 04	epp2 	-754,ic		000011 = 524000000060
001374  aa  6 01470 2521 00	spri2	pr6|824
001375  aa   776412 3520 04	epp2 	-758,ic		000007 = 516000000044
001376  aa  6 01472 2521 00	spri2	pr6|826
001377  aa   776407 3520 04	epp2 	-761,ic		000006 = 526000000040
001400  aa  6 01474 2521 00	spri2	pr6|828
001401  aa   776411 3520 04	epp2 	-759,ic		000012 = 524000000011
001402  aa  6 01476 2521 00	spri2	pr6|830
001403  aa  6 01500 2521 00	spri2	pr6|832
001404  aa   776401 3520 04	epp2 	-767,ic		000005 = 524000000040
001405  aa  6 01502 2521 00	spri2	pr6|834
001406  aa  6 01446 6211 00	eax1 	pr6|806
001407  aa   034000 4310 07	fld  	14336,dl
001410  la  4 00052 3521 20	epp2 	pr4|42,*		syserr
001411  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 414
	move_astep = null ();

001412  aa   776414 2370 04	ldaq 	-756,ic		000026 = 077777000043 000001000000
001413  aa  6 00512 7571 00	staq 	pr6|330		move_astep
						STATEMENT 1 ON LINE 415
	call release_pvtxs;

001414  aa   000772 6700 04	tsp4 	506,ic		002406
						STATEMENT 1 ON LINE 416
	call cleanup_dseg_and_meter;

001415  aa   000523 6700 04	tsp4 	339,ic		002140
						STATEMENT 1 ON LINE 417
	a_code = 0;

001416  aa  6 01234 4501 20	stz  	pr6|668,*		a_code
						STATEMENT 1 ON LINE 418
	return;

001417  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 420
move_fails:					/* Code is set appropriately */
	sstp -> sst.bad_sgms = sstp -> sst.bad_sgms + 1;

001420  aa  6 01224 3735 20	epp7 	pr6|660,*		sstp
001421  aa  7 00513 0541 00	aos  	pr7|331		sst.bad_sgms
						STATEMENT 1 ON LINE 422
	if ^demand_segmove
	then call syserr$error_code (LOG, code, "segment_mover: Failed to seg move ^w(^a) from ^a for ^a",
		move_astep -> aste.uid, temp_ename, diskname (old_pvtx), pds$process_group_id);

001422  aa  6 00107 2351 00	lda  	pr6|71		demand_segmove
001423  aa   000050 6010 04	tnz  	40,ic		001473
001424  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001425  aa   776466 00 0070	desc9a	-714,56		000112 = 163145147155
001426  aa  6 01334 00 0070	desc9a	pr6|732,56
001427  aa   001143 3520 04	epp2 	611,ic		002572 = 000004000000
001430  aa   000557 6700 04	tsp4 	367,ic		002207
001431  aa   776363 3520 04	epp2 	-781,ic		000014 = 000000000004
001432  aa  6 01450 2521 00	spri2	pr6|808
001433  aa  6 00105 3521 00	epp2 	pr6|69		code
001434  aa  6 01452 2521 00	spri2	pr6|810
001435  aa  6 01334 3521 00	epp2 	pr6|732
001436  aa  6 01454 2521 00	spri2	pr6|812
001437  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
001440  aa  7 00003 3521 00	epp2 	pr7|3		aste.uid
001441  aa  6 01456 2521 00	spri2	pr6|814
001442  aa  6 01147 3521 00	epp2 	pr6|615		temp_ename
001443  aa  6 01460 2521 00	spri2	pr6|816
001444  aa  6 01326 3521 00	epp2 	pr6|726
001445  aa  6 01462 2521 00	spri2	pr6|818
001446  aa  6 00044 3701 20	epp4 	pr6|36,*
001447  la  4 00040 3521 20	epp2 	pr4|32,*		pds$process_group_id
001450  aa  6 01464 2521 00	spri2	pr6|820
001451  aa   776346 3520 04	epp2 	-794,ic		000017 = 404000000021
001452  aa  6 01466 2521 00	spri2	pr6|822
001453  aa   776347 3520 04	epp2 	-793,ic		000022 = 404000000043
001454  aa  6 01470 2521 00	spri2	pr6|824
001455  aa   776327 3520 04	epp2 	-809,ic		000004 = 524000000067
001456  aa  6 01472 2521 00	spri2	pr6|826
001457  aa   776330 3520 04	epp2 	-808,ic		000007 = 516000000044
001460  aa  6 01474 2521 00	spri2	pr6|828
001461  aa   776325 3520 04	epp2 	-811,ic		000006 = 526000000040
001462  aa  6 01476 2521 00	spri2	pr6|830
001463  aa   776327 3520 04	epp2 	-809,ic		000012 = 524000000011
001464  aa  6 01500 2521 00	spri2	pr6|832
001465  aa   776320 3520 04	epp2 	-816,ic		000005 = 524000000040
001466  aa  6 01502 2521 00	spri2	pr6|834
001467  aa  6 01446 6211 00	eax1 	pr6|806
001470  aa   034000 4310 07	fld  	14336,dl
001471  la  4 00054 3521 20	epp2 	pr4|44,*		syserr$error_code
001472  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 425
	call lock$lock_ast;

001473  aa  6 00056 6211 00	eax1 	pr6|46
001474  aa   000000 4310 07	fld  	0,dl
001475  aa  6 00044 3701 20	epp4 	pr6|36,*
001476  la  4 00024 3521 20	epp2 	pr4|20,*		lock$lock_ast
001477  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 426
	call thread$cin (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));

001500  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
001501  aa  7 00013 2351 00	lda  	pr7|11		aste.ptsi
001502  aa   000034 7350 00	als  	28
001503  aa   000106 7730 00	lrl  	70
001504  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
001505  aa  6 01330 2521 00	spri2	pr6|728
001506  aa  6 01224 3715 20	epp5 	pr6|660,*		sstp
001507  aa  5 00044 3521 06	epp2 	pr5|36,ql		sst.ausedp
001510  aa  6 01332 2521 00	spri2	pr6|730
001511  aa  6 01326 6211 00	eax1 	pr6|726
001512  aa   010000 4310 07	fld  	4096,dl
001513  aa  6 00044 3701 20	epp4 	pr6|36,*
001514  la  4 00062 3521 20	epp2 	pr4|50,*		thread$cin
001515  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 428
	move_astep -> aste.pack_ovfl = "0"b;

001516  aa   001062 2350 04	lda  	562,ic		002600 = 777777677777
001517  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
001520  aa  7 00013 3551 00	ansa 	pr7|11		aste.pack_ovfl
						STATEMENT 1 ON LINE 429
	move_astep -> aste.nqsw = old_nqsw;

001521  aa  6 00525 2351 00	lda  	pr6|341		old_nqsw
001522  aa   000024 7710 00	arl  	20
001523  aa  7 00005 6751 00	era  	pr7|5		aste.nqsw
001524  aa   100000 3750 07	ana  	32768,dl
001525  aa  7 00005 6551 00	ersa 	pr7|5		aste.nqsw
						STATEMENT 1 ON LINE 430
	call search_ast$hash_in (move_astep);

001526  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
001527  aa  6 01330 2521 00	spri2	pr6|728
001530  aa  6 01326 6211 00	eax1 	pr6|726
001531  aa   004000 4310 07	fld  	2048,dl
001532  aa  6 00044 3701 20	epp4 	pr6|36,*
001533  la  4 00056 3521 20	epp2 	pr4|46,*		search_ast$hash_in
001534  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 431
	call release_pvtxs;

001535  aa   000651 6700 04	tsp4 	425,ic		002406
						STATEMENT 1 ON LINE 432
	call lock$unlock_ast;

001536  aa  6 00056 6211 00	eax1 	pr6|46
001537  aa   000000 4310 07	fld  	0,dl
001540  aa  6 00044 3701 20	epp4 	pr6|36,*
001541  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
001542  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 433
	call cleanup_dseg_and_meter;

001543  aa   000375 6700 04	tsp4 	253,ic		002140
						STATEMENT 1 ON LINE 434
	a_code = code;

001544  aa  6 00105 2361 00	ldq  	pr6|69		code
001545  aa  6 01234 7561 20	stq  	pr6|668,*		a_code
						STATEMENT 1 ON LINE 772
     end segment_mover;

001546  aa  0 00631 7101 00	tra  	pr0|409		return_mac
BEGIN PROCEDURE MOVE_THE_SEGMENT
ENTRY TO MOVE_THE_SEGMENT                                   STATEMENT 1 ON LINE 438
MOVE_THE_SEGMENT:
     procedure;

001547  aa  6 01244 6501 00	spri4	pr6|676
						STATEMENT 1 ON LINE 443
	code = 0;

001550  aa  6 00105 4501 00	stz  	pr6|69		code
						STATEMENT 1 ON LINE 444
	call lock$lock_ast;

001551  aa  6 00056 6211 00	eax1 	pr6|46
001552  aa   000000 4310 07	fld  	0,dl
001553  aa  6 00044 3701 20	epp4 	pr6|36,*
001554  la  4 00024 3521 20	epp2 	pr4|20,*		lock$lock_ast
001555  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 446
	do px = 1, 2;

001556  aa   000052 3520 04	epp2 	42,ic		001630 = 000005352004
001557  aa  6 01260 2521 00	spri2	pr6|688
001560  aa   000001 2360 07	ldq  	1,dl
001561  aa  6 01256 7561 00	stq  	pr6|686		px
						STATEMENT 1 ON LINE 447
	     astep, astes (px) = get_aste (size_needed);

001562  aa  6 01145 3521 00	epp2 	pr6|613		size_needed
001563  aa  6 01510 2521 00	spri2	pr6|840
001564  aa  6 01504 3521 00	epp2 	pr6|836
001565  aa  6 01512 2521 00	spri2	pr6|842
001566  aa  6 01506 6211 00	eax1 	pr6|838
001567  aa   010000 4310 07	fld  	4096,dl
001570  aa  6 00044 3701 20	epp4 	pr6|36,*
001571  la  4 00014 3521 20	epp2 	pr4|12,*		get_aste
001572  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
001573  aa  6 01504 3735 20	epp7 	pr6|836,*
001574  aa  6 01210 6535 00	spri7	pr6|648		astep
001575  aa  6 01256 2361 00	ldq  	pr6|686		px
001576  aa   000001 7360 00	qls  	1
001577  aa  6 01250 6535 06	spri7	pr6|680,ql	astes
						STATEMENT 1 ON LINE 448
	     if astes (px) = null ()
	     then do;

001600  aa  6 01514 7561 00	stq  	pr6|844
001601  aa  6 01250 2371 06	ldaq 	pr6|680,ql	astes
001602  aa   776224 6770 04	eraq 	-876,ic		000026 = 077777000043 000001000000
001603  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001604  aa   000005 6010 04	tnz  	5,ic		001611
						STATEMENT 1 ON LINE 450
		     code = error_table_$log_vol_full;

001605  aa  6 00044 3701 20	epp4 	pr6|36,*
001606  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$log_vol_full
001607  aa  6 00105 7561 00	stq  	pr6|69		code
						STATEMENT 1 ON LINE 451
		     go to retake_fault;

001610  aa   777153 7100 04	tra  	-405,ic		000763
						STATEMENT 1 ON LINE 452
		end;

						STATEMENT 1 ON LINE 454
	     call thread$out (astep, sst.ausedp (fixed (astep -> aste.ptsi, 2)));

001611  aa  6 01210 3715 20	epp5 	pr6|648,*		astep
001612  aa  5 00013 2351 00	lda  	pr5|11		aste.ptsi
001613  aa   000034 7350 00	als  	28
001614  aa   000106 7730 00	lrl  	70
001615  aa  6 01210 3521 00	epp2 	pr6|648		astep
001616  aa  6 01510 2521 00	spri2	pr6|840
001617  aa  6 01224 3535 20	epp3 	pr6|660,*		sstp
001620  aa  3 00044 3521 06	epp2 	pr3|36,ql		sst.ausedp
001621  aa  6 01512 2521 00	spri2	pr6|842
001622  aa  6 01506 6211 00	eax1 	pr6|838
001623  aa   010000 4310 07	fld  	4096,dl
001624  aa  6 00044 3701 20	epp4 	pr6|36,*
001625  la  4 00064 3521 20	epp2 	pr4|52,*		thread$out
001626  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 456
	end;

001627  aa  6 01260 7101 20	tra  	pr6|688,*
001630  aa   000005 3520 04	epp2 	5,ic		001635 = 776171237004
001631  aa  6 01260 2521 00	spri2	pr6|688
001632  aa   000002 2360 07	ldq  	2,dl
001633  aa  6 01256 7561 00	stq  	pr6|686		px
001634  aa   777726 7100 04	tra  	-42,ic		001562
						STATEMENT 1 ON LINE 457
	astep = null ();

001635  aa   776171 2370 04	ldaq 	-903,ic		000026 = 077777000043 000001000000
001636  aa  6 01210 7571 00	staq 	pr6|648		astep
						STATEMENT 1 ON LINE 459
	call lock$unlock_ast;

001637  aa  6 00056 6211 00	eax1 	pr6|46
001640  aa   000000 4310 07	fld  	0,dl
001641  aa  6 00044 3701 20	epp4 	pr6|36,*
001642  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
001643  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 461
	astes (1) -> aste.nqsw, astes (1) -> aste.gtms, astes (1) -> aste.gtus = "1"b;

001644  aa   100000 2350 07	lda  	32768,dl
001645  aa  6 01252 3735 20	epp7 	pr6|682,*		astes
001646  aa  7 00005 2551 00	orsa 	pr7|5		aste.nqsw
001647  aa   040000 2350 03	lda  	16384,du
001650  aa  7 00005 2551 00	orsa 	pr7|5		aste.gtms
001651  aa   100000 2350 03	lda  	32768,du
001652  aa  7 00005 2551 00	orsa 	pr7|5		aste.gtus
						STATEMENT 1 ON LINE 462
	astes (2) -> aste.nqsw, astes (2) -> aste.gtms, astes (2) -> aste.gtus = "1"b;

001653  aa   100000 2350 07	lda  	32768,dl
001654  aa  6 01254 3715 20	epp5 	pr6|684,*		astes
001655  aa  5 00005 2551 00	orsa 	pr5|5		aste.nqsw
001656  aa   040000 2350 03	lda  	16384,du
001657  aa  5 00005 2551 00	orsa 	pr5|5		aste.gtms
001660  aa   100000 2350 03	lda  	32768,du
001661  aa  5 00005 2551 00	orsa 	pr5|5		aste.gtus
						STATEMENT 1 ON LINE 463
	astes (2) -> aste.pvtx = new_pvtx;

001662  aa  6 00523 2361 00	ldq  	pr6|339		new_pvtx
001663  aa   000066 7370 00	lls  	54
001664  aa  5 00004 5511 20	stba 	pr5|4,20		aste.pvtx
						STATEMENT 1 ON LINE 468
	n_nulled_pages = 0;

001665  aa  6 00517 4501 00	stz  	pr6|335		n_nulled_pages
						STATEMENT 1 ON LINE 469
	depolist = ""b;

001666  aa   000001 2360 07	ldq  	1,dl
001667  aa  6 01262 7561 00	stq  	pr6|690
001670  aa  6 01262 7271 00	lxl7 	pr6|690
001671  aa  6 00107 4501 17	stz  	pr6|71,7		depolist
001672  aa  6 01262 2361 00	ldq  	pr6|690
001673  aa  6 01262 0541 00	aos  	pr6|690
001674  aa   000400 1160 07	cmpq 	256,dl
001675  aa   777773 6040 04	tmi  	-5,ic		001670
						STATEMENT 1 ON LINE 470
	pageno_list = 0;

001676  aa   000001 2360 07	ldq  	1,dl
001677  aa  6 01262 7561 00	stq  	pr6|690
001700  aa  6 01262 7271 00	lxl7 	pr6|690
001701  aa  6 00533 4501 17	stz  	pr6|347,7		pageno_list
001702  aa  6 01262 2361 00	ldq  	pr6|690
001703  aa  6 01262 0541 00	aos  	pr6|690
001704  aa   000400 1160 07	cmpq 	256,dl
001705  aa   777773 6040 04	tmi  	-5,ic		001700
						STATEMENT 1 ON LINE 471
	code = 0;

001706  aa  6 00105 4501 00	stz  	pr6|69		code
						STATEMENT 1 ON LINE 473
	call pc$segmove (move_astep, astes (1), astes (2), new_pvtx, new_vtocx, n_nulled_pages, dlp, addr (pageno_list),
	     code);

001707  aa  6 00534 3735 00	epp7 	pr6|348		pageno_list
001710  aa  6 01516 6535 00	spri7	pr6|846
001711  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
001712  aa  6 01522 2521 00	spri2	pr6|850
001713  aa  6 01252 3521 00	epp2 	pr6|682		astes
001714  aa  6 01524 2521 00	spri2	pr6|852
001715  aa  6 01254 3521 00	epp2 	pr6|684		astes
001716  aa  6 01526 2521 00	spri2	pr6|854
001717  aa  6 00523 3521 00	epp2 	pr6|339		new_pvtx
001720  aa  6 01530 2521 00	spri2	pr6|856
001721  aa  6 00524 3521 00	epp2 	pr6|340		new_vtocx
001722  aa  6 01532 2521 00	spri2	pr6|858
001723  aa  6 00517 3521 00	epp2 	pr6|335		n_nulled_pages
001724  aa  6 01534 2521 00	spri2	pr6|860
001725  aa  6 00510 3521 00	epp2 	pr6|328		dlp
001726  aa  6 01536 2521 00	spri2	pr6|862
001727  aa  6 01516 3521 00	epp2 	pr6|846
001730  aa  6 01540 2521 00	spri2	pr6|864
001731  aa  6 00105 3521 00	epp2 	pr6|69		code
001732  aa  6 01542 2521 00	spri2	pr6|866
001733  aa  6 01520 6211 00	eax1 	pr6|848
001734  aa   044000 4310 07	fld  	18432,dl
001735  aa  6 00044 3701 20	epp4 	pr6|36,*
001736  la  4 00036 3521 20	epp2 	pr4|30,*		pc$segmove
001737  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 480
	call lock$lock_ast;

001740  aa  6 00056 6211 00	eax1 	pr6|46
001741  aa   000000 4310 07	fld  	0,dl
001742  aa  6 00044 3701 20	epp4 	pr6|36,*
001743  la  4 00024 3521 20	epp2 	pr4|20,*		lock$lock_ast
001744  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 481
	if code ^= 0
	then do;

001745  aa  6 00105 2361 00	ldq  	pr6|69		code
001746  aa   000036 6000 04	tze  	30,ic		002004
						STATEMENT 1 ON LINE 483
		call put_aste (astes (1));

001747  aa  6 01252 3521 00	epp2 	pr6|682		astes
001750  aa  6 01510 2521 00	spri2	pr6|840
001751  aa  6 01506 6211 00	eax1 	pr6|838
001752  aa   004000 4310 07	fld  	2048,dl
001753  aa  6 00044 3701 20	epp4 	pr6|36,*
001754  la  4 00044 3521 20	epp2 	pr4|36,*		put_aste
001755  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 484
		astes (1) = null;

001756  aa   776050 2370 04	ldaq 	-984,ic		000026 = 077777000043 000001000000
001757  aa  6 01252 7571 00	staq 	pr6|682		astes
						STATEMENT 1 ON LINE 485
		call put_aste (astes (2));

001760  aa  6 01254 3521 00	epp2 	pr6|684		astes
001761  aa  6 01510 2521 00	spri2	pr6|840
001762  aa  6 01506 6211 00	eax1 	pr6|838
001763  aa   004000 4310 07	fld  	2048,dl
001764  aa  6 00044 3701 20	epp4 	pr6|36,*
001765  la  4 00044 3521 20	epp2 	pr4|36,*		put_aste
001766  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 486
		astes (2) = null ();

001767  aa   776037 2370 04	ldaq 	-993,ic		000026 = 077777000043 000001000000
001770  aa  6 01254 7571 00	staq 	pr6|684		astes
						STATEMENT 1 ON LINE 487
		call lock$unlock_ast;

001771  aa  6 00056 6211 00	eax1 	pr6|46
001772  aa   000000 4310 07	fld  	0,dl
001773  aa  6 00044 3701 20	epp4 	pr6|36,*
001774  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
001775  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 488
		if code = error_table_$log_vol_full	/* try another pv */
		then do;

001776  aa  6 00105 2361 00	ldq  	pr6|69		code
001777  aa  6 00044 3701 20	epp4 	pr6|36,*
002000  la  4 00100 1161 20	cmpq 	pr4|64,*		error_table_$log_vol_full
002001  aa   777417 6010 04	tnz  	-241,ic		001420
						STATEMENT 1 ON LINE 490
			call release_pvtxs;

002002  aa   000404 6700 04	tsp4 	260,ic		002406
						STATEMENT 1 ON LINE 491
			go to next_pv;

002003  aa   777242 7100 04	tra  	-350,ic		001245
						STATEMENT 1 ON LINE 492
		     end;

						STATEMENT 1 ON LINE 494
	     end;

						STATEMENT 1 ON LINE 496
	call thread$cin (move_astep, sst.ausedp (fixed (move_astep -> aste.ptsi, 2)));

002004  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
002005  aa  7 00013 2351 00	lda  	pr7|11		aste.ptsi
002006  aa   000034 7350 00	als  	28
002007  aa   000106 7730 00	lrl  	70
002010  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
002011  aa  6 01510 2521 00	spri2	pr6|840
002012  aa  6 01224 3715 20	epp5 	pr6|660,*		sstp
002013  aa  5 00044 3521 06	epp2 	pr5|36,ql		sst.ausedp
002014  aa  6 01512 2521 00	spri2	pr6|842
002015  aa  6 01506 6211 00	eax1 	pr6|838
002016  aa   010000 4310 07	fld  	4096,dl
002017  aa  6 00044 3701 20	epp4 	pr6|36,*
002020  la  4 00062 3521 20	epp2 	pr4|50,*		thread$cin
002021  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 499
	move_astep -> aste.pack_ovfl = "0"b;

002022  aa   000556 2350 04	lda  	366,ic		002600 = 777777677777
002023  aa  6 00512 3735 20	epp7 	pr6|330,*		move_astep
002024  aa  7 00013 3551 00	ansa 	pr7|11		aste.pack_ovfl
						STATEMENT 1 ON LINE 500
	move_astep -> aste.nqsw = old_nqsw;

002025  aa  6 00525 2351 00	lda  	pr6|341		old_nqsw
002026  aa   000024 7710 00	arl  	20
002027  aa  7 00005 6751 00	era  	pr7|5		aste.nqsw
002030  aa   100000 3750 07	ana  	32768,dl
002031  aa  7 00005 6551 00	ersa 	pr7|5		aste.nqsw
						STATEMENT 1 ON LINE 501
	call search_ast$hash_in (move_astep);

002032  aa  6 00512 3521 00	epp2 	pr6|330		move_astep
002033  aa  6 01510 2521 00	spri2	pr6|840
002034  aa  6 01506 6211 00	eax1 	pr6|838
002035  aa   004000 4310 07	fld  	2048,dl
002036  aa  6 00044 3701 20	epp4 	pr6|36,*
002037  la  4 00056 3521 20	epp2 	pr4|46,*		search_ast$hash_in
002040  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 503
	do astep = astes (1), astes (2);

002041  aa   000014 3520 04	epp2 	12,ic		002055 = 000005352004
002042  aa  6 01264 2521 00	spri2	pr6|692
002043  aa  6 01252 3735 20	epp7 	pr6|682,*		astes
002044  aa  6 01210 6535 00	spri7	pr6|648		astep
						STATEMENT 1 ON LINE 504
	     call put_aste (astep);

002045  aa  6 01210 3521 00	epp2 	pr6|648		astep
002046  aa  6 01510 2521 00	spri2	pr6|840
002047  aa  6 01506 6211 00	eax1 	pr6|838
002050  aa   004000 4310 07	fld  	2048,dl
002051  aa  6 00044 3701 20	epp4 	pr6|36,*
002052  la  4 00044 3521 20	epp2 	pr4|36,*		put_aste
002053  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 505
	end;

002054  aa  6 01264 7101 20	tra  	pr6|692,*
002055  aa   000005 3520 04	epp2 	5,ic		002062 = 775744373424
002056  aa  6 01264 2521 00	spri2	pr6|692
002057  aa  6 01254 3735 20	epp7 	pr6|684,*		astes
002060  aa  6 01210 6535 00	spri7	pr6|648		astep
002061  aa   777764 7100 04	tra  	-12,ic		002045
						STATEMENT 1 ON LINE 507
	astep, astes (1), astes (2) = null;

002062  aa   775744 3734 24	epp7 	-1052,ic*
002063  aa  6 01210 6535 00	spri7	pr6|648		astep
002064  aa  6 01252 6535 00	spri7	pr6|682		astes
002065  aa  6 01254 6535 00	spri7	pr6|684		astes
						STATEMENT 1 ON LINE 509
	call lock$unlock_ast;

002066  aa  6 00056 6211 00	eax1 	pr6|46
002067  aa   000000 4310 07	fld  	0,dl
002070  aa  6 00044 3701 20	epp4 	pr6|36,*
002071  la  4 00026 3521 20	epp2 	pr4|22,*		lock$unlock_ast
002072  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 510
	ep -> entry.pvid = pvid;

002073  aa  6 01134 2351 00	lda  	pr6|604		pvid
002074  aa  6 01212 3735 20	epp7 	pr6|650,*		ep
002075  aa  7 00030 7551 00	sta  	pr7|24		entry.pvid
						STATEMENT 1 ON LINE 511
	ep -> entry.vtocx = new_vtocx;

002076  aa  6 00524 2361 00	ldq  	pr6|340		new_vtocx
002077  aa   000066 7370 00	lls  	54
002100  aa  7 00031 5511 60	stba 	pr7|25,60		entry.vtocx
						STATEMENT 1 ON LINE 512
	if ep -> entry.dirsw
	then do;

002101  aa  7 00032 2351 00	lda  	pr7|26		entry.dirsw
002102  aa   400000 3150 03	cana 	131072,du
002103  aa   000022 6000 04	tze  	18,ic		002125
						STATEMENT 1 ON LINE 514
		dp = baseptr (segno);

002104  aa  6 01144 2361 00	ldq  	pr6|612		segno
002105  aa  6 00000 3525 00	epbp2	pr6|0
002106  aa   000000 3130 06	easp2	0,ql
002107  aa  6 01214 2521 00	spri2	pr6|652		dp
						STATEMENT 1 ON LINE 515
		dp -> dir.vtocx = new_vtocx;

002110  aa  6 00524 2361 00	ldq  	pr6|340		new_vtocx
002111  aa   000066 7370 00	lls  	54
002112  aa  2 00015 5511 60	stba 	pr2|13,60		dir.vtocx
						STATEMENT 1 ON LINE 516
		dp -> dir.pvid = pvid;

002113  aa  6 01134 2351 00	lda  	pr6|604		pvid
002114  aa  2 00011 7551 00	sta  	pr2|9		dir.pvid
						STATEMENT 1 ON LINE 517
		call sum$dirmod (dp);

002115  aa  6 01214 3521 00	epp2 	pr6|652		dp
002116  aa  6 01510 2521 00	spri2	pr6|840
002117  aa  6 01506 6211 00	eax1 	pr6|838
002120  aa   004000 4310 07	fld  	2048,dl
002121  aa  6 00044 3701 20	epp4 	pr6|36,*
002122  la  4 00050 3521 20	epp2 	pr4|40,*		sum$dirmod
002123  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 518
	     end;

002124  aa   000012 7100 04	tra  	10,ic		002136
						STATEMENT 1 ON LINE 519
	else call sum$dirmod (setwordno (ep, 0));

002125  aa  7 00000 3525 00	epbp2	pr7|0
002126  aa  6 01516 2521 00	spri2	pr6|846
002127  aa  6 01516 3521 00	epp2 	pr6|846
002130  aa  6 01510 2521 00	spri2	pr6|840
002131  aa  6 01506 6211 00	eax1 	pr6|838
002132  aa   004000 4310 07	fld  	2048,dl
002133  aa  6 00044 3701 20	epp4 	pr6|36,*
002134  la  4 00050 3521 20	epp2 	pr4|40,*		sum$dirmod
002135  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 520
	call release_old_vtoce;

002136  aa   000143 6700 04	tsp4 	99,ic		002301
						STATEMENT 1 ON LINE 522
     end MOVE_THE_SEGMENT;

002137  aa  6 01244 6101 00	rtcd 	pr6|676
  END PROCEDURE MOVE_THE_SEGMENT
BEGIN PROCEDURE cleanup_dseg_and_meter
ENTRY TO cleanup_dseg_and_meter                             STATEMENT 1 ON LINE 525
cleanup_dseg_and_meter:
     procedure;

002140  aa  6 01266 6501 00	spri4	pr6|694
						STATEMENT 1 ON LINE 528
	if cleanup_must_zero_sdw
	then do;

002141  aa  6 00104 2351 00	lda  	pr6|68		cleanup_must_zero_sdw
002142  aa   000022 6000 04	tze  	18,ic		002164
						STATEMENT 1 ON LINE 530
		tsdw = 0;

002143  aa   775661 2370 04	ldaq 	-1103,ic		000024 = 000000000000 000000000000
002144  aa  6 01164 7571 00	staq 	pr6|628		tsdw
						STATEMENT 1 ON LINE 531
		call pmut$swap_sdw (baseptr (segno), addr (tsdw));

002145  aa  6 01144 2361 00	ldq  	pr6|612		segno
002146  aa  6 00000 3525 00	epbp2	pr6|0
002147  aa   000000 3130 06	easp2	0,ql
002150  aa  6 01544 2521 00	spri2	pr6|868
002151  aa  6 01164 3735 00	epp7 	pr6|628		tsdw
002152  aa  6 01546 6535 00	spri7	pr6|870
002153  aa  6 01544 3521 00	epp2 	pr6|868
002154  aa  6 01552 2521 00	spri2	pr6|874
002155  aa  6 01546 3521 00	epp2 	pr6|870
002156  aa  6 01554 2521 00	spri2	pr6|876
002157  aa  6 01550 6211 00	eax1 	pr6|872
002160  aa   010000 4310 07	fld  	4096,dl
002161  aa  6 00044 3701 20	epp4 	pr6|36,*
002162  la  4 00042 3521 20	epp2 	pr4|34,*		pmut$swap_sdw
002163  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 533
	     end;

						STATEMENT 1 ON LINE 534
	call usage_values (pw2, time2);

002164  aa  6 01136 3521 00	epp2 	pr6|606		pw2
002165  aa  6 01552 2521 00	spri2	pr6|874
002166  aa  6 01162 3521 00	epp2 	pr6|626		time2
002167  aa  6 01554 2521 00	spri2	pr6|876
002170  aa  6 01550 6211 00	eax1 	pr6|872
002171  aa   010000 4310 07	fld  	4096,dl
002172  aa  6 00044 3701 20	epp4 	pr6|36,*
002173  la  4 00066 3521 20	epp2 	pr4|54,*		usage_values
002174  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 535
	sstp -> sst.sgm_time = sstp -> sst.sgm_time + time2 - time1;

002175  aa  6 01224 3735 20	epp7 	pr6|660,*		sstp
002176  aa  7 00510 2371 00	ldaq 	pr7|328		sst.sgm_time
002177  aa  6 01162 0771 00	adaq 	pr6|626		time2
002200  aa  6 01160 1771 00	sbaq 	pr6|624		time1
002201  aa  7 00510 7571 00	staq 	pr7|328		sst.sgm_time
						STATEMENT 1 ON LINE 536
	sstp -> sst.sgm_pf = sstp -> sst.sgm_pf + pw2 - pw1;

002202  aa  7 00512 2361 00	ldq  	pr7|330		sst.sgm_pf
002203  aa  6 01136 0761 00	adq  	pr6|606		pw2
002204  aa  6 01135 1761 00	sbq  	pr6|605		pw1
002205  aa  7 00512 7561 00	stq  	pr7|330		sst.sgm_pf
						STATEMENT 1 ON LINE 538
     end cleanup_dseg_and_meter;

002206  aa  6 01266 6101 00	rtcd 	pr6|694
  END PROCEDURE cleanup_dseg_and_meter
BEGIN PROCEDURE diskname
ENTRY TO diskname                                           STATEMENT 1 ON LINE 541
diskname:
     proc (pvtx1) returns (char (9));

002207  aa  6 01274 6501 00	spri4	pr6|700
002210  aa  6 01276 2521 00	spri2	pr6|702
						STATEMENT 1 ON LINE 546
	pvtep = addr (pvt_array (pvtx1));

002211  aa  2 00002 2361 20	ldq  	pr2|2,*		pvtx1
002212  aa   000034 4020 07	mpy  	28,dl
002213  aa  6 01216 3735 20	epp7 	pr6|654,*		pvt_arrayp
002214  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
002215  aa  6 01220 6535 00	spri7	pr6|656		pvtep
						STATEMENT 1 ON LINE 547
	pic99 = pvte.logical_area_number;

002216  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
002217  aa   000011 7350 00	als  	9
002220  aa   000077 7330 00	lrs  	63
002221  aa  6 01557 7561 00	stq  	pr6|879		pvte.logical_area_number
002222  aa  000 100 301 500	btd  	(pr),(pr)
002223  aa  6 01557 00 0004	desc9a	pr6|879,4		pvte.logical_area_number
002224  aa  6 01556 01 0003	desc9ls	pr6|878,3,0
002225  aa  6 01302 4501 00	stz  	pr6|706		pic99
002226  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
002227  aa  6 01556 01 0003	desc9ls	pr6|878,3,0
002230  aa   000334 00 0002	desc9a	220,2		002562 = 070322000000
002231  aa  6 01302 00 0002	desc9a	pr6|706,2		pic99
						STATEMENT 1 ON LINE 548
	if ^pvte.is_sv
	then return (pvte.devname || "_" || pic99);

002232  aa  7 00002 2351 00	lda  	pr7|2		pvte.is_sv
002233  aa   040000 3150 03	cana 	16384,du
002234  aa   000016 6010 04	tnz  	14,ic		002252
002235  aa  7 00003 2351 00	lda  	pr7|3		pvte.devname
002236  aa   137000 2360 03	ldq  	48640,du
002237  aa  6 01560 7571 00	staq 	pr6|880
002240  aa  6 01302 2351 00	lda  	pr6|706		pic99
002241  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
002242  aa   000055 7730 00	lrl  	45
002243  aa  6 01560 2771 00	oraq 	pr6|880
002244  aa  6 01560 7571 00	staq 	pr6|880
002245  aa  2 00004 3715 20	epp5 	pr2|4,*
002246  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002247  aa  6 01560 00 0007	desc9a	pr6|880,7
002250  aa  5 00000 00 0011	desc9a	pr5|0,9
002251  aa  6 01274 6101 00	rtcd 	pr6|700
						STATEMENT 1 ON LINE 550
	else return (pvte.devname || "_" || pic99 || pvte.sv_name);

002252  aa  7 00003 2351 00	lda  	pr7|3		pvte.devname
002253  aa   137000 2360 03	ldq  	48640,du
002254  aa  6 01560 7571 00	staq 	pr6|880
002255  aa  6 01302 2351 00	lda  	pr6|706		pic99
002256  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
002257  aa   000055 7730 00	lrl  	45
002260  aa  6 01560 2771 00	oraq 	pr6|880
002261  aa  6 01560 7571 00	staq 	pr6|880
002262  aa   000011 2360 07	ldq  	9,dl
002263  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002264  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002265  aa  6 01560 00 0007	desc9a	pr6|880,7
002266  aa  2 00000 00 0007	desc9a	pr2|0,7
002267  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002270  aa  7 00015 00 0002	desc9a	pr7|13,2		pvte.sv_name
002271  aa  2 00001 60 0002	desc9a	pr2|1(3),2
002272  aa  6 01276 3715 20	epp5 	pr6|702,*
002273  aa  5 00004 3535 20	epp3 	pr5|4,*
002274  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002275  aa  2 00000 00 0011	desc9a	pr2|0,9
002276  aa  3 00000 00 0011	desc9a	pr3|0,9
002277  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002300  aa  6 01274 6101 00	rtcd 	pr6|700
						STATEMENT 1 ON LINE 552
     end diskname;

  END PROCEDURE diskname
BEGIN PROCEDURE release_old_vtoce
ENTRY TO release_old_vtoce                                  STATEMENT 1 ON LINE 555
release_old_vtoce:
     procedure;

002301  aa  6 01304 6501 00	spri4	pr6|708
						STATEMENT 1 ON LINE 557
	call dbm_man$set_incr (old_pvtx, old_vtocx, ignore);

002302  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
002303  aa  6 01564 2521 00	spri2	pr6|884
002304  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
002305  aa  6 01566 2521 00	spri2	pr6|886
002306  aa  6 00515 3521 00	epp2 	pr6|333		ignore
002307  aa  6 01570 2521 00	spri2	pr6|888
002310  aa  6 01562 6211 00	eax1 	pr6|882
002311  aa   014000 4310 07	fld  	6144,dl
002312  aa  6 00044 3701 20	epp4 	pr6|36,*
002313  la  4 00012 3521 20	epp2 	pr4|10,*		dbm_man$set_incr
002314  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 558
	call vtoc_man$free_vtoce (old_pvid, old_pvtx, old_vtocx, code);

002315  aa  6 00530 3521 00	epp2 	pr6|344		old_pvid
002316  aa  6 01574 2521 00	spri2	pr6|892
002317  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
002320  aa  6 01576 2521 00	spri2	pr6|894
002321  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
002322  aa  6 01600 2521 00	spri2	pr6|896
002323  aa  6 00105 3521 00	epp2 	pr6|69		code
002324  aa  6 01602 2521 00	spri2	pr6|898
002325  aa  6 01572 6211 00	eax1 	pr6|890
002326  aa   020000 4310 07	fld  	8192,dl
002327  aa  6 00044 3701 20	epp4 	pr6|36,*
002330  la  4 00074 3521 20	epp2 	pr4|60,*		vtoc_man$free_vtoce
002331  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 559
	if code = 0
	then call truncator (old_pvid, old_pvtx, old_vtocx);

002332  aa  6 00105 2361 00	ldq  	pr6|69		code
002333  aa   000004 6010 04	tnz  	4,ic		002337
002334  aa   000216 3520 04	epp2 	142,ic		002552 = 000006000000
002335  aa   000077 6700 04	tsp4 	63,ic		002434
002336  aa   000047 7100 04	tra  	39,ic		002405
						STATEMENT 1 ON LINE 561
	else do;

						STATEMENT 1 ON LINE 562
		call syserr$error_code (0, code, "segment_mover: freeing vtocx ^o on old pvtx ^o", old_vtocx,
		     old_pvtx);

002337  aa  6 01604 4501 00	stz  	pr6|900
002340  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002341  aa   775470 00 0060	desc9a	-1224,48		000030 = 163145147155
002342  aa  6 01606 00 0060	desc9a	pr6|902,48
002343  aa  6 01604 3521 00	epp2 	pr6|900
002344  aa  6 01624 2521 00	spri2	pr6|916
002345  aa  6 00105 3521 00	epp2 	pr6|69		code
002346  aa  6 01626 2521 00	spri2	pr6|918
002347  aa  6 01606 3521 00	epp2 	pr6|902
002350  aa  6 01630 2521 00	spri2	pr6|920
002351  aa  6 00532 3521 00	epp2 	pr6|346		old_vtocx
002352  aa  6 01632 2521 00	spri2	pr6|922
002353  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
002354  aa  6 01634 2521 00	spri2	pr6|924
002355  aa   775426 3520 04	epp2 	-1258,ic		000003 = 404000000005
002356  aa  6 01636 2521 00	spri2	pr6|926
002357  aa   775443 3520 04	epp2 	-1245,ic		000022 = 404000000043
002360  aa  6 01640 2521 00	spri2	pr6|928
002361  aa   775421 3520 04	epp2 	-1263,ic		000002 = 524000000056
002362  aa  6 01642 2521 00	spri2	pr6|930
002363  aa   775434 3520 04	epp2 	-1252,ic		000017 = 404000000021
002364  aa  6 01644 2521 00	spri2	pr6|932
002365  aa  6 01646 2521 00	spri2	pr6|934
002366  aa  6 01622 6211 00	eax1 	pr6|914
002367  aa   024000 4310 07	fld  	10240,dl
002370  aa  6 00044 3701 20	epp4 	pr6|36,*
002371  la  4 00054 3521 20	epp2 	pr4|44,*		syserr$error_code
002372  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 564
		pvt_array (old_pvtx).vol_trouble_count = pvt_array (old_pvtx).vol_trouble_count + 1;

002373  aa  6 00531 2361 00	ldq  	pr6|345		old_pvtx
002374  aa   000034 4020 07	mpy  	28,dl
002375  aa  6 01216 3735 20	epp7 	pr6|654,*		pvt_arrayp
002376  aa  7 77777 2351 06	lda  	pr7|-1,ql		pvt_array.vol_trouble_count
002377  aa   000000 6270 06	eax7 	0,ql
002400  aa   000066 7330 00	lrs  	54
002401  aa   000001 0760 07	adq  	1,dl
002402  aa   000066 7370 00	lls  	54
002403  aa  7 77777 3715 17	epp5 	pr7|-1,7		pvt_array.vol_trouble_count
002404  aa  5 00000 5511 60	stba 	pr5|0,60		pvt_array.vol_trouble_count
						STATEMENT 1 ON LINE 565
	     end;

						STATEMENT 1 ON LINE 567
     end release_old_vtoce;

002405  aa  6 01304 6101 00	rtcd 	pr6|708
  END PROCEDURE release_old_vtoce
BEGIN PROCEDURE release_pvtxs
ENTRY TO release_pvtxs                                      STATEMENT 1 ON LINE 570
release_pvtxs:
     proc;

002406  aa  6 01312 6501 00	spri4	pr6|714
						STATEMENT 1 ON LINE 572
	call get_pvtx$release_pvtx (old_pvid, old_pvtx);

002407  aa  6 00530 3521 00	epp2 	pr6|344		old_pvid
002410  aa  6 01652 2521 00	spri2	pr6|938
002411  aa  6 00531 3521 00	epp2 	pr6|345		old_pvtx
002412  aa  6 01654 2521 00	spri2	pr6|940
002413  aa  6 01650 6211 00	eax1 	pr6|936
002414  aa   010000 4310 07	fld  	4096,dl
002415  aa  6 00044 3701 20	epp4 	pr6|36,*
002416  la  4 00022 3521 20	epp2 	pr4|18,*		get_pvtx$release_pvtx
002417  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 573
	if held_pvtx
	then call get_pvtx$release_pvtx (new_pvid, new_pvtx);

002420  aa  6 00514 2351 00	lda  	pr6|332		held_pvtx
002421  aa   000012 6000 04	tze  	10,ic		002433
002422  aa  6 00522 3521 00	epp2 	pr6|338		new_pvid
002423  aa  6 01652 2521 00	spri2	pr6|938
002424  aa  6 00523 3521 00	epp2 	pr6|339		new_pvtx
002425  aa  6 01654 2521 00	spri2	pr6|940
002426  aa  6 01650 6211 00	eax1 	pr6|936
002427  aa   010000 4310 07	fld  	4096,dl
002430  aa  6 00044 3701 20	epp4 	pr6|36,*
002431  la  4 00022 3521 20	epp2 	pr4|18,*		get_pvtx$release_pvtx
002432  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 576
     end release_pvtxs;

002433  aa  6 01312 6101 00	rtcd 	pr6|714
  END PROCEDURE release_pvtxs
BEGIN PROCEDURE truncator
ENTRY TO truncator                                          STATEMENT 1 ON LINE 581
truncator:
     procedure (a_pvid, a_pvtx, a_vtocx);

002434  aa  6 01320 6501 00	spri4	pr6|720
002435  aa  6 01322 2521 00	spri2	pr6|722
						STATEMENT 1 ON LINE 587
	call vtoc_man$await_vtoce (a_pvid, a_pvtx, a_vtocx, code);

002436  aa  2 00002 3521 20	epp2 	pr2|2,*		a_pvid
002437  aa  6 01660 2521 00	spri2	pr6|944
002440  aa  6 01322 3735 20	epp7 	pr6|722,*
002441  aa  7 00004 3521 20	epp2 	pr7|4,*		a_pvtx
002442  aa  6 01662 2521 00	spri2	pr6|946
002443  aa  7 00006 3521 20	epp2 	pr7|6,*		a_vtocx
002444  aa  6 01664 2521 00	spri2	pr6|948
002445  aa  6 00105 3521 00	epp2 	pr6|69		code
002446  aa  6 01666 2521 00	spri2	pr6|950
002447  aa  6 01656 6211 00	eax1 	pr6|942
002450  aa   020000 4310 07	fld  	8192,dl
002451  aa  6 00044 3701 20	epp4 	pr6|36,*
002452  la  4 00072 3521 20	epp2 	pr4|58,*		vtoc_man$await_vtoce
002453  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 589
	if code = 0
	then call pc$deposit_list (a_pvtx, n_nulled_pages, dlp, a_vtocx, addr (pageno_list));

002454  aa  6 00105 2361 00	ldq  	pr6|69		code
002455  aa   000024 6010 04	tnz  	20,ic		002501
002456  aa  6 00534 3735 00	epp7 	pr6|348		pageno_list
002457  aa  6 01670 6535 00	spri7	pr6|952
002460  aa  6 01322 3715 20	epp5 	pr6|722,*
002461  aa  5 00004 3521 20	epp2 	pr5|4,*		a_pvtx
002462  aa  6 01674 2521 00	spri2	pr6|956
002463  aa  6 00517 3521 00	epp2 	pr6|335		n_nulled_pages
002464  aa  6 01676 2521 00	spri2	pr6|958
002465  aa  6 00510 3521 00	epp2 	pr6|328		dlp
002466  aa  6 01700 2521 00	spri2	pr6|960
002467  aa  5 00006 3521 20	epp2 	pr5|6,*		a_vtocx
002470  aa  6 01702 2521 00	spri2	pr6|962
002471  aa  6 01670 3521 00	epp2 	pr6|952
002472  aa  6 01704 2521 00	spri2	pr6|964
002473  aa  6 01672 6211 00	eax1 	pr6|954
002474  aa   024000 4310 07	fld  	10240,dl
002475  aa  6 00044 3701 20	epp4 	pr6|36,*
002476  la  4 00032 3521 20	epp2 	pr4|26,*		pc$deposit_list
002477  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002500  aa   000051 7100 04	tra  	41,ic		002551
						STATEMENT 1 ON LINE 591
	else do;

						STATEMENT 1 ON LINE 592
		call syserr$error_code (0, code, "segment_mover: finishing truncation of pvtx ^o vtocx ^o.", a_pvtx,
		     a_vtocx);

002501  aa  6 01706 4501 00	stz  	pr6|966
002502  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002503  aa   775372 00 0070	desc9a	-1286,56		000074 = 163145147155
002504  aa  6 01710 00 0070	desc9a	pr6|968,56
002505  aa  6 01706 3521 00	epp2 	pr6|966
002506  aa  6 01730 2521 00	spri2	pr6|984
002507  aa  6 00105 3521 00	epp2 	pr6|69		code
002510  aa  6 01732 2521 00	spri2	pr6|986
002511  aa  6 01710 3521 00	epp2 	pr6|968
002512  aa  6 01734 2521 00	spri2	pr6|988
002513  aa  6 01322 3735 20	epp7 	pr6|722,*
002514  aa  7 00004 3521 20	epp2 	pr7|4,*		a_pvtx
002515  aa  6 01736 2521 00	spri2	pr6|990
002516  aa  7 00006 3521 20	epp2 	pr7|6,*		a_vtocx
002517  aa  6 01740 2521 00	spri2	pr6|992
002520  aa   775263 3520 04	epp2 	-1357,ic		000003 = 404000000005
002521  aa  6 01742 2521 00	spri2	pr6|994
002522  aa   775300 3520 04	epp2 	-1344,ic		000022 = 404000000043
002523  aa  6 01744 2521 00	spri2	pr6|996
002524  aa   775254 3520 04	epp2 	-1364,ic		000000 = 524000000070
002525  aa  6 01746 2521 00	spri2	pr6|998
002526  aa   775271 3520 04	epp2 	-1351,ic		000017 = 404000000021
002527  aa  6 01750 2521 00	spri2	pr6|1000
002530  aa  6 01752 2521 00	spri2	pr6|1002
002531  aa  6 01726 6211 00	eax1 	pr6|982
002532  aa   024000 4310 07	fld  	10240,dl
002533  aa  6 00044 3701 20	epp4 	pr6|36,*
002534  la  4 00054 3521 20	epp2 	pr4|44,*		syserr$error_code
002535  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 594
		pvt_array (a_pvtx).vol_trouble_count = pvt_array (a_pvtx).vol_trouble_count + 1;

002536  aa  6 01322 3735 20	epp7 	pr6|722,*
002537  aa  7 00004 2361 20	ldq  	pr7|4,*		a_pvtx
002540  aa   000034 4020 07	mpy  	28,dl
002541  aa  6 01216 3715 20	epp5 	pr6|654,*		pvt_arrayp
002542  aa  5 77777 2351 06	lda  	pr5|-1,ql		pvt_array.vol_trouble_count
002543  aa   000000 6270 06	eax7 	0,ql
002544  aa   000066 7330 00	lrs  	54
002545  aa   000001 0760 07	adq  	1,dl
002546  aa   000066 7370 00	lls  	54
002547  aa  5 77777 3535 17	epp3 	pr5|-1,7		pvt_array.vol_trouble_count
002550  aa  3 00000 5511 60	stba 	pr3|0,60		pvt_array.vol_trouble_count
						STATEMENT 1 ON LINE 595
	     end;

						STATEMENT 1 ON LINE 597
     end truncator;

002551  aa  6 01320 6101 00	rtcd 	pr6|720
  END PROCEDURE truncator
  END PROCEDURE segment_mover


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
