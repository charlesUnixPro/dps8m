	COMPILATION LISTING OF SEGMENT disk_control
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/01/90  1626.8 mdt Mon
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        *********************************************************** */
       10 
       11 /* DISK_CONTROL - Device Control Module for Disks.
       12*   coded 12/1/70 by N. I. Morris
       13*   revised 7/1/73 - Lee J. Scheffler to add metering
       14*   revised 12/73 by N. I. Morris to add DSU-191 disks.
       15*   revised 4/8/74 by S.H.Webber to change lockptl metering code
       16*   revised for new storage system - 3/27/75 by Noel I. Morris
       17*   test_drive entry by Bernard Greenberg 4/9/76
       18*   improved error handling by Noel I. Morris - 6/3/76
       19*   bad channel removal added by Noel I. Morris - 8/16/77
       20*   disk offline waiting added by Bernard Greenberg - 9/20/77
       21*   changed to use reset status command in test_drive 2/1/79 by Michael R. Jordan
       22*   modified for new seek optimization for MSU0500/1 devices 4/79 by Michael R. Jordan
       23*   modified for io_manager conversion February 1981 by Chris Jones
       24*   Modified July, 1981, WOS, to install Mike Jordan's fix to the 501 sector number
       25*   overflow problem (too many sectors to represent in 20 bits).
       26*   Modified February 1982 by C. Hornig for MR10 io_manager.
       27*   Modified March 1982 by C. Hornig to unload disks.
       28*   Modified March 1982 by J. Bongiovanni for queue_length_given_pvtx, new PVTE
       29*   Modified July 1982 by J. Bongiovanni for read_sectors, write_sectors
       30*   Modified June 1983 by Chris Jones for ioi rewrite
       31*   Modified January 1984 by Chris Jones to add add_channel entry
       32*   Modified April 1984 by T. Oke for system wide free_q.
       33*   Modified April 1984 by T. Oke for dynamic channel table and the use of
       34*   dskdcl_chans_per_subsys to define channel idx/subsystem relation.
       35*   Modified May 1984 by T. Oke to save pvtx in queue entry for AZM analysis
       36*   of queue.
       37*
       38*   Modified for adaptive optimizer by T. Oke May 1984.
       39*   Modified call_run to poll all sub-systems by T. Oke May 1984,
       40*   Lossage counters moved to chantab and renamed.
       41*   Modified to reset quentry.used in add_free_q by T. Oke November 1984.
       42*   Modified Nov 26, 1984 by R. A. Fawcett to support dev 0 (fips). Also include
       43*   Chris Jones's change for IMU-type detailed status delivery.
       44*   Stepped zealousness of esd_reset_locks from "call call_run (sx)" to
       45*   merely "call run" to prevent running un-reinitialized sub-systems.
       46*   by T. Oke November 1984.
       47*   Modified February 1985 by Chris Jones to allow a channel to be usurped if
       48*   of its devices are deleted.
       49*   Modified July 1985 by Paul Farley to correctly handle IMU style detailed status.
       50**/
       51 
       52 /****^  HISTORY COMMENTS:
       53*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
       54*     audit(85-12-02,CLJones), install(86-03-21,MR12.0-1033):
       55*     Add support for dev
       56*     0 FIPS, Chris Jones's change for IMU-type detailed status delivery.
       57*  2) change(86-04-01,Fawcett), approve(86-04-11,MCR7383),
       58*     audit(86-05-27,Coppola), install(86-07-17,MR12.0-1097):
       59*     Add support for subvolumes, and 512_word_io, devices 3380 and 3390.
       60*  3) change(86-07-24,Fawcett), approve(86-10-30,PBF7383),
       61*     audit(86-11-18,Beattie), install(86-11-21,MR12.0-1223):
       62*     Add an optional third line to the disk error message that gives the
       63*     subvolume name and logical record/sector for use with the
       64*     record_to_vtocx command.
       65*  4) change(86-10-29,Fawcett), approve(86-11-14,MCR7571),
       66*     audit(86-11-18,Beattie), install(86-11-21,MR12.0-1223):
       67*     Check the ioi_used bit before trying to place channels back in operation.
       68*  5) change(87-05-22,Fawcett), approve(87-05-27,MCR7704),
       69*     audit(87-07-08,Farley), install(87-07-17,MR12.1-1043):
       70*     Move the check for the TEST type IO quentry. This allows the secondary
       71*     channels to be used if the primary is down.
       72*  6) change(87-05-27,Fawcett), approve(87-05-27,MCR7704),
       73*     audit(87-07-08,Farley), install(87-07-17,MR12.1-1043):
       74*     Set the "substat" variable to ANY so that matches in the disk_error_data
       75*     segment can be found for such things as I/O system faults. Also display
       76*     the I/O system fault word on the console.
       77*  7) change(87-08-31,Fawcett), approve(87-08-31,PBF7704),
       78*     audit(87-08-31,Farley), install(87-09-01,MR12.1-1095):
       79*     Change to correct a bug in the sub-status reporting in the above fix.
       80*  8) change(88-02-23,Farley), approve(88-02-23,MCR7759),
       81*     audit(88-02-24,Fawcett), install(88-03-01,MR12.2-1029):
       82*     Changed to set a new flag in the error code "all_paths_bad" and to give up
       83*     if only one channel left and it is bad. At this time it will only be
       84*     implemented for bootload_io. This is I/O done for BCE commands.
       85*  9) change(88-02-23,Farley), approve(88-02-23,MCR7793),
       86*     audit(88-02-24,Fawcett), install(88-03-01,MR12.2-1029):
       87*     Changed the handle_error procedure to only display/retry TEST I/O errors
       88*     when they are of the bad_path variety.  The retry will be done by removing
       89*     the suspected bad path and re-queuing the I/O.  If bad_path error on all
       90*     paths, set the device inoperative and post the I/O. Same during esd.
       91* 10) change(88-03-18,Farley), approve(88-03-18,MCR7858),
       92*     audit(88-04-11,Fawcett), install(88-04-19,MR12.2-1037):
       93*     Changed disk_inter entry to set io_status_entry_ptr for all interrupt
       94*     levels that will be processed.  A null ptr fault was occuring with level-1
       95*     system faults.  Changed bad_dev error handling to set pvte inop when doing
       96*     TEST I/O during an ESD.
       97* 11) change(88-05-12,Farley), approve(88-06-03,MCR7906),
       98*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
       99*     Added a reconnect_announce_time variable to chantab to announce reconnect
      100*     attempts the first time and every thirty seconds thereafter, until the I/O
      101*     is successful.  All other times the messages will go only to the log as
      102*     they normally do.  Also added I/O type to message.
      103* 12) change(89-06-23,Farley), approve(89-07-26,MCR8122),
      104*     audit(89-09-11,WAAnderson), install(89-09-22,MR12.3-1072):
      105*     Added functionality to interpret_status and printerr procedures to
      106*     seperate FIPS disk statuses from all others by checking the pvte.is_sv
      107*     flag and using new fields in disk_error_data.  Also changed printerr to
      108*     check the new "just_log" flag in disk_error_data.
      109* 13) change(90-06-27,WAAnderson), approve(90-08-28,MCR8188),
      110*     audit(90-09-21,Schroth), install(90-10-01,MR12.4-1035):
      111*     Fix bug in esd_reset_locks and handle_error that caused ESD to fail.
      112*                                                   END HISTORY COMMENTS */
      113 
      114 /*
      115*   ERROR RECOVERY STRATEGY
      116*
      117*   When a fatal error is detected by  the  disk  DIM,  the
      118*   drive  involved is placed in a temporarily inoperative state.  If
      119*   the drive corrects the problem by itself within  several  seconds
      120*   and  sends  a special interrupt, the drive will be placed back in
      121*   operation.  If no special is received within the  several  second
      122*   time  limit, the DIM will attempt to use the drive once more.  If
      123*   it generates another fatal error, the drive  will  be  placed  in
      124*   broken  state.   The DIM will attempt to use a broken drive every
      125*   several minutes.  The  receipt  of  a  special  interrupt,  or  a
      126*   successful  attempt  to use a broken drive, will place that drive
      127*   back in operation.  Read requests that are queued  for  a  broken
      128*   drive  will  be posted as errors.  Write requests will be left in
      129*   the queue and ignored util the broken drive  becomes  operational
      130*   again.
      131*
      132**/
      133 
      134 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
      135 disk_control:
      136      proc;
      137 
      138 dcl	a_pvtx		   fixed bin;		/* index of PVT entry */
      139 dcl	a_coreadd		   fixed bin (24);		/* absolute core address */
      140 dcl	a_devadd		   bit (18) aligned;	/* secondary storage device address */
      141 dcl	a_intrpt		   fixed bin (1);		/* non-zero if completion interrupt desired */
      142 dcl	a_queue_length	   fixed bin;		/* current number of elements in Q */
      143 dcl	a_sect_off	   fixed bin (4);		/* sector offset for single sector requests */
      144 dcl	a_n_sectors	   fixed bin;		/* number of sectors for sector I/O */
      145 
      146 dcl	pvtx		   fixed bin;		/* copied args to prevent page faults */
      147 dcl	coreadd		   fixed bin (24);
      148 dcl	sect_off		   fixed bin (4);
      149 dcl	n_sectors		   fixed bin;
      150 dcl	record_offset	   fixed bin;
      151 
      152 /* Local Automatic storage. */
      153 
      154 dcl	bootload_sw	   bit (1) aligned;		/* set if I/O is being done for bootload Multics */
      155 dcl	call_run_sx	   fixed bin;		/* a_sx saved in call_run */
      156 dcl	channel_time	   fixed bin (52);		/* time channel spent doing I/O */
      157 dcl	command		   bit (6) aligned;		/* peripheral device command */
      158 dcl	cylinder		   fixed bin (12);		/* cylinder heads are currently on */
      159 dcl	dcdcwp		   ptr;			/* pointer to data xfer IDCW */
      160 dcl	dddcwp		   ptr;			/* pointer to data xfer DCW */
      161 dcl	dev		   unsigned fixed bin (6);	/* disk device code */
      162 dcl	devadd		   fixed bin (18);		/* record number part of device address */
      163 dcl	dev_count		   fixed bin;		/* counter in getwork */
      164 dcl	entry_time	   fixed bin (52);		/* time of call */
      165 dcl	errcd		   fixed bin (35);		/* error code to page control */
      166 dcl	i		   fixed bin;		/* usually channel index */
      167 dcl	intrpt		   bit (1);		/* if interrupt required */
      168 dcl	io_type		   fixed bin;		/* type of IO */
      169 dcl	lcp		   ptr;			/* local channel pointer in handle_error */
      170 dcl	level		   fixed bin (3);		/* level of interrupt from IOM */
      171 dcl	majstat		   fixed bin (5);		/* extended major status */
      172 dcl	mask		   fixed bin (71) aligned;	/* temp for wire and mask */
      173 dcl	masked		   bit (1);		/* running masked */
      174 dcl	meter_start_time	   fixed bin (52);		/* time of attempt to lock */
      175 dcl	name_rel		   fixed bin (17);		/* rel offset of the disk_error_data ascii names */
      176 dcl	pdi		   fixed bin (6) unsigned;	/* Primary Device Index. */
      177 dcl	post_sw		   bit (1) aligned;		/* "1"b if posting must be done */
      178 dcl	ptp		   ptr;			/* temp for wire_and_mask */
      179 dcl	qrp		   bit (18) aligned;	/* rel ptr to queue entry */
      180 dcl	qx		   fixed bin (8);		/* index to queue entry */
      181 dcl	required		   bit (1) aligned;		/* "1"b if IOI requires specific channel */
      182 dcl	sector		   fixed bin (21);		/* physical disk sector */
      183 dcl	sect_sw		   bit (1);		/* if sector IO */
      184 dcl	stat		   bit (36) aligned;	/* copy of special or fault status word */
      185 dcl	status_time	   fixed bin (52);		/* time status received */
      186 dcl	sx		   fixed bin (8);		/* index of disk subsystem */
      187 dcl	sysc		   fixed bin;		/* syserr report code */
      188 dcl	substat		   bit (6) aligned;		/* substatus */
      189 dcl	temp_time		   fixed bin (52);		/* for real time looping on inop chnl errors */
      190 dcl	usurped		   bit (1) aligned;		/* "1"b if IOI usurped channel successfully */
      191 dcl	wait_time		   fixed bin (52);		/* time from queuing to I/O completion */
      192 
      193 dcl	1 msg_buf		   like io_msg aligned;	/* for syserr data */
      194 
      195 dcl	1 stat_entry	   like io_status_entry;	/* the whole disaster */
      196 
      197 dcl	error_table_$bad_arg   fixed bin (35) ext static;
      198 dcl	error_table_$io_configured
      199 			   fixed bin (35) ext static;
      200 
      201 dcl	pds$processid	   ext bit (36);
      202 dcl	page_fault$disk_offline_event
      203 			   bit (36) aligned ext;
      204 dcl	tc_data$system_shutdown
      205 			   ext fixed bin;
      206 
      207 dcl	ANY		   bit (6) init ("000000"b) static options (constant);
      208 						/* used for substatus that will match on any */
      209 dcl	(
      210 	BOTH		   init ("1"b),
      211 	SINGLE		   init ("0"b),
      212 	ON		   init ("1"b),
      213 	OFF		   init ("0"b),
      214 	SUCCESS		   init ("1"b),
      215 	FAILURE		   init ("0"b)
      216 	)		   bit (1) aligned static options (constant);
      217 dcl	IDCW		   bit (3) init ("7"b3) static options (constant);
      218 dcl	(
      219 	WRITE		   init ("31"b3),
      220 	READ		   init ("25"b3),
      221 	RESET_STATUS	   init ("40"b3),
      222 	UNLOAD		   init ("72"b3)
      223 	)		   bit (6) static options (constant);
      224 dcl	UNLOCK		   bit (36) aligned init ((36)"0"b) static options (constant);
      225 dcl	(
      226 	ANNOUNCE_RECONNECT_DELTA
      227 			   fixed bin (35) init (30000000),
      228 						/* thirty seconds for reconnect announce throttling */
      229 	DISK_POLLING_TIME	   fixed bin (35) init (2000000),
      230 						/* two seconds for lost interrupt */
      231 	INOP_POLLING_TIME	   fixed bin (35) init (5000000),
      232 						/* five seconds for dropping out of ready */
      233 	BROKEN_POLLING_TIME	   fixed bin (35) init (180000000),
      234 						/* three minutes for standby */
      235 	CHANNEL_POLLING_TIME   fixed bin (35) init (60000000)
      236 						/* one minute for bad channel */
      237 	)		   static options (constant);
      238 
      239 dcl	bootload_disk_post	   entry (fixed bin (24), fixed bin (35));
      240 dcl	seek_512		   bit (6) init ("30"b3) static options (constant);
      241 dcl	syserr		   entry options (variable);
      242 dcl	syserr$binary	   entry options (variable);
      243 dcl	pxss$notify	   entry (bit (36) aligned);
      244 dcl	page$done		   entry (fixed bin (24), fixed bin (35));
      245 dcl	pmut$wire_and_mask	   entry (fixed bin (71) aligned, ptr);
      246 dcl	pmut$unwire_unmask	   entry (fixed bin (71) aligned, ptr);
      247 dcl	dctl$disk_inter	   entry (fixed bin (35), fixed bin (3), bit (36) aligned);
      248 dcl	vtoc_interrupt	   entry (fixed bin (24), fixed bin (35));
      249 dcl	ioi_masked$online_device_count
      250 			   entry (char (*)) returns (fixed bin);
      251 dcl	ioi_masked$interrupt   entry (fixed bin (35), fixed bin (3), bit (36) aligned);
      252 
      253 dcl	(abs, addr, addrel, bin, bit, clock, convert, divide, fixed, float, lbound, length, hbound, max, mod, null, ptr,
      254 	rel, stacq, string, substr, unspec)
      255 			   builtin;
      256 
      257 dcl	ME		   char (16) static options (constant) init ("disk_control");
      258 
      259 dcl	dev_mask		   (0:63) bit (72) aligned static options (constant)
      260 			   init ("100000000000000000000000000000000000000000000000000000000000000000000000"b,
      261 			   "010000000000000000000000000000000000000000000000000000000000000000000000"b,
      262 			   "001000000000000000000000000000000000000000000000000000000000000000000000"b,
      263 			   "000100000000000000000000000000000000000000000000000000000000000000000000"b,
      264 			   "000010000000000000000000000000000000000000000000000000000000000000000000"b,
      265 			   "000001000000000000000000000000000000000000000000000000000000000000000000"b,
      266 			   "000000100000000000000000000000000000000000000000000000000000000000000000"b,
      267 			   "000000010000000000000000000000000000000000000000000000000000000000000000"b,
      268 			   "000000001000000000000000000000000000000000000000000000000000000000000000"b,
      269 			   "000000000100000000000000000000000000000000000000000000000000000000000000"b,
      270 			   "000000000010000000000000000000000000000000000000000000000000000000000000"b,
      271 			   "000000000001000000000000000000000000000000000000000000000000000000000000"b,
      272 			   "000000000000100000000000000000000000000000000000000000000000000000000000"b,
      273 			   "000000000000010000000000000000000000000000000000000000000000000000000000"b,
      274 			   "000000000000001000000000000000000000000000000000000000000000000000000000"b,
      275 			   "000000000000000100000000000000000000000000000000000000000000000000000000"b,
      276 			   "000000000000000010000000000000000000000000000000000000000000000000000000"b,
      277 			   "000000000000000001000000000000000000000000000000000000000000000000000000"b,
      278 			   "000000000000000000100000000000000000000000000000000000000000000000000000"b,
      279 			   "000000000000000000010000000000000000000000000000000000000000000000000000"b,
      280 			   "000000000000000000001000000000000000000000000000000000000000000000000000"b,
      281 			   "000000000000000000000100000000000000000000000000000000000000000000000000"b,
      282 			   "000000000000000000000010000000000000000000000000000000000000000000000000"b,
      283 			   "000000000000000000000001000000000000000000000000000000000000000000000000"b,
      284 			   "000000000000000000000000100000000000000000000000000000000000000000000000"b,
      285 			   "000000000000000000000000010000000000000000000000000000000000000000000000"b,
      286 			   "000000000000000000000000001000000000000000000000000000000000000000000000"b,
      287 			   "000000000000000000000000000100000000000000000000000000000000000000000000"b,
      288 			   "000000000000000000000000000010000000000000000000000000000000000000000000"b,
      289 			   "000000000000000000000000000001000000000000000000000000000000000000000000"b,
      290 			   "000000000000000000000000000000100000000000000000000000000000000000000000"b,
      291 			   "000000000000000000000000000000010000000000000000000000000000000000000000"b,
      292 			   "000000000000000000000000000000001000000000000000000000000000000000000000"b,
      293 			   "000000000000000000000000000000000100000000000000000000000000000000000000"b,
      294 			   "000000000000000000000000000000000010000000000000000000000000000000000000"b,
      295 			   "000000000000000000000000000000000001000000000000000000000000000000000000"b,
      296 			   "000000000000000000000000000000000000100000000000000000000000000000000000"b,
      297 			   "000000000000000000000000000000000000010000000000000000000000000000000000"b,
      298 			   "000000000000000000000000000000000000001000000000000000000000000000000000"b,
      299 			   "000000000000000000000000000000000000000100000000000000000000000000000000"b,
      300 			   "000000000000000000000000000000000000000010000000000000000000000000000000"b,
      301 			   "000000000000000000000000000000000000000001000000000000000000000000000000"b,
      302 			   "000000000000000000000000000000000000000000100000000000000000000000000000"b,
      303 			   "000000000000000000000000000000000000000000010000000000000000000000000000"b,
      304 			   "000000000000000000000000000000000000000000001000000000000000000000000000"b,
      305 			   "000000000000000000000000000000000000000000000100000000000000000000000000"b,
      306 			   "000000000000000000000000000000000000000000000010000000000000000000000000"b,
      307 			   "000000000000000000000000000000000000000000000001000000000000000000000000"b,
      308 			   "000000000000000000000000000000000000000000000000100000000000000000000000"b,
      309 			   "000000000000000000000000000000000000000000000000010000000000000000000000"b,
      310 			   "000000000000000000000000000000000000000000000000001000000000000000000000"b,
      311 			   "000000000000000000000000000000000000000000000000000100000000000000000000"b,
      312 			   "000000000000000000000000000000000000000000000000000010000000000000000000"b,
      313 			   "000000000000000000000000000000000000000000000000000001000000000000000000"b,
      314 			   "000000000000000000000000000000000000000000000000000000100000000000000000"b,
      315 			   "000000000000000000000000000000000000000000000000000000010000000000000000"b,
      316 			   "000000000000000000000000000000000000000000000000000000001000000000000000"b,
      317 			   "000000000000000000000000000000000000000000000000000000000100000000000000"b,
      318 			   "000000000000000000000000000000000000000000000000000000000010000000000000"b,
      319 			   "000000000000000000000000000000000000000000000000000000000001000000000000"b,
      320 			   "000000000000000000000000000000000000000000000000000000000000100000000000"b,
      321 			   "000000000000000000000000000000000000000000000000000000000000010000000000"b,
      322 			   "000000000000000000000000000000000000000000000000000000000000001000000000"b,
      323 			   "000000000000000000000000000000000000000000000000000000000000000100000000"b);
      324 
      325 /* format: off */
      326 /* Assumptions:
      327*
      328*Several variables are expected to be correct through most of this program:
      329*
      330*   dev	Device index of the devtab entry for the current device.
      331*   dp	Devtab Pointer, indicates the current devtab to be operating upon.
      332*	It is typically set from addr (disktab.devtab (pdi)).
      333*   pdi	Primary Device Index of the current dev.  Found in devtab.pdi
      334*          Used to determine primary device of shared devices.  The primary
      335*	device will hold queue for all its shared spindles.
      336*   sect_sw Sector switch indication for the current IO to be entered into a
      337*	quentry (operation entry points), or when posting a completed IO.
      338*	Major importance when posting an IO, since it must be correct for
      339*	the coreadd being posted.
      340*   sx	Subsystem index.  Indicates which subsystem is in use, in order of
      341*	definition of subsystems in the config_file.
      342*
      343*     When a disk interrupt is received, we take info on dev, pdi, coreadd,
      344*sect_sw from the entry in check_stat.  These should not be messed with, since
      345*check_stat will also return the queue element to the free_q and will call
      346*getwork to start fresh IO on the channel ASAP.  Sect_sw and coreadd must still
      347*be good at post time.
      348*
      349*     Since on shared devices, a single pdi's queue will hold requests for more
      350*than a single device, the dev value is recovered from the selected queue in
      351*getwork (after xfer_join) to ensure we know who we are dealing with.
      352*
      353*     Add_wq will add the new request to the queue of the pdi, but will do the
      354*appropriate statistics (other than queue stats) on the device (dev).  Same with
      355*del_q.
      356**/
      357 /* format: on */
      358 
      359 /* Entry points to generate disk requests.  Setup the type of the IO and then
      360*   enter common code to process entry conditions.  If we are doing testing or
      361*   VTOCE IO, then we have to wire and mask.  If doing PAGE IO, then we are
      362*   wired and masked. */
      363 
      364 
      365 write_sectors:
      366      entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);
      367 
      368 	io_type = VTOC_WRITE;
      369 	goto go_sector;
      370 
      371 
      372 read_sectors:
      373      entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);
      374 
      375 	io_type = VTOC_READ;
      376 go_sector:
      377 	devadd = bin (a_devadd, 18);			/* copy device address */
      378 	coreadd = a_coreadd;			/* copy core address */
      379 
      380 	sect_off = a_sect_off;			/* setup offset */
      381 	n_sectors = a_n_sectors;
      382 	goto go_masked;				/* Enter masked env */
      383 
      384 
      385 test_drive:
      386      entry (a_pvtx);				/* test drive by issuing RSS */
      387 
      388 	io_type = TEST;
      389 	coreadd = bin (RESET_STATUS, 24);		/* Device TEST command */
      390 	goto go_test;
      391 
      392 
      393 
      394 unload_drive:
      395      entry (a_pvtx);				/* cycle down a drive */
      396 
      397 	io_type = TEST;
      398 	coreadd = bin (UNLOAD, 24);			/* Device UNLOAD command */
      399 go_test:
      400 	sect_off = 0;				/* no offset if TEST */
      401 	n_sectors = 0;				/* no sectors if TEST */
      402 	devadd = 0;				/* no core if TEST */
      403 
      404 /* Sector and Test IO must be masked and have the stack wired. */
      405 
      406 go_masked:
      407 	call pmut$wire_and_mask (mask, ptp);		/* mask for processing */
      408 	masked = "1"b;				/* so we unmask */
      409 	intrpt = "0"b;
      410 	goto go_common;
      411 
      412 
      413 /* Write/Read a Virtual Memory Page between Disk and a Memory Frame. */
      414 
      415 disk_write:
      416      entry (a_pvtx, a_coreadd, a_devadd, a_intrpt);
      417 
      418 	io_type = PAGE_WRITE;
      419 	goto go_page;
      420 
      421 disk_read:
      422      entry (a_pvtx, a_coreadd, a_devadd, a_intrpt);
      423 
      424 	io_type = PAGE_READ;
      425 go_page:
      426 	masked = "0"b;				/* run unmasked */
      427 	devadd = bin (a_devadd, 18);			/* copy device address */
      428 	coreadd = a_coreadd;			/* copy core address */
      429 	sect_off = 0;				/* no sector offset */
      430 	n_sectors = 0;
      431 	if a_intrpt ^= 0 then
      432 	     intrpt = "1"b;				/* completion interrupt */
      433 	else intrpt = "0"b;
      434 
      435 /* Initialize indices and pointers and lock database.  Then do operation. */
      436 
      437 
      438 go_common:
      439 	entry_time = clock ();
      440 	sect_sw = sector_map (io_type);
      441 	bootload_sw = bootload_map (io_type);
      442 	pvtep = addr (addr (pvt$array) -> pvt_array (a_pvtx));
      443 						/* Get pointer to PVT entry for this device. */
      444 	pvtdip = addr (pvte.dim_info);		/* Get pointer to DIM info. */
      445 	sx = pvtdi.sx;				/* Extract index for this disk subsystem. */
      446 	call setup;				/* Get pointers to data bases. */
      447 	call lock (addr (disktab.call_lock_meters));	/* Lock the database. */
      448 
      449 	dev = pvte.logical_area_number;		/* Get physical device number. */
      450 	pdi = disktab.devtab (dev).pdi;		/* Get PDI. */
      451 	dp = addr (disktab.devtab (pdi));		/* Get pointer to info for primary device. */
      452 
      453 /* Test for device not to be used. */
      454 
      455 	if devtab.abandoned then do;			/* If device is hopelessly broken ... */
      456 	     errcd = 0;				/* Clear error code. */
      457 	     if ^write_map (io_type) then do;		/* If about to read ... */
      458 		erfp = addr (errcd);		/* Get pointer for mismatching dcl. */
      459 		errflags.device_inoperative = "1"b;	/* Indicate read could not succeed. */
      460 	     end;
      461 	     call unlock;				/* Undo the lock. */
      462 	     call post;				/* Pretend write was successful. */
      463 	     go to call_exit;			/* Clean up and exit. */
      464 	end;
      465 
      466 /* Attempt to get free queue entry to fill in. */
      467 
      468 	disktab.alloc_wait_meters.count = disktab.alloc_wait_meters.count + 1;
      469 	if ^get_free_q () then do;			/* Try to grab a free queue entry. */
      470 	     call lock_meter_start (addr (disktab.alloc_wait_meters));
      471 	     do while (^get_free_q ());		/* Try to grab a free queue entry. */
      472 		call call_run (sx);			/* If none, wait until some free up. */
      473 	     end;					/* Note: run destroys value of pvtep */
      474 	     call lock_meter_stop (addr (disktab.alloc_wait_meters));
      475 	end;
      476 
      477 /* Compute physical sector address from input info.  Physical sector result
      478*   accounts for unused sectors per cylinder. */
      479 
      480 	if pvte.is_sv then do;			/* convert the subvolume devadd to the real devadd */
      481 	     record_offset = mod (devadd, pvte.records_per_cyl);
      482 	     devadd = ((devadd - record_offset) * pvte.num_of_svs) + pvte.record_factor + record_offset;
      483 	end;
      484 	sector = devadd * sect_per_rec (pvte.device_type);/* raw sector. */
      485 	cylinder = divide (sector, pvtdi.usable_sect_per_cyl, 12, 0);
      486 	sector = sector + cylinder * pvtdi.unused_sect_per_cyl;
      487 	sector = sector + sect_off;			/* sector offset, if any. */
      488 
      489 /* Fill in the queue entry. */
      490 
      491 	quentry.intrpt = intrpt;			/* completion? */
      492 	quentry.used = "1"b;			/* in-use */
      493 	quentry.type = io_type;			/* Type of IO */
      494 	quentry.coreadd = bit (coreadd, 24);		/* Insert the memory address for data xfer. */
      495 
      496 	quentry.pvtx = a_pvtx;			/* Save for azm */
      497 	quentry.pdi = pdi;				/* Also save PDI for this device. */
      498 	quentry.dev = dev;				/* Place device code in queue entry. */
      499 	quentry.cylinder = cylinder;			/* And the cylinder number. */
      500 
      501 	quentry.n_sectors = n_sectors;		/* And the number of sectors (sector I/O only) */
      502 	quentry.sector = bit (sector, 21);		/* Save the disk device address. */
      503 
      504 /* Record time for AZM and stagnation testing. */
      505 
      506 	quentry.time = entry_time;
      507 
      508 /* If this is the only request for this device, try to start up a free channel.
      509*   Otherwise, queue the request for processing later. */
      510 
      511 	if ^(disktab.dev_busy | disktab.dev_queued) & dev_mask (pdi) then
      512 	     do i = 1 to disktab.nchan;		/* If device is free with no other requests ... */
      513 	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
      514 						/* Try to find a channel to run. */
      515 	     if chantab.in_use & ^chantab.active then do; /* If free usable channel ... */
      516 		call gotwork;			/* Let's do this request. */
      517 		go to working;			/* And exit the loop. */
      518 	     end;
      519 	end;
      520 
      521 	call add_wq;				/* Add item to end of appropriate queue. */
      522 
      523 /* Clean up and exit. */
      524 
      525 working:
      526 	call unlock;				/* Unlock the data base now. */
      527 
      528 call_exit:
      529 	if masked then
      530 	     call pmut$unwire_unmask (mask, ptp);	/* Restore vtoc_man's environment */
      531 
      532 	return;
      533 
      534 /* ESD_RESET_LOCKS - Reset data base locks on emergency shutdown. */
      535 
      536 esd_reset_locks:
      537      entry;
      538 
      539 	disksp = addr (disk_seg$);
      540 
      541 	unspec (disk_data.free_q) = "0"b;		/* clear free_q */
      542 	disk_data.free_q.depth = disk_data.free_q_size;	/* empty queue */
      543 
      544 /* This form of unlocking is used because it causes a load of "0"b and
      545*   and ANSA instruction.  This will do a read/alter/re-write cycle and
      546*   correctly update cache.  We cannot STACQ since it may not have been locked
      547*   to our processid. */
      548 
      549 	unspec (disk_data.lock) = unspec (disk_data.lock) & "0"b;
      550 
      551 	do qx = 1 to disk_data.free_q_size;		/* Look at each queue entry. */
      552 	     qp = addr (disk_data.free_q_entries (qx));
      553 	     qrp = rel (qp);
      554 
      555 	     call add_free_q;			/* Free all entries at ESD time. */
      556 	end;
      557 
      558 	do sx = 1 to disk_data.subsystems;
      559 	     call setup;				/* Get pointer to subsystem data. */
      560 	     call unlock;				/* Undo the lock. */
      561 
      562 	     call lock (addr (disktab.call_lock_meters)); /* Set the lock to us. */
      563 
      564 	     do dev = disktab.first_dev to disktab.last_dev;
      565 						/* Clear each device. */
      566 		dp = addr (disktab.devtab (dev));	/* Get pointer to info for device. */
      567 		devtab.broken, devtab.was_broken, devtab.inop = "0"b;
      568 						/* Try to use broken device. */
      569 		devtab.cylinder = 0;		/* Reset positional info. */
      570 		unspec (devtab.wq) = "0"b;		/* Clear queue pointers */
      571 
      572 /* reset optimizer queue depth to reflect empty queues. */
      573 
      574 		do i = 0 to MAX_IO_TYPE;
      575 		     devtab.forward = "1"b;
      576 		     devtab.opt_info (i).depth = 0;
      577 		end;
      578 	     end;
      579 
      580 	     cp = ptr (disksp, disktab.channels);	/* Get pointer to channel table. */
      581 	     do i = 1 to disktab.nchan;		/* Iterate through all channels. */
      582 		cp -> disk_channel_table (i).active = "0"b;
      583 						/* Mark all channels as not busy. */
      584 		cp -> disk_channel_table (i).inop = "0"b;
      585 						/* Mark as operative */
      586 		cp -> disk_channel_table (i).broken = "0"b;
      587 						/* Mark as not broken */
      588                     if ^(cp -> disk_channel_table (i).ioi_use) &
      589                        ^(cp -> disk_channel_table (i).in_use) then do;
      590                         cp -> disk_channel_table (i).in_use = "1"b;
      591                         disktab.channels_online = disktab.channels_online+1;
      592 		  end;     
      593 		cp -> disk_channel_table (i).erct = 0;	/* clear error count */
      594 	     end;
      595 
      596 	     disktab.dev_busy = "0"b;			/* Clear busy device flags. */
      597 	     disktab.dev_queued = "0"b;		/* Clear request queued flags. */
      598 
      599 	     call run;				/* Start this subsystem rolling. */
      600 	     call unlock;				/* Undo the lock. */
      601 	end;
      602 
      603 	return;
      604 
      605 /* USURP_CHANNEL/CEDE_CHANNEL - Share disk channels with IOI. */
      606 
      607 usurp_channel:
      608      entry (a_sx, a_chx, a_required, a_iom_chx, a_statusp); /* Entry to usurp channel for IOI use. */
      609 
      610 dcl	a_sx		   fixed bin (8);		/* disk subsystem index */
      611 dcl	a_chx		   fixed bin (35);		/* disk channel index */
      612 dcl	a_required	   bit (1) aligned;		/* "1"b if specific channel required */
      613 
      614 dcl	chx		   fixed bin (35);		/* chx as an integer */
      615 
      616 	sx = a_sx;				/* Copy subsystem index. */
      617 	required = a_required;			/* Copy argument. */
      618 	chx = a_chx;				/* copy chx */
      619 	call setup;				/* Get appropriate pointers. */
      620 	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));
      621 						/* Get pointer to chantab entry. */
      622 
      623 	call pmut$wire_and_mask (mask, ptp);		/* Wire stack and mask interrupts. */
      624 	call lock (addr (disktab.call_lock_meters));	/* Lock the disk database. */
      625 
      626 	usurped = (required | ^(chantab.broken | chantab.inop)) &
      627 						/* Usurp if required or not defective channel, and ... */
      628 	     ((disktab.channels_online > 1) | ^chantab.in_use
      629 	     | (ioi_masked$online_device_count (disk_data.name (sx)) = 0));
      630 						/* Ensure last good channel will not be usurped. */
      631 
      632 	if usurped then do;				/* If we may, usurp the channel. */
      633 	     if chantab.in_use then			/* If channel is being used, count it out. */
      634 		disktab.channels_online = disktab.channels_online - 1;
      635 	     chantab.in_use = "0"b;			/* Take channel out of operation. */
      636 	     chantab.broken, chantab.inop = "0"b;	/* Clear flags. */
      637 	end;
      638 
      639 	call unlock;				/* Unlock the disk database. */
      640 	call pmut$unwire_unmask (mask, ptp);		/* Unwire stack and unmask interrupts now. */
      641 
      642 	if usurped then do;				/* If channel now usurped ... */
      643 	     do while (chantab.active);		/* Wait for I/O to stop. */
      644 	     end;
      645 	     a_iom_chx = chantab.chx;
      646 	     a_statusp = chantab.statusp;
      647 	     chantab.ioi_use = "1"b;			/* Now allow IOI to use channel. */
      648 	end;
      649 	else do;
      650 	     a_iom_chx = 0;
      651 	     a_statusp = null ();
      652 	end;
      653 
      654 	return;
      655 
      656 cede_channel:
      657      entry (a_sx, a_chx, a_iom_chx, a_statusp);		/* Entry to cede channel from IOI use. */
      658 
      659 dcl	a_iom_chx		   fixed bin (35) parameter;
      660 dcl	a_statusp		   ptr parameter;
      661 
      662 dcl	iom_chx		   fixed bin (35);
      663 dcl	statusp		   ptr;
      664 
      665 	sx = a_sx;				/* Copy subsystem index. */
      666 	chx = a_chx;				/* copy chx */
      667 	iom_chx = a_iom_chx;
      668 	statusp = a_statusp;
      669 	call setup;				/* Get appropriate pointers. */
      670 	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));
      671 						/* Get pointer to chantab entry. */
      672 
      673 	chantab.chx = iom_chx;
      674 	chantab.statusp = statusp;
      675 	chantab.ioi_use = "0"b;			/* Take channel back from IOI. */
      676 	chantab.in_use = "1"b;			/* Place channel back in operation. */
      677 	disktab.channels_online = disktab.channels_online + 1;
      678 
      679 	return;
      680 
      681 /* Entry to manually add a deleted channel */
      682 
      683 add_channel:
      684      entry (a_sx, a_chx, a_code);
      685 
      686 dcl	a_code		   fixed bin (35) parameter;
      687 
      688 	sx = a_sx;
      689 	chx = a_chx;
      690 	call setup;
      691 	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));
      692 	call pmut$wire_and_mask (mask, ptp);
      693 	call lock (addr (disktab.call_lock_meters));
      694 	if chantab.broken then do;
      695 	     chantab.broken = "0"b;
      696 	     chantab.in_use = "1"b;
      697 	     disktab.channels_online = disktab.channels_online + 1;
      698 	end;
      699 	else errcd = error_table_$io_configured;
      700 	call unlock;
      701 	call pmut$unwire_unmask (mask, ptp);
      702 	if errcd = 0 then
      703 	     call syserr (ANNOUNCE, "^a: Adding channel ^a.", ME, chantab.chanid);
      704 	a_code = errcd;
      705 	return;
      706 
      707 /* DISK_RUN - External entry to poll all disk subsystems. */
      708 
      709 disk_run:
      710      entry;					/* here to keep going */
      711 
      712 	entry_time = clock ();			/* get time of entry */
      713 
      714 	disksp = addr (disk_seg$);			/* Get pointer to disk data base. */
      715 
      716 	do sx = 1 to disk_data.subsystems;		/* Iterate through all disk subsystems. */
      717 	     call setup;				/* Get pointers to data base. */
      718 	     call lock (addr (disktab.run_lock_meters));	/* Lock the database. */
      719 	     call run;				/* Now perform run operation. */
      720 	     call unlock;				/* Unlock the data base when finished. */
      721 	end;
      722 
      723 	return;
      724 
      725 
      726 
      727 /* CALL_RUN - Entry to poll a single disk subsystem. */
      728 
      729 call_run:
      730      entry (a_sx);
      731 
      732 
      733 	entry_time = clock ();
      734 
      735 	sx = a_sx;				/* Copy the subsystem index. */
      736 	call setup;
      737 	call run;
      738 
      739 /* run the other sub-systems too.  But now we have to lock them if possible. */
      740 
      741 	call_run_sx = a_sx;				/* save sx to return to */
      742 	do sx = 1 to disk_data.subsystems;
      743 	     if sx ^= call_run_sx then do;
      744 		call setup;
      745 		if stacq (disktab.lock, pds$processid, UNLOCK) then do;
      746 						/* locked it */
      747 		     call run;
      748 		     call unlock;
      749 		end;
      750 	     end;
      751 	end;
      752 	sx = call_run_sx;
      753 	call setup;				/* restore sub-sys */
      754 	return;
      755 
      756 /* RUN - Internal entry to perform polling. */
      757 
      758 run:
      759      proc;
      760 
      761 /* Perform channel polling. */
      762 
      763 	do i = 1 to disktab.nchan;			/* Iterate through all channels. */
      764 	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
      765 						/* Generate pointer to channel info table. */
      766 
      767 	     if chantab.inop & ^chantab.in_use then	/* If channel is inoperative ... */
      768 		if clock () - chantab.connect_time > CHANNEL_POLLING_TIME then do;
      769 		     chantab.in_use = "1"b;		/* Try once more. */
      770 		     disktab.channels_online = disktab.channels_online + 1;
      771 		end;
      772 
      773 /* format: off */
      774 /* Poll for disk completion.  This is required for allocation lock checks, and
      775*   during run_locks from page control, since both are run masked, and this
      776*   polling is the only way we would see disk completion.  This race hazard
      777*   on normal 15-seconds run_locks will produce some interrupts without
      778*   terminate status, but you can't win them all.  It may also produce some
      779*   situations of interrupt wile not active. */
      780 /* format: on */
      781 
      782 	     if ^chantab.active then			/* If channel is inactive ... */
      783 		call getwork;			/* Fire it up. */
      784 
      785 	     else do;				/* Attempt to pick up status. */
      786 		status_time = clock ();		/* For reconnect test, NOT race */
      787 		io_status_entry_ptr = addr (stat_entry);
      788 		call io_manager$get_status ((chantab.chx), io_status_entry_ptr);
      789 						/* See if any status has come in. */
      790 		io_status_word_ptr = addr (stat_entry.word1);
      791 		if /* case */ io_status_word.t then do; /* If status is present ... */
      792 		     chantab.status_from_run = chantab.status_from_run + 1;
      793 		     level = 3;			/* Set terminate status level. */
      794 		     call check_stat;		/* Go examine the status. */
      795 
      796 		     if post_sw then do;		/* If previous I/O must be posted ... */
      797 			call unlock;		/* Don't call out with our lock set. */
      798 			call post;		/* Do the posting. */
      799 			call lock (addr (disktab.call_lock_meters));
      800 						/* Relock our data base now. */
      801 		     end;
      802 		end;
      803 
      804 		else if chantab.connect_time + DISK_POLLING_TIME < status_time then do;
      805 						/* If an interrupt has been lost ... */
      806 		     idcwp = addr (chantab.scdcw);	/* Find out device in operation. */
      807 		     dev = fixed (idcw.device, 6);	/* .. */
      808 		     pdi = disktab.devtab (dev).pdi;	/* Get PDI for this device. */
      809 		     if chantab.reconnect_announce_time < status_time then do;
      810 			chantab.reconnect_announce_time = status_time + ANNOUNCE_RECONNECT_DELTA;
      811 			sysc = ANNOUNCE;
      812 		     end;
      813 		     else sysc = LOG;
      814 		     call syserr (sysc, "^a: Reconnected ^a I/O on ^a (channel ^a).", ME,
      815 			IO_TYPE (ptr (disksp, chantab.qrp) -> quentry.type), disk_name (SINGLE), chantab.chanid);
      816 		     call connect (idcwp);		/* Reconnect */
      817 		end;
      818 	     end;
      819 	end;
      820 
      821 
      822 /* Perform device polling. */
      823 
      824 	do dev = disktab.first_dev to disktab.last_dev;	/* Poll all devices. */
      825 	     pdi = disktab.devtab (dev).pdi;		/* Get PDI for this device. */
      826 	     if pdi = dev then do;			/* This is primary device. */
      827 		dp = addr (disktab.devtab (pdi));	/* Get pointer to primary device info. */
      828 
      829 		if /* case */ devtab.inop then	/* If device is inoperative ... */
      830 		     if clock () - devtab.time_inop > INOP_POLLING_TIME then do;
      831 			disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
      832 		     end;				/* Try to use device again. */
      833 		     else ;
      834 
      835 		else if devtab.broken then		/* If device is broken ... */
      836 		     if clock () - devtab.time_inop > BROKEN_POLLING_TIME then do;
      837 			devtab.inop = "1"b;		/* Mark as inoperative again. */
      838 			devtab.was_broken = "1"b;	/* .. */
      839 			pvtep = addr (addr (pvt$array) -> pvt_array (devtab.pvtx));
      840 			call set_pvte_inop (OFF);
      841 			devtab.broken = "0"b;	/* Turn off broken flag. */
      842 		     end;
      843 		     else ;
      844 	     end;
      845 	end;
      846 
      847 	return;
      848 
      849 
      850      end run;
      851 
      852 /* DISK_INTER - This is the interrupt side of the disk DIM. */
      853 
      854 disk_inter:
      855      entry (idx, ilevel, istat);			/* called by io_manager at interrupt time */
      856 
      857 dcl	idx		   fixed bin (35),		/* channel ID index */
      858 	istat		   bit (36) aligned,	/* status for specials or faults */
      859 	ilevel		   fixed bin (3);		/* level of interrupt */
      860 
      861 dcl	int_idx		   fixed bin (35);		/* idx as an integer */
      862 
      863 	int_idx = idx;
      864 	sx = divide (int_idx, dskdcl_chans_per_subsys, 17, 0);
      865 						/* Get index of this disk subsystem. */
      866 	call setup;				/* Get pointer to data base. */
      867 
      868 	i = int_idx - sx * dskdcl_chans_per_subsys + 1;	/* Compute expected channel table index. */
      869 	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
      870 
      871 	level = ilevel;				/* copy the level */
      872 	stat = istat;
      873 	if level = 7 then do;
      874 	     call check_special_stat;
      875 	     return;
      876 	end;
      877 
      878 
      879 	io_status_word_ptr = chantab.statusp;		/* point to status */
      880 
      881 	if ^io_status_word.t then
      882 	     if level >= 3 then do;
      883 		chantab.no_status_terminate = chantab.no_status_terminate + 1;
      884 		return;
      885 	     end;
      886 
      887 
      888 	if ^chantab.ioi_use then do;			/* If terminate, marker, or fault ... */
      889 	     call lock (addr (disktab.int_lock_meters));	/* Lock the database. */
      890 	     io_status_entry_ptr = addr (stat_entry);	/* point to an area to return status */
      891 	     unspec (io_status_entry) = ""b;
      892 	     if /* case */ level = 3 then do;		/* Reget status, under lock */
      893 		call io_manager$get_status ((chantab.chx), io_status_entry_ptr);
      894 		io_status_word_ptr = addr (io_status_entry.word1);
      895 		if ^io_status_word.t then do;
      896 		     chantab.no_io_terminate = chantab.no_io_terminate + 1;
      897 		     call unlock;
      898 		     return;
      899 		end;
      900 	     end;
      901 	     call check_stat;			/* Go process the status. */
      902 	     call unlock;				/* Clear data base lock. */
      903 
      904 	     if post_sw then			/* If posting previous operation ... */
      905 		call post;
      906 	end;
      907 
      908 	else					/* If status for IOI channel ... */
      909 	     call ioi_masked$interrupt ((chantab.ioi_ctx), level, stat);
      910 
      911 	return;					/* And return to caller. */
      912 
      913 check_special_stat:
      914      proc;
      915 
      916 	io_special_status_ptr = addr (stat);		/* base our templates */
      917 	if ^io_special_status.t then
      918 	     return;
      919 
      920 	dev = fixed (io_special_status.device, 6);	/* Extract device address from status. */
      921 	if dev = 0 & disktab.first_dev ^= 0 then	/* If special for disk controller ... */
      922 	     go to ioi_special;			/* Perhaps IOI wants this one, but we don't. */
      923 	if dev > disktab.last_dev then
      924 	     return;				/* Ignore this if number out-of-bounds. */
      925 
      926 	dp = addr (disktab.devtab (dev));		/* Get pointer to device info structure. */
      927 	pdi = devtab.pdi;				/* Get PDI. */
      928 
      929 	pvtx = devtab.pvtx;				/* Get index to PVT entry for device. */
      930 	if pvtx = 0 then
      931 	     return;				/* This will occur when an MPC broadcasts
      932*						   a special interrupt status to all LA's attached to
      933*						   it, and the MPC controls more than one
      934*						   subsystem as seen by the PVT. */
      935 	pvtep = addr (pvt_array (pvtx));		/* Get pointer to PVT entry. */
      936 
      937 	if pvte.storage_system then do;		/* If storage system volume ... */
      938 	     call lock (addr (disktab.int_lock_meters));	/* Lock disk database. */
      939 
      940 	     dp = addr (disktab.devtab (pdi));
      941 	     if /* case */ devtab.broken then do;	/* If device declared broken ... */
      942 		call syserr (ANNOUNCE, "^a: Placing ^a in operation.", ME, disk_name (BOTH));
      943 		call set_pvte_inop (OFF);		/* Let ops get through */
      944 		devtab.inop = "1"b;			/* Promote to inoperative state. */
      945 		devtab.was_broken = "1"b;		/* .. */
      946 		devtab.broken = "0"b;		/* Attempt to use device again. */
      947 	     end;
      948 
      949 	     else if devtab.inop then do;		/* If device is inoperative ... */
      950 		devtab.inop = "0"b;			/* Attempt to place back in operation. */
      951 		disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
      952 	     end;
      953 
      954 	     call call_run (sx);			/* Force run call on special interrupt. */
      955 
      956 	     call unlock;				/* Undo the lock now. */
      957 	end;
      958 
      959 	else do;					/* If not storage system volume ... */
      960 ioi_special:
      961 	     call ioi_masked$interrupt ((chantab.ioi_ctx), level, stat);
      962 	end;					/* Pass on the status to IOI. */
      963 
      964 	return;
      965 
      966      end check_special_stat;
      967 
      968 /* Pick up and examine the status. */
      969 
      970 check_stat:
      971      procedure;
      972 
      973 	errcd = 0;				/* Clear the error code */
      974 	erfp = addr (errcd);
      975 	post_sw = "0"b;				/* Clear posting required flag. */
      976 
      977 	if ^chantab.active then do;			/* If channel wasn't active, whisper bloody murder. */
      978 	     chantab.terminate_not_active = chantab.terminate_not_active + 1;
      979 	     call syserr (JUST_LOG, "^a: Unexpected IOM status ^24.3b for ^a (channel ^a).", ME,
      980 		string (io_status_word), disk_data.name (sx), chantab.chanid);
      981 	     return;
      982 	end;
      983 
      984 	status_time = clock ();
      985 
      986 	qrp = chantab.qrp;				/* Get pointer to queue entry. */
      987 	qp = ptr (disksp, qrp);
      988 	dev = quentry.dev;				/* Extract device address from queue entry. */
      989 	pdi = quentry.pdi;				/* Get PDI for this request. */
      990 	coreadd = bin (quentry.coreadd, 24);		/* Get memory address. */
      991 	pvtx = quentry.pvtx;			/* Get PVT index. */
      992 	sect_sw = sector_map (quentry.type);
      993 	bootload_sw = bootload_map (quentry.type);
      994 
      995 	pvtep = addr (addr (pvt$array) -> pvt_array (pvtx));
      996 						/* Get pointer to PVT entry. */
      997 	dp = addr (disktab.devtab (pdi));		/* Get pointer to primary device info structure. */
      998 
      999 
     1000 /* Remember this queue type entry so that we do the posting correctly. */
     1001 
     1002 	io_type = quentry.type;
     1003 
     1004 
     1005 /* Process termination status. */
     1006 
     1007 	if level = 3 then do;			/* If terminate status... */
     1008 	     chantab.active = "0"b;			/* Channel is no longer active. */
     1009 	     disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
     1010 						/* Indicate primary device no longer busy. */
     1011 
     1012 /* Process completion of detailed status read. */
     1013 
     1014 	     if /* case */ chantab.rsr then do;		/* If detailed status was just read ... */
     1015 		if (string (io_status_word) & disk_data.status_mask) then
     1016 						/* Don't print bad RSR's */
     1017 		     chantab.rsr = "0"b;		/* So clear this bit now. */
     1018 		unspec (io_status_entry.detailed_status (*)) = unspec (chantab.detailed_status (*));
     1019 						/* copy detail over */
     1020 
     1021 		io_status_word_ptr = addr (chantab.status);
     1022 						/* Unsave previous error status. */
     1023 		command = chantab.command;		/* And previous device command. */
     1024 		call extract_status;		/* Extract status info anew. */
     1025 		call handle_error;			/* Now handle the error. */
     1026 
     1027 		chantab.rsr = "0"b;			/* Turn off the bit. */
     1028 	     end;
     1029 
     1030 /* Handle abnormal termination status. */
     1031 
     1032 	     else if string (io_status_word) & disk_data.status_mask then do;
     1033 		call extract_status;		/* Extract status info from status word. */
     1034 		call interpret_status;		/* Get pointer to interp data. */
     1035 		call get_disk_command;		/* Extract peripheral command. */
     1036 
     1037 		if disk_error_interp.rsr & (io_status_entry.detailed_status (1) = ""b) then do;
     1038 						/* If RSR required and none available ... */
     1039 		     chantab.rsr = "1"b;		/* Do it now. */
     1040 		     chantab.status = string (io_status_word);
     1041 						/* Save status info for after RSR. */
     1042 		     chantab.action_code = io_status_entry.action_code;
     1043 		     chantab.command = command;	/* Also the device command. */
     1044 
     1045 		     idcwp = addr (chantab.dscdcw);
     1046 		     idcw.device = bit (dev);
     1047 		     call connect (idcwp);		/* Connect to RSR instruction. */
     1048 		end;
     1049 
     1050 		else				/* If no RSR required ... */
     1051 		     call handle_error;		/* Handle error right now. */
     1052 	     end;
     1053 
     1054 /* Test for nonzero tally residue in DCW. */
     1055 
     1056 	     else if io_status_entry.tally_residue ^= 0 then do;
     1057 		majstat = 20;
     1058 		substat = ANY;
     1059 		call handle_error;			/* Treat like any other error. */
     1060 	     end;
     1061 
     1062 /* Handle successful termination of disk operation. */
     1063 
     1064 	     else do;				/* If we got here, operation was successful. */
     1065 		post_sw = "1"b;			/* Post the results. */
     1066 
     1067 		if io_status_word.sub & "010011"b then do;
     1068 						/* If controller performed EDAC or auto retry ... */
     1069 		     disktab.edac_errors = disktab.edac_errors + 1;
     1070 
     1071 		     if io_status_word.sub & "010000"b then
     1072 						/* If EDAC performed ... */
     1073 			majstat = 22;
     1074 		     else				/* If auto retries performed ... */
     1075 			majstat = 21;
     1076 		     substat = ANY;
     1077 		     call interpret_status;		/* Interpret status info. */
     1078 		     call get_disk_command ();	/* Get the command */
     1079 		     call printerr;			/* Enter message in syserr log. */
     1080 		end;
     1081 
     1082 		devtab.inop = "0"b;			/* Clear this flag. */
     1083 
     1084 		if devtab.was_broken | devtab.broken then do;
     1085 						/* Was disk previously inoperative? */
     1086 		     devtab.was_broken = "0"b;	/* Clear flag now. */
     1087 		     devtab.broken = "0"b;
     1088 		     call set_pvte_inop (OFF);
     1089 		     call syserr (ANNOUNCE, "^a: ^a now operational.", ME, disk_name (BOTH));
     1090 		end;
     1091 		chantab.inop = "0"b;		/* Clear this flag. */
     1092 	     end;
     1093 
     1094 	end;					/* level 3 */
     1095 
     1096 /* Handle system fault status. */
     1097 
     1098 	else if level = 1 then do;			/* If system fault word  ... */
     1099 	     chantab.active = "0"b;			/* Channel is no longer active. */
     1100 	     disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
     1101 						/* Indicate device no longer busy. */
     1102 	     majstat = 19;
     1103 	     substat = ANY;
     1104 	     call handle_error;			/* Use standard error handler. */
     1105 	end;
     1106 
     1107 
     1108 	else return;				/* Ignore anything else. */
     1109 
     1110 /* If no posting to be done, don't do any of the following. */
     1111 
     1112 	if post_sw then do;
     1113 	     if io_type = TEST then do;
     1114 		pvte.testing = "0"b;
     1115 		post_sw = "0"b;
     1116 	     end;					/* Perform metering on completed I/O (whether successful or not). */
     1117 	     else do;
     1118 		status_time = clock ();		/* Get time now. */
     1119 		channel_time = status_time - chantab.connect_time;
     1120 						/* Compute time channel in use. */
     1121 		wait_time = status_time - quentry.time;
     1122 
     1123 		optp = addr (devtab.opt_info (quentry.type));
     1124 						/* get opt_info */
     1125 
     1126 		opt_info.channel_wait = opt_info.channel_wait + channel_time;
     1127 		opt_info.queue_wait = opt_info.queue_wait + wait_time;
     1128 
     1129 /* Test for error */
     1130 
     1131 		if errcd ^= 0			/* count a fatal error */
     1132 		     then
     1133 		     disktab.ferrors = disktab.ferrors + 1;
     1134 	     end;
     1135 
     1136 	     call add_free_q;			/* Scrap queue entry now. */
     1137 	end;
     1138 
     1139 	if ^chantab.active then			/* If channel is now free ... */
     1140 	     call getwork;				/* Look for more work to do. */
     1141 
     1142 	return;					/* And return to caller. */
     1143 
     1144 /* EXTRACT_STATUS - Extract major and substatus. */
     1145 
     1146 extract_status:
     1147 	proc;
     1148 
     1149 	     if /* case */ io_status_word.power then do;
     1150 		majstat = 16;
     1151 		substat = ANY;
     1152 	     end;
     1153 	     else if io_status_word.channel_stat then do;
     1154 		majstat = 17;
     1155 		substat = io_status_word.channel_stat;
     1156 	     end;
     1157 	     else if io_status_word.central_stat then do;
     1158 		majstat = 18;
     1159 		substat = io_status_word.central_stat;
     1160 	     end;
     1161 	     else do;
     1162 		majstat = bin (io_status_word.major, 4);
     1163 		substat = io_status_word.sub;
     1164 	     end;
     1165 
     1166 
     1167 	end extract_status;
     1168 
     1169 
     1170 
     1171 /* INTERPRET_STATUS - Get interpretive info for status. */
     1172 
     1173 interpret_status:
     1174 	proc;
     1175 
     1176 
     1177 	     dedp = addr (disk_error_data$);
     1178 	     if pvte.is_sv then
     1179 		dskerap = addrel (dedp, disk_error_data (majstat).finterp);
     1180 	     else dskerap = addrel (dedp, disk_error_data (majstat).interp);
     1181 
     1182 /***** find first description, which is just after last used substatus array entry */
     1183 	     name_rel = fixed (rel (addrel (dedp, disk_error_data (lbound (disk_error_data, 1)).namep)), 17);
     1184 	     dskerp = addr (disk_status_interp_array (lbound (disk_status_interp_array, 1)));
     1185 	     do i = lbound (disk_status_interp_array, 1) by 1 while (bin (rel (dskerp), 18) < name_rel);
     1186 		dskerp = addr (disk_status_interp_array (i));
     1187 		if (substat & disk_error_interp.bitmask) = disk_error_interp.bitson then
     1188 		     return;
     1189 	     end;
     1190 
     1191 
     1192 	end interpret_status;
     1193 
     1194 
     1195 
     1196 /* GET_DISK_COMMAND - Find Command Causing Disk Error. */
     1197 
     1198 get_disk_command:
     1199 	proc;
     1200 
     1201 	     idcwp = addrel (diskp, bin (io_status_entry.next_lpw_offset, 18) - disktab.abs_mem_addr - 1);
     1202 						/* Get pointer to IDCW. */
     1203 	     do while (idcw.code ^= IDCW);		/* Search backward to IDCW. */
     1204 		idcwp = addrel (idcwp, -1);
     1205 	     end;
     1206 	     command = idcw.command;			/* Extract command from IDCW. */
     1207 
     1208 
     1209 	end get_disk_command;
     1210 
     1211 /* PRINTERR - Print disk error message. */
     1212 
     1213 printerr:
     1214 	proc;
     1215 
     1216 dcl	type		   fixed bin;		/* device type */
     1217 dcl	record_address	   fixed bin (18);		/* Multics page address */
     1218 dcl	mjsdp		   ptr;			/* major status description pointer */
     1219 dcl	ssdp		   ptr;			/* substatus description pointer */
     1220 dcl	imu_detailed_status	   (0:23) bit (8) based;	/* IMU detailed status bytes */
     1221 dcl	logical_rec_addr	   fixed bin (17);		/* logical record address of subvolume */
     1222 dcl	logical_sector	   fixed bin (21);		/* logical sector of subvolume */
     1223 dcl	sector_offset	   fixed bin (17);		/* used in calculation of logical_sector */
     1224 
     1225 	     if devtab.broken then
     1226 		return;				/* Keep mum about broken devices. */
     1227 
     1228 	     sector = bin (chantab.select_data.sector);	/* get sector number of disk address of error */
     1229 	     type = pvte.device_type;			/* get device type */
     1230 	     pvtdip = addr (pvte.dim_info);
     1231 	     record_address =
     1232 		divide (sector - (divide (sector, sect_per_cyl (type), 17, 0) * pvtdi.unused_sect_per_cyl),
     1233 		sect_per_rec (type), 17, 0);
     1234 
     1235 	     if pvte.is_sv then do;
     1236 		record_offset = mod (record_address, pvte.records_per_cyl);
     1237 		logical_rec_addr =
     1238 		     divide ((record_address - pvte.record_factor - record_offset), pvte.num_of_svs, 17)
     1239 		     + record_offset;
     1240 		sector_offset = mod (sector, sect_per_cyl (type));
     1241 		logical_sector =
     1242 		     divide ((sector - (pvte.sv_num * sect_per_cyl (type)) - sector_offset), pvte.num_of_svs, 17)
     1243 		     + sector_offset;
     1244 	     end;
     1245 	     else do;
     1246 		logical_rec_addr = record_address;
     1247 		logical_sector = sector;
     1248 	     end;
     1249 
     1250 
     1251 	     if pvte.is_sv then
     1252 		mjsdp = addrel (dedp, disk_error_data (majstat).fnamep);
     1253 	     else mjsdp = addrel (dedp, disk_error_data (majstat).namep);
     1254 	     ssdp = addrel (dedp, disk_error_interp.namep);
     1255 
     1256 	     unspec (msg_buf) = "0"b;			/* Now build data portion of syserr message */
     1257 	     io_msgp = addr (msg_buf);
     1258 	     io_msg.level = bit (level, 3);
     1259 	     io_msg.channel = chantab.chanid;
     1260 	     io_msg.device = bit (dev);
     1261 	     io_msg.type = chantab.action_code;
     1262 	     io_msg.command = command;
     1263 	     io_msg.status = string (io_status_word);
     1264 	     io_msg.devname = disk_data.name (sx);
     1265 
     1266 	     if /* case */ devtab.broken | disk_error_interp.just_log then
     1267 		sysc = JUST_LOG;
     1268 	     else if mod (chantab.erct, 5) = 1 then
     1269 		sysc = ANNOUNCE;
     1270 	     else sysc = JUST_LOG;
     1271 	     call syserr$binary (sysc, io_msgp, SB_disk_err, SBL_disk_err,
     1272 		"^a: ^a ^[^12.3b^1s^;^1s^a^] for ^a (channel ^a).^/^2-rec ^o, sect ^o, main ^o^[^/^2-subvol ^a, logical rec ^o, logical sect ^o^;^3s^]^[^/^2-detailed status:^24( ^2.4b^).^;^s^]",
     1273 		ME, mjsdp -> disk_status_descrip.chr, (level = 1), stat, ssdp -> disk_status_descrip.chr,
     1274 		disk_name (SINGLE), chantab.chanid, record_address, sector, coreadd, pvte.is_sv, pvte.sv_name,
     1275 		logical_rec_addr, logical_sector, (io_status_entry.detailed_status (1) ^= ""b),
     1276 		addr (io_status_entry.detailed_status) -> imu_detailed_status);
     1277 
     1278 	     return;
     1279 
     1280 
     1281 	end printerr;
     1282 
     1283 /* HANDLE_ERROR - Handle disk errors. */
     1284 
     1285 handle_error:
     1286 	proc;
     1287 
     1288 
     1289 	     chantab.erct = chantab.erct + 1;
     1290 	     disktab.errors = disktab.errors + 1;
     1291 
     1292 	     call interpret_status;			/* Look this error up. */
     1293 	     if io_type = TEST then
     1294 		idcwp = addr (chantab.rssdcw);
     1295 	     else idcwp = addr (chantab.scdcw);
     1296 
     1297 	     if ^(io_type = TEST & ^disk_error_interp.bad_path) then
     1298 		call printerr;			/* print and log error */
     1299 
     1300 	     if /* case */ chantab.erct <= disk_error_interp.max_retries & io_type ^= TEST then do;
     1301 		if disk_error_interp.reseek then do;	/* If reseek desired before retry ... */
     1302 		     idcwp = addr (chantab.rstdcw);
     1303 		     idcw.device = bit (dev);
     1304 		     call connect (idcwp);		/* Connect to restore instruction. */
     1305 		end;
     1306 		else do;				/* If retrying ... */
     1307 		     if disk_error_interp.bad_path then do;
     1308 						/* Burn real time */
     1309 			temp_time = clock ();
     1310 			do while (clock () < temp_time + 750000);
     1311 						/* 3/4 sec. */
     1312 			end;
     1313 		     end;
     1314 		     call connect (idcwp);
     1315 		end;
     1316 	     end;
     1317 
     1318 	     else if disk_error_interp.bad_dev then do;	/* If error indicates a bad device ... */
     1319 		if /* case */ devtab.inop | devtab.broken | io_type = TEST then do;
     1320 						/* If device is already inoperative or broken ... */
     1321 		     if ^devtab.broken then		/* If not already broken ... */
     1322 			if quentry.type ^= TEST then
     1323 			     call syserr (BEEP, "^a: ^a requires intervention.", ME, disk_name (SINGLE));
     1324 		     devtab.broken = "1"b;		/* Break the device altogether. */
     1325 		     call set_pvte_inop (ON);
     1326 		     devtab.was_broken = "0"b;
     1327 		     devtab.inop = "0"b;		/* And clear this flag. */
     1328 		     devtab.time_inop = clock ();	/* Note the current time. */
     1329 
     1330 		     errflags.device_inoperative = "1"b;/* Set error code. */
     1331 		     post_sw = "1"b;		/* Going to post this as error. */
     1332 		end;
     1333 
     1334 		else if tc_data$system_shutdown = 0 then do;
     1335 						/* Device was not previously inoperative. */
     1336 		     devtab.inop = "1"b;		/* Mark it as inoperative. */
     1337 		     disktab.dev_busy = disktab.dev_busy | dev_mask (pdi);
     1338 						/* Mark as busy to prevent further use. */
     1339 		     devtab.time_inop = clock ();	/* Note the current time. */
     1340 		     call add_wq;			/* Place request at tail of queue. */
     1341 		end;
     1342 
     1343 		else do;				/* If during shutdown ... */
     1344 		     if quentry.type = TEST then
     1345 			call set_pvte_inop (ON);
     1346 		     errflags.device_inoperative = "1"b;
     1347 		     post_sw = "1"b;		/* Post this fact without further ado. */
     1348 		end;
     1349 	     end;
     1350 	     else if disk_error_interp.bad_addr then do;	/* If disk address is no good ... */
     1351 		if write_map (quentry.type) then	/* If writing ... */
     1352 		     errflags.reassign_address = "1"b;	/* Try another disk address. */
     1353 		else				/* If reading ... */
     1354 		     errflags.seg_unusable = "1"b;	/* Mark segment as unusable. */
     1355 		post_sw = "1"b;			/* Post this as error. */
     1356 	     end;
     1357 
     1358 	     else if disk_error_interp.bad_path then do;	/* If error indicates a bad channel or controller ... */
     1359 		if chantab.inop then do;		/* If channel previously in trouble ... */
     1360 		     chantab.broken = "1"b;
     1361 		     chantab.inop = "0"b;
     1362 		end;
     1363 		else do;				/* If channel just started to act up ... */
     1364 		     chantab.inop = "1"b;		/* Mark channel inoperative. */
     1365 		     chantab.connect_time = clock ();	/* Record the time. */
     1366 		end;
     1367 
     1368 		if disktab.channels_online > 1 then do;
     1369 		     call syserr (BEEP, "^a: Removing channel ^a.", ME, chantab.chanid);
     1370 		     chantab.in_use = "0"b;
     1371 		     disktab.channels_online = disktab.channels_online - 1;
     1372 		end;
     1373 		else do;
     1374 		     if bootload_sw then do;		/* for this type I/O, give up. */
     1375 			errflags.all_paths_bad = "1"b;
     1376 			post_sw = "1"b;
     1377 		     end;
     1378 		     else if io_type = TEST then do;
     1379 			call set_pvte_inop (ON);	/* effectively inop */
     1380                               if (tc_data$system_shutdown ^= 0) then do;
     1381                                   post_sw = "1"b;
     1382                                   errflags.device_inoperative = "1"b;
     1383                                   errflags.all_paths_bad = "1"b;
     1384                                   return;
     1385                               end;
     1386 
     1387 		     end;
     1388 		     else if tc_data$system_shutdown ^= 0 then do;
     1389 			errflags.device_inoperative = "1"b;
     1390 						/* effectively inop */
     1391 			errflags.all_paths_bad = "1"b;
     1392 			post_sw = "1"b;
     1393 		     end;
     1394 		     else do;			/* Just keep trying. */
     1395 			chantab.erct = 0;
     1396 			chantab.inop = "0"b;
     1397 			call connect (addr (chantab.scdcw));
     1398 		     end;
     1399 
     1400 /* Every polling time re-ready channel entries for another try.  This way we
     1401*   are not stuck with just the last channel. */
     1402 
     1403 		     do i = 1 to disktab.nchan;
     1404 			lcp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
     1405 			if ^(lcp -> chantab.ioi_use) then do;
     1406 						/* If channel really belongs to disk dim (not ioi or deleted) */
     1407 			     if (lcp -> chantab.connect_time + CHANNEL_POLLING_TIME < clock ())
     1408 				| post_sw /* time to give up */ then do;
     1409 						/* time to open up */
     1410 
     1411 				lcp -> chantab.broken = "0"b;
     1412 						/* not broken */
     1413 				lcp -> chantab.inop = "0"b;
     1414 						/* operative */
     1415 				lcp -> chantab.erct = 0;
     1416 						/* no errors */
     1417 				lcp -> chantab.active = "0"b;
     1418 						/* not active */
     1419 
     1420 				lcp -> chantab.in_use = "1"b;
     1421 
     1422 /* can use */
     1423 				lcp -> chantab.connect_time = clock ();
     1424 				disktab.channels_online = disktab.channels_online + 1;
     1425 
     1426 			     end;
     1427 			end;
     1428 		     end;
     1429 		     return;
     1430 		end;
     1431 
     1432 		post_sw = "0"b;			/* Don't post this operation. */
     1433 		call add_wq;			/* Requeue the operation. */
     1434 
     1435 /* We should like to call call_run here, but this is indefinitely recursive. */
     1436 
     1437 
     1438 		do i = 1 to disktab.nchan;		/* Iterate thru all channels. */
     1439 		     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
     1440 						/* Find an idle channel */
     1441 		     if chantab.in_use & ^chantab.active then do;
     1442 			call getwork;
     1443 			return;
     1444 		     end;
     1445 		end;
     1446 	     end;
     1447 	     else if disk_error_interp.bad_mem then do;	/* Too bad, core lost. */
     1448 		errflags.fatal_error = "1"b;
     1449 		errflags.memory_unusable = "1"b;
     1450 		post_sw = "1"b;
     1451 	     end;
     1452 	     else do;				/* Very random error. */
     1453 		errflags.fatal_error = "1"b;
     1454 		post_sw = "1"b;			/* Tell _s_o_m_ebody. */
     1455 	     end;
     1456 
     1457 	     return;
     1458 
     1459 
     1460 	end handle_error;
     1461 
     1462      end check_stat;
     1463 
     1464 /* GETWORK - Look for more work to keep channel busy. */
     1465 
     1466 getwork:
     1467      proc;
     1468 
     1469 	if ^chantab.in_use then
     1470 	     return;				/* chnl ^in use. */
     1471 
     1472 	if ^disktab.dev_busy & disktab.dev_queued = "0"b then
     1473 	     return;				/* no work to do */
     1474 
     1475 /* Scan drives in sequence to determine one which needs service. */
     1476 
     1477 	do dev_count = lbound (disktab.devtab, 1) to hbound (disktab.devtab, 1);
     1478 	     disktab.dev_index = disktab.dev_index + 1;	/* drive to check */
     1479 	     if disktab.dev_index > hbound (disktab.devtab, 1) then
     1480 		disktab.dev_index = lbound (disktab.devtab, 1);
     1481 
     1482 	     dev = disktab.dev_index;
     1483 	     pdi = disktab.devtab (dev).pdi;
     1484 
     1485 	     if ^disktab.dev_busy & dev_mask (pdi) then do;
     1486 						/* If primary device free */
     1487 		dp = addr (disktab.devtab (pdi));	/* Get pointer to primary device info table. */
     1488 		if ^devtab.broken			/* Device usable */
     1489 		     then
     1490 		     if devtab.wq.depth > 0		/* work to do */
     1491 		     then do;
     1492 			qp = ptr (disksp, devtab.wq.head);
     1493 
     1494 /* If only one element in queue, then we are as optimal as you get. */
     1495 /* Stagnation control.  Head of queue is oldest request.  If it is older than
     1496*   disk_data.stagnate_time then we optimize with disk combing. */
     1497 
     1498 			if devtab.wq.depth > 1 then
     1499 			     if quentry.time >= (clock () - disk_data.stagnate_time) then
     1500 				call find_shortest_seek;
     1501 			     else call comb;	/* stagnation */
     1502 
     1503 			call del_q;		/* Remove from queue. */
     1504 			go to xfer_join;
     1505 		     end;
     1506 	     end;
     1507 	end;
     1508 
     1509 	return;					/* Nothing to do, so just return. */
     1510 
     1511 /* FIND_SHORTEST_SEEK - Procedure to Get Request Closest to Current Arm Position. */
     1512 
     1513 find_shortest_seek:
     1514 	proc;
     1515 
     1516 dcl	(
     1517 	best_seek,				/* best nearest seek */
     1518 	this_seek					/* seek distance for comparison */
     1519 	)		   float bin (27),
     1520 	(
     1521 	best_pos_comb,				/* best pos comb */
     1522 	best_neg_comb,				/* best neg comb */
     1523 	this_comb					/* seek distance for comparison */
     1524 	)		   fixed bin (35),
     1525 	best_qp		   ptr,			/* pointer to best request */
     1526 	best_neg_qp	   ptr,			/* best neg comb */
     1527 	type		   fixed bin;		/* type of this request */
     1528 
     1529 	     cylinder = devtab.cylinder;
     1530 	     best_seek = 1.0e+30;			/* maximum */
     1531 
     1532 /* Get type of queue entry to locate fraction and multipliers.  Determine
     1533*   Logical Seek Length for Nearest-Seek calculations. */
     1534 
     1535 seek_loop:
     1536 	     type = quentry.type;
     1537 	     this_seek = float (abs (quentry.cylinder - cylinder) * devtab.opt_info (type).multiplier);
     1538 	     if this_seek = 0.0 then
     1539 		goto seek_on_cylinder;		/* ON-CYLINDER */
     1540 
     1541 	     if this_seek < best_seek then do;		/* pick best */
     1542 		best_seek = this_seek;
     1543 		best_qp = qp;
     1544 	     end;
     1545 
     1546 /* Step to next queue entry as we scan the queue. */
     1547 
     1548 	     qrp = quentry.next;
     1549 	     if qrp = "0"b then
     1550 		goto seek_found;			/* we have best */
     1551 
     1552 	     qp = ptr (disksp, qrp);			/* pointer to entry. */
     1553 	     goto seek_loop;
     1554 
     1555 
     1556 seek_found:
     1557 	     qp = best_qp;				/* pick up best .. */
     1558 seek_on_cylinder:					/* qp -> entry */
     1559 	     qrp = rel (qp);
     1560 	     return;
     1561 
     1562 /* Combing optimization eliminates possible IO stagnation by moving the head
     1563*   in and out continuously in a combing motion. */
     1564 
     1565 comb:
     1566 	entry;
     1567 
     1568 	     devtab.comb = devtab.comb + 1;
     1569 	     cylinder = devtab.cylinder;
     1570 	     best_pos_comb = 34359738367;
     1571 	     best_neg_comb = -34359738367;
     1572 
     1573 /* Attempt to maintain direction by appropriately setting comparison order
     1574*   between this cylinder and the current cylinder. */
     1575 
     1576 comb_loop:
     1577 	     if devtab.forward then
     1578 		this_comb = quentry.cylinder - cylinder;
     1579 	     else this_comb = cylinder - quentry.cylinder;
     1580 
     1581 	     if this_comb = 0 then			/* ON-CYLINDER */
     1582 		goto seek_on_cylinder;		/* Pick this one */
     1583 	     else if this_comb > 0			/* same direction */
     1584 	     then do;
     1585 		if this_comb < best_pos_comb then do;
     1586 		     best_pos_comb = this_comb;
     1587 		     best_qp = qp;
     1588 		end;
     1589 	     end;
     1590 	     else do;				/* reverse direction */
     1591 		if this_comb > best_neg_comb then do;
     1592 		     best_neg_comb = this_comb;
     1593 		     best_neg_qp = qp;
     1594 		end;
     1595 	     end;
     1596 
     1597 	     qrp = quentry.next;
     1598 	     if qrp = "0"b then
     1599 		goto comb_found;			/* search complete */
     1600 	     qp = ptr (disksp, qrp);
     1601 	     goto comb_loop;
     1602 
     1603 
     1604 comb_found:
     1605 	     if best_pos_comb ^= 34359738367 then	/* if we found forward. */
     1606 		qp = best_qp;			/* pick up best .. */
     1607 	     else qp = best_neg_qp;
     1608 	     qrp = rel (qp);
     1609 	     return;
     1610 	end find_shortest_seek;
     1611 
     1612 /* GOTWORK - Found queue entry.  Start the I/O. */
     1613 
     1614 /* Presumes
     1615*   dp -> devtab(pdi)	Current devtab for this request's pdi.
     1616*   qp -> quentry		Quentry which has request to connect.
     1617*   cp -> chantab		Current channel table to connect request to.
     1618**/
     1619 
     1620 gotwork:
     1621      entry;
     1622 
     1623 xfer_join:
     1624 	if ^quentry.used then			/* This must never happen. */
     1625 	     call syserr (CRASH, "^a: Queuing error.", ME);
     1626 
     1627 	chantab.qrp = rel (qp);			/* Save queue entry index for later. */
     1628 	chantab.erct = 0;				/* Clear the retry error count. */
     1629 	chantab.reconnect_announce_time = 0;		/* force first reconnect to be announced */
     1630 
     1631 	dev = quentry.dev;				/* extract device */
     1632 
     1633 	if quentry.type = TEST then do;
     1634 	     idcwp = addr (chantab.rssdcw);		/* Get pointer to RSS. */
     1635 	     idcw.command = substr (quentry.coreadd, 19, 6);
     1636 	     idcw.device = bit (dev);			/* Set device address. */
     1637 
     1638 /* Count TEST or UNLOAD calls. */
     1639 
     1640 	     optp = addr (disktab.devtab (dev).opt_info (quentry.type));
     1641 	     if bin (quentry.coreadd, 24) = 58 then
     1642 		opt_info.seek_sum = opt_info.seek_sum + 1;
     1643 						/* UNLOAD */
     1644 	     else opt_info.seek_count = opt_info.seek_count + 1;
     1645 						/* TEST */
     1646 
     1647 
     1648 	     call connect (idcwp);			/* Get device status. */
     1649 	end;
     1650 
     1651 	else do;					/* Normal seek op - */
     1652 	     dcdcwp = addr (chantab.dcdcw);		/* Get pointer to data xfer IDCW. */
     1653 	     dddcwp = addr (chantab.dddcw);		/* Get pointer to data xfer DCW. */
     1654 	     idcwp = addr (chantab.scdcw);		/* Get pointer to SEEK or RSS IDCW. */
     1655 
     1656 	     idcw.device = bit (dev);			/* Set device address */
     1657 
     1658 	     unspec (dcdcwp -> idcw) = "0"b;		/* clear idcw */
     1659 	     dcdcwp -> idcw.code = IDCW;
     1660 	     dcdcwp -> idcw.ext_ctl = "1"b;
     1661 	     if write_map (quentry.type) then		/* set data transfer direction */
     1662 		dcdcwp -> idcw.command = WRITE;
     1663 	     else dcdcwp -> idcw.command = READ;
     1664 
     1665 	     dcdcwp -> idcw.ext = substr (quentry.coreadd, 1, length (idcw.ext));
     1666 						/* Set address extension in IDCW. */
     1667 	     dddcwp -> dcw.address = substr (quentry.coreadd, 7);
     1668 						/* Set DCW address. */
     1669 	     dcdcwp -> idcw.device = bit (dev);		/* Set up device address */
     1670 						/* idcw.chan_cmd = "00"b3 is ok, = data xfer */
     1671 
     1672 
     1673 	     chantab.select_data.sector = quentry.sector; /* set disk sector address */
     1674 						/* At this point the check is made for the type of seek (512 or 64) */
     1675 	     if idcw.command = seek_512 then do;	/* sector size is 512 */
     1676 		if quentry.type = VTOC_READ | quentry.type = VTOC_WRITE then do;
     1677 		     dddcwp -> dcw.tally = bit (bin (192, 12));
     1678 		     chantab.select_data.limit = bit (bin (1, 12));
     1679 		end;
     1680 		else if quentry.type = PAGE_READ | quentry.type = PAGE_WRITE then do;
     1681 		     dddcwp -> dcw.tally = bit (bin (1024, 12));
     1682 		     chantab.select_data.limit = bit (bin (2, 12));
     1683 		end;
     1684 		else if sector_map (quentry.type) then do;
     1685 		     dddcwp -> dcw.tally = bit (bin ((512 * quentry.n_sectors), 12));
     1686 		     chantab.select_data.limit = bit (bin (quentry.n_sectors, 12));
     1687 		end;
     1688 	     end;
     1689 	     else do;				/* sector size must be 64 */
     1690 		if sector_map (quentry.type) then do;	/* If 64-word I/O ... */
     1691 		     dddcwp -> dcw.tally = bit (bin (64 * quentry.n_sectors, 12));
     1692 						/* Set DCW tally. */
     1693 		     chantab.select_data.limit = bit (bin (quentry.n_sectors, 12));
     1694 						/* Set sector count limit. */
     1695 		end;
     1696 		else do;				/* If 1024-word I/O ... */
     1697 		     dddcwp -> dcw.tally = bit (bin (1024, 12));
     1698 						/* Set DCW tally. */
     1699 		     chantab.select_data.limit = bit (bin (16, 12));
     1700 						/* Set sector count limit. */
     1701 		end;
     1702 	     end;
     1703 
     1704 	     call connect (addr (chantab.scdcw));	/* Start up the channel. */
     1705 
     1706 /* find opt_info */
     1707 
     1708 	     optp = addr (disktab.devtab (dev).opt_info (quentry.type));
     1709 	     cylinder = devtab.cylinder - quentry.cylinder;
     1710 	     devtab.cylinder = quentry.cylinder;
     1711 
     1712 /* Determine direction of seek.  If going low cylinder to high, then
     1713*   devtab.forward is set true, if going  high to low it is set false.  If
     1714*   we stay on-cylinder, then we leave the direction as what it was. */
     1715 /* We use this information to maintain combing. */
     1716 
     1717 	     if cylinder > 0			/* Backward comb */
     1718 		then
     1719 		devtab.forward = "0"b;
     1720 	     else if cylinder < 0			/* Forward comb */
     1721 		then
     1722 		devtab.forward = "1"b;
     1723 
     1724 	     opt_info.seek_sum = opt_info.seek_sum + abs (cylinder);
     1725 	     opt_info.seek_count = opt_info.seek_count + 1;
     1726 	end;
     1727      end getwork;
     1728 
     1729 /* CONNECT - Start Up the Channel. */
     1730 
     1731 connect:
     1732      procedure (listp);
     1733 
     1734 dcl	listp		   ptr parameter;
     1735 dcl	1 ima		   aligned like io_manager_arg;
     1736 
     1737 	ima.chx = chantab.chx;
     1738 	ima.pcw = ""b;
     1739 	ima.ptp = null ();
     1740 	ima.listp = listp;
     1741 	call io_manager$connect_abs (ima);		/* Fire up the channel. */
     1742 						/* Fire up the channel. */
     1743 	chantab.connects = chantab.connects + 1;	/* Keep count of number of connects */
     1744 	chantab.active = "1"b;			/* Indicate channel now active */
     1745 	chantab.connect_time = clock ();		/* set time of connect */
     1746 
     1747 	disktab.dev_busy = disktab.dev_busy | dev_mask (pdi);
     1748 						/* Indicate primary device now busy. */
     1749 
     1750 	return;
     1751 
     1752 
     1753      end connect;
     1754 
     1755 
     1756 
     1757 /* POST - Notify system of completed operation. */
     1758 
     1759 post:
     1760      proc;
     1761 
     1762 	if /* case */ io_type = TEST then do;
     1763 
     1764 /*  test results have been indicated by this time. */
     1765 	     post_sw = "0"b;
     1766 	     return;
     1767 	end;
     1768 
     1769 
     1770 	if sect_sw then				/* If 64-word I/O ... */
     1771 	     if bootload_sw then
     1772 		call bootload_disk_post (coreadd, errcd);
     1773 	     else call vtoc_interrupt (coreadd, errcd);
     1774 	else					/* If page I/O ... */
     1775 	     call page$done (coreadd, errcd);
     1776 
     1777 	post_sw = "0"b;				/* Clear switch to prevent double posting. */
     1778 
     1779 	return;
     1780 
     1781 
     1782      end post;
     1783 
     1784 /* queue_length_given_pvtx - that says it all */
     1785 
     1786 queue_length_given_pvtx:
     1787      entry (a_pvtx, a_queue_length);
     1788 
     1789 	pvtep = addr (addr (pvt$array) -> pvt_array (a_pvtx));
     1790 						/* PVTE for this device */
     1791 	pvtdip = addr (pvte.dim_info);		/* Get pointer to DIM info */
     1792 	sx = pvtdi.sx;				/* Extract index for this disk subsystem */
     1793 
     1794 	call setup;				/* Get pointers to databases */
     1795 
     1796 	dev = pvte.logical_area_number;		/* Device number */
     1797 	pdi = disktab.devtab (dev).pdi;		/* Primary device number */
     1798 	dp = addr (disktab.devtab (pdi));		/* Get pointer to info for primary device */
     1799 
     1800 	a_queue_length = devtab.wq.depth;		/* current amount queued */
     1801 
     1802 	return;
     1803 
     1804 /* TUNING control.  Externally accessible entry with which to setup tuning
     1805*   parameters in disk_seg.  It ensures valid parameters. */
     1806 
     1807 tune:
     1808      entry (a_op, a_ptr, reason, ec);
     1809 
     1810 dcl	a_op		   char (*);		/* type of tuning */
     1811 dcl	a_ptr		   ptr;			/* pointer to structure */
     1812 dcl	reason		   char (*) varying;	/* textual description of error */
     1813 dcl	ec		   fixed bin (35);
     1814 
     1815 dcl	stagnate_time	   fixed bin (35) based (cptr);
     1816 						/* for setting time */
     1817 dcl	response		   fixed bin (35);
     1818 dcl	load		   fixed bin;
     1819 dcl	cptr		   ptr;
     1820 dcl	op		   char (16);
     1821 
  1     1 /* Begin include file ...... disk_tune.incl.pl1 84-05-16 */
  1     2 /* Structures used for passing tuning information to disk_control$tune. */
  1     3 
  1     4 /* Structure for sys_info operation. */
  1     5 
  1     6 /* type      - indicates which system information IO type is to be altered.
  1     7*   max_depth - is the maximum depth permissible before full optimizaiton. 
  1     8*   map	   - is the depth counter to utilize for determining depth.
  1     9**/
  1    10 
  1    11      dcl	   1 sys_info_tune	      aligned based,
  1    12 	     2 type	      fixed bin,
  1    13 	     2 max_depth	      fixed bin (35),
  1    14 	     2 map	      fixed bin;
  1    15 
  1    16      dcl	   SYS_TUNE	      char (8) static options (constant) initial ("sys_tune");
  1    17 
  1    18 /* Structure for optimizer tuning. */
  1    19 
  1    20 /* type	  - indicates which IO type is to be tuned.
  1    21*   sub_sys  - indicates which sub-system is to be tuned.
  1    22*   dev 	  - indicates the drive within the sub-system.
  1    23*   response - is the multiplier for maximum response.
  1    24*   load	  - is the fully optimized load point.
  1    25**/
  1    26 
  1    27      dcl	   1 opt_info_tune	      aligned based,
  1    28 	     2 type	      fixed bin,
  1    29 	     2 sub_sys	      char (4),
  1    30 	     2 dev	      fixed bin,
  1    31 	     2 response	      fixed bin (35),
  1    32 	     2 load	      fixed bin;
  1    33 
  1    34      dcl	   OPT_TUNE	      char (8) static options (constant) initial ("opt_tune");
  1    35      dcl	   STAGNATE_TIME	      char (8) static options (constant)
  1    36 			      initial ("stagnate");
  1    37      dcl	   RESET_SYS	      char (9) static options (constant)
  1    38 			      initial ("reset_sys");	/* reset sys_info.depth's */
  1    39      dcl	   RESET_MAX	      char (9) static options (constant)
  1    40 			      initial ("reset_max");	/* reset max_depth's */
  1    41 
  1    42 /* Define character array matching io_types. */
  1    43 
  1    44      dcl	   MAX_IO_NAME	      fixed bin static options (constant) initial (5);
  1    45 
  1    46      dcl	   io_name	      (0:4) char (10) static options (constant)
  1    47 			      initial ("page_read", "page_write", "vtoc_read", "vtoc_write", "test");
  1    48 
  1    49 /* Define error code type names. */
  1    50 
  1    51      dcl	   code_names	      (6) char (32) static options (constant)
  1    52 			      initial ("stagnate time range",
  1    53 			      "invalid IO TYPE",
  1    54 			      "invalid map IO TYPE",
  1    55 			      "unknown sub-system",
  1    56 			      "invalid device number",
  1    57 "response < 1");
  1    58 
  1    59 /* End of include file ...... disk_tune.incl.pl1 */
     1822 
     1823 
     1824 	disksp = addr (disk_seg$);
     1825 	cptr = a_ptr;
     1826 	op = a_op;
     1827 
     1828 	if op = STAGNATE_TIME then do;		/* limit 6 min. */
     1829 	     if stagnate_time > 360000000 | stagnate_time < 0 then do;
     1830 		if stagnate_time < 0 then
     1831 		     reason = "stagnate time must be >= 0";
     1832 		else reason = "stagname time must be <= 6 minutes";
     1833 		ec = error_table_$bad_arg;
     1834 		return;
     1835 	     end;
     1836 	     else disk_data.stagnate_time = a_ptr -> stagnate_time;
     1837 	end;
     1838 	else if op = SYS_TUNE then do;
     1839 	     io_type = cptr -> sys_info_tune.type;
     1840 	     if io_type < 0 | io_type > MAX_IO_TYPE then
     1841 		goto bad_io_type;
     1842 
     1843 	     sysp = addr (disk_data.sys_info (io_type));
     1844 
     1845 	     if cptr -> sys_info_tune.map > MAX_IO_TYPE then
     1846 		goto bad_map_type;
     1847 
     1848 /* if map is positive, then we update counter mapping. */
     1849 
     1850 	     if cptr -> sys_info_tune.map >= 0 then
     1851 		sys_info.depth_map = rel (addr (disk_data.sys_info (cptr -> sys_info_tune.map)));
     1852 
     1853 /* if max_depth is > 1 then we update it.  If 0 we would divide by 0. */
     1854 
     1855 	     if cptr -> sys_info_tune.max_depth > 0 then
     1856 		sys_info.max_depth = float (cptr -> sys_info_tune.max_depth);
     1857 	end;
     1858 	else if op = OPT_TUNE then do;
     1859 	     io_type = cptr -> opt_info_tune.type;
     1860 	     if io_type < 0 | io_type > MAX_IO_TYPE then
     1861 		goto bad_io_type;
     1862 
     1863 	     do sx = 1 to disk_data.subsystems;
     1864 		if cptr -> opt_info_tune.sub_sys = disk_data.array (sx).name then
     1865 		     goto tune_sub_sys;
     1866 	     end;
     1867 	     goto bad_io_sub_sys;
     1868 
     1869 tune_sub_sys:
     1870 	     call setup;				/* locate disktab */
     1871 	     dev = cptr -> opt_info_tune.dev;
     1872 	     if dev < lbound (disktab.devtab, 1) | dev > hbound (disktab.devtab, 1) then
     1873 		goto bad_io_dev;
     1874 
     1875 	     pdi = disktab.devtab (dev).pdi;		/* only tune pdi */
     1876 	     if pdi ^= dev then
     1877 		goto bad_io_dev;
     1878 
     1879 	     response = cptr -> opt_info_tune.response;
     1880 	     if response < 1 then
     1881 		goto response_range;
     1882 	     load = cptr -> opt_info_tune.load;
     1883 
     1884 	     optp = addr (disktab.devtab (pdi).opt_info (io_type));
     1885 	     if load > 1 then do;
     1886 		opt_info.slope = float (response - 1) / float (load - 1);
     1887 		opt_info.intercept = float ((response * load) - 1) / float (load - 1);
     1888 	     end;
     1889 	     else do;
     1890 		opt_info.slope = 0.0;
     1891 		opt_info.intercept = float (response);
     1892 	     end;
     1893 	end;
     1894 	else if op = RESET_SYS then do;
     1895 	     do i = 0 to MAX_IO_TYPE;			/* sys_info.depth's */
     1896 		disk_data.sys_info (i).depth = 0;
     1897 	     end;
     1898 	end;
     1899 	else if op = RESET_MAX then do;
     1900 	     disk_data.max_depth_reset_time = clock ();
     1901 	     disk_data.free_q.max_depth = 0;
     1902 	     do i = 1 to disk_data.subsystems;		/* each sub-sys */
     1903 		diskp = ptr (disksp, disk_data.array (i).offset);
     1904 		disktab.wq.max_depth = 0;
     1905 	     end;
     1906 	end;
     1907 	reason = "";
     1908 	ec = 0;
     1909 	return;
     1910 
     1911 bad_io_type:
     1912 	reason = "invalid I/O type";
     1913 	ec = error_table_$bad_arg;
     1914 	return;
     1915 
     1916 bad_map_type:
     1917 	reason = "invalid map I/O type";
     1918 	ec = error_table_$bad_arg;
     1919 	return;
     1920 
     1921 bad_io_sub_sys:
     1922 	reason = "unknown subsystem";
     1923 	ec = error_table_$bad_arg;
     1924 	return;
     1925 
     1926 bad_io_dev:
     1927 	reason = "invalid device number";
     1928 	ec = error_table_$bad_arg;
     1929 	return;
     1930 
     1931 response_range:
     1932 	reason = "response value must be >= 1";
     1933 	ec = error_table_$bad_arg;
     1934 	return;
     1935 
     1936 /* SETUP - Internal Procedure to set data base pointers. */
     1937 
     1938 setup:
     1939      proc;
     1940 
     1941 
     1942 	disksp = addr (disk_seg$);			/* Get a pointer to disk data segment. */
     1943 	pvt_arrayp = addr (pvt$array);		/* Get a pointer to the PVT array. */
     1944 	diskp = ptr (disksp, disk_data.offset (sx));	/* Get pointer to info for this subsystem. */
     1945 
     1946 	return;
     1947 
     1948 
     1949      end setup;
     1950 
     1951 
     1952 
     1953 /* DISK_NAME - Internal Procedure to generate name of disk drive. */
     1954 
     1955 disk_name:
     1956      proc (both) returns (char (21) aligned);
     1957 
     1958 dcl	both		   bit (1) aligned;
     1959 dcl	pic99		   pic "99";
     1960 dcl	this_name		   char (8);
     1961 dcl	other_name	   char (12);
     1962 dcl	other_dev		   fixed bin;
     1963 
     1964 
     1965 	if dev = pdi				/* If this is the priamry, we must rely on buddy */
     1966 	     then
     1967 	     other_dev = disktab.devtab (pdi).buddy;
     1968 	else other_dev = pdi;
     1969 
     1970 	this_name = disk_data.name (sx) || "_" || convert (pic99, dev);
     1971 	if other_dev = 0 then
     1972 	     other_name = "";
     1973 	else other_name = " and " || disk_data.name (sx) || "_" || convert (pic99, other_dev);
     1974 
     1975 	if both					/* return both device names, if appropriate */
     1976 	     then
     1977 	     return (this_name || other_name);
     1978 	else return (this_name);
     1979 
     1980 
     1981      end disk_name;
     1982 
     1983 
     1984 /* LOCK/UNLOCK - Internal Procedures to Lock & Unlock Disk Database. */
     1985 
     1986 lock:
     1987      proc (lmp);
     1988 
     1989 dcl	1 dlm		   like disk_lock_meters based (lmp) aligned,
     1990 						/* database lock meters */
     1991 	lmp		   ptr;
     1992 
     1993 
     1994 	dlm.count = dlm.count + 1;			/* Count locking attempt. */
     1995 	if ^stacq (disktab.lock, pds$processid, UNLOCK) then do;
     1996 						/* Attempt to lock database. */
     1997 	     call lock_meter_start (lmp);
     1998 	     do while (^stacq (disktab.lock, pds$processid, UNLOCK));
     1999 	     end;					/* Lock the disk data base. */
     2000 	     call lock_meter_stop (lmp);
     2001 	end;
     2002 
     2003 	return;
     2004 
     2005 
     2006 unlock:
     2007      entry;
     2008 
     2009 	if ^stacq (disktab.lock, UNLOCK, disktab.lock) then
     2010 	     ;					/* Unlock the data base. */
     2011 
     2012 	return;
     2013 
     2014 
     2015      end lock;
     2016 
     2017 
     2018 
     2019 /* LOCK_METER_START / LOCK_METER_STOP - Metering Procedures. */
     2020 
     2021 lock_meter_start:
     2022      proc (lmp);
     2023 
     2024 dcl	1 dlm		   like disk_lock_meters based (lmp) aligned,
     2025 	lmp		   ptr;
     2026 
     2027 
     2028 	meter_start_time = clock ();			/* Get time now. */
     2029 	dlm.waits = dlm.waits + 1;			/* Count a wait. */
     2030 
     2031 	return;
     2032 
     2033 
     2034 lock_meter_stop:
     2035      entry (lmp);
     2036 
     2037 	dlm.wait_time = dlm.wait_time + (clock () - meter_start_time);
     2038 						/* Meter time spent waiting. */
     2039 	return;
     2040 
     2041 
     2042      end lock_meter_start;
     2043 
     2044 /* GET_FREE_Q - Get a Queue Entry from the Free List. */
     2045 
     2046 get_free_q:
     2047      proc returns (bit (1) aligned);
     2048 
     2049 dcl	type		   fixed bin;
     2050 
     2051 /* SPIN-LOCK til queue available. */
     2052 
     2053 	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
     2054 	end;
     2055 
     2056 	qrp = disk_data.free_q.head;			/* Get rel ptr to head of free queue. */
     2057 	if qrp then do;				/* queue ^empty */
     2058 	     qp = ptr (disksp, qrp);			/* entry pointer */
     2059 	     disk_data.free_q.head = quentry.next;	/* new Q head */
     2060 
     2061 /* if queue is now empty ground the tail, else ground our next's previous */
     2062 
     2063 	     if disk_data.free_q.head = "0"b then
     2064 		disk_data.free_q.tail = "0"b;
     2065 	     else ptr (disksp, quentry.next) -> quentry.prev = "0"b;
     2066 
     2067 /* Compile queue statistics.  Depth is really depth assigned from free_q. */
     2068 
     2069 	     disk_data.free_q.sum = disk_data.free_q.sum + disk_data.free_q.depth;
     2070 	     disk_data.free_q.depth = disk_data.free_q.depth + 1;
     2071 	     if disk_data.free_q.depth > disk_data.free_q.max_depth then
     2072 		disk_data.free_q.max_depth = disk_data.free_q.depth;
     2073 	     disk_data.free_q.count = disk_data.free_q.count + 1;
     2074 
     2075 	     if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
     2076 		;				/* Unlock the database */
     2077 	     return (SUCCESS);
     2078 	end;
     2079 	else do;					/* If queue is empty ... */
     2080 	     if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
     2081 		;				/* Unlock the database */
     2082 	     return (FAILURE);
     2083 	end;
     2084 
     2085 /* ADD_FREE_Q - Add Entry to End of Free Queue. */
     2086 
     2087 add_free_q:
     2088      entry;
     2089 
     2090 	quentry.used = "0"b;			/* Queue entry is no longer in use. */
     2091 
     2092 /* SPIN-LOCK til queue is available to add free entry to it. */
     2093 
     2094 	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
     2095 	end;					/* lock database */
     2096 
     2097 /* If queue is ^empty, then add to tail, else create head and tail to element. */
     2098 
     2099 	if disk_data.free_q.tail ^= "0"b then
     2100 	     ptr (disksp, disk_data.free_q.tail) -> quentry.next = qrp;
     2101 	else disk_data.free_q.head = qrp;
     2102 
     2103 	quentry.prev = disk_data.free_q.tail;		/* link to prev */
     2104 	disk_data.free_q.tail = qrp;			/* New tail */
     2105 	quentry.next = "0"b;			/* clear next ptr. */
     2106 
     2107 /* Indicate element returned from system. */
     2108 
     2109 	disk_data.free_q.depth = disk_data.free_q.depth - 1;
     2110 
     2111 	if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
     2112 	     ;					/* Unlock the database */
     2113 	return;
     2114 
     2115 /* ADD_WQ - Add Entry to End of Work Queue. */
     2116 
     2117 add_wq:
     2118      entry;
     2119 
     2120 /* Indicate requests queued for device. */
     2121 /* If queue is not empty, then add to tail, else create queue. */
     2122 
     2123 	disktab.dev_queued = disktab.dev_queued | dev_mask (pdi);
     2124 	if devtab.wq.tail ^= "0"b then
     2125 	     ptr (disksp, devtab.wq.tail) -> quentry.next = qrp;
     2126 	else devtab.wq.head = qrp;
     2127 
     2128 	quentry.prev = devtab.wq.tail;
     2129 	quentry.next = "0"b;
     2130 	devtab.wq.tail = qrp;
     2131 
     2132 /* Compile queue statistics. */
     2133 
     2134 	devtab.wq.sum = devtab.wq.sum + devtab.wq.depth;
     2135 	devtab.wq.depth = devtab.wq.depth + 1;
     2136 	if devtab.wq.depth > devtab.wq.max_depth then
     2137 	     devtab.wq.max_depth = devtab.wq.depth;
     2138 	devtab.wq.count = devtab.wq.count + 1;
     2139 
     2140 /* Compile system loading statistics.
     2141*   Find map of counter to be used. */
     2142 
     2143 	type = quentry.type;
     2144 	sysp = addr (disk_data.sys_info (type));
     2145 	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
     2146 	end;
     2147 	ptr (disksp, sys_info.depth_map) -> sys_info.depth = ptr (disksp, sys_info.depth_map) -> sys_info.depth + 1.0;
     2148 	optp = addr (devtab.opt_info (type));
     2149 	opt_info.depth = opt_info.depth + 1;
     2150 
     2151 /* Common processing for system IO loading and drive IO loading. */
     2152 
     2153 wq_common:
     2154 	sys_info.fraction =
     2155 	     (sys_info.max_depth - ptr (disksp, sys_info.depth_map) -> sys_info.depth) / sys_info.max_depth;
     2156 	if sys_info.fraction < 0.0 then
     2157 	     sys_info.fraction = 0.0;
     2158 	if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
     2159 	     ;					/* Unlock disk_data. */
     2160 
     2161 /* Compile drive load multiplier for this IO type.  The multiplier cannot drop
     2162*   below 1.0 to give a true PHYSICAL=LOGICAL mapping.  */
     2163 
     2164 	opt_info.multiplier = (opt_info.intercept - float (opt_info.depth) * opt_info.slope) * sys_info.fraction;
     2165 	if opt_info.multiplier < 1.0 then
     2166 	     opt_info.multiplier = 1.0;		/* LIMIT to 1.0 */
     2167 	return;
     2168 
     2169 /* DEL_Q - Delete Item from Queue. */
     2170 
     2171 del_q:
     2172      entry;
     2173 
     2174 /* Remove item from queue, fixing previous and next entries, or head or tail */
     2175 
     2176 	if quentry.prev = "0"b then			/* head is prev */
     2177 	     devtab.wq.head = quentry.next;
     2178 	else ptr (disksp, quentry.prev) -> quentry.next = quentry.next;
     2179 
     2180 	if quentry.next = "0"b then			/* tail is next */
     2181 	     devtab.wq.tail = quentry.prev;
     2182 	else ptr (disksp, quentry.next) -> quentry.prev = quentry.prev;
     2183 
     2184 /* Fix queue statistics.  If queue is empty, indicate this for fast check. */
     2185 
     2186 	devtab.wq.depth = devtab.wq.depth - 1;
     2187 	if devtab.wq.depth <= 0 then
     2188 	     disktab.dev_queued = disktab.dev_queued & ^dev_mask (pdi);
     2189 
     2190 /* Do load statistics, use map of depth accumulator. */
     2191 
     2192 	type = quentry.type;
     2193 	sysp = addr (disk_data.sys_info (type));
     2194 	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
     2195 	end;					/* lock disk_data */
     2196 
     2197 /* prevent possible -ve depth if map is changed on the fly. */
     2198 
     2199 	ptr (disksp, sys_info.depth_map) -> sys_info.depth =
     2200 	     max (0.0, ptr (disksp, sys_info.depth_map) -> sys_info.depth - 1.0);
     2201 
     2202 	optp = addr (devtab.opt_info (type));
     2203 	opt_info.depth = opt_info.depth - 1;
     2204 	go to wq_common;				/* will unlock disk_data */
     2205 
     2206      end get_free_q;
     2207 
     2208 /* set_pvte_inop ...  Internal procedure to deal with pvte.inoperative, notifying
     2209*   the global disk offline event as necessary.  */
     2210 
     2211 set_pvte_inop:
     2212      proc (setting);
     2213 
     2214 dcl	setting		   bit (1) aligned;
     2215 
     2216 
     2217 /* pvtep is set */
     2218 
     2219 	call set (addr (addr (pvt$array) -> pvt_array (devtab.pvtx)));
     2220 						/* Set the first one (^)inop */
     2221 	if devtab.buddy ^= 0			/* Must also do it to the buddy */
     2222 	     then
     2223 	     call set (addr (addr (pvt$array) -> pvt_array (disktab.devtab (devtab.buddy).pvtx)));
     2224 
     2225 set:
     2226 	proc (pvte_ptr);
     2227 
     2228 dcl	pvte_ptr		   ptr;
     2229 
     2230 
     2231 	     if pvte_ptr -> pvte.device_inoperative & ^setting then do;
     2232 		pvte_ptr -> pvte.device_inoperative = "0"b;
     2233 		call pxss$notify (page_fault$disk_offline_event);
     2234 	     end;
     2235 	     else pvte_ptr -> pvte.device_inoperative = setting;
     2236 
     2237 	     return;
     2238 
     2239 
     2240 	end set;
     2241 
     2242      end set_pvte_inop;
     2243 
  2     1 
  2     2 /*  BEGIN INCLUDE FILE ... device_error.incl.pl1 */
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(88-02-23,Farley), approve(88-02-23,MCR7759),
  2     7*     audit(88-02-24,Fawcett), install(88-03-01,MR12.2-1029):
  2     8*     Added all_paths_bad flag.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* Error code produced by disk_control$disk_inter and passed to page control */
  2    13 
  2    14 dcl erfp ptr;
  2    15 
  2    16 dcl 1 errflags based (erfp) aligned,
  2    17    (2 pad bit (29),
  2    18     2 all_paths_bad bit (1),                                /* All paths have been tried and failed */
  2    19     2 memory_unusable bit (1),			/* Main memory frame bad */
  2    20     2 device_inoperative bit (1),			/* device cannot be used */
  2    21     2 reassign_address bit (1),			/* device address cannot be written - try another */
  2    22     2 seg_unusable bit (1),				/* segment cannot be accessed */
  2    23     2 please_repeat_call bit (1),			/* request must be requeued */
  2    24     2 fatal_error bit (1)) unal;			/* all other errors */
  2    25 
  2    26 /*  END INCLUDE FILE ... device_error.incl.pl1 */
  2    27 
     2244 
     2245 
  3     1 /* Begin include file ...... disk_error_interp.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(89-06-23,Farley), approve(89-07-26,MCR8122),
  3     6*     audit(89-09-11,WAAnderson), install(89-09-22,MR12.3-1072):
  3     7*     Added "finterp" and "fnamep" to major status array to allow seperation of
  3     8*     some of the FIPS statuses, due to different processing requirements.
  3     9*     Also added "just_log" flag to substatus entry to allow some errors to
  3    10*     only be logged and not displayed on the console.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 
  3    14 /* last modified 5/19/76 by Noel I. Morris */
  3    15 
  3    16 /* Breakdown of disk error status. */
  3    17 
  3    18 dcl  disk_error_data$ ext;				/* disk error status data segment */
  3    19 
  3    20 dcl  dedp ptr;					/* pointer to major status structure */
  3    21 
  3    22 dcl 1 disk_error_data (0: 23) aligned based (dedp),	/* major status array */
  3    23    (2 interp bit (18),				/* pointer to substatus data for this major status */
  3    24     2 namep bit (18),				/* rel pointer to major status description */
  3    25     2 finterp bit (18),				/* pointer to FIPS substatus data for this major status */
  3    26     2 fnamep bit (18)) unal;				/* rel pointer to FIPS major status description */
  3    27 
  3    28 dcl  dskerap ptr;					/* pointer to substatus array */
  3    29 
  3    30 dcl 1 disk_status_interp_array (100) like disk_error_interp based (dskerap) aligned;
  3    31 						/* array of substatus interpretations */
  3    32 
  3    33 dcl  dskerp ptr;					/* pointer to error interpretation data */
  3    34 
  3    35 dcl 1 disk_error_interp based (dskerp) aligned,		/* substatus interpretation structure */
  3    36    (2 bitson bit (6),				/* substatus bits which must be ON */
  3    37     2 bitmask bit (6),				/* substatus bits which must be checked */
  3    38     2 max_retries fixed bin (5),			/* maximum no. of retries for this error */
  3    39     2 reseek bit (1),				/* "1"b if restore and reseek required */
  3    40     2 rsr bit (1),					/* "1"b if detailed status should be read */
  3    41     2 bad_addr bit (1),				/* "1"b if disk address is defective */
  3    42     2 bad_dev bit (1),				/* "1"b if device is inoperative */
  3    43     2 bad_path bit (1),				/* "1"b if disk data path is defective */
  3    44     2 bad_mem bit (1),				/* "1"b if memory may be defective */
  3    45     2 just_log bit (1),				/* "1"b if error is only to be logged */
  3    46     2 pad1 bit (11),
  3    47     2 namep bit (18),				/* rel pointer to substatus description */
  3    48     2 pad2 bit (18)) unal;
  3    49 
  3    50 dcl  dsdp ptr;					/* pointer to status description */
  3    51 
  3    52 dcl 1 disk_status_descrip based (dsdp) aligned,		/* status description string */
  3    53    (2 lth fixed bin (8),				/* length of string */
  3    54     2 chr char (32 refer (disk_status_descrip.lth))) unal;	/* status description string */
  3    55 
  3    56 /* End of include file ...... disk_error_interp.incl.pl1 */
     2246 
     2247 
  4     1 /* Begin include file ...... dskdcl.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  4     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  4     6*     Support for FIPS dev 0.
  4     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
  4     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
  4     9*     Added reconnect_announce_time to chantab to allow announcement of
  4    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
  4    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 /* Structures used by the Disk DIM */
  4    15 
  4    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
  4    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
  4    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
  4    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
  4    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
  4    21 
  4    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
  4    23 
  4    24 dcl  disk_seg$ ext;					/* disk data segment */
  4    25 
  4    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
  4    27      diskp ptr,					/* pointer to disk DIM info structure */
  4    28      optp ptr,					/* pointer to opt_info */
  4    29      sysp ptr;					/* pointer to sys_info */
  4    30 
  4    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
  4    32        2 subsystems fixed bin,			/* number of subsystems */
  4    33        2 free_offset bit (18),			/* offset of first unused location in segment */
  4    34        2 status_mask bit (36),			/* mask for checking for disk error */
  4    35        2 lock bit (36) unal,				/* disk_data lock */
  4    36        2 free_q like qht,				/* head/tail offsets */
  4    37        2 free_q_size fixed bin,			/* length of queue */
  4    38        2 array (32),				/* per subsystem info */
  4    39          (
  4    40          3 offset bit (18),				/* location of data for this subsystem */
  4    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
  4    42          3 name char (4)
  4    43          ) unal,					/* name of subsystem */
  4    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
  4    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
  4    46        2 pad bit (36),				/* double word align */
  4    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
  4    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
  4    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
  4    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
  4    51 
  4    52 
  4    53 /* The following system table is used to hold the maximum queue loading
  4    54*   permitted system-wide for each IO type.  From the current loading and
  4    55*   the maximum loading a multiplier fraction is calculated.  These combine
  4    56*   to produce the final optimization multiplier to derive a Logcial Seek
  4    57*   from a Physical Seek. */
  4    58 
  4    59 dcl  1 sys_info aligned based (sysp),
  4    60        3 depth float bin (27),			/* current load */
  4    61        3 max_depth float bin (27),			/* max permissible */
  4    62        3 fraction float bin (27),			/* load fraction */
  4    63        3 depth_map bit (18) unaligned,			/* which depth counter */
  4    64        3 pad bit (18) unaligned;
  4    65 
  4    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
  4    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
  4    68*   dctl's use. */
  4    69 
  4    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
  4    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
  4    72 
  4    73 
  4    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
  4    75        2 lock bit (36) unal,				/* data base lock */
  4    76        2 nchan fixed bin,				/* number of disk channels */
  4    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
  4    78        2 last_dev fixed bin unal,			/* highest disk drive number */
  4    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
  4    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
  4    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
  4    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
  4    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
  4    84        2 dev_index fixed bin (17) unal,			/* current device to check */
  4    85        2 errors fixed bin,				/* error count */
  4    86        2 ferrors fixed bin,				/* fatal error count */
  4    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
  4    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
  4    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
  4    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
  4    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
  4    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
  4    93 
  4    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
  4    95 
  4    96 
  4    97 dcl  qp ptr,					/* pointer to queue entry */
  4    98      cp ptr;					/* pointer to channel information table */
  4    99 
  4   100 
  4   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
  4   102*   expansion space.  They will always be positive and upper bits can be
  4   103*   stolen for other fields.
  4   104*
  4   105*   Entries are forward and back linked to permit easy chasing and removal. */
  4   106 
  4   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
  4   108 						/* WORD 1 */
  4   109        2 next bit (18) unaligned,			/* forward link */
  4   110        2 prev bit (18) unaligned,			/* back link */
  4   111 						/* WORD 2 */
  4   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
  4   113        2 used bit (1) unaligned,			/* entry in use */
  4   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
  4   115        2 pad bit (6) unaligned,			/* future expansion */
  4   116        2 coreadd bit (24) unaligned,			/* main memory address */
  4   117 						/* WORD 3 */
  4   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
  4   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
  4   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
  4   121        2 pad2 bit (5) unaligned,
  4   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
  4   123 						/* WORD 4 */
  4   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
  4   125        2 pad3 bit (9) unaligned,
  4   126        2 sector bit (21) unaligned,			/* device sector desired */
  4   127 						/* WORDS 5&6 */
  4   128        2 time fixed bin (71);				/* clock at queue */
  4   129 
  4   130 
  4   131 
  4   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
  4   133        2 chx fixed bin (35),				/* io_manager channel index */
  4   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
  4   135        2 statusp ptr,				/* pointer to hardware status word */
  4   136        2 chanid char (8),				/* channel name */
  4   137        (
  4   138        2 pad0 bit (18),
  4   139        2 in_use bit (1),				/* non-zero if channel being used */
  4   140        2 active bit (1),				/* non-zero if channel active */
  4   141        2 rsr bit (1),				/* non-zero if RSR in progress */
  4   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
  4   143        2 inop bit (1),				/* non-zero if channel inoperative */
  4   144        2 broken bit (1),				/* non-zero if channel broken */
  4   145        2 action_code bit (2),				/* saved from status */
  4   146        2 pad1 bit (10)
  4   147        ) unal,
  4   148        (
  4   149        2 qrp bit (18),				/* rel ptr to queue entry */
  4   150        2 pad2 bit (3),
  4   151        2 command bit (6),				/* peripheral command */
  4   152        2 erct fixed bin (8)
  4   153        ) unal,					/* error retry count */
  4   154        2 select_data,				/* data passed to IOM on select */
  4   155          (
  4   156          3 limit bit (12),				/* limit on number of sectors */
  4   157          3 mbz bit (3),
  4   158          3 sector bit (21)
  4   159          ) unaligned,				/* sector address */
  4   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
  4   161        2 connect_time fixed bin (52),			/* time of last connect */
  4   162        2 connects fixed bin,				/* count of connects performed */
  4   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
  4   164        2 rstdcw bit (36),				/* restore command */
  4   165        2 scdcw bit (36),				/* select command */
  4   166        2 sddcw bit (36),				/* select data xfer */
  4   167        2 dcdcw bit (36),				/* command to read or write */
  4   168        2 dddcw bit (36),				/* data xfer DCW */
  4   169        2 dscdcw bit (36),				/* RSR command */
  4   170        2 dsddcw bit (36),				/* RSR data xfer */
  4   171        2 rssdcw bit (36),				/* RSS command */
  4   172        2 status bit (36) aligned,			/* saved status */
  4   173 						/* Lossage counters for interrupt loss. */
  4   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
  4   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
  4   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
  4   177        2 status_from_run fixed bin (35);		/* status missed til run called */
  4   178 
  4   179 dcl  1 qht aligned based,				/* queue head/tail structure */
  4   180        2 sum fixed bin (35),				/* sum of depths */
  4   181        2 count fixed bin (35),			/* allocs */
  4   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
  4   183        2 depth fixed bin (17) unaligned,		/* current depth */
  4   184        2 head bit (18) unaligned,			/* queue head */
  4   185        2 tail bit (18) unaligned;			/* queue tail */
  4   186 
  4   187 dcl  dp ptr,					/* pointer to device information table */
  4   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
  4   189 
  4   190 dcl  1 devtab based (dp) aligned,			/* device information table */
  4   191        (
  4   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
  4   193        2 inop bit (1),				/* device inoperative */
  4   194        2 was_broken bit (1),				/* device previously broken */
  4   195        2 broken bit (1),				/* device down */
  4   196        2 abandoned bit (1),				/* device lost and gone forever */
  4   197        2 forward bit (1),				/* moving low->high */
  4   198        2 pad bit (10),
  4   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
  4   200        2 pdi unsigned fixed bin (6)
  4   201        ) unal,					/* primary device index */
  4   202        2 cylinder fixed bin (35),			/* current cylinder position */
  4   203        2 comb fixed bin (35),				/* number of combs */
  4   204        2 pad1 fixed bin (35),
  4   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
  4   206        2 wq like qht,				/* work queue */
  4   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
  4   208        2 opt_info (0:6) like opt_info;			/* optimizer */
  4   209 
  4   210 
  4   211 /* Optimizing table for device. Must be even multiple words long. */
  4   212 /* Slope and intercept define a straight line of y = intercept - slope*x
  4   213*   Multiplier is calculated from this and current system loading.
  4   214*
  4   215*   sys_info is the offset to the relevant system queue loading fraction. */
  4   216 
  4   217 dcl  1 opt_info aligned based (optp),
  4   218        3 multiplier float bin (27),			/* depth mult */
  4   219        3 slope float bin (27),			/* slope of line */
  4   220        3 intercept float bin (27),			/* Y intercept */
  4   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
  4   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
  4   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
  4   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
  4   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
  4   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
  4   227 
  4   228 
  4   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
  4   230        (
  4   231        2 sx fixed bin (11),				/* structure index */
  4   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
  4   233        2 unused_sect_per_cyl fixed bin (11)
  4   234        ) unal;					/* # of unused sectors at end of cylinder */
  4   235 
  4   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
  4   237        2 count fixed bin,				/* total number of attempts */
  4   238        2 waits fixed bin,				/* number of attempts which required waiting */
  4   239        2 wait_time fixed bin (52);			/* total time spent waiting */
  4   240 
  4   241 dcl  (
  4   242      RST_LISTX init (1),				/* listx for restore */
  4   243      SC_LISTX init (2),				/* listx for select */
  4   244      DSC_LISTX init (6),				/* listx for RSR */
  4   245      RSS_LISTX init (8)
  4   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
  4   247 
  4   248 /* IO types defined.  Value is also index of write_map to determine if
  4   249*   the IO type is a read or a write. */
  4   250 
  4   251 dcl  (
  4   252      PAGE_READ init (0),
  4   253      PAGE_WRITE init (1),
  4   254      VTOC_READ init (2),
  4   255      VTOC_WRITE init (3),
  4   256      TEST init (4),
  4   257      BOOTLOAD_READ init (5),
  4   258      BOOTLOAD_WRITE init (6),
  4   259      MAX_IO_TYPE init (6)
  4   260      ) fixed bin (4) static options (constant);
  4   261 
  4   262 dcl  IO_TYPE (0:6) char (16)
  4   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
  4   264 	static options (constant);
  4   265 
  4   266 /* Map indexed by IO type to determine if operation is a read or write. */
  4   267 
  4   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
  4   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
  4   270 
  4   271 /* Map indexed by IO type to determine if operation is a sector IO. */
  4   272 
  4   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
  4   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
  4   275 
  4   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
  4   277 
  4   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
  4   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
  4   280 
  4   281 /* End of include file ...... dskdcl.incl.pl1 */
     2248 
     2249 
  5     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  5     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  5     6*     Add support for FIPS
  5     7*     3380.
  5     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  5     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  5    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  5    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  5    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  5    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  5    14*                                                   END HISTORY COMMENTS */
  5    15 
  5    16 /* Modified 5/19/76 by N. I. Morris */
  5    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  5    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  5    19 /* Modified '82 by BIM for needs_alt_part */
  5    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  5    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  5    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  5    23*   volmap and record stock can be expanded. */
  5    24 
  5    25 /*
  5    26********************************************************************************
  5    27**							        *
  5    28**                           WARNING:                                          *
  5    29**							        *
  5    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  5    31**   type is added.						        *
  5    32**							        *
  5    33**   There are other include files that contain arrays indexed by the device   *
  5    34**   index obtained by references to MODELX or MODELN in this include file.    *
  5    35**   These must be modified when a new device type is added:		        *
  5    36**   disk_pack.incl.pl1					        *
  5    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  5    38**							        *
  5    39********************************************************************************
  5    40**/
  5    41 
  5    42 
  5    43 dcl (maxdevt init (9),				/* maximum legal devt */
  5    44      bulkdevt init (1),				/* bulk store devt */
  5    45      msu0500devt init (2),				/* MSU0500 device type */
  5    46      msu0451devt init (3),				/* MSU0451 device type */
  5    47      msu0450devt init (3),				/* MSU0450 device type */
  5    48      msu0400devt init (4),				/* MSU0400 device type */
  5    49      dsu191devt init (4),				/* DSU191 device type */
  5    50      dsu190devt init (5),				/* DSU190 device type */
  5    51      dsu181devt init (6),				/* DSU181 device type */
  5    52      msu0501devt init (7),				/* MSU0501 device type */
  5    53      fips3380devt init (8),				/* 3380D FIPS device type */
  5    54      fips3381devt init (9)				/* 3380E FIPS device type */
  5    55      ) fixed bin (4) static options (constant);
  5    56 
  5    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  5    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  5    59 
  5    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  5    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  5    62 
  5    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  5    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  5    65 
  5    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  5    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  5    68 
  5    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  5    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  5    71 
  5    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  5    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  5    74 
  5    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  5    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  5    77 
  5    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  5    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  5    80 
  5    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  5    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  5    83 
  5    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  5    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  5    86 
  5    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  5    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  5    89 
  5    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  5    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  5    92 
  5    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  5    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  5    95 
  5    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  5    97      ("abc");
  5    98 
  5    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  5   100      init ("a","b","c");
  5   101 
  5   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  5   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  5   104 
  5   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  5   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  5   107 
  5   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  5   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  5   110 
  5   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  5   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  5   113 
  5   114 
  5   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  5   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  5   117 
  5   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  5   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  5   120 
  5   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  5   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  5   123 
  5   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  5   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  5   126 
  5   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  5   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  5   129 
  5   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  5   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  5   132 
  5   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  5   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  5   135 
  5   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  5   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  5   138 
  5   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  5   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  5   141 
  6     1 /* Begin fs_dev_types_sector.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  6     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  6     7*     Add the sector differance for devices that do 64 word IO and devices that
  6     8*     do 512 word IO.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  6    12*	 need all the data in fs_dev_types. This is also included in
  6    13*	 fs_dev_types.incl.pl1  */
  6    14 
  6    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  6    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  6    17 
  6    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  6    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  6    20 
  6    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  6    22  /* table of # of sectors per record on each device */
  6    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  6    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  6    25 
  6    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  6    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  6    28 	
  6    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  6    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  6    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  6    32 
  6    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  6    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  6    35 
  6    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  6    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  6    38 
  6    39 /* End fs_dev_types_sector.incl.pl1 */
  6    40 
  5   142 
  5   143 
  5   144 /* End of include file ...... fs_dev_types.incl.pl1 */
     2250 
     2251 
  7     1 /* Begin include file io_manager_dcls.incl.pl1 */
  7     2 
  7     3 /* Written by Charles Hornig, late 1980 and early 1981 */
  7     4 /* Modified for MR10 interface, February 1982 */
  7     5 /* Channel reconfiguration entries added by Chris Jones, January 1984 */
  7     6 
  7     7 /* These entries are callable on unwired stacks. */
  7     8 
  7     9 /* call io_manager$assign (Chx, Channel, Handler, Index, Statusp, Code); */
  7    10 dcl  io_manager$assign
  7    11 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  7    12 	fixed bin (35), ptr, fixed bin (35));
  7    13 
  7    14 /* call io_manager$assign_add (Chx, Channel, Handler, Index, Statusp, Code); */
  7    15 dcl  io_manager$assign_add
  7    16 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  7    17 	fixed bin (35), ptr, fixed bin (35));
  7    18 
  7    19 /* call io_manager$unassign (Chx, Code); */
  7    20 dcl  io_manager$unassign entry (fixed bin (35), fixed bin (35));
  7    21 
  7    22 /* call io_manager$unassign_delete (Chx, Code); */
  7    23 dcl  io_manager$unassign_delete entry (fixed bin (35), fixed bin (35));
  7    24 
  7    25 /* call io_manager$connect (Io_manager_arg); */
  7    26 dcl  io_manager$connect entry (1 aligned like io_manager_arg);
  7    27 
  7    28 /* call io_manager$connect_abs (Io_manager_arg); */
  7    29 dcl  io_manager$connect_abs entry (1 aligned like io_manager_arg);
  7    30 
  7    31 /* call io_manager$connect_direct (Io_manager_arg); */
  7    32 dcl  io_manager$connect_direct entry (1 aligned like io_manager_arg);
  7    33 
  7    34 /* call io_manager$get_status (Chx, Io_status_entry_ptr); */
  7    35 dcl  io_manager$get_status entry (fixed bin (35), ptr);
  7    36 
  7    37 /* call io_manager$mask (Chx); */
  7    38 dcl  io_manager$mask entry (fixed bin (35));
  7    39 
  7    40 /* call io_manager$ignore_interrupt (); */
  7    41 dcl  io_manager$ignore_interrupt entry (fixed bin (35), fixed bin (3), bit (36) aligned);
  7    42 
  7    43 /* call io_manager$data_tdcw (Io_manager_arg);
  7    44*   dcl  io_manager$data_tdcw entry (1 aligned like io_manager_arg);
  7    45*
  7    46*   /* call io_manager$workspace_tdcw (Io_manager_arg); */
  7    47 dcl  io_manager$workspace_tdcw entry (1 aligned like io_manager_arg);
  7    48 
  7    49 dcl  io_manager_arg_ptr ptr;
  7    50 dcl  1 io_manager_arg aligned based (io_manager_arg_ptr),
  7    51        2 chx fixed bin (35),				/* channel index from io_manager$assign */
  7    52        2 bound fixed bin (19),			/* workspace size */
  7    53        2 pcw bit (36) aligned,			/* or IDCW */
  7    54        2 listx fixed bin (18),			/* DCW list offset */
  7    55        2 ptp ptr,					/* page table pointer */
  7    56        2 listp ptr,					/* DCW list pointer */
  7    57        2 dcw_pair_ptr ptr;				/* DCW pair pointer */
  7    58 
  7    59 /* End include file io_manager_dcls.incl.pl1 */
     2252 
     2253 
  8     1 /* Begin include file ...... io_special_status.incl.pl1 */
  8     2 /* Written February 1981 by Chris Jones (from iom_stat.incl.pl1) */
  8     3 
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(88-01-06,Farley), approve(88-03-01,MCR7831),
  8     7*     audit(88-03-01,Parisek), install(88-03-08,MR12.2-1032):
  8     8*     Corrected channel size to 6 bits, was incorrectly set to 8.
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 
  8    12 dcl  io_special_status_ptr ptr;			/* pointer to status */
  8    13 
  8    14 dcl  1 io_special_status based (io_special_status_ptr) aligned,
  8    15 						/* special status from PSIA */
  8    16        (
  8    17        2 t bit (1),					/* entry present bit */
  8    18        2 pad bit (2),
  8    19        2 channel bit (6),				/* channel number */
  8    20        2 pad1 bit (3),
  8    21        2 device bit (6),				/* device address */
  8    22        2 pad2 bit (1),
  8    23        2 byte2 bit (8),				/* device dependent information */
  8    24        2 pad3 bit (1),
  8    25        2 byte3 bit (8)
  8    26        ) unal;					/* device dependent information */
  8    27 
  8    28 /* End of include file io_special_status.incl.pl1 */
     2254 
     2255 
  9     1 /* Begin include file io_status_entry.incl.pl1 */
  9     2 /* Written by C. Hornig sometime late in 1980. */
  9     3 /* Modified January 1983 by Chris Jones to show detailed status. */
  9     4 
  9     5 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  9     6 dcl	io_status_entry_ptr	   ptr;
  9     7 dcl	1 io_status_entry	   aligned based (io_status_entry_ptr),
  9     8 	  2 word1		   like io_status_word,	/* major status word */
  9     9 	  2 word2,
  9    10 	    3 next_lpw_offset  bit (18) unaligned,
  9    11 	    3 rfu1	   bit (5) unaligned,
  9    12 	    3 workspace	   bit (1) unaligned,	/* DCW is in the workspace */
  9    13 	    3 rfu2	   bit (12) unaligned,
  9    14 	  2 word3		   bit (36),
  9    15 	  2 word4,
  9    16 	    3 next_dcw_offset  bit (18) unaligned,	/* 1 + offset of last data word */
  9    17 	    3 character_position
  9    18 			   uns fixed bin (3) unaligned,
  9    19 	    3 write	   bit (1) unaligned,
  9    20 	    3 action_code	   bit (2) unaligned,
  9    21 	    3 tally_residue	   uns fixed bin (12) unaligned,
  9    22 						/* residue of last DCW tally */
  9    23 	  2 word5,
  9    24 	    3 data_count	   uns fixed bin (26) unaligned,
  9    25 						/* total words transferred (on IIOC & IOX) */
  9    26 	    3 rfu		   bit (10) unaligned,
  9    27 	  2 words		   (6:8) bit (36),
  9    28 	  2 detailed_status	   (8) bit (36);		/* detailed status (IIOC and IOX) */
  9    29 
 10     1 /* Begin include file io_status_word.incl.pl1 */
 10     2 /* Made from iom_stat.incl.pl1 by C. Hornig */
 10     3 
 10     4 dcl  io_status_word_ptr ptr;
 10     5 dcl  1 io_status_word based (io_status_word_ptr) aligned,	/* I/O status information */
 10     6        (
 10     7        2 t bit (1),					/* set to "1"b by IOM */
 10     8        2 power bit (1),				/* non-zero if peripheral absent or power off */
 10     9        2 major bit (4),				/* major status */
 10    10        2 sub bit (6),				/* substatus */
 10    11        2 eo bit (1),				/* even/odd bit */
 10    12        2 marker bit (1),				/* non-zero if marker status */
 10    13        2 soft bit (2),				/* software status */
 10    14        2 initiate bit (1),				/* initiate bit */
 10    15        2 abort bit (1),				/* software abort bit */
 10    16        2 channel_stat bit (3),			/* IOM channel status */
 10    17        2 central_stat bit (3),			/* IOM central status */
 10    18        2 mbz bit (6),
 10    19        2 rcount bit (6)
 10    20        ) unaligned;					/* record count residue */
 10    21 
 10    22 /* End include file io_status_word.incl.pl1 */
  9    30 
  9    31 
  9    32 /* End include file io_status_entry.incl.pl1 */
     2256 
     2257 
 11     1 /* Begin include file ..... io_syserr_msg.incl.pl1 */
 11     2 
 11     3 /* Created October 1975 by Larry Johnson */
 11     4 /* Modified 11/11/76 by Noel I. Morris */
 11     5 /* Modified November 1979 by Larry Johnson for detailed status */
 11     6 /* Modified February 1981 by Chris Jones to use channel names */
 11     7 
 11     8 /* This include file defines the format of the syserr message generated for I/O errors. */
 11     9 /* This message is also defined (size and type) by the "io_msg" and "io_msg_detail"
 11    10*   constants in syserr_binary_def.incl.pl1 */
 11    11 
 11    12 dcl  io_msgp ptr;					/* Pointer to syserr message structure */
 11    13 
 11    14 dcl  1 io_msg aligned based (io_msgp),
 11    15        (
 11    16        2 level bit (3),				/* Level of interrupt being logged */
 11    17        2 fill1 bit (9),
 11    18        2 device bit (6),				/* Device which caused error */
 11    19        2 time_out bit (1),				/* Set if error caused by channel timeout */
 11    20        2 type bit (2),				/* Type of last DCW */
 11    21        2 command bit (6),				/* Command being executed by device */
 11    22        2 fill2 bit (3),
 11    23        2 count bit (6)
 11    24        ) unal,					/* Count of message repetitions */
 11    25        2 channel char (8),				/* Channel over which interrupt came */
 11    26        2 status bit (36),				/* First word of IOM status */
 11    27        2 devname char (4),				/* Device name */
 11    28        2 detailed_status bit (216) unaligned;               /* Optional detailed device status */
 11    29 
 11    30 /* End include file ..... io_syserr_msg.incl.pl1 */
     2258 
     2259 
 12     1 
 12     2 /* Begin include file ...... iom_dcw.incl.pl1 */
 12     3 
 12     4 dcl  dcwp ptr,					/* pointer to DCW */
 12     5      tdcwp ptr;					/* pointer to TDCW */
 12     6 
 12     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
 12     8      (2 address bit (18),				/* address for data transfer */
 12     9       2 char_pos bit (3),				/* character position */
 12    10       2 m64 bit (1),				/* non-zero for mod 64 address */
 12    11       2 type bit (2),				/* DCW type */
 12    12       2 tally bit (12)) unal;				/* tally for data transfer */
 12    13 
 12    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
 12    15      (2 address bit (18),				/* address to transfer to */
 12    16       2 mbz1 bit (4),
 12    17       2 type bit (2),				/* should be "10"b for TDCW */
 12    18       2 mbz2 bit (9),
 12    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
 12    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
 12    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
 12    22 
 12    23 /* End of include file ...... iom_dcw.incl.pl1 */
 12    24 
     2260 
     2261 
 13     1 
 13     2 /* Begin include file ...... iom_pcw.incl.pl1 */
 13     3 
 13     4 dcl  pcwp ptr;					/* pointer to PCW */
 13     5 
 13     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
 13     7      (2 command bit (6),				/* device command */
 13     8       2 device bit (6),				/* device code */
 13     9       2 ext bit (6),				/* address extension */
 13    10       2 code bit (3),				/* should be "111"b for PCW */
 13    11       2 mask bit (1),				/* channel mask bit */
 13    12       2 control bit (2),				/* terminate/proceed and marker control bits */
 13    13       2 chan_cmd bit (6),				/* type of I/O operation */
 13    14       2 count bit (6),				/* record count or control character */
 13    15       2 mbz1 bit (3),
 13    16       2 channel bit (6),				/* channel number */
 13    17       2 mbz2 bit (27)) unal;
 13    18 
 13    19 dcl  idcwp ptr;					/* pointer to IDCW */
 13    20 
 13    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
 13    22      (2 command bit (6),				/* device command */
 13    23       2 device bit (6),				/* device code */
 13    24       2 ext bit (6),				/* address extension */
 13    25       2 code bit (3),				/* should be "111"b for PCW */
 13    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
 13    27       2 control bit (2),				/* terminate/proceed and marker control bits */
 13    28       2 chan_cmd bit (6),				/* type of I/O operation */
 13    29       2 count bit (6)) unal;				/* record count or control character */
 13    30 
 13    31 /* End include file ...... iom_pcw.incl.pl1 */
 13    32 
     2262 
     2263 
 14     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 14     2 
 14     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
 14     4 
 14     5 /****^  HISTORY COMMENTS:
 14     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
 14     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 14     8*     Add the support for subvolumes
 14     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
 14    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 14    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
 14    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 14    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 14    14*     Added inconsistent_dbm bit for determining the status of volume
 14    15*     dumper bit maps.
 14    16*                                                   END HISTORY COMMENTS */
 14    17 
 14    18      dcl	   pvt$array	      aligned external;
 14    19      dcl	   pvt$max_n_entries      fixed bin external;
 14    20 
 14    21      dcl	   pvt_arrayp	      ptr;
 14    22      dcl	   pvtep		      ptr;
 14    23 
 14    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
 14    25 
 14    26      dcl	   1 pvte		      based (pvtep) aligned,
 14    27 
 14    28 	     2 pvid	      bit (36),		/* physical volume ID */
 14    29 
 14    30 	     2 lvid	      bit (36),		/* logical volume ID */
 14    31 
 14    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
 14    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
 14    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
 14    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
 14    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
 14    37 	     2 pad3	      bit (2) unaligned,
 14    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
 14    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
 14    40 
 14    41 
 14    42 
 14    43 	     2 devname	      char (4),		/* device name */
 14    44 
 14    45 	     (2 device_type	      fixed bin (8),	/* device type */
 14    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
 14    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
 14    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
 14    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
 14    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
 14    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
 14    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
 14    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
 14    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
 14    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
 14    56 	     2 scav_check_address
 14    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
 14    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
 14    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
 14    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
 14    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
 14    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
 14    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
 14    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
 14    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
 14    66 
 14    67 
 14    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
 14    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
 14    70 
 14    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
 14    72 
 14    73 	     2 nleft	      fixed bin (17),	/* number of records left */
 14    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
 14    75 
 14    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
 14    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
 14    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
 14    79 	     2 records_per_cyl    fixed bin,
 14    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
 14    81 	     2 sv_name            char (2) aligned,
 14    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
 14    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
 14    84 
 14    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
 14    86 	     2 pad2	      bit (18) unaligned,
 14    87 
 14    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
 14    89 
 14    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
 14    91 
 14    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
 14    93 
 14    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
 14    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
 14    96 
 14    97 
 14    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
 14    99 
 14   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
 14   101 
 14   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
 14   103 
 14   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
 14   105 
 14   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
 14   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
 14   108 
 14   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
 14   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
 14   111 
 14   112 
 14   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
 14   114 	   VOLMAP_ASYNC_READ      init (1),
 14   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
 14   116 
 14   117 
 14   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     2264 
     2265 
 15     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
 15     2 
 15     3 /* This include file has an ALM version, keep 'em in sync. */
 15     4 
 15     5 /* format: off */
 15     6 
 15     7 /* Modified January 1984 by Paul Farley to add an array of entry values
 15     8*   to be examined by display_cpu_error. */
 15     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
 15    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
 15    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
 15    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
 15    13*		also changed some codes to "SB_unused_NN" - see line comments */
 15    14 
 15    15 /* In the future, these will be the only constants needed in this include
 15    16*file.  They are the binary data class strings for messages in the new format
 15    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
 15    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
 15    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
 15    20 
 15    21 dcl (						/* include file name */
 15    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
 15    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
 15    24 SB_mos_data_class		init ("mos"),		/* scr */
 15    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
 15    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
 15    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
 15    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
 15    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
 15    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
 15    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
 15    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
 15    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
 15    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
 15    35 ) static internal char (16) varying options (constant);
 15    36 
 15    37 
 15    38 /************************
 15    39*Once the syserr$binary is replaced with something that takes real data classes
 15    40*and all system modules and tools are upgraded to use the new interface, the
 15    41*rest of this include file may be discarded.
 15    42*************************/
 15    43 
 15    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
 15    45*   extended at any time. */
 15    46 
 15    47 dcl (
 15    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
 15    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
 15    50 SB_io_err		init (3),		SBL_io_err	init (5),
 15    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
 15    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
 15    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
 15    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
 15    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
 15    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
 15    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
 15    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
 15    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
 15    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
 15    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
 15    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
 15    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
 15    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
 15    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
 15    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
 15    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
 15    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
 15    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
 15    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
 15    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
 15    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
 15    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
 15    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
 15    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
 15    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
 15    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
 15    78   ) internal static options (constant) fixed bin;
 15    79 
 15    80 
 15    81 /* The following array is a mapping of the old syserr$binary codes into the
 15    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
 15    83*the binary data codes stored in the wired syserr log (see above) into the data
 15    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
 15    85*is also used by syserr_log_util_ to translate the data classes back into the
 15    86*corresponding binary code (for tools not yet upgraded to deal with the new
 15    87*format log messages). */
 15    88 
 15    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
 15    90 	init (	"io_status",		/* 1 */
 15    91 		"hwfault",		/* 2 */
 15    92 		"io_status",		/* 3 */
 15    93 		"unused_4",		/* 4 */
 15    94 		"mos",			/* 5 */
 15    95 
 15    96 		"unused_6",		/* 6 */
 15    97 		"unused_7",		/* 7 */
 15    98 		"unused_8",		/* 8 */
 15    99 		"unused_9",		/* 9 */ 
 15   100 		"unused_10",		/* 10 */
 15   101 
 15   102 		"segdamage",		/* 11 */
 15   103 		"unused_12",		/* 12 */
 15   104 		"segdamage",		/* 13 */
 15   105 		"unused_14",		/* 14 */
 15   106 		"unused_15",		/* 15 */
 15   107 
 15   108 		"segdamage",		/* 16 */
 15   109 		"voldamage",		/* 17 */
 15   110 		"unused_18",		/* 18 */
 15   111 		"mdc_del_uidpath",		/* 19 */
 15   112 		"io_status",		/* 20 */
 15   113 
 15   114 		"mmdam",			/* 21 */
 15   115 		"hwfault",		/* 22 */
 15   116 		"io_status",		/* 23 */
 15   117 		"mpc_poll",		/* 24 */
 15   118 		"fnp_poll",		/* 25 */
 15   119 
 15   120 		"config_deck",		/* 26 */
 15   121 		"vtoce",			/* 27 */
 15   122 		"access_audit",		/* 28 */
 15   123 		"unused_29",		/* 29 */
 15   124 		"unused_30",		/* 30 */
 15   125 		"unused_31",		/* 31 */
 15   126 		"unused_32",		/* 32 */
 15   127 		"unused_33",		/* 33 */
 15   128 		"unused_34",		/* 34 */
 15   129 		"ibm3270_mde",		/* 35 */
 15   130 		"unused_36"		/* 36 */
 15   131 	);
 15   132 
 15   133 
 15   134 /* format: on */
 15   135 
 15   136 /* These constants are used by various tools which analyze syserr messages and
 15   137*still call the old interface "syserr_log_util_". */
 15   138 
 15   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
 15   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
 15   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
 15   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
 15   143 
 15   144      dcl	   display_cpu_error_binary_defs (2) init (
 15   145 			      2,			/** SB_hw_fault */
 15   146 			      22			/** SB_verify_lock */
 15   147 			      ) internal static options (constant) fixed bin;
 15   148 
 15   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
     2266 
     2267 
 16     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 16     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 16     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 16     4 
 16     5 /* This include file has an ALM version.  Keep 'em in sync! */
 16     6 
 16     7 dcl (
 16     8 
 16     9 /* The following constants define the message action codes.  This indicates
 16    10*how a message is to be handled.  */
 16    11 
 16    12      SYSERR_CRASH_SYSTEM	init (1),			
 16    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 16    14 
 16    15      SYSERR_TERMINATE_PROCESS	init (2),
 16    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 16    17 
 16    18      SYSERR_PRINT_WITH_ALARM	init (3),
 16    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 16    20 
 16    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 16    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 16    23 
 16    24      SYSERR_LOG_OR_PRINT	init (4),
 16    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 16    26 
 16    27      SYSERR_LOG_OR_DISCARD	init (5),
 16    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 16    29 
 16    30 
 16    31 /* The following constants are added to the normal severities to indicate
 16    32*different sorting classes of messages.  */
 16    33 
 16    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 16    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 16    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 16    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 16    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 16    39 	) fixed bin internal static options (constant);
 16    40 
 16    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     2268 
     2269 
     2270 /* BEGIN MESSAGE DOCUMENTATION
     2271*
     2272*   Message:
     2273*   disk_control: Adding channel ICC.
     2274*
     2275*   S:	$info
     2276*
     2277*   T:	$run
     2278*
     2279*   M:	A message to confirm that channel ICC has been added to the system
     2280*   in response to a reconfigure command.
     2281*
     2282*   A:	$ignore
     2283*
     2284*   Message:
     2285*   disk_control: Reconnected IO_TYPE I/O on dskX_NN (channel ICC).
     2286*
     2287*   S:	$info and/or $log
     2288*
     2289*   T:	$run
     2290*
     2291*   M:	A disk interrupt was apparently lost.
     2292*   Status for the disk did not arrive within the expected time.
     2293*   This may be an indication of a channel or controller malfunction.
     2294*   The system restarts the disk operation.
     2295*
     2296*   A:	$ignore Unless these messages persist, which may indicate
     2297*   a hardware malfunction that needs investigation.  Some types of
     2298*   channel adapters and/or disk controllers can be "reset" in an attempt
     2299*   to correct the condition.
     2300*
     2301*   Message:
     2302*   disk_control: Placing dskX_NN in operation.
     2303*
     2304*   S:	$info
     2305*
     2306*   T:	$run
     2307*
     2308*   M:	A special interrupt has been received for a disk drive marked as
     2309*   broken. The system will attempt to use the device.
     2310*
     2311*   A:	$ignore
     2312*
     2313*   Message:
     2314*   disk_control: Unexpected IOM status SSSS for dskX_NN (channel ICC).
     2315*
     2316*   S:	$info
     2317*
     2318*   T:	$run
     2319*
     2320*   M:	Status has been received from a channel which was not marked active.
     2321*   This is due to a disk subsystem or IOM problem,
     2322*   or to a logic error in the supervisor.
     2323*   See manual AN87, System Formats, for an interpretation
     2324*   of the status SSSS.
     2325*   The system ignores the status and attempts to continue operation.
     2326*
     2327*   A:	$ignore
     2328*
     2329*   Message:
     2330*   disk_control: dskX_NN now operational.
     2331*
     2332*   S:	$info
     2333*
     2334*   T:	$run
     2335*
     2336*   M:	A disk drive which required intervention has successfully completed
     2337*   an I/O operation. The system will again use its contents.
     2338*
     2339*   A:	$ignore
     2340*
     2341*   Message:
     2342*   disk_control: MAJOR_STAT SUBSTAT for dskX_NN (channel ICC).
     2343*   .br
     2344*   rec RRRR, sect SSSS, main AAAA
     2345*   .br
     2346*   detailed status: XX XX XX XX XX XX XX XX
     2347*
     2348*   S:	$info
     2349*
     2350*   T:	$run
     2351*
     2352*   M:	A disk error has occurred on drive dskX_NN.
     2353*   The major status and substatus are interpreted as character strings.
     2354*   The disk address is given both as a Multics record address in octal,
     2355*   and as an absolute sector number in octal.
     2356*   The main store address being used was AAAA octal.
     2357*   The third line gives the hexadecimal value of the detailed status
     2358*   in cases where this data is useful.
     2359*   See manual AN87, System Formats, for interpretation of this information.
     2360*
     2361*   A:	Note for Customer Service action.
     2362*   The segment involved in a disk error can often be identified by
     2363*   an application of the "record_to_vtocx" tool to the Multics
     2364*   record number given in the message.
     2365*
     2366*   Message:
     2367*   disk_control: MAJOR_STAT SUBSTAT for dskX_NN (channel ICC).
     2368*   .br
     2369*   rec RRRR, sect SSSS, main AAAA
     2370*   .br
     2371*   subvol V, logical rec OOOO, logical sect TTTT
     2372*   .br
     2373*   detailed status: XX XX XX XX XX XX XX XX
     2374*
     2375*   S:	$info
     2376*
     2377*   T:	$run
     2378*
     2379*   M:	A disk error has occurred on drive dskX_NN.
     2380*   The major status and substatus are interpreted as character strings.
     2381*   The disk address is given both as a Multics record address in octal,
     2382*   and as an absolute sector number in octal.
     2383*   The main store address being used was AAAA octal.
     2384*   The subvolume name is V (the logical device name is dskX_NNV),
     2385*   the logical record address is OOOO octal
     2386*   and the logical sector number is TTTT octal.
     2387*   The fourth line gives the hexadecimal value of the detailed status
     2388*   in cases where this data is useful.
     2389*   See manual AN87, System Formats, for interpretation of this information.
     2390*
     2391*   A:	Note for Customer Service action.
     2392*   The segment involved in a disk error can often be identified by
     2393*   an application of the "record_to_vtocx" tool to the Multics
     2394*   logical record number given in the message.
     2395*
     2396*   Message:
     2397*   disk_control: dskX_NN requires intervention.
     2398*
     2399*   S:	$beep
     2400*
     2401*   T:	$run
     2402*
     2403*   M:	A disk error has occurred which
     2404*   could have been caused by the pack or drive being broken
     2405*   or requiring operator attention.
     2406*   The system has retried the operation an appropriate number of times
     2407*   without success.
     2408*   The system will try the device
     2409*   periodically to check if it has been repaired.
     2410*
     2411*   A:	Inspect the device.
     2412*   If it is not ready, ready it.
     2413*   If it is ready, try unreadying and re-readying it.
     2414*   If the drive cannot be made ready, contact Customer Service personnel.
     2415*
     2416*   Message:
     2417*   disk_control: Removing channel ICC.
     2418*
     2419*   S:	$beep
     2420*
     2421*   T:	$run
     2422*
     2423*   M:	Errors occurred indicative of a defective disk channel or MPC.
     2424*   The channel receiving the errors is placed offline.
     2425*
     2426*   A:	$inform
     2427*   Also inform Customer Service personnel.
     2428*
     2429*   Message:
     2430*   disk_control: Queuing error.
     2431*
     2432*   S:	$crash
     2433*
     2434*   T:	$run
     2435*
     2436*   M:	$err
     2437*
     2438*   A:	$recover
     2439*
     2440*   END MESSAGE DOCUMENTATION */
     2441 
     2442      end disk_control;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/01/90  1626.9  disk_control.pl1                  >spec>install>1035>disk_control.pl1
1822         1    10/02/84  0950.0  disk_tune.incl.pl1                >ldd>include>disk_tune.incl.pl1
2244         2    03/10/88  2109.6  device_error.incl.pl1             >ldd>include>device_error.incl.pl1
2246         3    09/28/89  1407.9  disk_error_interp.incl.pl1        >ldd>include>disk_error_interp.incl.pl1
2248         4    08/11/88  2111.5  dskdcl.incl.pl1                   >ldd>include>dskdcl.incl.pl1
2250         5    10/30/86  2110.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
5-142        6    07/24/86  2151.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
2252         7    07/11/84  1037.3  io_manager_dcls.incl.pl1          >ldd>include>io_manager_dcls.incl.pl1
2254         8    03/10/88  2109.5  io_special_status.incl.pl1        >ldd>include>io_special_status.incl.pl1
2256         9    10/26/83  1207.8  io_status_entry.incl.pl1          >ldd>include>io_status_entry.incl.pl1
9-30        10    03/27/82  0530.3  io_status_word.incl.pl1           >ldd>include>io_status_word.incl.pl1
2258        11    01/18/85  1053.2  io_syserr_msg.incl.pl1            >ldd>include>io_syserr_msg.incl.pl1
2260        12    11/12/74  1650.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
2262        13    05/06/74  1842.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
2264        14    07/21/88  2136.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
2266        15    03/15/85  1053.1  syserr_binary_def.incl.pl1        >ldd>include>syserr_binary_def.incl.pl1
2268        16    05/17/85  0715.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000000 constant        fixed bin(17,0)          initial dcl 16-7 set ref 702* 811 942* 1089* 1268
ANNOUNCE_RECONNECT_DELTA        000306 constant        fixed bin(35,0)          initial dcl 225 ref 810
ANY                                    constant        bit(6)                   initial packed unaligned dcl 207 ref 1058 1076 1103
                                                                                  1151
BEEP                            000353 constant        fixed bin(17,0)          initial dcl 16-7 set ref 1321* 1369*
BOTH                                   constant        bit(1)                   initial dcl 209 set ref 942* 942* 1089* 1089*
BROKEN_POLLING_TIME             000303 constant        fixed bin(35,0)          initial dcl 225 ref 835
CHANNEL_POLLING_TIME            000302 constant        fixed bin(35,0)          initial dcl 225 ref 767 1407
CRASH                           000357 constant        fixed bin(17,0)          initial dcl 16-7 set ref 1623*
DISK_POLLING_TIME               000305 constant        fixed bin(35,0)          initial dcl 225 ref 804
FAILURE                                constant        bit(1)                   initial dcl 209 ref 2082
IDCW                                   constant        bit(3)                   initial packed unaligned dcl 217 ref 1203 1659
INOP_POLLING_TIME               000304 constant        fixed bin(35,0)          initial dcl 225 ref 829
IO_TYPE                         000025 constant        char(16)                 initial array packed unaligned dcl 4-262 set ref
                                                                                  814*
JUST_LOG                        000350 constant        fixed bin(17,0)          initial dcl 16-7 set ref 979* 1266 1270
LOG                                    constant        fixed bin(17,0)          initial dcl 16-7 ref 813
MAX_IO_TYPE                            constant        fixed bin(4,0)           initial dcl 4-251 ref 574 1840 1845 1860 1895
ME                              000276 constant        char(16)                 initial packed unaligned dcl 257 set ref 702* 814*
                                                                                  942* 979* 1089* 1271* 1321* 1369* 1623*
OFF                                    constant        bit(1)                   initial dcl 209 set ref 840* 943* 1088*
ON                                     constant        bit(1)                   initial dcl 209 set ref 1325* 1344* 1379*
OPT_TUNE                        000072 constant        char(8)                  initial packed unaligned dcl 1-34 ref 1858
PAGE_READ                              constant        fixed bin(4,0)           initial dcl 4-251 ref 424 1680
PAGE_WRITE                             constant        fixed bin(4,0)           initial dcl 4-251 ref 418 1680
READ                                   constant        bit(6)                   initial packed unaligned dcl 218 ref 1663
RESET_MAX                       000061 constant        char(9)                  initial packed unaligned dcl 1-39 ref 1899
RESET_STATUS                           constant        bit(6)                   initial packed unaligned dcl 218 ref 389
RESET_SYS                       000064 constant        char(9)                  initial packed unaligned dcl 1-37 ref 1894
SBL_disk_err                    000350 constant        fixed bin(17,0)          initial dcl 15-47 set ref 1271*
SB_disk_err                     000357 constant        fixed bin(17,0)          initial dcl 15-47 set ref 1271*
SINGLE                                 constant        bit(1)                   initial dcl 209 set ref 814* 814* 1271* 1271* 1321*
                                                                                  1321*
STAGNATE_TIME                   000070 constant        char(8)                  initial packed unaligned dcl 1-35 ref 1828
SUCCESS                                constant        bit(1)                   initial dcl 209 ref 2077
SYS_TUNE                        000074 constant        char(8)                  initial packed unaligned dcl 1-16 ref 1838
TEST                                   constant        fixed bin(4,0)           initial dcl 4-251 ref 388 397 1113 1293 1297 1300
                                                                                  1319 1321 1344 1378 1633 1762
UNLOAD                                 constant        bit(6)                   initial packed unaligned dcl 218 ref 398
UNLOCK                                 constant        bit(36)                  initial dcl 224 ref 745 1995 1998 2009 2053 2075
                                                                                  2080 2094 2111 2145 2158 2194
VTOC_READ                              constant        fixed bin(4,0)           initial dcl 4-251 ref 375 1676
VTOC_WRITE                             constant        fixed bin(4,0)           initial dcl 4-251 ref 368 1676
WRITE                                  constant        bit(6)                   initial packed unaligned dcl 218 ref 1661
a_chx                                  parameter       fixed bin(35,0)          dcl 611 ref 607 618 656 666 683 689
a_code                                 parameter       fixed bin(35,0)          dcl 686 set ref 683 704*
a_coreadd                              parameter       fixed bin(24,0)          dcl 139 ref 365 372 378 415 421 428
a_devadd                               parameter       bit(18)                  dcl 140 ref 365 372 376 415 421 427
a_intrpt                               parameter       fixed bin(1,0)           dcl 141 ref 415 421 431
a_iom_chx                              parameter       fixed bin(35,0)          dcl 659 set ref 607 645* 650* 656 667
a_n_sectors                            parameter       fixed bin(17,0)          dcl 144 ref 365 372 381
a_op                                   parameter       char                     packed unaligned dcl 1810 ref 1807 1826
a_ptr                                  parameter       pointer                  dcl 1811 ref 1807 1825 1836
a_pvtx                                 parameter       fixed bin(17,0)          dcl 138 ref 365 372 385 394 415 421 442 496 1786
                                                                                  1789
a_queue_length                         parameter       fixed bin(17,0)          dcl 142 set ref 1786 1800*
a_required                             parameter       bit(1)                   dcl 612 ref 607 617
a_sect_off                             parameter       fixed bin(4,0)           dcl 143 ref 365 372 380
a_statusp                              parameter       pointer                  dcl 660 set ref 607 646* 651* 656 668
a_sx                                   parameter       fixed bin(8,0)           dcl 610 ref 607 616 656 665 683 688 729 735 741
abandoned                 0(12)        based           bit(1)                   level 2 packed packed unaligned dcl 4-190 ref 455
abs                                                    builtin function         dcl 253 ref 1537 1724
abs_mem_addr             10            based           fixed bin(26,0)          level 2 unsigned dcl 4-74 ref 1201
action_code               3(22)        based           bit(2)                   level 3 in structure "io_status_entry" packed packed
                                                                                  unaligned dcl 9-7 in procedure "disk_control" set
                                                                                  ref 1042
action_code               6(24)        based           bit(2)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 1042* 1261
active                    6(19)        based           bit(1)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 515 643 782 977 1008* 1099* 1139 1417*
                                                                                  1441 1744*
active                    6(19)        based           bit(1)                   array level 2 in structure "disk_channel_table"
                                                                                  packed packed unaligned dcl 4-94 in procedure
                                                                                  "disk_control" set ref 582*
addr                                                   builtin function         dcl 253 ref 442 442 444 447 447 451 458 470 470 474
                                                                                  474 513 539 552 562 562 566 620 624 624 670 691
                                                                                  693 693 714 718 718 764 787 790 799 799 806 827
                                                                                  839 839 869 889 889 890 894 916 926 935 938 938
                                                                                  940 974 995 995 997 1021 1045 1123 1177 1184 1186
                                                                                  1230 1257 1271 1293 1295 1302 1397 1397 1404 1439
                                                                                  1487 1634 1640 1652 1653 1654 1704 1704 1708 1789
                                                                                  1789 1791 1798 1824 1843 1850 1884 1942 1943 2144
                                                                                  2148 2193 2202 2219 2219 2219 2219 2221 2221 2221
                                                                                  2221
addrel                                                 builtin function         dcl 253 ref 1178 1180 1183 1201 1204 1251 1253 1254
address                                based           bit(18)                  level 2 packed packed unaligned dcl 12-7 set ref
                                                                                  1667*
all_paths_bad             0(29)        based           bit(1)                   level 2 packed packed unaligned dcl 2-16 set ref
                                                                                  1375* 1383* 1391*
alloc_wait_meters        26            based           structure                level 2 dcl 4-74 set ref 470 470 474 474
array                    11            based           structure                array level 2 dcl 4-31
bad_addr                  0(20)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 1350
bad_dev                   0(21)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 1318
bad_mem                   0(23)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 1447
bad_path                  0(22)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 1297
                                                                                  1307 1358
best_neg_comb                   000521 automatic       fixed bin(35,0)          dcl 1516 set ref 1571* 1591 1592*
best_neg_qp                     000526 automatic       pointer                  dcl 1516 set ref 1593* 1607
best_pos_comb                   000520 automatic       fixed bin(35,0)          dcl 1516 set ref 1570* 1585 1586* 1604
best_qp                         000524 automatic       pointer                  dcl 1516 set ref 1543* 1556 1587* 1604
best_seek                       000516 automatic       float bin(27)            dcl 1516 set ref 1530* 1541 1542*
bin                                                    builtin function         dcl 253 ref 376 389 398 427 990 1162 1185 1201 1228
                                                                                  1641 1677 1678 1681 1682 1685 1686 1691 1693 1697
                                                                                  1699
bit                                                    builtin function         dcl 253 ref 494 502 1046 1258 1260 1303 1636 1656
                                                                                  1669 1677 1678 1681 1682 1685 1686 1691 1693 1697
                                                                                  1699
bitmask                   0(06)        based           bit(6)                   level 2 packed packed unaligned dcl 3-35 ref 1187
bitson                                 based           bit(6)                   level 2 packed packed unaligned dcl 3-35 ref 1187
bootload_disk_post              000022 constant        entry                    external dcl 239 ref 1770
bootload_map                           defined         bit(1)                   array packed unaligned dcl 4-279 ref 441 993
bootload_mapping                000022 constant        bit(7)                   initial packed unaligned dcl 4-278 ref 441 441 993
                                                                                  993
bootload_sw                     000105 automatic       bit(1)                   dcl 154 set ref 441* 993* 1374 1770
both                                   parameter       bit(1)                   dcl 1958 ref 1955 1975
broken                    0(11)        based           bit(1)                   level 2 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 567* 835 841* 941 946* 1084 1087* 1225
                                                                                  1266 1319 1321 1324* 1488
broken                    6(23)        based           bit(1)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 626 636* 694 695* 1360* 1411*
broken                    6(23)        based           bit(1)                   array level 2 in structure "disk_channel_table"
                                                                                  packed packed unaligned dcl 4-94 in procedure
                                                                                  "disk_control" set ref 586*
buddy                    36(24)        based           fixed bin(6,0)           array level 3 in structure "disktab" packed packed
                                                                                  unsigned unaligned dcl 4-74 in procedure
                                                                                  "disk_control" set ref 1965
buddy                     0(24)        based           fixed bin(6,0)           level 2 in structure "devtab" packed packed unsigned
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  ref 2221 2221 2221
call_lock_meters         16            based           structure                level 2 dcl 4-74 set ref 447 447 562 562 624 624 693
                                                                                  693 799 799
call_run_sx                     000106 automatic       fixed bin(17,0)          dcl 155 set ref 741* 743 752
central_stat              0(21)        based           bit(3)                   level 2 packed packed unaligned dcl 10-5 ref 1157
                                                                                  1159
chanid                    4            based           char(8)                  level 2 dcl 4-132 set ref 702* 814* 979* 1259 1271*
                                                                                  1369*
channel                   1            based           char(8)                  level 2 dcl 11-14 set ref 1259*
channel_stat              0(18)        based           bit(3)                   level 2 packed packed unaligned dcl 10-5 ref 1153
                                                                                  1155
channel_time                    000110 automatic       fixed bin(52,0)          dcl 156 set ref 1119* 1126
channel_wait              4            based           fixed bin(52,0)          level 2 dcl 4-217 set ref 1126* 1126
channels                 11            based           bit(18)                  level 2 packed packed unaligned dcl 4-74 ref 513 580
                                                                                  620 670 691 764 869 1404 1439
channels_online           3            based           fixed bin(17,0)          level 2 dcl 4-74 set ref 591* 591 626 633* 633 677*
                                                                                  677 697* 697 770* 770 1368 1371* 1371 1424* 1424
chantab                                based           structure                level 1 dcl 4-132
chr                       0(09)        based           char                     level 2 packed packed unaligned dcl 3-52 set ref
                                                                                  1271* 1271*
chx                             000540 automatic       fixed bin(35,0)          level 2 in structure "ima" dcl 1735 in procedure
                                                                                  "connect" set ref 1737*
chx                                    based           fixed bin(35,0)          level 2 in structure "chantab" dcl 4-132
                                                                                  in procedure "disk_control" set ref 645 673* 788
                                                                                  893 1737
chx                             000227 automatic       fixed bin(35,0)          dcl 614 in procedure "disk_control" set ref 618* 620
                                                                                  666* 670 689* 691
clock                                                  builtin function         dcl 253 ref 438 712 733 767 786 829 835 984 1118
                                                                                  1309 1310 1328 1339 1365 1407 1423 1498 1745 1900
                                                                                  2028 2037
code                      0(18)        based           bit(3)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  1203 1659*
comb                      2            based           fixed bin(35,0)          level 2 dcl 4-190 set ref 1568* 1568
command                                based           bit(6)                   level 2 in structure "idcw" packed packed unaligned
                                                                                  dcl 13-21 in procedure "disk_control" set ref 1206
                                                                                  1635* 1661* 1663* 1675
command                         000112 automatic       bit(6)                   dcl 157 in procedure "disk_control" set ref 1023*
                                                                                  1043 1206* 1262
command                   7(21)        based           bit(6)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 1023 1043*
command                   0(21)        based           bit(6)                   level 2 in structure "io_msg" packed packed
                                                                                  unaligned dcl 11-14 in procedure "disk_control"
                                                                                  set ref 1262*
connect_time             14            based           fixed bin(52,0)          level 2 dcl 4-132 set ref 767 804 1119 1365* 1407
                                                                                  1423* 1745*
connects                 16            based           fixed bin(17,0)          level 2 dcl 4-132 set ref 1743* 1743
convert                                                builtin function         dcl 253 ref 1970 1973
coreadd                   1(12)        based           bit(24)                  level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 4-107 in procedure "disk_control"
                                                                                  set ref 494* 990 1635 1641 1665 1667
coreadd                         000101 automatic       fixed bin(24,0)          dcl 147 in procedure "disk_control" set ref 378*
                                                                                  389* 398* 428* 494 990* 1271* 1770* 1773* 1774*
count                     5            based           fixed bin(35,0)          level 3 in structure "disk_data" dcl 4-31
                                                                                  in procedure "disk_control" set ref 2073* 2073
count                     7            based           fixed bin(35,0)          level 3 in structure "devtab" dcl 4-190 in procedure
                                                                                  "disk_control" set ref 2138* 2138
count                    26            based           fixed bin(17,0)          level 3 in structure "disktab" dcl 4-74 in procedure
                                                                                  "disk_control" set ref 468* 468
count                                  based           fixed bin(17,0)          level 2 in structure "dlm" dcl 1989 in procedure
                                                                                  "lock" set ref 1994* 1994
cp                              000270 automatic       pointer                  dcl 4-97 set ref 513* 515 515 580* 582 584 586 588
                                                                                  588 590 593 620* 626 626 626 633 635 636 636 643
                                                                                  645 646 647 670* 673 674 675 676 691* 694 695 696
                                                                                  702 764* 767 767 767 769 782 788 792 792 804 806
                                                                                  809 810 814 814 869* 879 883 883 888 893 896 896
                                                                                  908 960 977 978 978 979 986 1008 1014 1015 1018
                                                                                  1021 1023 1027 1039 1040 1042 1043 1045 1091 1099
                                                                                  1119 1139 1228 1259 1261 1268 1271 1289 1289 1293
                                                                                  1295 1300 1302 1359 1360 1361 1364 1365 1369 1370
                                                                                  1395 1396 1397 1397 1439* 1441 1441 1469 1627 1628
                                                                                  1629 1634 1652 1653 1654 1673 1678 1682 1686 1693
                                                                                  1699 1704 1704 1737 1743 1743 1744 1745
cptr                            000240 automatic       pointer                  dcl 1819 set ref 1825* 1829 1829 1830 1839 1845 1850
                                                                                  1850 1855 1855 1859 1864 1871 1879 1882
cylinder                  2(25)        based           fixed bin(11,0)          level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 4-107 in procedure
                                                                                  "disk_control" set ref 499* 1537 1576 1579 1709
                                                                                  1710
cylinder                        000113 automatic       fixed bin(12,0)          dcl 158 in procedure "disk_control" set ref 485* 486
                                                                                  499 1529* 1537 1569* 1576 1579 1709* 1717 1720
                                                                                  1724
cylinder                  1            based           fixed bin(35,0)          level 2 in structure "devtab" dcl 4-190 in procedure
                                                                                  "disk_control" set ref 569* 1529 1569 1709 1710*
dcdcw                    26            based           bit(36)                  level 2 dcl 4-132 set ref 1652
dcdcwp                          000114 automatic       pointer                  dcl 159 set ref 1652* 1658 1659 1660 1661 1663 1665
                                                                                  1669
dcw                                    based           structure                level 1 dcl 12-7
dddcw                    27            based           bit(36)                  level 2 dcl 4-132 set ref 1653
dddcwp                          000116 automatic       pointer                  dcl 160 set ref 1653* 1667 1677 1681 1685 1691 1697
dedp                            000250 automatic       pointer                  dcl 3-20 set ref 1177* 1178 1178 1180 1180 1183 1183
                                                                                  1183 1251 1251 1253 1253 1254
depth                    15(18)        based           fixed bin(17,0)          array level 3 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 576*
depth                    10(18)        based           fixed bin(17,0)          level 3 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 1488 1498 1800 2134 2135* 2135 2136 2136
                                                                                  2186* 2186 2187
depth                     3(18)        based           fixed bin(17,0)          level 2 in structure "opt_info" packed packed
                                                                                  unaligned dcl 4-217 in procedure "disk_control"
                                                                                  set ref 2149* 2149 2164 2203* 2203
depth                     6(18)        based           fixed bin(17,0)          level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 4-31 in procedure "disk_control" set
                                                                                  ref 542* 2069 2070* 2070 2071 2071 2109* 2109
depth                                  based           float bin(27)            level 2 in structure "sys_info" dcl 4-59
                                                                                  in procedure "disk_control" set ref 2147* 2147
                                                                                  2153 2199* 2199
depth                   116            based           float bin(27)            array level 3 in structure "disk_data" dcl 4-31
                                                                                  in procedure "disk_control" set ref 1896*
depth_map                 3            based           bit(18)                  level 2 packed packed unaligned dcl 4-59 set ref
                                                                                  1850* 2147 2147 2153 2199 2199
detailed_status          17            based           bit(8)                   array level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  ref 1018
detailed_status          10            based           bit(36)                  array level 2 in structure "io_status_entry" dcl 9-7
                                                                                  in procedure "disk_control" set ref 1018* 1037
                                                                                  1271 1271
dev                             000120 automatic       fixed bin(6,0)           unsigned dcl 161 in procedure "disk_control" set ref
                                                                                  449* 450 498 564* 566* 807* 808 824* 825 826* 920*
                                                                                  921 923 926 988* 1046 1260 1303 1482* 1483 1631*
                                                                                  1636 1640 1656 1669 1708 1796* 1797 1871* 1872
                                                                                  1872 1875 1876 1965 1970
dev                       2(14)        based           fixed bin(6,0)           level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 4-107 in procedure
                                                                                  "disk_control" set ref 498* 988 1631
dev                       2            based           fixed bin(17,0)          level 2 in structure "opt_info_tune" dcl 1-27
                                                                                  in procedure "disk_control" ref 1871
dev_busy                  4            based           bit(72)                  level 2 dcl 4-74 set ref 511 596* 831* 831 951* 951
                                                                                  1009* 1009 1100* 1100 1337* 1337 1472 1485 1747*
                                                                                  1747
dev_count                       000122 automatic       fixed bin(17,0)          dcl 163 set ref 1477*
dev_index                11(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-74 set ref
                                                                                  1478* 1478 1479 1479* 1482
dev_mask                        000076 constant        bit(72)                  initial array dcl 259 ref 511 831 951 1009 1100 1337
                                                                                  1485 1747 2123 2187
dev_queued                6            based           bit(72)                  level 2 dcl 4-74 set ref 511 597* 1472 2123* 2123
                                                                                  2187* 2187
devadd                          000121 automatic       fixed bin(18,0)          dcl 162 set ref 376* 402* 427* 481 482* 482 484
device                    0(12)        based           bit(6)                   level 2 in structure "io_special_status" packed
                                                                                  packed unaligned dcl 8-14 in procedure
                                                                                  "disk_control" ref 920
device                    0(12)        based           bit(6)                   level 2 in structure "io_msg" packed packed
                                                                                  unaligned dcl 11-14 in procedure "disk_control"
                                                                                  set ref 1260*
device                    0(06)        based           bit(6)                   level 2 in structure "idcw" packed packed unaligned
                                                                                  dcl 13-21 in procedure "disk_control" set ref 807
                                                                                  1046* 1303* 1636* 1656* 1669*
device_inoperative        4(25)        based           bit(1)                   level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 14-26 in procedure "disk_control" set ref 2231
                                                                                  2232* 2235*
device_inoperative        0(31)        based           bit(1)                   level 2 in structure "errflags" packed packed
                                                                                  unaligned dcl 2-16 in procedure "disk_control" set
                                                                                  ref 459* 1330* 1346* 1382* 1389*
device_type               4            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 14-26 ref 484
                                                                                  1229
devname                   4            based           char(4)                  level 2 dcl 11-14 set ref 1264*
devtab                   36            based           structure                array level 2 in structure "disktab" dcl 4-74
                                                                                  in procedure "disk_control" set ref 451 566 827
                                                                                  926 940 997 1477 1477 1479 1479 1487 1798 1872
                                                                                  1872
devtab                                 based           structure                level 1 dcl 4-190 in procedure "disk_control"
dim_info                 10            based           bit(36)                  level 2 dcl 14-26 set ref 444 1230 1791
disk_channel_table                     based           structure                array level 1 dcl 4-94 set ref 513 620 670 691 764
                                                                                  869 1404 1439
disk_data                              based           structure                level 1 dcl 4-31
disk_error_data                        based           structure                array level 1 dcl 3-22 ref 1183
disk_error_data$                000046 external static fixed bin(17,0)          dcl 3-18 set ref 1177
disk_error_interp                      based           structure                level 1 dcl 3-35
disk_lock_meters                       based           structure                level 1 dcl 4-236
disk_seg$                       000050 external static fixed bin(17,0)          dcl 4-24 set ref 539 714 1824 1942
disk_status_descrip                    based           structure                level 1 dcl 3-52
disk_status_interp_array               based           structure                array level 1 dcl 3-30 set ref 1184 1184 1185 1186
diskp                           000260 automatic       pointer                  dcl 4-26 set ref 447 447 450 451 468 468 470 470 474
                                                                                  474 511 511 511 513 562 562 564 564 566 580 581
                                                                                  591 591 596 597 620 624 624 626 633 633 670 677
                                                                                  677 691 693 693 697 697 718 718 745 763 764 770
                                                                                  770 799 799 808 824 824 825 827 831 831 869 889
                                                                                  889 921 923 926 938 938 940 951 951 997 1009 1009
                                                                                  1069 1069 1100 1100 1131 1131 1201 1201 1290 1290
                                                                                  1337 1337 1368 1371 1371 1403 1404 1424 1424 1438
                                                                                  1439 1472 1472 1477 1477 1478 1478 1479 1479 1479
                                                                                  1479 1482 1483 1485 1487 1640 1708 1747 1747 1797
                                                                                  1798 1872 1872 1875 1884 1903* 1904 1944* 1965
                                                                                  1995 1998 2009 2009 2123 2123 2187 2187 2221 2221
disksp                          000256 automatic       pointer                  dcl 4-26 set ref 513 539* 541 542 542 549 549 551
                                                                                  552 558 580 620 626 670 691 714* 716 742 764 814
                                                                                  869 979 987 1015 1032 1264 1404 1439 1492 1498
                                                                                  1552 1600 1824* 1836 1843 1850 1863 1864 1896 1900
                                                                                  1901 1902 1903 1903 1942* 1944 1944 1970 1973 2053
                                                                                  2056 2058 2059 2063 2063 2065 2069 2069 2069 2070
                                                                                  2070 2071 2071 2071 2071 2073 2073 2075 2075 2080
                                                                                  2080 2094 2099 2099 2099 2101 2103 2104 2109 2109
                                                                                  2111 2111 2124 2144 2145 2147 2147 2153 2158 2158
                                                                                  2178 2182 2193 2194 2199 2199
disktab                                based           structure                level 1 dcl 4-74
divide                                                 builtin function         dcl 253 ref 485 864 1231 1231 1237 1241
dlm                                    based           structure                level 1 dcl 2024 in procedure "lock_meter_start"
dlm                                    based           structure                level 1 dcl 1989 in procedure "lock"
dp                              000272 automatic       pointer                  dcl 4-187 set ref 451* 455 566* 567 567 567 569 570
                                                                                  575 576 827* 829 829 835 835 837 838 839 841 926*
                                                                                  927 929 940* 941 944 945 946 949 950 997* 1082
                                                                                  1084 1084 1086 1087 1123 1225 1266 1319 1319 1321
                                                                                  1324 1326 1327 1328 1336 1339 1487* 1488 1488 1492
                                                                                  1498 1529 1537 1568 1568 1569 1576 1709 1710 1717
                                                                                  1720 1798* 1800 2124 2124 2126 2128 2130 2134 2134
                                                                                  2134 2135 2135 2136 2136 2136 2136 2138 2138 2148
                                                                                  2176 2180 2186 2186 2187 2202 2219 2219 2221 2221
                                                                                  2221
dscdcw                   30            based           bit(36)                  level 2 dcl 4-132 set ref 1045
dskdcl_chans_per_subsys                constant        fixed bin(17,0)          initial dcl 4-70 ref 864 868
dskerap                         000252 automatic       pointer                  dcl 3-28 set ref 1178* 1180* 1184 1184 1185 1186
dskerp                          000254 automatic       pointer                  dcl 3-33 set ref 1037 1184* 1185 1186* 1187 1187
                                                                                  1254 1266 1297 1300 1301 1307 1318 1350 1358 1447
ec                                     parameter       fixed bin(35,0)          dcl 1813 set ref 1807 1833* 1908* 1913* 1918* 1923*
                                                                                  1928* 1933*
edac_errors              14            based           fixed bin(17,0)          level 2 dcl 4-74 set ref 1069* 1069
entry_time                      000124 automatic       fixed bin(52,0)          dcl 164 set ref 438* 506 712* 733*
erct                      7(27)        based           fixed bin(8,0)           level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 1268 1289* 1289 1300 1395* 1415* 1628*
erct                      7(27)        based           fixed bin(8,0)           array level 2 in structure "disk_channel_table"
                                                                                  packed packed unaligned dcl 4-94 in procedure
                                                                                  "disk_control" set ref 593*
erfp                            000246 automatic       pointer                  dcl 2-14 set ref 458* 459 974* 1330 1346 1351 1353
                                                                                  1375 1382 1383 1389 1391 1448 1449 1453
errcd                           000126 automatic       fixed bin(35,0)          dcl 165 set ref 456* 458 699* 702 704 973* 974 1131
                                                                                  1770* 1773* 1774*
errflags                               based           structure                level 1 dcl 2-16
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 197 ref 1833 1913 1918 1923 1928 1933
error_table_$io_configured      000012 external static fixed bin(35,0)          dcl 198 ref 699
errors                   12            based           fixed bin(17,0)          level 2 dcl 4-74 set ref 1290* 1290
ext                       0(12)        based           bit(6)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  1665* 1665
ext_ctl                   0(21)        based           bit(1)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  1660*
fatal_error               0(35)        based           bit(1)                   level 2 packed packed unaligned dcl 2-16 set ref
                                                                                  1448* 1453*
ferrors                  13            based           fixed bin(17,0)          level 2 dcl 4-74 set ref 1131* 1131
finterp                   1            based           bit(18)                  array level 2 packed packed unaligned dcl 3-22 ref
                                                                                  1178
first_dev                 2            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-74 ref 564 824
                                                                                  921
fixed                                                  builtin function         dcl 253 ref 807 920 1183
float                                                  builtin function         dcl 253 ref 1537 1855 1886 1886 1887 1887 1891 2164
fnamep                    1(18)        based           bit(18)                  array level 2 packed packed unaligned dcl 3-22 ref
                                                                                  1251
forward                   0(13)        based           bit(1)                   level 2 packed packed unaligned dcl 4-190 set ref
                                                                                  575* 1576 1717* 1720*
fraction                  2            based           float bin(27)            level 2 dcl 4-59 set ref 2153* 2156 2156* 2164
free_q                    4            based           structure                level 2 dcl 4-31 set ref 541*
free_q_entries          152            based           structure                array level 2 dcl 4-31 set ref 552
free_q_size              10            based           fixed bin(17,0)          level 2 dcl 4-31 ref 542 551
hbound                                                 builtin function         dcl 253 ref 1477 1479 1872
head                      7            based           bit(18)                  level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 4-31 in procedure "disk_control" set
                                                                                  ref 2056 2059* 2063 2101*
head                     11            based           bit(18)                  level 3 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 1492 2126* 2176*
i                               000127 automatic       fixed bin(17,0)          dcl 166 set ref 511* 513* 574* 576* 581* 582 584 586
                                                                                  588 588 590 593* 763* 764* 868* 869 1185* 1186*
                                                                                  1403* 1404* 1438* 1439* 1895* 1896* 1902* 1903*
idcw                                   based           structure                level 1 dcl 13-21 set ref 1658*
idcwp                           000310 automatic       pointer                  dcl 13-19 set ref 806* 807 816* 1045* 1046 1047*
                                                                                  1201* 1203 1204* 1204 1206 1293* 1295* 1302* 1303
                                                                                  1304* 1314* 1634* 1635 1636 1648* 1654* 1656 1665
                                                                                  1675
idx                                    parameter       fixed bin(35,0)          dcl 857 ref 854 863
ilevel                                 parameter       fixed bin(3,0)           dcl 857 ref 854 871
ima                             000540 automatic       structure                level 1 dcl 1735 set ref 1741*
imu_detailed_status                    based           bit(8)                   array packed unaligned dcl 1220 set ref 1271*
in_use                    6(18)        based           bit(1)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 515 626 633 635* 676* 696* 767 769* 1370*
                                                                                  1420* 1441 1469
in_use                    6(18)        based           bit(1)                   array level 2 in structure "disk_channel_table"
                                                                                  packed packed unaligned dcl 4-94 in procedure
                                                                                  "disk_control" set ref 588 590*
inop                      6(22)        based           bit(1)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 626 636* 767 1091* 1359 1361* 1364* 1396*
                                                                                  1413*
inop                      0(09)        based           bit(1)                   level 2 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 567* 829 837* 944* 949 950* 1082* 1319
                                                                                  1327* 1336*
inop                      6(22)        based           bit(1)                   array level 2 in structure "disk_channel_table"
                                                                                  packed packed unaligned dcl 4-94 in procedure
                                                                                  "disk_control" set ref 584*
int_idx                         000234 automatic       fixed bin(35,0)          dcl 861 set ref 863* 864 868
int_lock_meters          22            based           structure                level 2 dcl 4-74 set ref 889 889 938 938
intercept                 2            based           float bin(27)            level 2 dcl 4-217 set ref 1887* 1891* 2164
interp                                 based           bit(18)                  array level 2 packed packed unaligned dcl 3-22 ref
                                                                                  1180
intrpt                    1            based           bit(1)                   level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 4-107 in procedure "disk_control"
                                                                                  set ref 491*
intrpt                          000130 automatic       bit(1)                   packed unaligned dcl 167 in procedure "disk_control"
                                                                                  set ref 409* 431* 433* 491
io_manager$connect_abs          000052 constant        entry                    external dcl 7-29 ref 1741
io_manager$get_status           000054 constant        entry                    external dcl 7-35 ref 788 893
io_manager_arg                         based           structure                level 1 dcl 7-50
io_msg                                 based           structure                level 1 dcl 11-14
io_msgp                         000306 automatic       pointer                  dcl 11-12 set ref 1257* 1258 1259 1260 1261 1262
                                                                                  1263 1264 1271*
io_special_status                      based           structure                level 1 dcl 8-14
io_special_status_ptr           000300 automatic       pointer                  dcl 8-12 set ref 916* 917 920
io_status_entry                        based           structure                level 1 dcl 9-7 set ref 891*
io_status_entry_ptr             000302 automatic       pointer                  dcl 9-6 set ref 787* 788* 890* 891 893* 894 1018
                                                                                  1037 1042 1056 1201 1271 1271
io_status_word                         based           structure                level 1 dcl 10-5 ref 979 979 1015 1032 1040 1263
io_status_word_ptr              000304 automatic       pointer                  dcl 10-4 set ref 790* 791 879* 881 894* 895 979 979
                                                                                  1015 1021* 1032 1040 1067 1071 1149 1153 1155 1157
                                                                                  1159 1162 1163 1263
io_type                         000131 automatic       fixed bin(17,0)          dcl 168 set ref 368* 375* 388* 397* 418* 424* 440
                                                                                  441 457 493 1002* 1113 1293 1297 1300 1319 1378
                                                                                  1762 1839* 1840 1840 1843 1859* 1860 1860 1884
ioi_ctx                   1            based           fixed bin(35,0)          level 2 dcl 4-132 ref 908 960
ioi_masked$interrupt            000044 constant        entry                    external dcl 251 ref 908 960
ioi_masked$online_device_count  000042 constant        entry                    external dcl 249 ref 626
ioi_use                   6(21)        based           bit(1)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 647* 675* 888 1405
ioi_use                   6(21)        based           bit(1)                   array level 2 in structure "disk_channel_table"
                                                                                  packed packed unaligned dcl 4-94 in procedure
                                                                                  "disk_control" set ref 588
iom_chx                         000230 automatic       fixed bin(35,0)          dcl 662 set ref 667* 673
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 14-26 set ref
                                                                                  480 1178 1235 1251 1271*
istat                                  parameter       bit(36)                  dcl 857 ref 854 872
just_log                  0(24)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 1266
last_dev                  2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-74 ref 564 824
                                                                                  923 1477 1479 1872 1904
lbound                                                 builtin function         dcl 253 ref 1183 1184 1185 1477 1479 1872
lcp                             000132 automatic       pointer                  dcl 169 set ref 1404* 1405 1407 1411 1413 1415 1417
                                                                                  1420 1423
length                                                 builtin function         dcl 253 ref 1665
level                                  based           bit(3)                   level 2 in structure "io_msg" packed packed
                                                                                  unaligned dcl 11-14 in procedure "disk_control"
                                                                                  set ref 1258*
level                           000134 automatic       fixed bin(3,0)           dcl 170 in procedure "disk_control" set ref 793*
                                                                                  871* 873 881 892 908* 960* 1007 1098 1258 1271
limit                    10            based           bit(12)                  level 3 packed packed unaligned dcl 4-132 set ref
                                                                                  1678* 1682* 1686* 1693* 1699*
listp                                  parameter       pointer                  dcl 1734 in procedure "connect" ref 1731 1740
listp                     6     000540 automatic       pointer                  level 2 in structure "ima" dcl 1735 in procedure
                                                                                  "connect" set ref 1740*
lmp                                    parameter       pointer                  dcl 1989 in procedure "lock" set ref 1986 1994 1994
                                                                                  1997* 2000*
lmp                                    parameter       pointer                  dcl 2024 in procedure "lock_meter_start" ref 2021
                                                                                  2029 2029 2034 2037 2037
load                      4            based           fixed bin(17,0)          level 2 in structure "opt_info_tune" dcl 1-27
                                                                                  in procedure "disk_control" ref 1882
load                            000236 automatic       fixed bin(17,0)          dcl 1818 in procedure "disk_control" set ref 1882*
                                                                                  1885 1886 1887 1887
lock                      3            based           bit(36)                  level 2 in structure "disk_data" packed packed
                                                                                  unaligned dcl 4-31 in procedure "disk_control" set
                                                                                  ref 549* 549 2053 2075 2075 2080 2080 2094 2111
                                                                                  2111 2145 2158 2158 2194
lock                                   based           bit(36)                  level 2 in structure "disktab" packed packed
                                                                                  unaligned dcl 4-74 in procedure "disk_control" ref
                                                                                  745 1995 1998 2009 2009
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 14-26 ref 449
                                                                                  1796
logical_rec_addr                000464 automatic       fixed bin(17,0)          dcl 1221 set ref 1237* 1246* 1271*
logical_sector                  000465 automatic       fixed bin(21,0)          dcl 1222 set ref 1241* 1247* 1271*
lth                                    based           fixed bin(8,0)           level 2 packed packed unaligned dcl 3-52 ref 1271
                                                                                  1271 1271 1271
major                     0(02)        based           bit(4)                   level 2 packed packed unaligned dcl 10-5 ref 1162
majstat                         000135 automatic       fixed bin(5,0)           dcl 171 set ref 1057* 1071* 1074* 1102* 1150* 1154*
                                                                                  1158* 1162* 1178 1180 1251 1253
map                       2            based           fixed bin(17,0)          level 2 dcl 1-11 ref 1845 1850 1850
mask                            000136 automatic       fixed bin(71,0)          dcl 172 set ref 406* 528* 623* 640* 692* 701*
masked                          000140 automatic       bit(1)                   packed unaligned dcl 173 set ref 408* 425* 528
max                                                    builtin function         dcl 253 ref 2199
max_depth                 6            based           fixed bin(17,0)          level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 4-31 in procedure "disk_control" set
                                                                                  ref 1901* 2071 2071*
max_depth                10            based           fixed bin(17,0)          level 3 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 2136 2136*
max_depth                 1            based           float bin(27)            level 2 in structure "sys_info" dcl 4-59
                                                                                  in procedure "disk_control" set ref 1855* 2153
                                                                                  2153
max_depth                46            based           fixed bin(17,0)          array level 4 in structure "disktab" packed packed
                                                                                  unaligned dcl 4-74 in procedure "disk_control" set
                                                                                  ref 1904*
max_depth                 1            based           fixed bin(35,0)          level 2 in structure "sys_info_tune" dcl 1-11
                                                                                  in procedure "disk_control" ref 1855 1855
max_depth_reset_time    114            based           fixed bin(71,0)          level 2 dcl 4-31 set ref 1900*
max_retries               0(12)        based           fixed bin(5,0)           level 2 packed packed unaligned dcl 3-35 ref 1300
memory_unusable           0(30)        based           bit(1)                   level 2 packed packed unaligned dcl 2-16 set ref
                                                                                  1449*
meter_start_time                000142 automatic       fixed bin(52,0)          dcl 174 set ref 2028* 2037
mjsdp                           000460 automatic       pointer                  dcl 1218 set ref 1251* 1253* 1271
mod                                                    builtin function         dcl 253 ref 481 1236 1240 1268
msg_buf                         000174 automatic       structure                level 1 dcl 193 set ref 1256* 1257
multiplier               12            based           float bin(27)            array level 3 in structure "devtab" dcl 4-190
                                                                                  in procedure "disk_control" set ref 1537
multiplier                             based           float bin(27)            level 2 in structure "opt_info" dcl 4-217
                                                                                  in procedure "disk_control" set ref 2164* 2165
                                                                                  2165*
n_sectors                 3            based           fixed bin(6,0)           level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 4-107 in procedure
                                                                                  "disk_control" set ref 501* 1685 1686 1691 1693
n_sectors                       000103 automatic       fixed bin(17,0)          dcl 149 in procedure "disk_control" set ref 381*
                                                                                  401* 430* 501
name                     12            based           char(4)                  array level 3 packed packed unaligned dcl 4-31 set
                                                                                  ref 626* 979* 1264 1864 1970 1973
name_rel                        000144 automatic       fixed bin(17,0)          dcl 175 set ref 1183* 1185
namep                     1            based           bit(18)                  level 2 in structure "disk_error_interp" packed
                                                                                  packed unaligned dcl 3-35 in procedure
                                                                                  "disk_control" ref 1254
namep                     0(18)        based           bit(18)                  array level 2 in structure "disk_error_data" packed
                                                                                  packed unaligned dcl 3-22 in procedure
                                                                                  "disk_control" ref 1183 1253
nchan                     1            based           fixed bin(17,0)          level 2 dcl 4-74 ref 511 581 763 1403 1438
next                                   based           bit(18)                  level 2 packed packed unaligned dcl 4-107 set ref
                                                                                  1548 1597 2059 2065 2099* 2105* 2124* 2129* 2176
                                                                                  2178* 2178 2180 2182
next_lpw_offset           1            based           bit(18)                  level 3 packed packed unaligned dcl 9-7 set ref 1201
no_io_terminate          34            based           fixed bin(35,0)          level 2 dcl 4-132 set ref 896* 896
no_status_terminate      36            based           fixed bin(35,0)          level 2 dcl 4-132 set ref 883* 883
null                                                   builtin function         dcl 253 ref 651 1739
num_of_svs               12            based           fixed bin(17,0)          level 2 dcl 14-26 ref 482 1237 1241
offset                   11            based           bit(18)                  array level 3 packed packed unaligned dcl 4-31 ref
                                                                                  1903 1944
op                              000242 automatic       char(16)                 packed unaligned dcl 1820 set ref 1826* 1828 1838
                                                                                  1858 1894 1899
opt_info                 50            based           structure                array level 3 in structure "disktab" dcl 4-74
                                                                                  in procedure "disk_control" set ref 1640 1708 1884
opt_info                 12            based           structure                array level 2 in structure "devtab" dcl 4-190
                                                                                  in procedure "disk_control" set ref 1123 2148 2202
opt_info                               based           structure                level 1 dcl 4-217 in procedure "disk_control"
opt_info_tune                          based           structure                level 1 dcl 1-27
optp                            000262 automatic       pointer                  dcl 4-26 set ref 1123* 1126 1126 1127 1127 1640*
                                                                                  1641 1641 1644 1644 1708* 1724 1724 1725 1725
                                                                                  1884* 1886 1887 1890 1891 2148* 2149 2149 2164
                                                                                  2164 2164 2164 2165 2165 2202* 2203 2203
other_dev                       000601 automatic       fixed bin(17,0)          dcl 1962 set ref 1965* 1968* 1971 1973
other_name                      000576 automatic       char(12)                 packed unaligned dcl 1961 set ref 1971* 1973* 1975
page$done                       000032 constant        entry                    external dcl 244 ref 1774
page_fault$disk_offline_event   000016 external static bit(36)                  dcl 202 set ref 2233*
pcw                       2     000540 automatic       bit(36)                  level 2 dcl 1735 set ref 1738*
pdi                             000145 automatic       fixed bin(6,0)           unsigned dcl 176 in procedure "disk_control" set ref
                                                                                  450* 451 497 511 808* 825* 826 827 831 927* 940
                                                                                  951 989* 997 1009 1100 1337 1483* 1485 1487 1747
                                                                                  1797* 1798 1875* 1876 1884 1965 1965 1968 2123
                                                                                  2187
pdi                       0(30)        based           fixed bin(6,0)           level 2 in structure "devtab" packed packed unsigned
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  ref 927
pdi                      36(30)        based           fixed bin(6,0)           array level 3 in structure "disktab" packed packed
                                                                                  unsigned unaligned dcl 4-74 in procedure
                                                                                  "disk_control" set ref 450 808 825 1483 1797 1875
pdi                       2(08)        based           fixed bin(6,0)           level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 4-107 in procedure
                                                                                  "disk_control" set ref 497* 989
pds$processid                   000014 external static bit(36)                  packed unaligned dcl 201 ref 745 1995 1998 2053 2094
                                                                                  2145 2194
pic99                                  automatic       picture(2)               packed unaligned dcl 1959 ref 1970 1973
pmut$unwire_unmask              000036 constant        entry                    external dcl 246 ref 528 640 701
pmut$wire_and_mask              000034 constant        entry                    external dcl 245 ref 406 623 692
post_sw                         000146 automatic       bit(1)                   dcl 177 set ref 796 904 975* 1065* 1112 1115* 1331*
                                                                                  1347* 1355* 1376* 1381* 1392* 1407 1432* 1450*
                                                                                  1454* 1765* 1777*
power                     0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 10-5 ref 1149
prev                      0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-107 set ref
                                                                                  2065* 2103* 2128* 2176 2178 2180 2182* 2182
ptp                       4     000540 automatic       pointer                  level 2 in structure "ima" dcl 1735 in procedure
                                                                                  "connect" set ref 1739*
ptp                             000150 automatic       pointer                  dcl 178 in procedure "disk_control" set ref 406*
                                                                                  528* 623* 640* 692* 701*
ptr                                                    builtin function         dcl 253 ref 513 580 620 670 691 764 814 869 987 1404
                                                                                  1439 1492 1552 1600 1903 1944 2058 2065 2099 2124
                                                                                  2147 2147 2153 2178 2182 2199 2199
pvt$array                       000056 external static fixed bin(17,0)          dcl 14-18 set ref 442 839 995 1789 1943 2219 2219
                                                                                  2221 2221
pvt_array                              based           structure                array level 1 dcl 14-24 set ref 442 839 935 995 1789
                                                                                  2219 2219 2221 2221
pvt_arrayp                      000312 automatic       pointer                  dcl 14-21 set ref 935 1943*
pvtdi                                  based           structure                level 1 dcl 4-229
pvtdip                          000274 automatic       pointer                  dcl 4-187 set ref 444* 445 485 486 1230* 1231 1791*
                                                                                  1792
pvte                                   based           structure                level 1 dcl 14-26
pvte_ptr                               parameter       pointer                  dcl 2228 ref 2225 2231 2232 2235
pvtep                           000314 automatic       pointer                  dcl 14-22 set ref 442* 444 449 480 481 482 482 484
                                                                                  839* 935* 937 995* 1114 1178 1229 1230 1235 1236
                                                                                  1237 1237 1241 1241 1251 1271 1271 1789* 1791 1796
pvtx                            000100 automatic       fixed bin(17,0)          dcl 146 in procedure "disk_control" set ref 929* 930
                                                                                  935 991* 995
pvtx                                   based           fixed bin(8,0)           level 2 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  ref 839 929 2219 2219
pvtx                      2            based           fixed bin(8,0)           level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 4-107 in procedure
                                                                                  "disk_control" set ref 496* 991
pvtx                     36            based           fixed bin(8,0)           array level 3 in structure "disktab" packed packed
                                                                                  unaligned dcl 4-74 in procedure "disk_control" set
                                                                                  ref 2221 2221
pxss$notify                     000030 constant        entry                    external dcl 243 ref 2233
qht                                    based           structure                level 1 dcl 4-179
qp                              000266 automatic       pointer                  dcl 4-97 set ref 491 492 493 494 496 497 498 499 501
                                                                                  502 506 552* 553 987* 988 989 990 991 992 993 1002
                                                                                  1121 1123 1321 1344 1351 1492* 1498 1535 1537 1543
                                                                                  1548 1552* 1556* 1558 1576 1579 1587 1593 1597
                                                                                  1600* 1604* 1607* 1608 1623 1627 1631 1633 1635
                                                                                  1640 1641 1661 1665 1667 1673 1676 1676 1680 1680
                                                                                  1684 1685 1686 1690 1691 1693 1708 1709 1710 2058*
                                                                                  2059 2065 2090 2103 2105 2128 2129 2143 2176 2176
                                                                                  2178 2178 2180 2180 2182 2182 2192
qrp                       7            based           bit(18)                  level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 814 986 1627*
qrp                             000152 automatic       bit(18)                  dcl 179 in procedure "disk_control" set ref 553*
                                                                                  986* 987 1548* 1549 1552 1558* 1597* 1598 1600
                                                                                  1608* 2056* 2057 2058 2099 2101 2104 2124 2126
                                                                                  2130
quentry                                based           structure                level 1 dcl 4-107
queue_wait                6            based           fixed bin(52,0)          level 2 dcl 4-217 set ref 1127* 1127
qx                              000153 automatic       fixed bin(8,0)           dcl 180 set ref 551* 552*
reason                                 parameter       varying char             dcl 1812 set ref 1807 1830* 1832* 1907* 1911* 1916*
                                                                                  1921* 1926* 1931*
reassign_address          0(32)        based           bit(1)                   level 2 packed packed unaligned dcl 2-16 set ref
                                                                                  1351*
reconnect_announce_time
                         12            based           fixed bin(52,0)          level 2 dcl 4-132 set ref 809 810* 1629*
record_address                  000457 automatic       fixed bin(18,0)          dcl 1217 set ref 1231* 1236 1237 1246 1271*
record_factor            14            based           fixed bin(17,0)          level 2 dcl 14-26 ref 482 1237
record_offset                   000104 automatic       fixed bin(17,0)          dcl 150 set ref 481* 482 482 1236* 1237 1237
records_per_cyl          13            based           fixed bin(17,0)          level 2 dcl 14-26 ref 481 1236
rel                                                    builtin function         dcl 253 ref 553 1183 1185 1558 1608 1627 1850
required                        000154 automatic       bit(1)                   dcl 181 set ref 617* 626
reseek                    0(18)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 1301
response                  3            based           fixed bin(35,0)          level 2 in structure "opt_info_tune" dcl 1-27
                                                                                  in procedure "disk_control" ref 1879
response                        000235 automatic       fixed bin(35,0)          dcl 1817 in procedure "disk_control" set ref 1879*
                                                                                  1880 1886 1887 1891
rsr                       6(20)        based           bit(1)                   level 2 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 1014 1015* 1027* 1039*
rsr                       0(19)        based           bit(1)                   level 2 in structure "disk_error_interp" packed
                                                                                  packed unaligned dcl 3-35 in procedure
                                                                                  "disk_control" ref 1037
rssdcw                   32            based           bit(36)                  level 2 dcl 4-132 set ref 1293 1634
rstdcw                   23            based           bit(36)                  level 2 dcl 4-132 set ref 1302
run_lock_meters          32            based           structure                level 2 dcl 4-74 set ref 718 718
scdcw                    24            based           bit(36)                  level 2 dcl 4-132 set ref 806 1295 1397 1397 1654
                                                                                  1704 1704
sect_off                        000102 automatic       fixed bin(4,0)           dcl 148 set ref 380* 399* 429* 487
sect_per_cyl                    000011 constant        fixed bin(17,0)          initial array dcl 6-15 ref 1231 1240 1241
sect_per_rec                    000000 constant        fixed bin(17,0)          initial array dcl 6-21 ref 484 1231
sect_sw                         000156 automatic       bit(1)                   packed unaligned dcl 183 set ref 440* 992* 1770
sector                    3(15)        based           bit(21)                  level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 4-107 in procedure "disk_control"
                                                                                  set ref 502* 1673
sector                          000155 automatic       fixed bin(21,0)          dcl 182 in procedure "disk_control" set ref 484* 485
                                                                                  486* 486 487* 487 502 1228* 1231 1231 1240 1241
                                                                                  1247 1271*
sector                   10(15)        based           bit(21)                  level 3 in structure "chantab" packed packed
                                                                                  unaligned dcl 4-132 in procedure "disk_control"
                                                                                  set ref 1228 1673*
sector_map                             defined         bit(1)                   array packed unaligned dcl 4-274 ref 440 992 1684
                                                                                  1690
sector_mapping                  000023 constant        bit(7)                   initial packed unaligned dcl 4-273 ref 440 440 992
                                                                                  992 1684 1684 1690 1690
sector_offset                   000466 automatic       fixed bin(17,0)          dcl 1223 set ref 1240* 1241 1241
seek_512                               constant        bit(6)                   initial packed unaligned dcl 240 ref 1675
seek_command                    000276 automatic       bit(6)                   initial array packed unaligned dcl 5-84 set ref
                                                                                  5-84* 5-84* 5-84* 5-84* 5-84* 5-84* 5-84* 5-84*
                                                                                  5-84*
seek_count               11            based           fixed bin(35,0)          level 2 packed packed unaligned dcl 4-217 set ref
                                                                                  1644* 1644 1725* 1725
seek_sum                 10            based           fixed bin(35,0)          level 2 packed packed unaligned dcl 4-217 set ref
                                                                                  1641* 1641 1724* 1724
seg_unusable              0(33)        based           bit(1)                   level 2 packed packed unaligned dcl 2-16 set ref
                                                                                  1353*
select_data              10            based           structure                level 2 dcl 4-132
setting                                parameter       bit(1)                   dcl 2214 ref 2211 2231 2235
slope                     1            based           float bin(27)            level 2 dcl 4-217 set ref 1886* 1890* 2164
ssdp                            000462 automatic       pointer                  dcl 1219 set ref 1254* 1271
stacq                                                  builtin function         dcl 253 ref 745 1995 1998 2009 2053 2075 2080 2094
                                                                                  2111 2145 2158 2194
stagnate_time                          based           fixed bin(35,0)          dcl 1815 in procedure "disk_control" ref 1829 1829
                                                                                  1830 1836
stagnate_time           111            based           fixed bin(35,0)          level 2 in structure "disk_data" dcl 4-31
                                                                                  in procedure "disk_control" set ref 1498 1836*
stat                            000157 automatic       bit(36)                  dcl 184 set ref 872* 908* 916 960* 1271*
stat_entry                      000207 automatic       structure                level 1 packed packed unaligned dcl 195 set ref 787
                                                                                  890
status                   33            based           bit(36)                  level 2 in structure "chantab" dcl 4-132
                                                                                  in procedure "disk_control" set ref 1021 1040*
status                    3            based           bit(36)                  level 2 in structure "io_msg" dcl 11-14 in procedure
                                                                                  "disk_control" set ref 1263*
status_from_run          37            based           fixed bin(35,0)          level 2 dcl 4-132 set ref 792* 792
status_mask               2            based           bit(36)                  level 2 dcl 4-31 ref 1015 1032
status_time                     000160 automatic       fixed bin(52,0)          dcl 185 set ref 786* 804 809 810 984* 1118* 1119
                                                                                  1121
statusp                   2            based           pointer                  level 2 in structure "chantab" dcl 4-132
                                                                                  in procedure "disk_control" set ref 646 674* 879
statusp                         000232 automatic       pointer                  dcl 663 in procedure "disk_control" set ref 668* 674
storage_system            4(19)        based           bit(1)                   level 2 packed packed unaligned dcl 14-26 ref 937
string                                                 builtin function         dcl 253 ref 979 979 1015 1032 1040 1263
sub                       0(06)        based           bit(6)                   level 2 packed packed unaligned dcl 10-5 ref 1067
                                                                                  1071 1163
sub_sys                   1            based           char(4)                  level 2 dcl 1-27 ref 1864
substat                         000164 automatic       bit(6)                   dcl 188 set ref 1058* 1076* 1103* 1151* 1155* 1159*
                                                                                  1163* 1187
substr                                                 builtin function         dcl 253 ref 1635 1665 1667
subsystems                             based           fixed bin(17,0)          level 2 dcl 4-31 ref 558 716 742 1863 1902
sum                       6            based           fixed bin(35,0)          level 3 in structure "devtab" dcl 4-190 in procedure
                                                                                  "disk_control" set ref 2134* 2134
sum                       4            based           fixed bin(35,0)          level 3 in structure "disk_data" dcl 4-31
                                                                                  in procedure "disk_control" set ref 2069* 2069
sv_name                  15            based           char(2)                  level 2 dcl 14-26 set ref 1271*
sv_num                   11            based           fixed bin(17,0)          level 2 dcl 14-26 ref 1241
sx                              000162 automatic       fixed bin(8,0)           dcl 186 in procedure "disk_control" set ref 445*
                                                                                  472* 558* 616* 626 665* 688* 716* 735* 742* 743*
                                                                                  752* 864* 868 954* 979 1264 1792* 1863* 1864* 1944
                                                                                  1970 1973
sx                                     based           fixed bin(11,0)          level 2 in structure "pvtdi" packed packed unaligned
                                                                                  dcl 4-229 in procedure "disk_control" ref 445 1792
sys_info                116            based           structure                array level 2 in structure "disk_data" dcl 4-31
                                                                                  in procedure "disk_control" set ref 1843 1850 2144
                                                                                  2193
sys_info                               based           structure                level 1 dcl 4-59 in procedure "disk_control"
sys_info_tune                          based           structure                level 1 dcl 1-11
sysc                            000163 automatic       fixed bin(17,0)          dcl 187 set ref 811* 813* 814* 1266* 1268* 1270*
                                                                                  1271*
syserr                          000024 constant        entry                    external dcl 241 ref 702 814 942 979 1089 1321 1369
                                                                                  1623
syserr$binary                   000026 constant        entry                    external dcl 242 ref 1271
sysp                            000264 automatic       pointer                  dcl 4-26 set ref 1843* 1850 1855 2144* 2147 2147
                                                                                  2153 2153 2153 2153 2156 2156 2164 2193* 2199 2199
t                                      based           bit(1)                   level 2 in structure "io_special_status" packed
                                                                                  packed unaligned dcl 8-14 in procedure
                                                                                  "disk_control" ref 917
t                                      based           bit(1)                   level 2 in structure "io_status_word" packed packed
                                                                                  unaligned dcl 10-5 in procedure "disk_control" ref
                                                                                  791 881 895
tail                     11(18)        based           bit(18)                  level 3 in structure "devtab" packed packed
                                                                                  unaligned dcl 4-190 in procedure "disk_control"
                                                                                  set ref 2124 2124 2128 2130* 2180*
tail                      7(18)        based           bit(18)                  level 3 in structure "disk_data" packed packed
                                                                                  unaligned dcl 4-31 in procedure "disk_control" set
                                                                                  ref 2063* 2099 2099 2103 2104*
tally                     0(24)        based           bit(12)                  level 2 packed packed unaligned dcl 12-7 set ref
                                                                                  1677* 1681* 1685* 1691* 1697*
tally_residue             3(24)        based           fixed bin(12,0)          level 3 packed packed unsigned unaligned dcl 9-7 set
                                                                                  ref 1056
tc_data$system_shutdown         000020 external static fixed bin(17,0)          dcl 204 ref 1334 1380 1388
temp_time                       000166 automatic       fixed bin(52,0)          dcl 189 set ref 1309* 1310
terminate_not_active     35            based           fixed bin(35,0)          level 2 dcl 4-132 set ref 978* 978
testing                   4(21)        based           bit(1)                   level 2 packed packed unaligned dcl 14-26 set ref
                                                                                  1114*
this_comb                       000522 automatic       fixed bin(35,0)          dcl 1516 set ref 1576* 1579* 1581 1583 1585 1586
                                                                                  1591 1592
this_name                       000574 automatic       char(8)                  packed unaligned dcl 1960 set ref 1970* 1975 1978
this_seek                       000517 automatic       float bin(27)            dcl 1516 set ref 1537* 1538 1541 1542
time                      4            based           fixed bin(71,0)          level 2 dcl 4-107 set ref 506* 1121 1498
time_inop                 4            based           fixed bin(52,0)          level 2 dcl 4-190 set ref 829 835 1328* 1339*
type                      1(02)        based           fixed bin(4,0)           level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 4-107 in procedure
                                                                                  "disk_control" set ref 493* 814 992 993 1002 1123
                                                                                  1321 1344 1351 1535 1633 1640 1661 1676 1676 1680
                                                                                  1680 1684 1690 1708 2143 2192
type                            000530 automatic       fixed bin(17,0)          dcl 1516 in procedure "find_shortest_seek" set ref
                                                                                  1535* 1537
type                                   based           fixed bin(17,0)          level 2 in structure "sys_info_tune" dcl 1-11
                                                                                  in procedure "disk_control" ref 1839
type                      0(19)        based           bit(2)                   level 2 in structure "io_msg" packed packed
                                                                                  unaligned dcl 11-14 in procedure "disk_control"
                                                                                  set ref 1261*
type                            000624 automatic       fixed bin(17,0)          dcl 2049 in procedure "get_free_q" set ref 2143*
                                                                                  2144 2148 2192* 2193 2202
type                            000456 automatic       fixed bin(17,0)          dcl 1216 in procedure "printerr" set ref 1229* 1231
                                                                                  1231 1240 1241
type                                   based           fixed bin(17,0)          level 2 in structure "opt_info_tune" dcl 1-27
                                                                                  in procedure "disk_control" ref 1859
unspec                                                 builtin function         dcl 253 set ref 541* 549* 549 570* 891* 1018* 1018
                                                                                  1256* 1658*
unused_sect_per_cyl       0(24)        based           fixed bin(11,0)          level 2 packed packed unaligned dcl 4-229 ref 486
                                                                                  1231
usable_sect_per_cyl       0(12)        based           fixed bin(11,0)          level 2 packed packed unaligned dcl 4-229 ref 485
used                      1(01)        based           bit(1)                   level 2 packed packed unaligned dcl 4-107 set ref
                                                                                  492* 1623 2090*
usurped                         000170 automatic       bit(1)                   dcl 190 set ref 626* 632 642
vtoc_interrupt                  000040 constant        entry                    external dcl 248 ref 1773
wait_time                       000172 automatic       fixed bin(52,0)          dcl 191 in procedure "disk_control" set ref 1121*
                                                                                  1127
wait_time                 2            based           fixed bin(52,0)          level 2 in structure "dlm" dcl 2024 in procedure
                                                                                  "lock_meter_start" set ref 2037* 2037
waits                     1            based           fixed bin(17,0)          level 2 dcl 2024 set ref 2029* 2029
was_broken                0(10)        based           bit(1)                   level 2 packed packed unaligned dcl 4-190 set ref
                                                                                  567* 838* 945* 1084 1086* 1326*
word1                           000207 automatic       structure                level 2 in structure "stat_entry" packed packed
                                                                                  unaligned dcl 195 in procedure "disk_control" set
                                                                                  ref 790
word1                                  based           structure                level 2 in structure "io_status_entry" dcl 9-7
                                                                                  in procedure "disk_control" set ref 894
word2                     1            based           structure                level 2 dcl 9-7
word4                     3            based           structure                level 2 dcl 9-7
wq                        6            based           structure                level 2 in structure "devtab" dcl 4-190 in procedure
                                                                                  "disk_control" set ref 570*
wq                       44            based           structure                array level 3 in structure "disktab" dcl 4-74
                                                                                  in procedure "disk_control"
write_map                              defined         bit(1)                   array packed unaligned dcl 4-269 ref 457 1351 1661
write_mapping                   000024 constant        bit(7)                   initial packed unaligned dcl 4-268 ref 457 457 1351
                                                                                  1351 1661 1661

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BOOTLOAD_READ                          internal static fixed bin(4,0)           initial dcl 4-251
BOOTLOAD_WRITE                         internal static fixed bin(4,0)           initial dcl 4-251
DSC_LISTX                              internal static fixed bin(12,0)          initial dcl 4-241
MAX_IO_NAME                            internal static fixed bin(17,0)          initial dcl 1-44
MODEL                                  internal static fixed bin(17,0)          initial array dcl 5-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 5-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 5-60
RSS_LISTX                              internal static fixed bin(12,0)          initial dcl 4-241
RST_LISTX                              internal static fixed bin(12,0)          initial dcl 4-241
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 15-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 15-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 15-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 15-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 15-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 15-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 15-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 15-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 15-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 15-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 15-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 15-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 15-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 15-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 15-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 15-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 15-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 15-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 15-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 15-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 15-21
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 15-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 15-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 15-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 15-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 15-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 15-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 15-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 15-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 15-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 15-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 15-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 15-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 15-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 15-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 15-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 15-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 15-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 15-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 15-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 15-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 15-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 15-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 15-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 15-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 15-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 15-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 15-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 15-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 15-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 15-47
SC_LISTX                               internal static fixed bin(12,0)          initial dcl 4-241
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 16-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 16-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 16-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 14-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 14-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 14-113
bulkdevt                               internal static fixed bin(4,0)           initial dcl 5-43
code_names                             internal static char(32)                 initial array packed unaligned dcl 1-51
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 5-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 5-105
dctl$disk_inter                 000000 constant        entry                    external dcl 247
dcwp                                   automatic       pointer                  dcl 12-4
dev_time                               internal static float bin(27)            initial array dcl 5-139
device_names                           internal static char(4)                  initial array dcl 5-66
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 15-144
dsdp                                   automatic       pointer                  dcl 3-50
dskdcl_chans_per_subsys_shift          internal static fixed bin(17,0)          initial dcl 4-71
dsu181devt                             internal static fixed bin(4,0)           initial dcl 5-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 5-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 5-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 5-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 5-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 5-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 5-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 5-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 5-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 5-124
io_manager$assign               000000 constant        entry                    external dcl 7-10
io_manager$assign_add           000000 constant        entry                    external dcl 7-15
io_manager$connect              000000 constant        entry                    external dcl 7-26
io_manager$connect_direct       000000 constant        entry                    external dcl 7-32
io_manager$ignore_interrupt     000000 constant        entry                    external dcl 7-41
io_manager$mask                 000000 constant        entry                    external dcl 7-38
io_manager$unassign             000000 constant        entry                    external dcl 7-20
io_manager$unassign_delete      000000 constant        entry                    external dcl 7-23
io_manager$workspace_tdcw       000000 constant        entry                    external dcl 7-47
io_manager_arg_ptr                     automatic       pointer                  dcl 7-49
io_name                                internal static char(10)                 initial array packed unaligned dcl 1-46
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 5-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 5-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 5-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 5-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 5-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 5-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 5-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 5-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 5-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 5-93
pcw                                    based           structure                level 1 dcl 13-6
pcwp                                   automatic       pointer                  dcl 13-4
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 14-19
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 5-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 5-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 5-90
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 6-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 6-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 6-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 5-78
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 15-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 15-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 15-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 15-141
tdcw                                   based           structure                level 1 dcl 12-14
tdcwp                                  automatic       pointer                  dcl 12-4
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 5-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 5-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 5-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 6-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 6-36

NAMES DECLARED BY EXPLICIT CONTEXT.
add_channel                     002154 constant        entry                    external dcl 683
add_free_q                      007572 constant        entry                    internal dcl 2087 ref 555 1136
add_wq                          007654 constant        entry                    internal dcl 2117 ref 521 1340 1433
bad_io_dev                      003325 constant        label                    dcl 1926 ref 1872 1876
bad_io_sub_sys                  003307 constant        label                    dcl 1921 set ref 1867
bad_io_type                     003257 constant        label                    dcl 1911 ref 1840 1860
bad_map_type                    003273 constant        label                    dcl 1916 ref 1845
call_exit                       001444 constant        label                    dcl 528 ref 463
call_run                        002347 constant        entry                    external dcl 729 ref 472 954
cede_channel                    002077 constant        entry                    external dcl 656
check_special_stat              003721 constant        entry                    internal dcl 913 ref 874
check_stat                      004120 constant        entry                    internal dcl 970 ref 794 901
comb                            006772 constant        entry                    internal dcl 1565 ref 1501
comb_found                      007051 constant        label                    dcl 1604 ref 1598
comb_loop                       007006 constant        label                    dcl 1576 ref 1601
connect                         007065 constant        entry                    internal dcl 1731 ref 816 1047 1304 1314 1397 1648
                                                                                  1704
del_q                           010055 constant        entry                    internal dcl 2171 ref 1503
disk_control                    000723 constant        entry                    external dcl 135
disk_inter                      002424 constant        entry                    external dcl 854
disk_name                       007214 constant        entry                    internal dcl 1955 ref 814 814 942 942 1089 1089 1271
                                                                                  1271 1321 1321
disk_read                       001071 constant        entry                    external dcl 421
disk_run                        002307 constant        entry                    external dcl 709
disk_write                      001056 constant        entry                    external dcl 415
esd_reset_locks                 001461 constant        entry                    external dcl 536
extract_status                  004603 constant        entry                    internal dcl 1146 ref 1024 1033
find_shortest_seek              006720 constant        entry                    internal dcl 1513 ref 1498
get_disk_command                004741 constant        entry                    internal dcl 1198 ref 1035 1078
get_free_q                      007444 constant        entry                    internal dcl 2046 ref 469 471
getwork                         006156 constant        entry                    internal dcl 1466 ref 782 1139 1442
go_common                       001120 constant        label                    dcl 438 ref 410
go_masked                       001034 constant        label                    dcl 406 ref 382
go_page                         001101 constant        label                    dcl 425 ref 419
go_sector                       000762 constant        label                    dcl 376 ref 369
go_test                         001031 constant        label                    dcl 399 ref 390
gotwork                         006317 constant        entry                    internal dcl 1620 ref 516
handle_error                    005403 constant        entry                    internal dcl 1285 ref 1025 1050 1059 1104
interpret_status                004646 constant        entry                    internal dcl 1173 ref 1034 1077 1292
ioi_special                     004101 constant        label                    dcl 960 ref 921
lock                            007353 constant        entry                    internal dcl 1986 ref 447 562 624 693 718 799 889
                                                                                  938
lock_meter_start                007422 constant        entry                    internal dcl 2021 ref 470 1997
lock_meter_stop                 007432 constant        entry                    internal dcl 2034 ref 474 2000
post                            007125 constant        entry                    internal dcl 1759 ref 462 798 904
printerr                        004771 constant        entry                    internal dcl 1213 ref 1079 1297
queue_length_given_pvtx         002606 constant        entry                    external dcl 1786
read_sectors                    000752 constant        entry                    external dcl 372
response_range                  003343 constant        label                    dcl 1931 ref 1880
run                             003361 constant        entry                    internal dcl 758 ref 599 719 737 747
seek_found                      006765 constant        label                    dcl 1556 ref 1549
seek_loop                       006726 constant        label                    dcl 1535 ref 1553
seek_on_cylinder                006767 constant        label                    dcl 1558 ref 1538 1581
set                             010231 constant        entry                    internal dcl 2225 ref 2219 2221
set_pvte_inop                   010176 constant        entry                    internal dcl 2211 ref 840 943 1088 1325 1344 1379
setup                           007176 constant        entry                    internal dcl 1938 ref 446 559 619 669 690 717 736
                                                                                  744 753 866 1794 1869
test_drive                      001000 constant        entry                    external dcl 385
tune                            002661 constant        entry                    external dcl 1807
tune_sub_sys                    003053 constant        label                    dcl 1869 ref 1864
unload_drive                    001016 constant        entry                    external dcl 394
unlock                          007413 constant        entry                    internal dcl 2006 ref 461 525 560 600 639 700 720
                                                                                  748 797 897 902 956
usurp_channel                   001672 constant        entry                    external dcl 607
working                         001443 constant        label                    dcl 525 ref 517
wq_common                       010006 constant        label                    dcl 2153 ref 2204
write_sectors                   000737 constant        entry                    external dcl 365
xfer_join                       006320 constant        label                    dcl 1623 ref 1504

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11036       11116   10421       11046
Length     11740   10421        60         605     414           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
disk_control                        846 external procedure  is an external procedure.  
run                                     internal procedure  shares stack frame of external procedure disk_control.  
check_special_stat                      internal procedure  shares stack frame of external procedure disk_control.  
check_stat                              internal procedure  shares stack frame of external procedure disk_control.  
extract_status                          internal procedure  shares stack frame of external procedure disk_control.  
interpret_status                        internal procedure  shares stack frame of external procedure disk_control.  
get_disk_command                        internal procedure  shares stack frame of external procedure disk_control.  
printerr                                internal procedure  shares stack frame of external procedure disk_control.  
handle_error                            internal procedure  shares stack frame of external procedure disk_control.  
getwork                                 internal procedure  shares stack frame of external procedure disk_control.  
find_shortest_seek                      internal procedure  shares stack frame of external procedure disk_control.  
connect                                 internal procedure  shares stack frame of external procedure disk_control.  
post                                    internal procedure  shares stack frame of external procedure disk_control.  
setup                                   internal procedure  shares stack frame of external procedure disk_control.  
disk_name                               internal procedure  shares stack frame of external procedure disk_control.  
lock                                    internal procedure  shares stack frame of external procedure disk_control.  
lock_meter_start                        internal procedure  shares stack frame of external procedure disk_control.  
get_free_q                              internal procedure  shares stack frame of external procedure disk_control.  
set_pvte_inop                           internal procedure  shares stack frame of external procedure disk_control.  
set                                     internal procedure  shares stack frame of external procedure disk_control.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
disk_control             000100 pvtx                        disk_control
                         000101 coreadd                     disk_control
                         000102 sect_off                    disk_control
                         000103 n_sectors                   disk_control
                         000104 record_offset               disk_control
                         000105 bootload_sw                 disk_control
                         000106 call_run_sx                 disk_control
                         000110 channel_time                disk_control
                         000112 command                     disk_control
                         000113 cylinder                    disk_control
                         000114 dcdcwp                      disk_control
                         000116 dddcwp                      disk_control
                         000120 dev                         disk_control
                         000121 devadd                      disk_control
                         000122 dev_count                   disk_control
                         000124 entry_time                  disk_control
                         000126 errcd                       disk_control
                         000127 i                           disk_control
                         000130 intrpt                      disk_control
                         000131 io_type                     disk_control
                         000132 lcp                         disk_control
                         000134 level                       disk_control
                         000135 majstat                     disk_control
                         000136 mask                        disk_control
                         000140 masked                      disk_control
                         000142 meter_start_time            disk_control
                         000144 name_rel                    disk_control
                         000145 pdi                         disk_control
                         000146 post_sw                     disk_control
                         000150 ptp                         disk_control
                         000152 qrp                         disk_control
                         000153 qx                          disk_control
                         000154 required                    disk_control
                         000155 sector                      disk_control
                         000156 sect_sw                     disk_control
                         000157 stat                        disk_control
                         000160 status_time                 disk_control
                         000162 sx                          disk_control
                         000163 sysc                        disk_control
                         000164 substat                     disk_control
                         000166 temp_time                   disk_control
                         000170 usurped                     disk_control
                         000172 wait_time                   disk_control
                         000174 msg_buf                     disk_control
                         000207 stat_entry                  disk_control
                         000227 chx                         disk_control
                         000230 iom_chx                     disk_control
                         000232 statusp                     disk_control
                         000234 int_idx                     disk_control
                         000235 response                    disk_control
                         000236 load                        disk_control
                         000240 cptr                        disk_control
                         000242 op                          disk_control
                         000246 erfp                        disk_control
                         000250 dedp                        disk_control
                         000252 dskerap                     disk_control
                         000254 dskerp                      disk_control
                         000256 disksp                      disk_control
                         000260 diskp                       disk_control
                         000262 optp                        disk_control
                         000264 sysp                        disk_control
                         000266 qp                          disk_control
                         000270 cp                          disk_control
                         000272 dp                          disk_control
                         000274 pvtdip                      disk_control
                         000276 seek_command                disk_control
                         000300 io_special_status_ptr       disk_control
                         000302 io_status_entry_ptr         disk_control
                         000304 io_status_word_ptr          disk_control
                         000306 io_msgp                     disk_control
                         000310 idcwp                       disk_control
                         000312 pvt_arrayp                  disk_control
                         000314 pvtep                       disk_control
                         000456 type                        printerr
                         000457 record_address              printerr
                         000460 mjsdp                       printerr
                         000462 ssdp                        printerr
                         000464 logical_rec_addr            printerr
                         000465 logical_sector              printerr
                         000466 sector_offset               printerr
                         000516 best_seek                   find_shortest_seek
                         000517 this_seek                   find_shortest_seek
                         000520 best_pos_comb               find_shortest_seek
                         000521 best_neg_comb               find_shortest_seek
                         000522 this_comb                   find_shortest_seek
                         000524 best_qp                     find_shortest_seek
                         000526 best_neg_qp                 find_shortest_seek
                         000530 type                        find_shortest_seek
                         000540 ima                         connect
                         000574 this_name                   disk_name
                         000576 other_name                  disk_name
                         000601 other_dev                   disk_name
                         000624 type                        get_free_q

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_l_a               r_g_a               r_e_as              r_ne_as             alloc_char_temp
cat_realloc_chars   call_ext_in         call_ext_out_desc   call_ext_out        return_mac          mdfx1
signal_op           shorten_stack       ext_entry           ext_entry_desc      divide_fx3          stacq_mac
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bootload_disk_post            io_manager$connect_abs        io_manager$get_status         ioi_masked$interrupt
ioi_masked$online_device_count                              page$done                     pmut$unwire_unmask
pmut$wire_and_mask            pxss$notify                   syserr                        syserr$binary
vtoc_interrupt

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
disk_error_data$              disk_seg$                     error_table_$bad_arg          error_table_$io_configured
page_fault$disk_offline_event pds$processid                 pvt$array                     tc_data$system_shutdown


CONSTANTS
010266  aa     777777775777

010270  aa     000002000000
010271  aa     000000000000
010272  aa     600000000041
010273  aa     001506000000

010274  aa     577777777777

010275  aa  070 322 000 000	8

010276  aa     777757777777

010300  aa     000002000000
010301  aa     000000000000
010302  aa     600000000041
010303  aa     001452000000

010304  aa     000002000000
010305  aa     000000000000
010306  aa     600000000041
010307  aa     001362000000

010310  aa     000002000000
010311  aa     000000000000
010312  ta     000335000000
010313  aa     000000000000

010314  aa     000004000000
010315  aa     000000000000
010316  ta     000336000000
010317  aa     000000000000
010320  aa     600000000041
010321  aa     001374000000

010322  aa     000004000000
010323  aa     000000000000
010324  ta     000336000000
010325  aa     000000000000
010326  aa     600000000041
010327  aa     001224000000

010330  aa     000004000000
010331  aa     000000000000
010332  ta     000335000000
010333  aa     000000000000
010334  aa     600000000041
010335  aa     001062000000

010336  aa     777777677777

010340  aa     000004000000
010341  aa     000000000000
010342  ta     000335000000
010343  aa     000000000000
010344  aa     600000000041
010345  aa     001012000000

010346  aa     000002000000
010347  aa     000000000000
010350  aa     600000000041
010351  aa     000776000000

010352  aa     000002000000
010353  aa     000000000000
010354  ta     000336000000
010355  aa     000000000000

010356  aa     000002000000
010357  aa     000000000000
010360  aa     600000000041
010361  aa     000310000000

010362  aa     000004000000
010363  aa     000000000000
010364  ta     000336000000
010365  aa     000000000000
010366  aa     600000000041
010367  aa     000722000000

010370  aa     000002000000
010371  aa     000000000000
010372  aa     600000000041
010373  aa     000716000000

010374  aa     777777737777

010375  aa     777777377777

010376  aa     777777767777

010377  aa     777777757777

010400  aa     777777577777

010401  aa     777377777777

010402  aa     777577777777

010403  aa     777677777777

010404  aa     000007777777

010405  aa     000017600000

010406  aa     000002000000
010407  aa     000000000000
010410  aa     600000000041
010411  aa     000643000000

010412  aa     000002000000
010413  aa     000000000000
010414  aa     600000000041
010415  aa     000652000000

000000  aa     000000000000
000001  aa     000000000020
000002  aa     000000000020
000003  aa     000000000020
000004  aa     000000000020
000005  aa     000000000020
000006  aa     000000000020
000007  aa     000000000002
000010  aa     000000000002

000011  aa     000000000000
000012  aa     000000001370
000013  aa     000000001370
000014  aa     000000001370
000015  aa     000000001115
000016  aa     000000000550
000017  aa     000000002400
000020  aa     000000000377
000021  aa     000000000377

000022  aa     014000000000

000023  aa     174000000000

000024  aa     244000000000

000025  aa  120 141 147 145	Page
000026  aa  040 122 145 141	 Rea
000027  aa  144 040 040 040	d   
000030  aa  040 040 040 040	    
000031  aa  120 141 147 145	Page
000032  aa  040 127 162 151	 Wri
000033  aa  164 145 040 040	te  
000034  aa  040 040 040 040	    
000035  aa  126 124 117 103	VTOC
000036  aa  040 122 145 141	 Rea
000037  aa  144 040 040 040	d   
000040  aa  040 040 040 040	    
000041  aa  126 124 117 103	VTOC
000042  aa  040 127 162 151	 Wri
000043  aa  164 145 040 040	te  
000044  aa  040 040 040 040	    
000045  aa  124 145 163 164	Test
000046  aa  040 040 040 040	    
000047  aa  040 040 040 040	    
000050  aa  040 040 040 040	    
000051  aa  102 157 157 164	Boot
000052  aa  154 157 141 144	load
000053  aa  040 122 145 141	 Rea
000054  aa  144 040 040 040	d   
000055  aa  102 157 157 164	Boot
000056  aa  154 157 141 144	load
000057  aa  040 127 162 151	 Wri
000060  aa  164 145 040 040	te  

000061  aa  162 145 163 145	rese
000062  aa  164 137 155 141	t_ma
000063  aa  170 000 000 000	x

000064  aa  162 145 163 145	rese
000065  aa  164 137 163 171	t_sy
000066  aa  163 000 000 000	s

000070  aa  163 164 141 147	stag
000071  aa  156 141 164 145	nate

000072  aa  157 160 164 137	opt_
000073  aa  164 165 156 145	tune

000074  aa  163 171 163 137	sys_
000075  aa  164 165 156 145	tune

000076  aa     400000000000
000077  aa     000000000000
000100  aa     200000000000
000101  aa     000000000000
000102  aa     100000000000
000103  aa     000000000000
000104  aa     040000000000
000105  aa     000000000000
000106  aa     020000000000
000107  aa     000000000000
000110  aa     010000000000
000111  aa     000000000000
000112  aa     004000000000
000113  aa     000000000000
000114  aa     002000000000
000115  aa     000000000000
000116  aa     001000000000
000117  aa     000000000000
000120  aa     000400000000
000121  aa     000000000000
000122  aa     000200000000
000123  aa     000000000000
000124  aa     000100000000
000125  aa     000000000000
000126  aa     000040000000
000127  aa     000000000000
000130  aa     000020000000
000131  aa     000000000000
000132  aa     000010000000
000133  aa     000000000000
000134  aa     000004000000
000135  aa     000000000000
000136  aa     000002000000
000137  aa     000000000000
000140  aa     000001000000
000141  aa     000000000000
000142  aa     000000400000
000143  aa     000000000000
000144  aa     000000200000
000145  aa     000000000000
000146  aa     000000100000
000147  aa     000000000000
000150  aa     000000040000
000151  aa     000000000000
000152  aa     000000020000
000153  aa     000000000000
000154  aa     000000010000
000155  aa     000000000000
000156  aa     000000004000
000157  aa     000000000000
000160  aa     000000002000
000161  aa     000000000000
000162  aa     000000001000
000163  aa     000000000000
000164  aa     000000000400
000165  aa     000000000000
000166  aa     000000000200
000167  aa     000000000000
000170  aa     000000000100
000171  aa     000000000000
000172  aa     000000000040
000173  aa     000000000000
000174  aa     000000000020
000175  aa     000000000000
000176  aa     000000000010
000177  aa     000000000000
000200  aa     000000000004
000201  aa     000000000000
000202  aa     000000000002
000203  aa     000000000000
000204  aa     000000000001
000205  aa     000000000000
000206  aa     000000000000
000207  aa     400000000000
000210  aa     000000000000
000211  aa     200000000000
000212  aa     000000000000
000213  aa     100000000000
000214  aa     000000000000
000215  aa     040000000000
000216  aa     000000000000
000217  aa     020000000000
000220  aa     000000000000
000221  aa     010000000000
000222  aa     000000000000
000223  aa     004000000000
000224  aa     000000000000
000225  aa     002000000000
000226  aa     000000000000
000227  aa     001000000000
000230  aa     000000000000
000231  aa     000400000000
000232  aa     000000000000
000233  aa     000200000000
000234  aa     000000000000
000235  aa     000100000000
000236  aa     000000000000
000237  aa     000040000000
000240  aa     000000000000
000241  aa     000020000000
000242  aa     000000000000
000243  aa     000010000000
000244  aa     000000000000
000245  aa     000004000000
000246  aa     000000000000
000247  aa     000002000000
000250  aa     000000000000
000251  aa     000001000000
000252  aa     000000000000
000253  aa     000000400000
000254  aa     000000000000
000255  aa     000000200000
000256  aa     000000000000
000257  aa     000000100000
000260  aa     000000000000
000261  aa     000000040000
000262  aa     000000000000
000263  aa     000000020000
000264  aa     000000000000
000265  aa     000000010000
000266  aa     000000000000
000267  aa     000000004000
000270  aa     000000000000
000271  aa     000000002000
000272  aa     000000000000
000273  aa     000000001000
000274  aa     000000000000
000275  aa     000000000400

000276  aa  144 151 163 153	disk
000277  aa  137 143 157 156	_con
000300  aa  164 162 157 154	trol
000301  aa  040 040 040 040	    

000302  aa     000344703400

000303  aa     001256512400

000304  aa     000023045500

000305  aa     000007502200

000306  aa     000162341600

010416  aa  137 000 000 000	_

000307  aa     400000000001

000310  aa     377777777777

000311  aa     310623713116

000312  aa     524000000022

000313  aa     524000000030

000314  aa     524000000035

000315  aa     000002670660

000316  aa     524000000002

000317  aa     516000000001

000320  aa     404000000025

000321  aa     404000000022

000322  aa     526000000000

000323  aa     524000000257

000324  aa     524000000027

000325  aa     524000000065

000326  aa     524000000034

000327  aa     524000000052

010417  aa     300000000000

010420  aa     340000000000

000330  aa     002535225000

000331  aa     524000000010

000332  aa     526000000020

000333  aa     524000000026

000334  aa     526000000004

000335  aa     400000000000

000336  aa     000000000000

000337  aa     524000000025

000340  aa     530077777777

000341  aa     526077777777

000342  aa     404000000003

000343  aa     514000000044

000344  aa     464000000000

000345  aa     514000000001

000346  aa     404000000043

000347  aa     404000000010

000350  aa     000000000005

000351  aa     404000000004

000352  aa     404000000001

000353  aa     000000000003

000354  aa     514000000022

000355  aa     404000000030

000356  aa     404000000021

000357  aa     000000000001

000360  aa  040 141 156 144	 and
000361  aa  040 000 000 000	 

000362  aa     000000000000
000363  aa     377777777777

000364  aa     077777000043
000365  aa     000001000000

000366  aa     000000000000
000367  aa     000000000000

000370  aa     516100000010
000371  aa     000000000000
000372  aa     000000000027
000373  aa     000000000010

000374  aa  151 156 166 141	inva
000375  aa  154 151 144 040	lid 
000376  aa  111 057 117 040	I/O 
000377  aa  164 171 160 145	type

000400  aa  136 141 072 040	^a: 
000401  aa  121 165 145 165	Queu
000402  aa  151 156 147 040	ing 
000403  aa  145 162 162 157	erro
000404  aa  162 056 000 000	r.

000405  aa  165 156 153 156	unkn
000406  aa  157 167 156 040	own 
000407  aa  163 165 142 163	subs
000410  aa  171 163 164 145	yste
000411  aa  155 000 000 000	m

000412  aa  151 156 166 141	inva
000413  aa  154 151 144 040	lid 
000414  aa  155 141 160 040	map 
000415  aa  111 057 117 040	I/O 
000416  aa  164 171 160 145	type

000417  aa  162 145 164 165	retu
000420  aa  162 156 137 143	rn_c
000421  aa  157 156 166 145	onve
000422  aa  162 163 151 157	rsio
000423  aa  156 137 145 162	n_er
000424  aa  162 157 162 000	ror

000425  aa  136 141 072 040	^a: 
000426  aa  122 145 155 157	Remo
000427  aa  166 151 156 147	ving
000430  aa  040 143 150 141	 cha
000431  aa  156 156 145 154	nnel
000432  aa  040 136 141 056	 ^a.

000433  aa  136 141 072 040	^a: 
000434  aa  136 141 040 156	^a n
000435  aa  157 167 040 157	ow o
000436  aa  160 145 162 141	pera
000437  aa  164 151 157 156	tion
000440  aa  141 154 056 000	al.

000441  aa  151 156 166 141	inva
000442  aa  154 151 144 040	lid 
000443  aa  144 145 166 151	devi
000444  aa  143 145 040 156	ce n
000445  aa  165 155 142 145	umbe
000446  aa  162 000 000 000	r

000447  aa  136 141 072 040	^a: 
000450  aa  101 144 144 151	Addi
000451  aa  156 147 040 143	ng c
000452  aa  150 141 156 156	hann
000453  aa  145 154 040 136	el ^
000454  aa  141 056 000 000	a.

000455  aa  136 141 072 040	^a: 
000456  aa  120 154 141 143	Plac
000457  aa  151 156 147 040	ing 
000460  aa  136 141 040 151	^a i
000461  aa  156 040 157 160	n op
000462  aa  145 162 141 164	erat
000463  aa  151 157 156 056	ion.

000464  aa  162 145 163 160	resp
000465  aa  157 156 163 145	onse
000466  aa  040 166 141 154	 val
000467  aa  165 145 040 155	ue m
000470  aa  165 163 164 040	ust 
000471  aa  142 145 040 076	be >
000472  aa  075 040 061 000	= 1

000473  aa  163 164 141 147	stag
000474  aa  156 141 164 145	nate
000475  aa  040 164 151 155	 tim
000476  aa  145 040 155 165	e mu
000477  aa  163 164 040 142	st b
000500  aa  145 040 076 075	e >=
000501  aa  040 060 000 000	 0

000502  aa  136 141 072 040	^a: 
000503  aa  136 141 040 162	^a r
000504  aa  145 161 165 151	equi
000505  aa  162 145 163 040	res 
000506  aa  151 156 164 145	inte
000507  aa  162 166 145 156	rven
000510  aa  164 151 157 156	tion
000511  aa  056 000 000 000	.

000512  aa  163 164 141 147	stag
000513  aa  156 141 155 145	name
000514  aa  040 164 151 155	 tim
000515  aa  145 040 155 165	e mu
000516  aa  163 164 040 142	st b
000517  aa  145 040 074 075	e <=
000520  aa  040 066 040 155	 6 m
000521  aa  151 156 165 164	inut
000522  aa  145 163 000 000	es

000523  aa  136 141 072 040	^a: 
000524  aa  122 145 143 157	Reco
000525  aa  156 156 145 143	nnec
000526  aa  164 145 144 040	ted 
000527  aa  136 141 040 111	^a I
000530  aa  057 117 040 157	/O o
000531  aa  156 040 136 141	n ^a
000532  aa  040 050 143 150	 (ch
000533  aa  141 156 156 145	anne
000534  aa  154 040 136 141	l ^a
000535  aa  051 056 000 000	).

000536  aa  136 141 072 040	^a: 
000537  aa  125 156 145 170	Unex
000540  aa  160 145 143 164	pect
000541  aa  145 144 040 111	ed I
000542  aa  117 115 040 163	OM s
000543  aa  164 141 164 165	tatu
000544  aa  163 040 136 062	s ^2
000545  aa  064 056 063 142	4.3b
000546  aa  040 146 157 162	 for
000547  aa  040 136 141 040	 ^a 
000550  aa  050 143 150 141	(cha
000551  aa  156 156 145 154	nnel
000552  aa  040 136 141 051	 ^a)
000553  aa  056 000 000 000	.

000554  aa  136 141 072 040	^a: 
000555  aa  136 141 040 136	^a ^
000556  aa  133 136 061 062	[^12
000557  aa  056 063 142 136	.3b^
000560  aa  061 163 136 073	1s^;
000561  aa  136 061 163 136	^1s^
000562  aa  141 136 135 040	a^] 
000563  aa  146 157 162 040	for 
000564  aa  136 141 040 050	^a (
000565  aa  143 150 141 156	chan
000566  aa  156 145 154 040	nel 
000567  aa  136 141 051 056	^a).
000570  aa  136 057 136 062	^/^2
000571  aa  055 162 145 143	-rec
000572  aa  040 136 157 054	 ^o,
000573  aa  040 163 145 143	 sec
000574  aa  164 040 136 157	t ^o
000575  aa  054 040 155 141	, ma
000576  aa  151 156 040 136	in ^
000577  aa  157 136 133 136	o^[^
000600  aa  057 136 062 055	/^2-
000601  aa  163 165 142 166	subv
000602  aa  157 154 040 136	ol ^
000603  aa  141 054 040 154	a, l
000604  aa  157 147 151 143	ogic
000605  aa  141 154 040 162	al r
000606  aa  145 143 040 136	ec ^
000607  aa  157 054 040 154	o, l
000610  aa  157 147 151 143	ogic
000611  aa  141 154 040 163	al s
000612  aa  145 143 164 040	ect 
000613  aa  136 157 136 073	^o^;
000614  aa  136 063 163 136	^3s^
000615  aa  135 136 133 136	]^[^
000616  aa  057 136 062 055	/^2-
000617  aa  144 145 164 141	deta
000620  aa  151 154 145 144	iled
000621  aa  040 163 164 141	 sta
000622  aa  164 165 163 072	tus:
000623  aa  136 062 064 050	^24(
000624  aa  040 136 062 056	 ^2.
000625  aa  064 142 136 051	4b^)
000626  aa  056 136 073 136	.^;^
000627  aa  163 136 135 000	s^]

BEGIN PROCEDURE disk_control
PROLOGUE SEQUENCE
000630  aa  6 00642 4401 00	sxl0 	pr6|418
						STATEMENT 1 ON LINE 84 OF FILE 5
000631  aa  6 00322 4501 00	stz  	pr6|210
000632  aa  6 00322 0541 00	aos  	pr6|210
000633  aa  6 00322 2361 00	ldq  	pr6|210
000634  aa   000006 4020 07	mpy  	6,dl
000635  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
000636  aa   000000 00 0000	descb	0,0
000637  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000640  aa  6 00322 0541 00	aos  	pr6|210
000641  aa  6 00322 2361 00	ldq  	pr6|210
000642  aa   000006 4020 07	mpy  	6,dl
000643  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000644  aa   007555 00 0006	descb	3949,6		010420 = 340000000000
000645  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000646  aa  6 00322 0541 00	aos  	pr6|210
000647  aa  6 00322 2361 00	ldq  	pr6|210
000650  aa   000006 4020 07	mpy  	6,dl
000651  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000652  aa   007547 00 0006	descb	3943,6		010420 = 340000000000
000653  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000654  aa  6 00322 0541 00	aos  	pr6|210
000655  aa  6 00322 2361 00	ldq  	pr6|210
000656  aa   000006 4020 07	mpy  	6,dl
000657  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000660  aa   007541 00 0006	descb	3937,6		010420 = 340000000000
000661  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000662  aa  6 00322 0541 00	aos  	pr6|210
000663  aa  6 00322 2361 00	ldq  	pr6|210
000664  aa   000006 4020 07	mpy  	6,dl
000665  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000666  aa   007533 00 0006	descb	3931,6		010420 = 340000000000
000667  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000670  aa  6 00322 0541 00	aos  	pr6|210
000671  aa  6 00322 2361 00	ldq  	pr6|210
000672  aa   000006 4020 07	mpy  	6,dl
000673  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000674  aa   007525 00 0006	descb	3925,6		010420 = 340000000000
000675  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000676  aa  6 00322 0541 00	aos  	pr6|210
000677  aa  6 00322 2361 00	ldq  	pr6|210
000700  aa   000006 4020 07	mpy  	6,dl
000701  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000702  aa   007517 00 0006	descb	3919,6		010420 = 340000000000
000703  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000704  aa  6 00322 0541 00	aos  	pr6|210
000705  aa  6 00322 2361 00	ldq  	pr6|210
000706  aa   000006 4020 07	mpy  	6,dl
000707  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000710  aa   007510 00 0006	descb	3912,6		010417 = 300000000000
000711  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000712  aa  6 00322 0541 00	aos  	pr6|210
000713  aa  6 00322 2361 00	ldq  	pr6|210
000714  aa   000006 4020 07	mpy  	6,dl
000715  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000716  aa   007502 00 0006	descb	3906,6		010417 = 300000000000
000717  aa  6 00275 63 0006	descb	pr6|189(30),6	seek_command
000720  aa  6 00642 7201 00	lxl0 	pr6|418
000721  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO disk_control                                       STATEMENT 1 ON LINE 135
disk_control:
     proc;

000722  da     000246200000
000723  aa   001520 6270 00	eax7 	848
000724  aa  7 00034 3521 20	epp2 	pr7|28,*
000725  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000726  aa     000000000000
000727  aa     000000000000
000730  aa   777700 7000 04	tsx0 	-64,ic		000630
						STATEMENT 1 ON LINE 365
write_sectors:
     entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);

000731  aa   000014 7100 04	tra  	12,ic		000745
ENTRY TO write_sectors                                      STATEMENT 1 ON LINE 365
write_sectors:
     entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);

000732  at     000005000356
000733  tt     000355000354
000734  tt     000351000356
000735  ta     000732000000
000736  da     000255300000
000737  aa   001520 6270 00	eax7 	848
000740  aa  7 00034 3521 20	epp2 	pr7|28,*
000741  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000742  aa     000012000000
000743  aa     000000000000
000744  aa   777664 7000 04	tsx0 	-76,ic		000630
						STATEMENT 1 ON LINE 368
	io_type = VTOC_WRITE;

000745  aa   000003 2360 07	ldq  	3,dl
000746  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 369
	goto go_sector;

000747  aa   000013 7100 04	tra  	11,ic		000762
ENTRY TO read_sectors                                       STATEMENT 1 ON LINE 372
read_sectors:
     entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);

000750  ta     000732000000
000751  da     000264300000
000752  aa   001520 6270 00	eax7 	848
000753  aa  7 00034 3521 20	epp2 	pr7|28,*
000754  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000755  aa     000012000000
000756  aa     000000000000
000757  aa   777651 7000 04	tsx0 	-87,ic		000630
						STATEMENT 1 ON LINE 375
	io_type = VTOC_READ;

000760  aa   000002 2360 07	ldq  	2,dl
000761  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 376
go_sector:
	devadd = bin (a_devadd, 18);

000762  aa  6 00032 3735 20	epp7 	pr6|26,*
000763  aa  7 00006 2351 20	lda  	pr7|6,*		a_devadd
000764  aa   000066 7730 00	lrl  	54
000765  aa  6 00121 7561 00	stq  	pr6|81		devadd
						STATEMENT 1 ON LINE 378
	coreadd = a_coreadd;

000766  aa  7 00004 2361 20	ldq  	pr7|4,*		a_coreadd
000767  aa  6 00101 7561 00	stq  	pr6|65		coreadd
						STATEMENT 1 ON LINE 380
	sect_off = a_sect_off;

000770  aa  7 00010 2361 20	ldq  	pr7|8,*		a_sect_off
000771  aa  6 00102 7561 00	stq  	pr6|66		sect_off
						STATEMENT 1 ON LINE 381
	n_sectors = a_n_sectors;

000772  aa  7 00012 2361 20	ldq  	pr7|10,*		a_n_sectors
000773  aa  6 00103 7561 00	stq  	pr6|67		n_sectors
						STATEMENT 1 ON LINE 382
	goto go_masked;

000774  aa   000040 7100 04	tra  	32,ic		001034
ENTRY TO test_drive                                         STATEMENT 1 ON LINE 385
test_drive:
     entry (a_pvtx);

000775  at     000001000356
000776  ta     000775000000
000777  da     000272300000
001000  aa   001520 6270 00	eax7 	848
001001  aa  7 00034 3521 20	epp2 	pr7|28,*
001002  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001003  aa     000002000000
001004  aa     000000000000
001005  aa   777623 7000 04	tsx0 	-109,ic		000630
						STATEMENT 1 ON LINE 388
	io_type = TEST;

001006  aa   000004 2360 07	ldq  	4,dl
001007  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 389
	coreadd = bin (RESET_STATUS, 24);

001010  aa   400000 2350 03	lda  	131072,du
001011  aa   000102 7730 00	lrl  	66
001012  aa  6 00101 7561 00	stq  	pr6|65		coreadd
						STATEMENT 1 ON LINE 390
	goto go_test;

001013  aa   000016 7100 04	tra  	14,ic		001031
ENTRY TO unload_drive                                       STATEMENT 1 ON LINE 394
unload_drive:
     entry (a_pvtx);

001014  ta     000775000000
001015  da     000301300000
001016  aa   001520 6270 00	eax7 	848
001017  aa  7 00034 3521 20	epp2 	pr7|28,*
001020  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001021  aa     000002000000
001022  aa     000000000000
001023  aa   777605 7000 04	tsx0 	-123,ic		000630
						STATEMENT 1 ON LINE 397
	io_type = TEST;

001024  aa   000004 2360 07	ldq  	4,dl
001025  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 398
	coreadd = bin (UNLOAD, 24);

001026  aa   720000 2350 03	lda  	237568,du
001027  aa   000102 7730 00	lrl  	66
001030  aa  6 00101 7561 00	stq  	pr6|65		coreadd
						STATEMENT 1 ON LINE 399
go_test:
	sect_off = 0;

001031  aa  6 00102 4501 00	stz  	pr6|66		sect_off
						STATEMENT 1 ON LINE 401
	n_sectors = 0;

001032  aa  6 00103 4501 00	stz  	pr6|67		n_sectors
						STATEMENT 1 ON LINE 402
	devadd = 0;

001033  aa  6 00121 4501 00	stz  	pr6|81		devadd
						STATEMENT 1 ON LINE 406
go_masked:
	call pmut$wire_and_mask (mask, ptp);

001034  aa  6 00136 3521 00	epp2 	pr6|94		mask
001035  aa  6 00646 2521 00	spri2	pr6|422
001036  aa  6 00150 3521 00	epp2 	pr6|104		ptp
001037  aa  6 00650 2521 00	spri2	pr6|424
001040  aa  6 00644 6211 00	eax1 	pr6|420
001041  aa   010000 4310 07	fld  	4096,dl
001042  aa  6 00044 3701 20	epp4 	pr6|36,*
001043  la  4 00034 3521 20	epp2 	pr4|28,*		pmut$wire_and_mask
001044  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 408
	masked = "1"b;

001045  aa   400000 2350 03	lda  	131072,du
001046  aa  6 00140 7551 00	sta  	pr6|96		masked
						STATEMENT 1 ON LINE 409
	intrpt = "0"b;

001047  aa  6 00130 4501 00	stz  	pr6|88		intrpt
						STATEMENT 1 ON LINE 410
	goto go_common;

001050  aa   000050 7100 04	tra  	40,ic		001120
ENTRY TO disk_write                                         STATEMENT 1 ON LINE 415
disk_write:
     entry (a_pvtx, a_coreadd, a_devadd, a_intrpt);

001051  at     000004000356
001052  tt     000355000354
001053  ta     000352000000
001054  ta     001051000000
001055  da     000307300000
001056  aa   001520 6270 00	eax7 	848
001057  aa  7 00034 3521 20	epp2 	pr7|28,*
001060  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001061  aa     000010000000
001062  aa     000000000000
001063  aa   777545 7000 04	tsx0 	-155,ic		000630
						STATEMENT 1 ON LINE 418
	io_type = PAGE_WRITE;

001064  aa   000001 2360 07	ldq  	1,dl
001065  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 419
	goto go_page;

001066  aa   000013 7100 04	tra  	11,ic		001101
ENTRY TO disk_read                                          STATEMENT 1 ON LINE 421
disk_read:
     entry (a_pvtx, a_coreadd, a_devadd, a_intrpt);

001067  ta     001051000000
001070  da     000315300000
001071  aa   001520 6270 00	eax7 	848
001072  aa  7 00034 3521 20	epp2 	pr7|28,*
001073  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001074  aa     000010000000
001075  aa     000000000000
001076  aa   777532 7000 04	tsx0 	-166,ic		000630
						STATEMENT 1 ON LINE 424
	io_type = PAGE_READ;

001077  aa   000000 2360 07	ldq  	0,dl
001100  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 425
go_page:
	masked = "0"b;

001101  aa  6 00140 4501 00	stz  	pr6|96		masked
						STATEMENT 1 ON LINE 427
	devadd = bin (a_devadd, 18);

001102  aa  6 00032 3735 20	epp7 	pr6|26,*
001103  aa  7 00006 2351 20	lda  	pr7|6,*		a_devadd
001104  aa   000066 7730 00	lrl  	54
001105  aa  6 00121 7561 00	stq  	pr6|81		devadd
						STATEMENT 1 ON LINE 428
	coreadd = a_coreadd;

001106  aa  7 00004 2361 20	ldq  	pr7|4,*		a_coreadd
001107  aa  6 00101 7561 00	stq  	pr6|65		coreadd
						STATEMENT 1 ON LINE 429
	sect_off = 0;

001110  aa  6 00102 4501 00	stz  	pr6|66		sect_off
						STATEMENT 1 ON LINE 430
	n_sectors = 0;

001111  aa  6 00103 4501 00	stz  	pr6|67		n_sectors
						STATEMENT 1 ON LINE 431
	if a_intrpt ^= 0 then
	     intrpt = "1"b;

001112  aa  7 00010 2361 20	ldq  	pr7|8,*		a_intrpt
001113  aa   000004 6000 04	tze  	4,ic		001117
001114  aa   400000 2350 03	lda  	131072,du
001115  aa  6 00130 7551 00	sta  	pr6|88		intrpt
001116  aa   000002 7100 04	tra  	2,ic		001120
						STATEMENT 1 ON LINE 433
	else intrpt = "0"b;

001117  aa  6 00130 4501 00	stz  	pr6|88		intrpt
						STATEMENT 1 ON LINE 438
go_common:
	entry_time = clock ();

001120  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
001121  aa  6 00124 7571 00	staq 	pr6|84		entry_time
						STATEMENT 1 ON LINE 440
	sect_sw = sector_map (io_type);

001122  aa  6 00156 4501 00	stz  	pr6|110		sect_sw
001123  aa  6 00131 7271 00	lxl7 	pr6|89		io_type
001124  aa  003 100 060 417	csl  	(x7),(pr),fill(0),bool(move)
001125  ta   000023 00 0001	descb	19,1
001126  aa  6 00156 00 0001	descb	pr6|110,1		sect_sw
						STATEMENT 1 ON LINE 441
	bootload_sw = bootload_map (io_type);

001127  aa  6 00105 4501 00	stz  	pr6|69		bootload_sw
001130  aa  003 100 060 417	csl  	(x7),(pr),fill(0),bool(move)
001131  ta   000022 00 0001	descb	18,1
001132  aa  6 00105 00 0001	descb	pr6|69,1		bootload_sw
						STATEMENT 1 ON LINE 442
	pvtep = addr (addr (pvt$array) -> pvt_array (a_pvtx));

001133  aa  6 00032 3735 20	epp7 	pr6|26,*
001134  aa  7 00002 2361 20	ldq  	pr7|2,*		a_pvtx
001135  aa   000034 4020 07	mpy  	28,dl
001136  aa  6 00044 3701 20	epp4 	pr6|36,*
001137  la  4 00056 3715 20	epp5 	pr4|46,*
001140  aa  5 77744 3715 06	epp5 	pr5|-28,ql	pvt_array
001141  aa  6 00314 6515 00	spri5	pr6|204		pvtep
						STATEMENT 1 ON LINE 444
	pvtdip = addr (pvte.dim_info);

001142  aa  5 00010 3535 00	epp3 	pr5|8		pvte.dim_info
001143  aa  6 00274 2535 00	spri3	pr6|188		pvtdip
						STATEMENT 1 ON LINE 445
	sx = pvtdi.sx;

001144  aa  3 00000 2351 00	lda  	pr3|0		pvtdi.sx
001145  aa   000074 7330 00	lrs  	60
001146  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 446
	call setup;

001147  aa   006027 6700 04	tsp4 	3095,ic		007176
						STATEMENT 1 ON LINE 447
	call lock (addr (disktab.call_lock_meters));

001150  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001151  aa  7 00016 3735 00	epp7 	pr7|14		disktab.call_lock_meters
001152  aa  6 00652 6535 00	spri7	pr6|426
001153  aa   007237 3520 04	epp2 	3743,ic		010412 = 000002000000
001154  aa   006177 6700 04	tsp4 	3199,ic		007353
						STATEMENT 1 ON LINE 449
	dev = pvte.logical_area_number;

001155  aa  6 00314 3735 20	epp7 	pr6|204,*		pvtep
001156  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
001157  aa   000011 7350 00	als  	9
001160  aa   000077 7330 00	lrs  	63
001161  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 450
	pdi = disktab.devtab (dev).pdi;

001162  aa   000120 4020 07	mpy  	80,dl
001163  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
001164  aa  5 00036 2361 06	ldq  	pr5|30,ql		disktab.pdi
001165  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
001166  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 451
	dp = addr (disktab.devtab (pdi));

001167  aa   000120 4020 07	mpy  	80,dl
001170  aa  5 00036 3535 06	epp3 	pr5|30,ql		disktab.devtab
001171  aa  6 00272 2535 00	spri3	pr6|186		dp
						STATEMENT 1 ON LINE 455
	if devtab.abandoned then do;

001172  aa  3 00000 2351 00	lda  	pr3|0		devtab.abandoned
001173  aa   000040 3150 03	cana 	32,du
001174  aa   000016 6000 04	tze  	14,ic		001212
						STATEMENT 1 ON LINE 456
	     errcd = 0;

001175  aa  6 00126 4501 00	stz  	pr6|86		errcd
						STATEMENT 1 ON LINE 457
	     if ^write_map (io_type) then do;

001176  aa  6 00131 7271 00	lxl7 	pr6|89		io_type
001177  aa  000 000 066 417	cmpb 	(x7),(),fill(0)
001200  ta   000024 00 0001	descb	20,1
001201  aa   000000 00 0000	descb	0,0
001202  aa   000005 6010 04	tnz  	5,ic		001207
						STATEMENT 1 ON LINE 458
		erfp = addr (errcd);

001203  aa  6 00126 3515 00	epp1 	pr6|86		errcd
001204  aa  6 00246 2515 00	spri1	pr6|166		erfp
						STATEMENT 1 ON LINE 459
		errflags.device_inoperative = "1"b;

001205  aa   000020 2350 07	lda  	16,dl
001206  aa  1 00000 2551 00	orsa 	pr1|0		errflags.device_inoperative
						STATEMENT 1 ON LINE 460
	     end;

						STATEMENT 1 ON LINE 461
	     call unlock;

001207  aa   006204 6700 04	tsp4 	3204,ic		007413
						STATEMENT 1 ON LINE 462
	     call post;

001210  aa   005715 6700 04	tsp4 	3021,ic		007125
						STATEMENT 1 ON LINE 463
	     go to call_exit;

001211  aa   000233 7100 04	tra  	155,ic		001444
						STATEMENT 1 ON LINE 464
	end;

						STATEMENT 1 ON LINE 468
	disktab.alloc_wait_meters.count = disktab.alloc_wait_meters.count + 1;

001212  aa  5 00026 0541 00	aos  	pr5|22		disktab.count
						STATEMENT 1 ON LINE 469
	if ^get_free_q () then do;

001213  aa   007173 3520 04	epp2 	3707,ic		010406 = 000002000000
001214  aa   006230 6700 04	tsp4 	3224,ic		007444
001215  aa  6 00643 2351 00	lda  	pr6|419
001216  aa   400000 3150 03	cana 	131072,du
001217  aa   000030 6010 04	tnz  	24,ic		001247
						STATEMENT 1 ON LINE 470
	     call lock_meter_start (addr (disktab.alloc_wait_meters));

001220  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001221  aa  7 00026 3735 00	epp7 	pr7|22		disktab.alloc_wait_meters
001222  aa  6 00652 6535 00	spri7	pr6|426
001223  aa   007167 3520 04	epp2 	3703,ic		010412 = 000002000000
001224  aa   006176 6700 04	tsp4 	3198,ic		007422
						STATEMENT 1 ON LINE 471
	     do while (^get_free_q ());

001225  aa   000000 0110 03	nop  	0,du
001226  aa   007160 3520 04	epp2 	3696,ic		010406 = 000002000000
001227  aa   006215 6700 04	tsp4 	3213,ic		007444
001230  aa  6 00643 2351 00	lda  	pr6|419
001231  aa   400000 3150 03	cana 	131072,du
001232  aa   000010 6010 04	tnz  	8,ic		001242
						STATEMENT 1 ON LINE 472
		call call_run (sx);

001233  aa  6 00162 3521 00	epp2 	pr6|114		sx
001234  aa  6 00646 2521 00	spri2	pr6|422
001235  aa  6 00644 6211 00	eax1 	pr6|420
001236  aa   004000 4310 07	fld  	2048,dl
001237  aa   001110 3520 04	epp2 	584,ic		002347 = 001520627000
001240  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 473
	     end;

001241  aa   777765 7100 04	tra  	-11,ic		001226
						STATEMENT 1 ON LINE 474
	     call lock_meter_stop (addr (disktab.alloc_wait_meters));

001242  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001243  aa  7 00026 3735 00	epp7 	pr7|22		disktab.alloc_wait_meters
001244  aa  6 00652 6535 00	spri7	pr6|426
001245  aa   007145 3520 04	epp2 	3685,ic		010412 = 000002000000
001246  aa   006164 6700 04	tsp4 	3188,ic		007432
						STATEMENT 1 ON LINE 475
	end;

						STATEMENT 1 ON LINE 480
	if pvte.is_sv then do;

001247  aa  6 00314 3735 20	epp7 	pr6|204,*		pvtep
001250  aa  7 00002 2351 00	lda  	pr7|2		pvte.is_sv
001251  aa   040000 3150 03	cana 	16384,du
001252  aa   000013 6000 04	tze  	11,ic		001265
						STATEMENT 1 ON LINE 481
	     record_offset = mod (devadd, pvte.records_per_cyl);

001253  aa  6 00121 2361 00	ldq  	pr6|81		devadd
001254  aa  7 00013 3521 00	epp2 	pr7|11		pvte.records_per_cyl
001255  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
001256  aa  6 00104 7561 00	stq  	pr6|68		record_offset
						STATEMENT 1 ON LINE 482
	     devadd = ((devadd - record_offset) * pvte.num_of_svs) + pvte.record_factor + record_offset;

001257  aa  6 00121 2361 00	ldq  	pr6|81		devadd
001260  aa  6 00104 1761 00	sbq  	pr6|68		record_offset
001261  aa  7 00012 4021 00	mpy  	pr7|10		pvte.num_of_svs
001262  aa  7 00014 0331 00	adl  	pr7|12		pvte.record_factor
001263  aa  6 00104 0331 00	adl  	pr6|68		record_offset
001264  aa  6 00121 7561 00	stq  	pr6|81		devadd
						STATEMENT 1 ON LINE 483
	end;

						STATEMENT 1 ON LINE 484
	sector = devadd * sect_per_rec (pvte.device_type);

001265  aa  7 00004 2351 00	lda  	pr7|4		pvte.device_type
001266  aa   000077 7330 00	lrs  	63
001267  aa   000000 6270 06	eax7 	0,ql
001270  aa  6 00121 2361 00	ldq  	pr6|81		devadd
001271  ta   777777 4020 17	mpy  	-1,7
001272  aa  6 00155 7561 00	stq  	pr6|109		sector
						STATEMENT 1 ON LINE 485
	cylinder = divide (sector, pvtdi.usable_sect_per_cyl, 12, 0);

001273  aa  6 00274 2351 20	lda  	pr6|188,*		pvtdi.usable_sect_per_cyl
001274  aa   000014 7350 00	als  	12
001275  aa   000074 7330 00	lrs  	60
001276  aa  6 00643 7561 00	stq  	pr6|419		pvtdi.usable_sect_per_cyl
001277  aa  6 00155 2361 00	ldq  	pr6|109		sector
001300  aa  6 00643 5061 00	div  	pr6|419		pvtdi.usable_sect_per_cyl
001301  aa  6 00113 7561 00	stq  	pr6|75		cylinder
						STATEMENT 1 ON LINE 486
	sector = sector + cylinder * pvtdi.unused_sect_per_cyl;

001302  aa  6 00274 2351 20	lda  	pr6|188,*		pvtdi.unused_sect_per_cyl
001303  aa   000030 7350 00	als  	24
001304  aa   000074 7330 00	lrs  	60
001305  aa  6 00113 4021 00	mpy  	pr6|75		cylinder
001306  aa  6 00155 0561 00	asq  	pr6|109		sector
						STATEMENT 1 ON LINE 487
	sector = sector + sect_off;

001307  aa  6 00102 2361 00	ldq  	pr6|66		sect_off
001310  aa  6 00155 0561 00	asq  	pr6|109		sector
						STATEMENT 1 ON LINE 491
	quentry.intrpt = intrpt;

001311  aa  6 00130 2351 00	lda  	pr6|88		intrpt
001312  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
001313  aa  5 00001 6751 00	era  	pr5|1		quentry.intrpt
001314  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
001315  aa  5 00001 6551 00	ersa 	pr5|1		quentry.intrpt
						STATEMENT 1 ON LINE 492
	quentry.used = "1"b;

001316  aa   200000 2350 03	lda  	65536,du
001317  aa  5 00001 2551 00	orsa 	pr5|1		quentry.used
						STATEMENT 1 ON LINE 493
	quentry.type = io_type;

001320  aa  6 00131 2361 00	ldq  	pr6|89		io_type
001321  aa   000102 7370 00	lls  	66
001322  aa  5 00001 6751 00	era  	pr5|1		quentry.type
001323  aa   170000 3750 03	ana  	61440,du
001324  aa  5 00001 6551 00	ersa 	pr5|1		quentry.type
						STATEMENT 1 ON LINE 494
	quentry.coreadd = bit (coreadd, 24);

001325  aa  6 00101 2351 00	lda  	pr6|65		coreadd
001326  aa   000002 6050 04	tpl  	2,ic		001330
001327  aa   000000 5310 00	neg  	0
001330  aa  0 00250 3771 00	anaq 	pr0|168		= 000077777777 777777777777
001331  aa  5 00001 7511 17	stca 	pr5|1,17		quentry.coreadd
						STATEMENT 1 ON LINE 496
	quentry.pvtx = a_pvtx;

001332  aa  6 00032 3535 20	epp3 	pr6|26,*
001333  aa  3 00002 2361 20	ldq  	pr3|2,*		a_pvtx
001334  aa   000100 7370 00	lls  	64
001335  aa  5 00002 6751 00	era  	pr5|2		quentry.pvtx
001336  aa  0 00020 3751 00	ana  	pr0|16		= 776000000000
001337  aa  5 00002 6551 00	ersa 	pr5|2		quentry.pvtx
						STATEMENT 1 ON LINE 497
	quentry.pdi = pdi;

001340  aa  6 00145 2361 00	ldq  	pr6|101		pdi
001341  aa   000072 7370 00	lls  	58
001342  aa  5 00002 6751 00	era  	pr5|2		quentry.pdi
001343  aa   001760 3750 03	ana  	1008,du
001344  aa  5 00002 6551 00	ersa 	pr5|2		quentry.pdi
						STATEMENT 1 ON LINE 498
	quentry.dev = dev;

001345  aa  6 00120 2361 00	ldq  	pr6|80		dev
001346  aa   000064 7370 00	lls  	52
001347  aa  5 00002 6751 00	era  	pr5|2		quentry.dev
001350  aa   007035 3750 04	ana  	3613,ic		010405 = 000017600000
001351  aa  5 00002 6551 00	ersa 	pr5|2		quentry.dev
						STATEMENT 1 ON LINE 499
	quentry.cylinder = cylinder;

001352  aa  6 00113 2361 00	ldq  	pr6|75		cylinder
001353  aa  5 00002 6761 00	erq  	pr5|2		quentry.cylinder
001354  aa   003777 3760 07	anq  	2047,dl
001355  aa  5 00002 6561 00	ersq 	pr5|2		quentry.cylinder
						STATEMENT 1 ON LINE 501
	quentry.n_sectors = n_sectors;

001356  aa  6 00103 2361 00	ldq  	pr6|67		n_sectors
001357  aa   000102 7370 00	lls  	66
001360  aa  5 00003 7511 40	stca 	pr5|3,40		quentry.n_sectors
						STATEMENT 1 ON LINE 502
	quentry.sector = bit (sector, 21);

001361  aa  6 00155 2351 00	lda  	pr6|109		sector
001362  aa   000002 6050 04	tpl  	2,ic		001364
001363  aa   000000 5310 00	neg  	0
001364  aa  0 00256 3771 00	anaq 	pr0|174		= 000007777777 777777777777
001365  aa  5 00003 6751 00	era  	pr5|3		quentry.sector
001366  aa   007016 3750 04	ana  	3598,ic		010404 = 000007777777
001367  aa  5 00003 6551 00	ersa 	pr5|3		quentry.sector
						STATEMENT 1 ON LINE 506
	quentry.time = entry_time;

001370  aa  6 00124 2371 00	ldaq 	pr6|84		entry_time
001371  aa  5 00004 7571 00	staq 	pr5|4		quentry.time
						STATEMENT 1 ON LINE 511
	if ^(disktab.dev_busy | disktab.dev_queued) & dev_mask (pdi) then
	     do i = 1 to disktab.nchan;

001372  aa  6 00145 2361 00	ldq  	pr6|101		pdi
001373  aa   000001 7360 00	qls  	1
001374  aa  6 00260 3515 20	epp1 	pr6|176,*		diskp
001375  aa   000000 6260 06	eax6 	0,ql
001376  aa  1 00004 2351 00	lda  	pr1|4		disktab.dev_busy
001377  aa  1 00005 2361 00	ldq  	pr1|5		disktab.dev_busy
001400  aa  1 00006 2751 00	ora  	pr1|6		disktab.dev_queued
001401  aa  1 00007 2761 00	orq  	pr1|7		disktab.dev_queued
001402  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
001403  ta   000076 3750 16	ana  	62,6
001404  ta   000077 3760 16	anq  	63,6
001405  aa  0 00000 1171 00	cmpaq	pr0|0		= 000000000000 000000000000
001406  aa   000034 6000 04	tze  	28,ic		001442
001407  aa  1 00001 2361 00	ldq  	pr1|1		disktab.nchan
001410  aa  6 00323 7561 00	stq  	pr6|211
001411  aa   000001 2360 07	ldq  	1,dl
001412  aa  6 00127 7561 00	stq  	pr6|87		i
001413  aa   000000 0110 03	nop  	0,du
001414  aa  6 00127 2361 00	ldq  	pr6|87		i
001415  aa  6 00323 1161 00	cmpq 	pr6|211
001416  aa   000024 6054 04	tpnz 	20,ic		001442
						STATEMENT 1 ON LINE 513
	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));

001417  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001420  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
001421  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001422  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
001423  aa   000000 3120 01	eawp2	0,au
001424  aa  6 00127 2361 00	ldq  	pr6|87		i
001425  aa   000005 7360 00	qls  	5
001426  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
001427  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 515
	     if chantab.in_use & ^chantab.active then do;

001430  aa  5 00006 2351 00	lda  	pr5|6		chantab.in_use
001431  aa   400000 3150 07	cana 	131072,dl
001432  aa   000006 6000 04	tze  	6,ic		001440
001433  aa  5 00006 2351 00	lda  	pr5|6		chantab.active
001434  aa   200000 3150 07	cana 	65536,dl
001435  aa   000003 6010 04	tnz  	3,ic		001440
						STATEMENT 1 ON LINE 516
		call gotwork;

001436  aa   004661 6700 04	tsp4 	2481,ic		006317
						STATEMENT 1 ON LINE 517
		go to working;

001437  aa   000004 7100 04	tra  	4,ic		001443
						STATEMENT 1 ON LINE 518
	     end;

						STATEMENT 1 ON LINE 519
	end;

001440  aa  6 00127 0541 00	aos  	pr6|87		i
001441  aa   777753 7100 04	tra  	-21,ic		001414
						STATEMENT 1 ON LINE 521
	call add_wq;

001442  aa   006212 6700 04	tsp4 	3210,ic		007654
						STATEMENT 1 ON LINE 525
working:
	call unlock;

001443  aa   005750 6700 04	tsp4 	3048,ic		007413
						STATEMENT 1 ON LINE 528
call_exit:
	if masked then
	     call pmut$unwire_unmask (mask, ptp);

001444  aa  6 00140 2351 00	lda  	pr6|96		masked
001445  aa   000012 6000 04	tze  	10,ic		001457
001446  aa  6 00136 3521 00	epp2 	pr6|94		mask
001447  aa  6 00646 2521 00	spri2	pr6|422
001450  aa  6 00150 3521 00	epp2 	pr6|104		ptp
001451  aa  6 00650 2521 00	spri2	pr6|424
001452  aa  6 00644 6211 00	eax1 	pr6|420
001453  aa   010000 4310 07	fld  	4096,dl
001454  aa  6 00044 3701 20	epp4 	pr6|36,*
001455  la  4 00036 3521 20	epp2 	pr4|30,*		pmut$unwire_unmask
001456  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 532
	return;

001457  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO esd_reset_locks                                    STATEMENT 1 ON LINE 536
esd_reset_locks:
     entry;

001460  da     000324200000
001461  aa   001520 6270 00	eax7 	848
001462  aa  7 00034 3521 20	epp2 	pr7|28,*
001463  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001464  aa     000000000000
001465  aa     000000000000
001466  aa   777142 7000 04	tsx0 	-414,ic		000630
						STATEMENT 1 ON LINE 539
	disksp = addr (disk_seg$);

001467  aa  6 00044 3701 20	epp4 	pr6|36,*
001470  la  4 00050 3735 20	epp7 	pr4|40,*		disk_seg$
001471  aa  6 00256 6535 00	spri7	pr6|174		disksp
						STATEMENT 1 ON LINE 541
	unspec (disk_data.free_q) = "0"b;

001472  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001473  aa   000000 00 0000	desc9a	0,0
001474  aa  7 00004 00 0020	desc9a	pr7|4,16
						STATEMENT 1 ON LINE 542
	disk_data.free_q.depth = disk_data.free_q_size;

001475  aa  7 00010 2361 00	ldq  	pr7|8		disk_data.free_q_size
001476  aa  7 00006 5521 14	stbq 	pr7|6,14		disk_data.depth
						STATEMENT 1 ON LINE 549
	unspec (disk_data.lock) = unspec (disk_data.lock) & "0"b;

001477  aa   000000 2350 07	lda  	0,dl
001500  aa  7 00003 3551 00	ansa 	pr7|3
						STATEMENT 1 ON LINE 551
	do qx = 1 to disk_data.free_q_size;

001501  aa  6 00324 7561 00	stq  	pr6|212
001502  aa   000001 2360 07	ldq  	1,dl
001503  aa  6 00153 7561 00	stq  	pr6|107		qx
001504  aa  6 00153 2361 00	ldq  	pr6|107		qx
001505  aa  6 00324 1161 00	cmpq 	pr6|212
001506  aa   000012 6054 04	tpnz 	10,ic		001520
						STATEMENT 1 ON LINE 552
	     qp = addr (disk_data.free_q_entries (qx));

001507  aa   000006 4020 07	mpy  	6,dl
001510  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
001511  aa  7 00144 3735 06	epp7 	pr7|100,ql	disk_data.free_q_entries
001512  aa  6 00266 6535 00	spri7	pr6|182		qp
						STATEMENT 1 ON LINE 553
	     qrp = rel (qp);

001513  aa  7 00000 6351 00	eaa  	pr7|0		qp
001514  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 555
	     call add_free_q;

001515  aa   006055 6700 04	tsp4 	3117,ic		007572
						STATEMENT 1 ON LINE 556
	end;

001516  aa  6 00153 0541 00	aos  	pr6|107		qx
001517  aa   777765 7100 04	tra  	-11,ic		001504
						STATEMENT 1 ON LINE 558
	do sx = 1 to disk_data.subsystems;

001520  aa  6 00256 2361 20	ldq  	pr6|174,*		disk_data.subsystems
001521  aa  6 00325 7561 00	stq  	pr6|213
001522  aa   000001 2360 07	ldq  	1,dl
001523  aa  6 00162 7561 00	stq  	pr6|114		sx
001524  aa  6 00162 2361 00	ldq  	pr6|114		sx
001525  aa  6 00325 1161 00	cmpq 	pr6|213
001526  aa   000136 6054 04	tpnz 	94,ic		001664
						STATEMENT 1 ON LINE 559
	     call setup;

001527  aa   005447 6700 04	tsp4 	2855,ic		007176
						STATEMENT 1 ON LINE 560
	     call unlock;

001530  aa   005663 6700 04	tsp4 	2995,ic		007413
						STATEMENT 1 ON LINE 562
	     call lock (addr (disktab.call_lock_meters));

001531  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001532  aa  7 00016 3735 00	epp7 	pr7|14		disktab.call_lock_meters
001533  aa  6 00652 6535 00	spri7	pr6|426
001534  aa   006656 3520 04	epp2 	3502,ic		010412 = 000002000000
001535  aa   005616 6700 04	tsp4 	2958,ic		007353
						STATEMENT 1 ON LINE 564
	     do dev = disktab.first_dev to disktab.last_dev;

001536  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001537  aa  7 00002 2351 00	lda  	pr7|2		disktab.last_dev
001540  aa   000022 7350 00	als  	18
001541  aa   000066 7330 00	lrs  	54
001542  aa  6 00326 7561 00	stq  	pr6|214
001543  aa  7 00002 2351 00	lda  	pr7|2		disktab.first_dev
001544  aa   000066 7330 00	lrs  	54
001545  aa  6 00120 7561 00	stq  	pr6|80		dev
001546  aa  6 00120 2361 00	ldq  	pr6|80		dev
001547  aa  6 00326 1161 00	cmpq 	pr6|214
001550  aa   000040 6054 04	tpnz 	32,ic		001610
						STATEMENT 1 ON LINE 566
		dp = addr (disktab.devtab (dev));

001551  aa   000120 4020 07	mpy  	80,dl
001552  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001553  aa  7 00036 3735 06	epp7 	pr7|30,ql		disktab.devtab
001554  aa  6 00272 6535 00	spri7	pr6|186		dp
						STATEMENT 1 ON LINE 567
		devtab.broken, devtab.was_broken, devtab.inop = "0"b;

001555  aa   006626 2350 04	lda  	3478,ic		010403 = 777677777777
001556  aa  7 00000 3551 00	ansa 	pr7|0		devtab.broken
001557  aa   006623 2350 04	lda  	3475,ic		010402 = 777577777777
001560  aa  7 00000 3551 00	ansa 	pr7|0		devtab.was_broken
001561  aa   006620 2350 04	lda  	3472,ic		010401 = 777377777777
001562  aa  7 00000 3551 00	ansa 	pr7|0		devtab.inop
						STATEMENT 1 ON LINE 569
		devtab.cylinder = 0;

001563  aa  7 00001 4501 00	stz  	pr7|1		devtab.cylinder
						STATEMENT 1 ON LINE 570
		unspec (devtab.wq) = "0"b;

001564  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001565  aa   000000 00 0000	desc9a	0,0
001566  aa  7 00006 00 0020	desc9a	pr7|6,16
						STATEMENT 1 ON LINE 574
		do i = 0 to MAX_IO_TYPE;

001567  aa   000006 2360 07	ldq  	6,dl
001570  aa  6 00350 7561 00	stq  	pr6|232
001571  aa  6 00127 4501 00	stz  	pr6|87		i
001572  aa  6 00127 2361 00	ldq  	pr6|87		i
001573  aa  6 00350 1161 00	cmpq 	pr6|232
001574  aa   000012 6054 04	tpnz 	10,ic		001606
						STATEMENT 1 ON LINE 575
		     devtab.forward = "1"b;

001575  aa   000020 2350 03	lda  	16,du
001576  aa  6 00272 2551 20	orsa 	pr6|186,*		devtab.forward
						STATEMENT 1 ON LINE 576
		     devtab.opt_info (i).depth = 0;

001577  aa   000012 4020 07	mpy  	10,dl
001600  aa   000000 2350 03	lda  	0,du
001601  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
001602  aa  7 00015 3715 06	epp5 	pr7|13,ql		devtab.depth
001603  aa  5 00000 5511 14	stba 	pr5|0,14		devtab.depth
						STATEMENT 1 ON LINE 577
		end;

001604  aa  6 00127 0541 00	aos  	pr6|87		i
001605  aa   777765 7100 04	tra  	-11,ic		001572
						STATEMENT 1 ON LINE 578
	     end;

001606  aa  6 00120 0541 00	aos  	pr6|80		dev
001607  aa   777737 7100 04	tra  	-33,ic		001546
						STATEMENT 1 ON LINE 580
	     cp = ptr (disksp, disktab.channels);

001610  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001611  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
001612  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001613  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
001614  aa   000000 3120 01	eawp2	0,au
001615  aa  6 00270 2521 00	spri2	pr6|184		cp
						STATEMENT 1 ON LINE 581
	     do i = 1 to disktab.nchan;

001616  aa  7 00001 2361 00	ldq  	pr7|1		disktab.nchan
001617  aa  6 00351 7561 00	stq  	pr6|233
001620  aa   000001 2360 07	ldq  	1,dl
001621  aa  6 00127 7561 00	stq  	pr6|87		i
001622  aa  6 00127 2361 00	ldq  	pr6|87		i
001623  aa  6 00351 1161 00	cmpq 	pr6|233
001624  aa   000026 6054 04	tpnz 	22,ic		001652
						STATEMENT 1 ON LINE 582
		cp -> disk_channel_table (i).active = "0"b;

001625  aa   000005 7360 00	qls  	5
001626  aa   006552 2350 04	lda  	3434,ic		010400 = 777777577777
001627  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
001630  aa  7 77746 3551 06	ansa 	pr7|-26,ql	disk_channel_table.active
						STATEMENT 1 ON LINE 584
		cp -> disk_channel_table (i).inop = "0"b;

001631  aa   006546 2350 04	lda  	3430,ic		010377 = 777777757777
001632  aa  7 77746 3551 06	ansa 	pr7|-26,ql	disk_channel_table.inop
						STATEMENT 1 ON LINE 586
		cp -> disk_channel_table (i).broken = "0"b;

001633  aa   006543 2350 04	lda  	3427,ic		010376 = 777777767777
001634  aa  7 77746 3551 06	ansa 	pr7|-26,ql	disk_channel_table.broken
						STATEMENT 1 ON LINE 588
                    if ^(cp -> disk_channel_table (i).ioi_use) &
                       ^(cp -> disk_channel_table (i).in_use) then do;

001635  aa  6 00643 7561 00	stq  	pr6|419
001636  aa  7 77746 2351 06	lda  	pr7|-26,ql	disk_channel_table.in_use
001637  aa   440000 3150 07	cana 	147456,dl
001640  aa   000005 6010 04	tnz  	5,ic		001645
						STATEMENT 1 ON LINE 590
                        cp -> disk_channel_table (i).in_use = "1"b;

001641  aa   400000 2350 07	lda  	131072,dl
001642  aa  7 77746 2551 06	orsa 	pr7|-26,ql	disk_channel_table.in_use
						STATEMENT 1 ON LINE 591
                        disktab.channels_online = disktab.channels_online+1;

001643  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
001644  aa  5 00003 0541 00	aos  	pr5|3		disktab.channels_online
						STATEMENT 1 ON LINE 592
		  end;

						STATEMENT 1 ON LINE 593
		cp -> disk_channel_table (i).erct = 0;

001645  aa   000000 2350 03	lda  	0,du
001646  aa  7 77747 3715 06	epp5 	pr7|-25,ql	disk_channel_table.erct
001647  aa  5 00000 5511 04	stba 	pr5|0,04		disk_channel_table.erct
						STATEMENT 1 ON LINE 594
	     end;

001650  aa  6 00127 0541 00	aos  	pr6|87		i
001651  aa   777751 7100 04	tra  	-23,ic		001622
						STATEMENT 1 ON LINE 596
	     disktab.dev_busy = "0"b;

001652  aa   776514 2370 04	ldaq 	-692,ic		000366 = 000000000000 000000000000
001653  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001654  aa  7 00004 7551 00	sta  	pr7|4		disktab.dev_busy
001655  aa  7 00005 7561 00	stq  	pr7|5		disktab.dev_busy
						STATEMENT 1 ON LINE 597
	     disktab.dev_queued = "0"b;

001656  aa  7 00006 7551 00	sta  	pr7|6		disktab.dev_queued
001657  aa  7 00007 7561 00	stq  	pr7|7		disktab.dev_queued
						STATEMENT 1 ON LINE 599
	     call run;

001660  aa   001501 6700 04	tsp4 	833,ic		003361
						STATEMENT 1 ON LINE 600
	     call unlock;

001661  aa   005532 6700 04	tsp4 	2906,ic		007413
						STATEMENT 1 ON LINE 601
	end;

001662  aa  6 00162 0541 00	aos  	pr6|114		sx
001663  aa   777641 7100 04	tra  	-95,ic		001524
						STATEMENT 1 ON LINE 603
	return;

001664  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO usurp_channel                                      STATEMENT 1 ON LINE 607
usurp_channel:
     entry (a_sx, a_chx, a_required, a_iom_chx, a_statusp);

001665  at     000005000347
001666  tt     000346000345
001667  tt     000346000344
001670  ta     001665000000
001671  da     000333300000
001672  aa   001520 6270 00	eax7 	848
001673  aa  7 00034 3521 20	epp2 	pr7|28,*
001674  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001675  aa     000012000000
001676  aa     000000000000
001677  aa  6 00032 3735 20	epp7 	pr6|26,*
001700  aa  7 00010 3715 20	epp5 	pr7|8,*
001701  aa  6 00316 6515 00	spri5	pr6|206
001702  aa  7 00012 3535 20	epp3 	pr7|10,*
001703  aa  6 00320 2535 00	spri3	pr6|208
001704  aa   776724 7000 04	tsx0 	-556,ic		000630
						STATEMENT 1 ON LINE 616
	sx = a_sx;

001705  aa  6 00032 3735 20	epp7 	pr6|26,*
001706  aa  7 00002 2361 20	ldq  	pr7|2,*		a_sx
001707  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 617
	required = a_required;

001710  aa  7 00006 2351 20	lda  	pr7|6,*		a_required
001711  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001712  aa  6 00154 7551 00	sta  	pr6|108		required
						STATEMENT 1 ON LINE 618
	chx = a_chx;

001713  aa  7 00004 2361 20	ldq  	pr7|4,*		a_chx
001714  aa  6 00227 7561 00	stq  	pr6|151		chx
						STATEMENT 1 ON LINE 619
	call setup;

001715  aa   005261 6700 04	tsp4 	2737,ic		007176
						STATEMENT 1 ON LINE 620
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));

001716  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001717  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
001720  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001721  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
001722  aa   000000 3120 01	eawp2	0,au
001723  aa  6 00227 2361 00	ldq  	pr6|151		chx
001724  aa   000005 7360 00	qls  	5
001725  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
001726  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 623
	call pmut$wire_and_mask (mask, ptp);

001727  aa  6 00136 3521 00	epp2 	pr6|94		mask
001730  aa  6 00646 2521 00	spri2	pr6|422
001731  aa  6 00150 3521 00	epp2 	pr6|104		ptp
001732  aa  6 00650 2521 00	spri2	pr6|424
001733  aa  6 00644 6211 00	eax1 	pr6|420
001734  aa   010000 4310 07	fld  	4096,dl
001735  aa  6 00044 3701 20	epp4 	pr6|36,*
001736  la  4 00034 3521 20	epp2 	pr4|28,*		pmut$wire_and_mask
001737  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 624
	call lock (addr (disktab.call_lock_meters));

001740  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
001741  aa  7 00016 3735 00	epp7 	pr7|14		disktab.call_lock_meters
001742  aa  6 00652 6535 00	spri7	pr6|426
001743  aa   006447 3520 04	epp2 	3367,ic		010412 = 000002000000
001744  aa   005407 6700 04	tsp4 	2823,ic		007353
						STATEMENT 1 ON LINE 626
	usurped = (required | ^(chantab.broken | chantab.inop)) &
						/* Usurp if required or not defective channel, and ... */
	     ((disktab.channels_online > 1) | ^chantab.in_use
	     | (ioi_masked$online_device_count (disk_data.name (sx)) = 0));

001745  aa  6 00162 2361 00	ldq  	pr6|114		sx
001746  aa   000001 7360 00	qls  	1
001747  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
001750  aa  7 00010 3521 06	epp2 	pr7|8,ql		disk_data.name
001751  aa  6 00656 2521 00	spri2	pr6|430
001752  aa  6 00643 3521 00	epp2 	pr6|419
001753  aa  6 00660 2521 00	spri2	pr6|432
001754  aa   776360 3520 04	epp2 	-784,ic		000334 = 526000000004
001755  aa  6 00662 2521 00	spri2	pr6|434
001756  aa   776400 3520 04	epp2 	-768,ic		000356 = 404000000021
001757  aa  6 00664 2521 00	spri2	pr6|436
001760  aa  6 00654 6211 00	eax1 	pr6|428
001761  aa   010000 4310 07	fld  	4096,dl
001762  aa  6 00044 3701 20	epp4 	pr6|36,*
001763  la  4 00042 3521 20	epp2 	pr4|34,*		ioi_masked$online_device_count
001764  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
001765  aa  6 00643 2361 00	ldq  	pr6|419
001766  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
001767  aa  6 00643 7551 00	sta  	pr6|419
001770  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
001771  aa  7 00006 2351 00	lda  	pr7|6		chantab.in_use
001772  aa   000022 7350 00	als  	18
001773  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001774  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001775  aa  6 00666 7551 00	sta  	pr6|438
001776  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
001777  aa  5 00003 2361 00	ldq  	pr5|3		disktab.channels_online
002000  aa   000001 1160 07	cmpq 	1,dl
002001  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
002002  aa  6 00666 2751 00	ora  	pr6|438
002003  aa  6 00643 2751 00	ora  	pr6|419
002004  aa  6 00643 7551 00	sta  	pr6|419
002005  aa  7 00006 2351 00	lda  	pr7|6		chantab.inop
002006  aa   000026 7350 00	als  	22
002007  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002010  aa  6 00666 7551 00	sta  	pr6|438		chantab.inop
002011  aa  7 00006 2351 00	lda  	pr7|6		chantab.broken
002012  aa   000027 7350 00	als  	23
002013  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002014  aa  6 00666 2751 00	ora  	pr6|438		chantab.inop
002015  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
002016  aa  6 00154 2751 00	ora  	pr6|108		required
002017  aa  6 00643 3751 00	ana  	pr6|419
002020  aa  6 00170 7551 00	sta  	pr6|120		usurped
						STATEMENT 1 ON LINE 632
	if usurped then do;

002021  aa   000014 6000 04	tze  	12,ic		002035
						STATEMENT 1 ON LINE 633
	     if chantab.in_use then			/* If channel is being used, count it out. */
		disktab.channels_online = disktab.channels_online - 1;

002022  aa  7 00006 2351 00	lda  	pr7|6		chantab.in_use
002023  aa   400000 3150 07	cana 	131072,dl
002024  aa   000003 6000 04	tze  	3,ic		002027
002025  aa   000001 3360 07	lcq  	1,dl
002026  aa  5 00003 0561 00	asq  	pr5|3		disktab.channels_online
						STATEMENT 1 ON LINE 635
	     chantab.in_use = "0"b;

002027  aa   006346 2350 04	lda  	3302,ic		010375 = 777777377777
002030  aa  7 00006 3551 00	ansa 	pr7|6		chantab.in_use
						STATEMENT 1 ON LINE 636
	     chantab.broken, chantab.inop = "0"b;

002031  aa   006345 2350 04	lda  	3301,ic		010376 = 777777767777
002032  aa  7 00006 3551 00	ansa 	pr7|6		chantab.broken
002033  aa   006344 2350 04	lda  	3300,ic		010377 = 777777757777
002034  aa  7 00006 3551 00	ansa 	pr7|6		chantab.inop
						STATEMENT 1 ON LINE 637
	end;

						STATEMENT 1 ON LINE 639
	call unlock;

002035  aa   005356 6700 04	tsp4 	2798,ic		007413
						STATEMENT 1 ON LINE 640
	call pmut$unwire_unmask (mask, ptp);

002036  aa  6 00136 3521 00	epp2 	pr6|94		mask
002037  aa  6 00646 2521 00	spri2	pr6|422
002040  aa  6 00150 3521 00	epp2 	pr6|104		ptp
002041  aa  6 00650 2521 00	spri2	pr6|424
002042  aa  6 00644 6211 00	eax1 	pr6|420
002043  aa   010000 4310 07	fld  	4096,dl
002044  aa  6 00044 3701 20	epp4 	pr6|36,*
002045  la  4 00036 3521 20	epp2 	pr4|30,*		pmut$unwire_unmask
002046  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 642
	if usurped then do;

002047  aa  6 00170 2351 00	lda  	pr6|120		usurped
002050  aa   000016 6000 04	tze  	14,ic		002066
						STATEMENT 1 ON LINE 643
	     do while (chantab.active);

002051  aa   000000 0110 03	nop  	0,du
002052  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
002053  aa  7 00006 2351 00	lda  	pr7|6		chantab.active
002054  aa   200000 3150 07	cana 	65536,dl
002055  aa   000002 6000 04	tze  	2,ic		002057
						STATEMENT 1 ON LINE 644
	     end;

002056  aa   777774 7100 04	tra  	-4,ic		002052
						STATEMENT 1 ON LINE 645
	     a_iom_chx = chantab.chx;

002057  aa  7 00000 2361 00	ldq  	pr7|0		chantab.chx
002060  aa  6 00316 7561 20	stq  	pr6|206,*		a_iom_chx
						STATEMENT 1 ON LINE 646
	     a_statusp = chantab.statusp;

002061  aa  7 00002 3715 20	epp5 	pr7|2,*		chantab.statusp
002062  aa  6 00320 6515 20	spri5	pr6|208,*		a_statusp
						STATEMENT 1 ON LINE 647
	     chantab.ioi_use = "1"b;

002063  aa   040000 2350 07	lda  	16384,dl
002064  aa  7 00006 2551 00	orsa 	pr7|6		chantab.ioi_use
						STATEMENT 1 ON LINE 648
	end;

002065  aa   000004 7100 04	tra  	4,ic		002071
						STATEMENT 1 ON LINE 649
	else do;

						STATEMENT 1 ON LINE 650
	     a_iom_chx = 0;

002066  aa  6 00316 4501 20	stz  	pr6|206,*		a_iom_chx
						STATEMENT 1 ON LINE 651
	     a_statusp = null ();

002067  aa   776275 2370 04	ldaq 	-835,ic		000364 = 077777000043 000001000000
002070  aa  6 00320 7571 20	staq 	pr6|208,*		a_statusp
						STATEMENT 1 ON LINE 652
	end;

						STATEMENT 1 ON LINE 654
	return;

002071  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO cede_channel                                       STATEMENT 1 ON LINE 656
cede_channel:
     entry (a_sx, a_chx, a_iom_chx, a_statusp);

002072  at     000004000347
002073  tt     000346000346
002074  ta     000344000000
002075  ta     002072000000
002076  da     000342300000
002077  aa   001520 6270 00	eax7 	848
002100  aa  7 00034 3521 20	epp2 	pr7|28,*
002101  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002102  aa     000010000000
002103  aa     000000000000
002104  aa  6 00032 3735 20	epp7 	pr6|26,*
002105  aa  7 00006 3715 20	epp5 	pr7|6,*
002106  aa  6 00316 6515 00	spri5	pr6|206
002107  aa  7 00010 3535 20	epp3 	pr7|8,*
002110  aa  6 00320 2535 00	spri3	pr6|208
002111  aa   776517 7000 04	tsx0 	-689,ic		000630
						STATEMENT 1 ON LINE 665
	sx = a_sx;

002112  aa  6 00032 3735 20	epp7 	pr6|26,*
002113  aa  7 00002 2361 20	ldq  	pr7|2,*		a_sx
002114  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 666
	chx = a_chx;

002115  aa  7 00004 2361 20	ldq  	pr7|4,*		a_chx
002116  aa  6 00227 7561 00	stq  	pr6|151		chx
						STATEMENT 1 ON LINE 667
	iom_chx = a_iom_chx;

002117  aa  6 00316 2361 20	ldq  	pr6|206,*		a_iom_chx
002120  aa  6 00230 7561 00	stq  	pr6|152		iom_chx
						STATEMENT 1 ON LINE 668
	statusp = a_statusp;

002121  aa  6 00320 3715 20	epp5 	pr6|208,*		a_statusp
002122  aa  5 00000 3715 20	epp5 	pr5|0,*		a_statusp
002123  aa  6 00232 6515 00	spri5	pr6|154		statusp
						STATEMENT 1 ON LINE 669
	call setup;

002124  aa   005052 6700 04	tsp4 	2602,ic		007176
						STATEMENT 1 ON LINE 670
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));

002125  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
002126  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
002127  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
002130  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
002131  aa   000000 3120 01	eawp2	0,au
002132  aa  6 00227 2361 00	ldq  	pr6|151		chx
002133  aa   000005 7360 00	qls  	5
002134  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
002135  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 673
	chantab.chx = iom_chx;

002136  aa  6 00230 2361 00	ldq  	pr6|152		iom_chx
002137  aa  5 00000 7561 00	stq  	pr5|0		chantab.chx
						STATEMENT 1 ON LINE 674
	chantab.statusp = statusp;

002140  aa  6 00232 3535 20	epp3 	pr6|154,*		statusp
002141  aa  5 00002 2535 00	spri3	pr5|2		chantab.statusp
						STATEMENT 1 ON LINE 675
	chantab.ioi_use = "0"b;

002142  aa   006232 2350 04	lda  	3226,ic		010374 = 777777737777
002143  aa  5 00006 3551 00	ansa 	pr5|6		chantab.ioi_use
						STATEMENT 1 ON LINE 676
	chantab.in_use = "1"b;

002144  aa   400000 2350 07	lda  	131072,dl
002145  aa  5 00006 2551 00	orsa 	pr5|6		chantab.in_use
						STATEMENT 1 ON LINE 677
	disktab.channels_online = disktab.channels_online + 1;

002146  aa  7 00003 0541 00	aos  	pr7|3		disktab.channels_online
						STATEMENT 1 ON LINE 679
	return;

002147  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO add_channel                                        STATEMENT 1 ON LINE 683
add_channel:
     entry (a_sx, a_chx, a_code);

002150  at     000003000347
002151  tt     000346000346
002152  ta     002150000000
002153  da     000350300000
002154  aa   001520 6270 00	eax7 	848
002155  aa  7 00034 3521 20	epp2 	pr7|28,*
002156  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002157  aa     000006000000
002160  aa     000000000000
002161  aa   776447 7000 04	tsx0 	-729,ic		000630
						STATEMENT 1 ON LINE 688
	sx = a_sx;

002162  aa  6 00032 3735 20	epp7 	pr6|26,*
002163  aa  7 00002 2361 20	ldq  	pr7|2,*		a_sx
002164  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 689
	chx = a_chx;

002165  aa  7 00004 2361 20	ldq  	pr7|4,*		a_chx
002166  aa  6 00227 7561 00	stq  	pr6|151		chx
						STATEMENT 1 ON LINE 690
	call setup;

002167  aa   005007 6700 04	tsp4 	2567,ic		007176
						STATEMENT 1 ON LINE 691
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));

002170  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
002171  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
002172  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
002173  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
002174  aa   000000 3120 01	eawp2	0,au
002175  aa  6 00227 2361 00	ldq  	pr6|151		chx
002176  aa   000005 7360 00	qls  	5
002177  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
002200  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 692
	call pmut$wire_and_mask (mask, ptp);

002201  aa  6 00136 3521 00	epp2 	pr6|94		mask
002202  aa  6 00646 2521 00	spri2	pr6|422
002203  aa  6 00150 3521 00	epp2 	pr6|104		ptp
002204  aa  6 00650 2521 00	spri2	pr6|424
002205  aa  6 00644 6211 00	eax1 	pr6|420
002206  aa   010000 4310 07	fld  	4096,dl
002207  aa  6 00044 3701 20	epp4 	pr6|36,*
002210  la  4 00034 3521 20	epp2 	pr4|28,*		pmut$wire_and_mask
002211  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 693
	call lock (addr (disktab.call_lock_meters));

002212  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
002213  aa  7 00016 3735 00	epp7 	pr7|14		disktab.call_lock_meters
002214  aa  6 00652 6535 00	spri7	pr6|426
002215  aa   006175 3520 04	epp2 	3197,ic		010412 = 000002000000
002216  aa   005135 6700 04	tsp4 	2653,ic		007353
						STATEMENT 1 ON LINE 694
	if chantab.broken then do;

002217  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
002220  aa  7 00006 2351 00	lda  	pr7|6		chantab.broken
002221  aa   010000 3150 07	cana 	4096,dl
002222  aa   000010 6000 04	tze  	8,ic		002232
						STATEMENT 1 ON LINE 695
	     chantab.broken = "0"b;

002223  aa   006153 2350 04	lda  	3179,ic		010376 = 777777767777
002224  aa  7 00006 3551 00	ansa 	pr7|6		chantab.broken
						STATEMENT 1 ON LINE 696
	     chantab.in_use = "1"b;

002225  aa   400000 2350 07	lda  	131072,dl
002226  aa  7 00006 2551 00	orsa 	pr7|6		chantab.in_use
						STATEMENT 1 ON LINE 697
	     disktab.channels_online = disktab.channels_online + 1;

002227  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
002230  aa  5 00003 0541 00	aos  	pr5|3		disktab.channels_online
						STATEMENT 1 ON LINE 698
	end;

002231  aa   000004 7100 04	tra  	4,ic		002235
						STATEMENT 1 ON LINE 699
	else errcd = error_table_$io_configured;

002232  aa  6 00044 3701 20	epp4 	pr6|36,*
002233  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$io_configured
002234  aa  6 00126 7561 00	stq  	pr6|86		errcd
						STATEMENT 1 ON LINE 700
	call unlock;

002235  aa   005156 6700 04	tsp4 	2670,ic		007413
						STATEMENT 1 ON LINE 701
	call pmut$unwire_unmask (mask, ptp);

002236  aa  6 00136 3521 00	epp2 	pr6|94		mask
002237  aa  6 00646 2521 00	spri2	pr6|422
002240  aa  6 00150 3521 00	epp2 	pr6|104		ptp
002241  aa  6 00650 2521 00	spri2	pr6|424
002242  aa  6 00644 6211 00	eax1 	pr6|420
002243  aa   010000 4310 07	fld  	4096,dl
002244  aa  6 00044 3701 20	epp4 	pr6|36,*
002245  la  4 00036 3521 20	epp2 	pr4|30,*		pmut$unwire_unmask
002246  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 702
	if errcd = 0 then
	     call syserr (ANNOUNCE, "^a: Adding channel ^a.", ME, chantab.chanid);

002247  aa  6 00126 2361 00	ldq  	pr6|86		errcd
002250  aa   000032 6010 04	tnz  	26,ic		002302
002251  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002252  aa   776176 00 0030	desc9a	-898,24		000447 = 136141072040
002253  aa  6 00644 00 0030	desc9a	pr6|420,24
002254  aa   775524 3520 04	epp2 	-1196,ic		000000 = 000000000000
002255  aa  6 00672 2521 00	spri2	pr6|442
002256  aa  6 00644 3521 00	epp2 	pr6|420
002257  aa  6 00674 2521 00	spri2	pr6|444
002260  aa   776016 3520 04	epp2 	-1010,ic		000276 = 144151163153
002261  aa  6 00676 2521 00	spri2	pr6|446
002262  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
002263  aa  7 00004 3521 00	epp2 	pr7|4		chantab.chanid
002264  aa  6 00700 2521 00	spri2	pr6|448
002265  aa   776071 3520 04	epp2 	-967,ic		000356 = 404000000021
002266  aa  6 00702 2521 00	spri2	pr6|450
002267  aa   776044 3520 04	epp2 	-988,ic		000333 = 524000000026
002270  aa  6 00704 2521 00	spri2	pr6|452
002271  aa   776041 3520 04	epp2 	-991,ic		000332 = 526000000020
002272  aa  6 00706 2521 00	spri2	pr6|454
002273  aa   776036 3520 04	epp2 	-994,ic		000331 = 524000000010
002274  aa  6 00710 2521 00	spri2	pr6|456
002275  aa  6 00670 6211 00	eax1 	pr6|440
002276  aa   020000 4310 07	fld  	8192,dl
002277  aa  6 00044 3701 20	epp4 	pr6|36,*
002300  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
002301  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 704
	a_code = errcd;

002302  aa  6 00126 2361 00	ldq  	pr6|86		errcd
002303  aa  6 00032 3735 20	epp7 	pr6|26,*
002304  aa  7 00006 7561 20	stq  	pr7|6,*		a_code
						STATEMENT 1 ON LINE 705
	return;

002305  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO disk_run                                           STATEMENT 1 ON LINE 709
disk_run:
     entry;

002306  da     000356200000
002307  aa   001520 6270 00	eax7 	848
002310  aa  7 00034 3521 20	epp2 	pr7|28,*
002311  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002312  aa     000000000000
002313  aa     000000000000
002314  aa   776314 7000 04	tsx0 	-820,ic		000630
						STATEMENT 1 ON LINE 712
	entry_time = clock ();

002315  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
002316  aa  6 00124 7571 00	staq 	pr6|84		entry_time
						STATEMENT 1 ON LINE 714
	disksp = addr (disk_seg$);

002317  aa  6 00044 3701 20	epp4 	pr6|36,*
002320  la  4 00050 3735 20	epp7 	pr4|40,*		disk_seg$
002321  aa  6 00256 6535 00	spri7	pr6|174		disksp
						STATEMENT 1 ON LINE 716
	do sx = 1 to disk_data.subsystems;

002322  aa  7 00000 2361 00	ldq  	pr7|0		disk_data.subsystems
002323  aa  6 00352 7561 00	stq  	pr6|234
002324  aa   000001 2360 07	ldq  	1,dl
002325  aa  6 00162 7561 00	stq  	pr6|114		sx
002326  aa  6 00162 2361 00	ldq  	pr6|114		sx
002327  aa  6 00352 1161 00	cmpq 	pr6|234
002330  aa   000013 6054 04	tpnz 	11,ic		002343
						STATEMENT 1 ON LINE 717
	     call setup;

002331  aa   004645 6700 04	tsp4 	2469,ic		007176
						STATEMENT 1 ON LINE 718
	     call lock (addr (disktab.run_lock_meters));

002332  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
002333  aa  7 00032 3735 00	epp7 	pr7|26		disktab.run_lock_meters
002334  aa  6 00652 6535 00	spri7	pr6|426
002335  aa   006055 3520 04	epp2 	3117,ic		010412 = 000002000000
002336  aa   005015 6700 04	tsp4 	2573,ic		007353
						STATEMENT 1 ON LINE 719
	     call run;

002337  aa   001022 6700 04	tsp4 	530,ic		003361
						STATEMENT 1 ON LINE 720
	     call unlock;

002340  aa   005053 6700 04	tsp4 	2603,ic		007413
						STATEMENT 1 ON LINE 721
	end;

002341  aa  6 00162 0541 00	aos  	pr6|114		sx
002342  aa   777764 7100 04	tra  	-12,ic		002326
						STATEMENT 1 ON LINE 723
	return;

002343  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO call_run                                           STATEMENT 1 ON LINE 729
call_run:
     entry (a_sx);

002344  at     000001000347
002345  ta     002344000000
002346  da     000364300000
002347  aa   001520 6270 00	eax7 	848
002350  aa  7 00034 3521 20	epp2 	pr7|28,*
002351  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002352  aa     000002000000
002353  aa     000000000000
002354  aa   776254 7000 04	tsx0 	-852,ic		000630
						STATEMENT 1 ON LINE 733
	entry_time = clock ();

002355  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
002356  aa  6 00124 7571 00	staq 	pr6|84		entry_time
						STATEMENT 1 ON LINE 735
	sx = a_sx;

002357  aa  6 00032 3735 20	epp7 	pr6|26,*
002360  aa  7 00002 2361 20	ldq  	pr7|2,*		a_sx
002361  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 736
	call setup;

002362  aa   004614 6700 04	tsp4 	2444,ic		007176
						STATEMENT 1 ON LINE 737
	call run;

002363  aa   000776 6700 04	tsp4 	510,ic		003361
						STATEMENT 1 ON LINE 741
	call_run_sx = a_sx;

002364  aa  6 00032 3735 20	epp7 	pr6|26,*
002365  aa  7 00002 2361 20	ldq  	pr7|2,*		a_sx
002366  aa  6 00106 7561 00	stq  	pr6|70		call_run_sx
						STATEMENT 1 ON LINE 742
	do sx = 1 to disk_data.subsystems;

002367  aa  6 00256 2361 20	ldq  	pr6|174,*		disk_data.subsystems
002370  aa  6 00353 7561 00	stq  	pr6|235
002371  aa   000001 2360 07	ldq  	1,dl
002372  aa  6 00162 7561 00	stq  	pr6|114		sx
002373  aa   000000 0110 03	nop  	0,du
002374  aa  6 00162 2361 00	ldq  	pr6|114		sx
002375  aa  6 00353 1161 00	cmpq 	pr6|235
002376  aa   000016 6054 04	tpnz 	14,ic		002414
						STATEMENT 1 ON LINE 743
	     if sx ^= call_run_sx then do;

002377  aa  6 00106 1161 00	cmpq 	pr6|70		call_run_sx
002400  aa   000012 6000 04	tze  	10,ic		002412
						STATEMENT 1 ON LINE 744
		call setup;

002401  aa   004575 6700 04	tsp4 	2429,ic		007176
						STATEMENT 1 ON LINE 745
		if stacq (disktab.lock, pds$processid, UNLOCK) then do;

002402  aa  6 00044 3701 20	epp4 	pr6|36,*
002403  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
002404  aa  6 00260 3521 20	epp2 	pr6|176,*		disktab.lock
002405  aa   000000 2360 07	ldq  	0,dl
002406  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
002407  aa   000003 6000 04	tze  	3,ic		002412
						STATEMENT 1 ON LINE 747
		     call run;

002410  aa   000751 6700 04	tsp4 	489,ic		003361
						STATEMENT 1 ON LINE 748
		     call unlock;

002411  aa   005002 6700 04	tsp4 	2562,ic		007413
						STATEMENT 1 ON LINE 749
		end;

						STATEMENT 1 ON LINE 750
	     end;

						STATEMENT 1 ON LINE 751
	end;

002412  aa  6 00162 0541 00	aos  	pr6|114		sx
002413  aa   777761 7100 04	tra  	-15,ic		002374
						STATEMENT 1 ON LINE 752
	sx = call_run_sx;

002414  aa  6 00106 2361 00	ldq  	pr6|70		call_run_sx
002415  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 753
	call setup;

002416  aa   004560 6700 04	tsp4 	2416,ic		007176
						STATEMENT 1 ON LINE 754
	return;

002417  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO disk_inter                                         STATEMENT 1 ON LINE 854
disk_inter:
     entry (idx, ilevel, istat);

002420  at     000003000346
002421  tt     000342000343
002422  ta     002420000000
002423  da     000372300000
002424  aa   001520 6270 00	eax7 	848
002425  aa  7 00034 3521 20	epp2 	pr7|28,*
002426  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002427  aa     000006000000
002430  aa     000000000000
002431  aa   776177 7000 04	tsx0 	-897,ic		000630
						STATEMENT 1 ON LINE 863
	int_idx = idx;

002432  aa  6 00032 3735 20	epp7 	pr6|26,*
002433  aa  7 00002 2361 20	ldq  	pr7|2,*		idx
002434  aa  6 00234 7561 00	stq  	pr6|156		int_idx
						STATEMENT 1 ON LINE 864
	sx = divide (int_idx, dskdcl_chans_per_subsys, 17, 0);

002435  aa   000040 5060 07	div  	32,dl
002436  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 866
	call setup;

002437  aa   004537 6700 04	tsp4 	2399,ic		007176
						STATEMENT 1 ON LINE 868
	i = int_idx - sx * dskdcl_chans_per_subsys + 1;

002440  aa  6 00162 2361 00	ldq  	pr6|114		sx
002441  aa   000005 7360 00	qls  	5
002442  aa  6 00667 7561 00	stq  	pr6|439
002443  aa  6 00234 3361 00	lcq  	pr6|156		int_idx
002444  aa   000044 7770 00	llr  	36
002445  aa   000044 7330 00	lrs  	36
002446  aa  6 00667 0331 00	adl  	pr6|439
002447  aa   000000 5330 00	negl 	0
002450  aa   000001 0330 07	adl  	1,dl
002451  aa  6 00127 7561 00	stq  	pr6|87		i
						STATEMENT 1 ON LINE 869
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));

002452  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
002453  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
002454  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
002455  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
002456  aa   000000 3120 01	eawp2	0,au
002457  aa  6 00127 2361 00	ldq  	pr6|87		i
002460  aa   000005 7360 00	qls  	5
002461  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
002462  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 871
	level = ilevel;

002463  aa  6 00032 3535 20	epp3 	pr6|26,*
002464  aa  3 00004 2361 20	ldq  	pr3|4,*		ilevel
002465  aa  6 00134 7561 00	stq  	pr6|92		level
						STATEMENT 1 ON LINE 872
	stat = istat;

002466  aa  3 00006 2351 20	lda  	pr3|6,*		istat
002467  aa  6 00157 7551 00	sta  	pr6|111		stat
						STATEMENT 1 ON LINE 873
	if level = 7 then do;

002470  aa   000007 1160 07	cmpq 	7,dl
002471  aa   000003 6010 04	tnz  	3,ic		002474
						STATEMENT 1 ON LINE 874
	     call check_special_stat;

002472  aa   001227 6700 04	tsp4 	663,ic		003721
						STATEMENT 1 ON LINE 875
	     return;

002473  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 876
	end;

						STATEMENT 1 ON LINE 879
	io_status_word_ptr = chantab.statusp;

002474  aa  5 00002 3515 20	epp1 	pr5|2,*		chantab.statusp
002475  aa  6 00304 2515 00	spri1	pr6|196		io_status_word_ptr
						STATEMENT 1 ON LINE 881
	if ^io_status_word.t then
	     if level >= 3 then do;

002476  aa  1 00000 2351 00	lda  	pr1|0		io_status_word.t
002477  aa   400000 3150 03	cana 	131072,du
002500  aa   000010 6010 04	tnz  	8,ic		002510
002501  aa   000003 1160 07	cmpq 	3,dl
002502  aa   000006 6040 04	tmi  	6,ic		002510
						STATEMENT 1 ON LINE 883
		chantab.no_status_terminate = chantab.no_status_terminate + 1;

002503  aa  5 00036 2351 00	lda  	pr5|30		chantab.no_status_terminate
002504  aa   000044 7330 00	lrs  	36
002505  aa   000001 0330 07	adl  	1,dl
002506  aa  5 00036 7561 00	stq  	pr5|30		chantab.no_status_terminate
						STATEMENT 1 ON LINE 884
		return;

002507  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 885
	     end;

						STATEMENT 1 ON LINE 888
	if ^chantab.ioi_use then do;

002510  aa  5 00006 2351 00	lda  	pr5|6		chantab.ioi_use
002511  aa   040000 3150 07	cana 	16384,dl
002512  aa   000052 6010 04	tnz  	42,ic		002564
						STATEMENT 1 ON LINE 889
	     call lock (addr (disktab.int_lock_meters));

002513  aa  7 00022 3515 00	epp1 	pr7|18		disktab.int_lock_meters
002514  aa  6 00652 2515 00	spri1	pr6|426
002515  aa   005675 3520 04	epp2 	3005,ic		010412 = 000002000000
002516  aa   004635 6700 04	tsp4 	2461,ic		007353
						STATEMENT 1 ON LINE 890
	     io_status_entry_ptr = addr (stat_entry);

002517  aa  6 00207 3735 00	epp7 	pr6|135		stat_entry
002520  aa  6 00302 6535 00	spri7	pr6|194		io_status_entry_ptr
						STATEMENT 1 ON LINE 891
	     unspec (io_status_entry) = ""b;

002521  aa  000 100 100 400	mlr  	(),(pr),fill(000)
002522  aa   000000 00 0000	desc9a	0,0
002523  aa  7 00000 00 0100	desc9a	pr7|0,64
						STATEMENT 1 ON LINE 892
	     if /* case */ level = 3 then do;

002524  aa  6 00134 2361 00	ldq  	pr6|92		level
002525  aa   000003 1160 07	cmpq 	3,dl
002526  aa   000030 6010 04	tnz  	24,ic		002556
						STATEMENT 1 ON LINE 893
		call io_manager$get_status ((chantab.chx), io_status_entry_ptr);

002527  aa  6 00270 2361 20	ldq  	pr6|184,*		chantab.chx
002530  aa  6 00667 7561 00	stq  	pr6|439
002531  aa  6 00667 3521 00	epp2 	pr6|439
002532  aa  6 00646 2521 00	spri2	pr6|422
002533  aa  6 00302 3521 00	epp2 	pr6|194		io_status_entry_ptr
002534  aa  6 00650 2521 00	spri2	pr6|424
002535  aa  6 00644 6211 00	eax1 	pr6|420
002536  aa   010000 4310 07	fld  	4096,dl
002537  aa  6 00044 3701 20	epp4 	pr6|36,*
002540  la  4 00054 3521 20	epp2 	pr4|44,*		io_manager$get_status
002541  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 894
		io_status_word_ptr = addr (io_status_entry.word1);

002542  aa  6 00302 3735 20	epp7 	pr6|194,*		io_status_entry.word1
002543  aa  6 00304 6535 00	spri7	pr6|196		io_status_word_ptr
						STATEMENT 1 ON LINE 895
		if ^io_status_word.t then do;

002544  aa  7 00000 2351 00	lda  	pr7|0		io_status_word.t
002545  aa   400000 3150 03	cana 	131072,du
002546  aa   000010 6010 04	tnz  	8,ic		002556
						STATEMENT 1 ON LINE 896
		     chantab.no_io_terminate = chantab.no_io_terminate + 1;

002547  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
002550  aa  5 00034 2351 00	lda  	pr5|28		chantab.no_io_terminate
002551  aa   000044 7330 00	lrs  	36
002552  aa   000001 0330 07	adl  	1,dl
002553  aa  5 00034 7561 00	stq  	pr5|28		chantab.no_io_terminate
						STATEMENT 1 ON LINE 897
		     call unlock;

002554  aa   004637 6700 04	tsp4 	2463,ic		007413
						STATEMENT 1 ON LINE 898
		     return;

002555  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 899
		end;

						STATEMENT 1 ON LINE 900
	     end;

						STATEMENT 1 ON LINE 901
	     call check_stat;

002556  aa   001342 6700 04	tsp4 	738,ic		004120
						STATEMENT 1 ON LINE 902
	     call unlock;

002557  aa   004634 6700 04	tsp4 	2460,ic		007413
						STATEMENT 1 ON LINE 904
	     if post_sw then			/* If posting previous operation ... */
		call post;

002560  aa  6 00146 2351 00	lda  	pr6|102		post_sw
002561  aa   000020 6000 04	tze  	16,ic		002601
002562  aa   004343 6700 04	tsp4 	2275,ic		007125
						STATEMENT 1 ON LINE 906
	end;

002563  aa   000016 7100 04	tra  	14,ic		002601
						STATEMENT 1 ON LINE 908
	else					/* If status for IOI channel ... */
	     call ioi_masked$interrupt ((chantab.ioi_ctx), level, stat);

002564  aa  5 00001 2361 00	ldq  	pr5|1		chantab.ioi_ctx
002565  aa  6 00667 7561 00	stq  	pr6|439
002566  aa  6 00667 3521 00	epp2 	pr6|439
002567  aa  6 00656 2521 00	spri2	pr6|430
002570  aa  6 00134 3521 00	epp2 	pr6|92		level
002571  aa  6 00660 2521 00	spri2	pr6|432
002572  aa  6 00157 3521 00	epp2 	pr6|111		stat
002573  aa  6 00662 2521 00	spri2	pr6|434
002574  aa  6 00654 6211 00	eax1 	pr6|428
002575  aa   014000 4310 07	fld  	6144,dl
002576  aa  6 00044 3701 20	epp4 	pr6|36,*
002577  la  4 00044 3521 20	epp2 	pr4|36,*		ioi_masked$interrupt
002600  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 911
	return;

002601  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO queue_length_given_pvtx                            STATEMENT 1 ON LINE 1786
queue_length_given_pvtx:
     entry (a_pvtx, a_queue_length);

002602  at     000002000356
002603  ta     000356000000
002604  ta     002602000000
002605  da     000403300000
002606  aa   001520 6270 00	eax7 	848
002607  aa  7 00034 3521 20	epp2 	pr7|28,*
002610  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002611  aa     000004000000
002612  aa     000000000000
002613  aa   776015 7000 04	tsx0 	-1011,ic		000630
						STATEMENT 1 ON LINE 1789
	pvtep = addr (addr (pvt$array) -> pvt_array (a_pvtx));

002614  aa  6 00032 3735 20	epp7 	pr6|26,*
002615  aa  7 00002 2361 20	ldq  	pr7|2,*		a_pvtx
002616  aa   000034 4020 07	mpy  	28,dl
002617  aa  6 00044 3701 20	epp4 	pr6|36,*
002620  la  4 00056 3715 20	epp5 	pr4|46,*
002621  aa  5 77744 3715 06	epp5 	pr5|-28,ql	pvt_array
002622  aa  6 00314 6515 00	spri5	pr6|204		pvtep
						STATEMENT 1 ON LINE 1791
	pvtdip = addr (pvte.dim_info);

002623  aa  5 00010 3535 00	epp3 	pr5|8		pvte.dim_info
002624  aa  6 00274 2535 00	spri3	pr6|188		pvtdip
						STATEMENT 1 ON LINE 1792
	sx = pvtdi.sx;

002625  aa  3 00000 2351 00	lda  	pr3|0		pvtdi.sx
002626  aa   000074 7330 00	lrs  	60
002627  aa  6 00162 7561 00	stq  	pr6|114		sx
						STATEMENT 1 ON LINE 1794
	call setup;

002630  aa   004346 6700 04	tsp4 	2278,ic		007176
						STATEMENT 1 ON LINE 1796
	dev = pvte.logical_area_number;

002631  aa  6 00314 3735 20	epp7 	pr6|204,*		pvtep
002632  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
002633  aa   000011 7350 00	als  	9
002634  aa   000077 7330 00	lrs  	63
002635  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 1797
	pdi = disktab.devtab (dev).pdi;

002636  aa   000120 4020 07	mpy  	80,dl
002637  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
002640  aa  5 00036 2361 06	ldq  	pr5|30,ql		disktab.pdi
002641  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
002642  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 1798
	dp = addr (disktab.devtab (pdi));

002643  aa   000120 4020 07	mpy  	80,dl
002644  aa  5 00036 3535 06	epp3 	pr5|30,ql		disktab.devtab
002645  aa  6 00272 2535 00	spri3	pr6|186		dp
						STATEMENT 1 ON LINE 1800
	a_queue_length = devtab.wq.depth;

002646  aa  3 00010 2351 00	lda  	pr3|8		devtab.depth
002647  aa   000022 7350 00	als  	18
002650  aa   000066 7330 00	lrs  	54
002651  aa  6 00032 3515 20	epp1 	pr6|26,*
002652  aa  1 00004 7561 20	stq  	pr1|4,*		a_queue_length
						STATEMENT 1 ON LINE 1802
	return;

002653  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO tune                                               STATEMENT 1 ON LINE 1807
tune:
     entry (a_op, a_ptr, reason, ec);

002654  at     000004000341
002655  tt     000344000340
002656  ta     000346000000
002657  ta     002654000000
002660  da     000410300000
002661  aa   001520 6270 00	eax7 	848
002662  aa  7 00034 3521 20	epp2 	pr7|28,*
002663  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002664  aa     000010000000
002665  aa     000000000000
002666  aa  6 00042 3735 20	epp7 	pr6|34,*
002667  aa  7 00000 2361 20	ldq  	pr7|0,*
002670  aa   000002 6040 04	tmi  	2,ic		002672
002671  aa   777777 3760 07	anq  	262143,dl
002672  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002673  aa  6 00712 7561 00	stq  	pr6|458
002674  aa  7 00004 2361 20	ldq  	pr7|4,*
002675  aa   000002 6040 04	tmi  	2,ic		002677
002676  aa   777777 3760 07	anq  	262143,dl
002677  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002700  aa  6 00713 7561 00	stq  	pr6|459
002701  aa   775727 7000 04	tsx0 	-1065,ic		000630
						STATEMENT 1 ON LINE 1824
	disksp = addr (disk_seg$);

002702  aa  6 00044 3701 20	epp4 	pr6|36,*
002703  la  4 00050 3735 20	epp7 	pr4|40,*		disk_seg$
002704  aa  6 00256 6535 00	spri7	pr6|174		disksp
						STATEMENT 1 ON LINE 1825
	cptr = a_ptr;

002705  aa  6 00032 3715 20	epp5 	pr6|26,*
002706  aa  5 00004 3535 20	epp3 	pr5|4,*		a_ptr
002707  aa  3 00000 3535 20	epp3 	pr3|0,*		a_ptr
002710  aa  6 00240 2535 00	spri3	pr6|160		cptr
						STATEMENT 1 ON LINE 1826
	op = a_op;

002711  aa  5 00002 3515 20	epp1 	pr5|2,*
002712  aa  6 00712 2351 00	lda  	pr6|458
002713  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002714  aa  1 00000 00 0005	desc9a	pr1|0,al		a_op
002715  aa  6 00242 00 0020	desc9a	pr6|162,16	op
						STATEMENT 1 ON LINE 1828
	if op = STAGNATE_TIME then do;

002716  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002717  aa  6 00242 00 0020	desc9a	pr6|162,16	op
002720  aa   775152 00 0010	desc9a	-1430,8		000070 = 163164141147
002721  aa   000041 6010 04	tnz  	33,ic		002762
						STATEMENT 1 ON LINE 1829
	     if stagnate_time > 360000000 | stagnate_time < 0 then do;

002722  aa  6 00240 2361 20	ldq  	pr6|160,*		stagnate_time
002723  aa   775405 1160 04	cmpq 	-1275,ic		000330 = 002535225000
002724  aa   000003 6054 04	tpnz 	3,ic		002727
002725  aa  6 00240 2361 20	ldq  	pr6|160,*		stagnate_time
002726  aa   000031 6050 04	tpl  	25,ic		002757
						STATEMENT 1 ON LINE 1830
		if stagnate_time < 0 then
		     reason = "stagnate time must be >= 0";

002727  aa  6 00240 2361 20	ldq  	pr6|160,*		stagnate_time
002730  aa   000013 6050 04	tpl  	11,ic		002743
002731  aa   000032 2360 07	ldq  	26,dl
002732  aa  6 00713 1161 00	cmpq 	pr6|459
002733  aa   000002 6040 04	tmi  	2,ic		002735
002734  aa  6 00713 2361 00	ldq  	pr6|459
002735  aa  5 00006 3735 20	epp7 	pr5|6,*
002736  aa  7 77777 7561 00	stq  	pr7|-1		reason
002737  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
002740  aa   775534 00 0006	desc9a	-1188,ql		000473 = 163164141147
002741  aa  7 00000 00 0006	desc9a	pr7|0,ql		reason
002742  aa   000012 7100 04	tra  	10,ic		002754
						STATEMENT 1 ON LINE 1832
		else reason = "stagname time must be <= 6 minutes";

002743  aa   000042 2360 07	ldq  	34,dl
002744  aa  6 00713 1161 00	cmpq 	pr6|459
002745  aa   000002 6040 04	tmi  	2,ic		002747
002746  aa  6 00713 2361 00	ldq  	pr6|459
002747  aa  5 00006 3735 20	epp7 	pr5|6,*
002750  aa  7 77777 7561 00	stq  	pr7|-1		reason
002751  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
002752  aa   775541 00 0006	desc9a	-1183,ql		000512 = 163164141147
002753  aa  7 00000 00 0006	desc9a	pr7|0,ql		reason
						STATEMENT 1 ON LINE 1833
		ec = error_table_$bad_arg;

002754  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
002755  aa  5 00010 7561 20	stq  	pr5|8,*		ec
						STATEMENT 1 ON LINE 1834
		return;

002756  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1835
	     end;

						STATEMENT 1 ON LINE 1836
	     else disk_data.stagnate_time = a_ptr -> stagnate_time;

002757  aa  3 00000 2361 00	ldq  	pr3|0		stagnate_time
002760  aa  7 00111 7561 00	stq  	pr7|73		disk_data.stagnate_time
						STATEMENT 1 ON LINE 1837
	end;

002761  aa   000271 7100 04	tra  	185,ic		003252
						STATEMENT 1 ON LINE 1838
	else if op = SYS_TUNE then do;

002762  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002763  aa  6 00242 00 0020	desc9a	pr6|162,16	op
002764  aa   775112 00 0010	desc9a	-1462,8		000074 = 163171163137
002765  aa   000034 6010 04	tnz  	28,ic		003021
						STATEMENT 1 ON LINE 1839
	     io_type = cptr -> sys_info_tune.type;

002766  aa  6 00240 2361 20	ldq  	pr6|160,*		sys_info_tune.type
002767  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 1840
	     if io_type < 0 | io_type > MAX_IO_TYPE then
		goto bad_io_type;

002770  aa   000267 6040 04	tmi  	183,ic		003257
002771  aa   000006 1160 07	cmpq 	6,dl
002772  aa   000265 6054 04	tpnz 	181,ic		003257
						STATEMENT 1 ON LINE 1843
	     sysp = addr (disk_data.sys_info (io_type));

002773  aa   000002 7360 00	qls  	2
002774  aa  7 00116 3535 06	epp3 	pr7|78,ql		disk_data.sys_info
002775  aa  6 00264 2535 00	spri3	pr6|180		sysp
						STATEMENT 1 ON LINE 1845
	     if cptr -> sys_info_tune.map > MAX_IO_TYPE then
		goto bad_map_type;

002776  aa  6 00240 3515 20	epp1 	pr6|160,*		cptr
002777  aa  1 00002 2361 00	ldq  	pr1|2		sys_info_tune.map
003000  aa   000006 1160 07	cmpq 	6,dl
003001  aa   000272 6054 04	tpnz 	186,ic		003273
						STATEMENT 1 ON LINE 1850
	     if cptr -> sys_info_tune.map >= 0 then
		sys_info.depth_map = rel (addr (disk_data.sys_info (cptr -> sys_info_tune.map)));

003002  aa  1 00002 2361 00	ldq  	pr1|2		sys_info_tune.map
003003  aa   000006 6040 04	tmi  	6,ic		003011
003004  aa   000002 7360 00	qls  	2
003005  aa  7 00116 3535 06	epp3 	pr7|78,ql		disk_data.sys_info
003006  aa  3 00000 6351 00	eaa  	pr3|0
003007  aa  6 00264 3515 20	epp1 	pr6|180,*		sysp
003010  aa  1 00003 5511 60	stba 	pr1|3,60		sys_info.depth_map
003011  aa  6 00652 2535 00	spri3	pr6|426
						STATEMENT 1 ON LINE 1855
	     if cptr -> sys_info_tune.max_depth > 0 then
		sys_info.max_depth = float (cptr -> sys_info_tune.max_depth);

003012  aa  6 00240 3535 20	epp3 	pr6|160,*		cptr
003013  aa  3 00001 2361 00	ldq  	pr3|1		sys_info_tune.max_depth
003014  aa   000236 6044 04	tmoz 	158,ic		003252
003015  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
003016  aa  6 00264 3515 20	epp1 	pr6|180,*		sysp
003017  aa  1 00001 4551 00	fst  	pr1|1		sys_info.max_depth
						STATEMENT 1 ON LINE 1857
	end;

003020  aa   000232 7100 04	tra  	154,ic		003252
						STATEMENT 1 ON LINE 1858
	else if op = OPT_TUNE then do;

003021  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003022  aa  6 00242 00 0020	desc9a	pr6|162,16	op
003023  aa   775051 00 0010	desc9a	-1495,8		000072 = 157160164137
003024  aa   000131 6010 04	tnz  	89,ic		003155
						STATEMENT 1 ON LINE 1859
	     io_type = cptr -> opt_info_tune.type;

003025  aa  6 00240 2361 20	ldq  	pr6|160,*		opt_info_tune.type
003026  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 1860
	     if io_type < 0 | io_type > MAX_IO_TYPE then
		goto bad_io_type;

003027  aa   000230 6040 04	tmi  	152,ic		003257
003030  aa   000006 1160 07	cmpq 	6,dl
003031  aa   000226 6054 04	tpnz 	150,ic		003257
						STATEMENT 1 ON LINE 1863
	     do sx = 1 to disk_data.subsystems;

003032  aa  7 00000 2361 00	ldq  	pr7|0		disk_data.subsystems
003033  aa  6 00354 7561 00	stq  	pr6|236
003034  aa   000001 2360 07	ldq  	1,dl
003035  aa  6 00162 7561 00	stq  	pr6|114		sx
003036  aa  6 00162 2361 00	ldq  	pr6|114		sx
003037  aa  6 00354 1161 00	cmpq 	pr6|236
003040  aa   000247 6054 04	tpnz 	167,ic		003307
						STATEMENT 1 ON LINE 1864
		if cptr -> opt_info_tune.sub_sys = disk_data.array (sx).name then
		     goto tune_sub_sys;

003041  aa   000001 7360 00	qls  	1
003042  aa  6 00667 7561 00	stq  	pr6|439
003043  aa  6 00240 3735 20	epp7 	pr6|160,*		cptr
003044  aa  7 00001 2351 00	lda  	pr7|1		opt_info_tune.sub_sys
003045  aa  6 00256 3715 20	epp5 	pr6|174,*		disksp
003046  aa  5 00010 1151 06	cmpa 	pr5|8,ql		disk_data.name
003047  aa   000004 6000 04	tze  	4,ic		003053
						STATEMENT 1 ON LINE 1866
	     end;

003050  aa  6 00162 0541 00	aos  	pr6|114		sx
003051  aa   777765 7100 04	tra  	-11,ic		003036
						STATEMENT 1 ON LINE 1867
	     goto bad_io_sub_sys;

003052  aa   000235 7100 04	tra  	157,ic		003307
						STATEMENT 1 ON LINE 1869
tune_sub_sys:
	     call setup;

003053  aa   004123 6700 04	tsp4 	2131,ic		007176
						STATEMENT 1 ON LINE 1871
	     dev = cptr -> opt_info_tune.dev;

003054  aa  6 00240 3735 20	epp7 	pr6|160,*		cptr
003055  aa  7 00002 2361 00	ldq  	pr7|2		opt_info_tune.dev
003056  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 1872
	     if dev < lbound (disktab.devtab, 1) | dev > hbound (disktab.devtab, 1) then
		goto bad_io_dev;

003057  aa   000246 6040 04	tmi  	166,ic		003325
003060  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
003061  aa  5 00002 2351 00	lda  	pr5|2		disktab.last_dev
003062  aa   000022 7350 00	als  	18
003063  aa   000066 7330 00	lrs  	54
003064  aa  6 00120 1161 00	cmpq 	pr6|80		dev
003065  aa   000240 6040 04	tmi  	160,ic		003325
						STATEMENT 1 ON LINE 1875
	     pdi = disktab.devtab (dev).pdi;

003066  aa  6 00120 2361 00	ldq  	pr6|80		dev
003067  aa   000120 4020 07	mpy  	80,dl
003070  aa  5 00036 2361 06	ldq  	pr5|30,ql		disktab.pdi
003071  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
003072  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 1876
	     if pdi ^= dev then
		goto bad_io_dev;

003073  aa  6 00120 1161 00	cmpq 	pr6|80		dev
003074  aa   000231 6010 04	tnz  	153,ic		003325
						STATEMENT 1 ON LINE 1879
	     response = cptr -> opt_info_tune.response;

003075  aa  7 00003 2361 00	ldq  	pr7|3		opt_info_tune.response
003076  aa  6 00235 7561 00	stq  	pr6|157		response
						STATEMENT 1 ON LINE 1880
	     if response < 1 then
		goto response_range;

003077  aa   000001 1160 07	cmpq 	1,dl
003100  aa   000243 6040 04	tmi  	163,ic		003343
						STATEMENT 1 ON LINE 1882
	     load = cptr -> opt_info_tune.load;

003101  aa  7 00004 2361 00	ldq  	pr7|4		opt_info_tune.load
003102  aa  6 00236 7561 00	stq  	pr6|158		load
						STATEMENT 1 ON LINE 1884
	     optp = addr (disktab.devtab (pdi).opt_info (io_type));

003103  aa  6 00145 2361 00	ldq  	pr6|101		pdi
003104  aa   000120 4020 07	mpy  	80,dl
003105  aa  6 00667 7561 00	stq  	pr6|439
003106  aa  6 00131 2361 00	ldq  	pr6|89		io_type
003107  aa   000012 4020 07	mpy  	10,dl
003110  aa  6 00667 0761 00	adq  	pr6|439
003111  aa  5 00050 3535 06	epp3 	pr5|40,ql		disktab.opt_info
003112  aa  6 00262 2535 00	spri3	pr6|178		optp
						STATEMENT 1 ON LINE 1885
	     if load > 1 then do;

003113  aa  6 00236 2361 00	ldq  	pr6|158		load
003114  aa   000001 1160 07	cmpq 	1,dl
003115  aa   000032 6044 04	tmoz 	26,ic		003147
						STATEMENT 1 ON LINE 1886
		opt_info.slope = float (response - 1) / float (load - 1);

003116  aa   000001 1760 07	sbq  	1,dl
003117  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
003120  aa  6 00714 4571 00	dfst 	pr6|460
003121  aa  6 00667 4551 00	fst  	pr6|439
003122  aa  6 00235 3361 00	lcq  	pr6|157		response
003123  aa   000044 7770 00	llr  	36
003124  aa   000044 7330 00	lrs  	36
003125  aa   000001 0330 07	adl  	1,dl
003126  aa   000000 5330 00	negl 	0
003127  aa   216000 4110 03	lde  	72704,du
003130  aa   400000 4750 03	fad  	131072,du
003131  aa  6 00714 5671 00	dfdv 	pr6|460
003132  aa  3 00001 4551 00	fst  	pr3|1		opt_info.slope
						STATEMENT 1 ON LINE 1887
		opt_info.intercept = float ((response * load) - 1) / float (load - 1);

003133  aa  6 00667 4311 00	fld  	pr6|439
003134  aa  6 00714 4571 00	dfst 	pr6|460
003135  aa  6 00235 2361 00	ldq  	pr6|157		response
003136  aa  6 00236 4021 00	mpy  	pr6|158		load
003137  aa   000000 5330 00	negl 	0
003140  aa   000001 0330 07	adl  	1,dl
003141  aa   000000 5330 00	negl 	0
003142  aa   216000 4110 03	lde  	72704,du
003143  aa   400000 4750 03	fad  	131072,du
003144  aa  6 00714 5671 00	dfdv 	pr6|460
003145  aa  3 00002 4551 00	fst  	pr3|2		opt_info.intercept
						STATEMENT 1 ON LINE 1888
	     end;

003146  aa   000104 7100 04	tra  	68,ic		003252
						STATEMENT 1 ON LINE 1889
	     else do;

						STATEMENT 1 ON LINE 1890
		opt_info.slope = 0.0;

003147  aa   400000 4310 03	fld  	131072,du
003150  aa  3 00001 4551 00	fst  	pr3|1		opt_info.slope
						STATEMENT 1 ON LINE 1891
		opt_info.intercept = float (response);

003151  aa  6 00235 2361 00	ldq  	pr6|157		response
003152  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
003153  aa  3 00002 4551 00	fst  	pr3|2		opt_info.intercept
						STATEMENT 1 ON LINE 1892
	     end;

						STATEMENT 1 ON LINE 1893
	end;

003154  aa   000076 7100 04	tra  	62,ic		003252
						STATEMENT 1 ON LINE 1894
	else if op = RESET_SYS then do;

003155  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003156  aa  6 00242 00 0020	desc9a	pr6|162,16	op
003157  aa   774707 00 0011	desc9a	-1593,9		000064 = 162145163145
003160  aa   000017 6010 04	tnz  	15,ic		003177
						STATEMENT 1 ON LINE 1895
	     do i = 0 to MAX_IO_TYPE;

003161  aa   000006 2360 07	ldq  	6,dl
003162  aa  6 00355 7561 00	stq  	pr6|237
003163  aa  6 00127 4501 00	stz  	pr6|87		i
003164  aa  6 00127 2361 00	ldq  	pr6|87		i
003165  aa  6 00355 1161 00	cmpq 	pr6|237
003166  aa   000064 6054 04	tpnz 	52,ic		003252
						STATEMENT 1 ON LINE 1896
		disk_data.sys_info (i).depth = 0;

003167  aa   000002 7360 00	qls  	2
003170  aa   000000 6270 06	eax7 	0,ql
003171  aa   400000 4310 03	fld  	131072,du
003172  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
003173  aa  7 00116 4551 17	fst  	pr7|78,7		disk_data.depth
						STATEMENT 1 ON LINE 1897
	     end;

003174  aa  6 00127 0541 00	aos  	pr6|87		i
003175  aa   777767 7100 04	tra  	-9,ic		003164
						STATEMENT 1 ON LINE 1898
	end;

003176  aa   000054 7100 04	tra  	44,ic		003252
						STATEMENT 1 ON LINE 1899
	else if op = RESET_MAX then do;

003177  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003200  aa  6 00242 00 0020	desc9a	pr6|162,16	op
003201  aa   774662 00 0011	desc9a	-1614,9		000061 = 162145163145
003202  aa   000050 6010 04	tnz  	40,ic		003252
						STATEMENT 1 ON LINE 1900
	     disk_data.max_depth_reset_time = clock ();

003203  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
003204  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
003205  aa  7 00114 7571 00	staq 	pr7|76		disk_data.max_depth_reset_time
						STATEMENT 1 ON LINE 1901
	     disk_data.free_q.max_depth = 0;

003206  aa   000000 2350 07	lda  	0,dl
003207  aa  7 00006 5511 60	stba 	pr7|6,60		disk_data.max_depth
						STATEMENT 1 ON LINE 1902
	     do i = 1 to disk_data.subsystems;

003210  aa  7 00000 2361 00	ldq  	pr7|0		disk_data.subsystems
003211  aa  6 00356 7561 00	stq  	pr6|238
003212  aa   000001 2360 07	ldq  	1,dl
003213  aa  6 00127 7561 00	stq  	pr6|87		i
003214  aa  6 00127 2361 00	ldq  	pr6|87		i
003215  aa  6 00356 1161 00	cmpq 	pr6|238
003216  aa   000034 6054 04	tpnz 	28,ic		003252
						STATEMENT 1 ON LINE 1903
		diskp = ptr (disksp, disk_data.array (i).offset);

003217  aa   000001 7360 00	qls  	1
003220  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
003221  aa  7 00007 2351 06	lda  	pr7|7,ql		disk_data.offset
003222  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
003223  aa  7 00000 3521 00	epp2 	pr7|0
003224  aa   000000 3120 01	eawp2	0,au
003225  aa  6 00260 2521 00	spri2	pr6|176		diskp
						STATEMENT 1 ON LINE 1904
		disktab.wq.max_depth = 0;

003226  aa  2 00002 2351 00	lda  	pr2|2		disktab.last_dev
003227  aa   000022 7350 00	als  	18
003230  aa   000066 7330 00	lrs  	54
003231  aa   000001 0760 07	adq  	1,dl
003232  aa  6 00667 7561 00	stq  	pr6|439
003233  aa   000001 2360 07	ldq  	1,dl
003234  aa  6 00357 7561 00	stq  	pr6|239
003235  aa   000000 0110 03	nop  	0,du
003236  aa  6 00357 2361 00	ldq  	pr6|239
003237  aa   000120 4020 07	mpy  	80,dl
003240  aa   000000 2350 07	lda  	0,dl
003241  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003242  aa  7 77726 3715 06	epp5 	pr7|-42,ql	disktab.max_depth
003243  aa  5 00000 5511 60	stba 	pr5|0,60		disktab.max_depth
003244  aa  6 00357 2361 00	ldq  	pr6|239
003245  aa  6 00357 0541 00	aos  	pr6|239
003246  aa  6 00667 1161 00	cmpq 	pr6|439
003247  aa   777767 6040 04	tmi  	-9,ic		003236
						STATEMENT 1 ON LINE 1905
	     end;

003250  aa  6 00127 0541 00	aos  	pr6|87		i
003251  aa   777743 7100 04	tra  	-29,ic		003214
						STATEMENT 1 ON LINE 1906
	end;

						STATEMENT 1 ON LINE 1907
	reason = "";

003252  aa  6 00032 3735 20	epp7 	pr6|26,*
003253  aa  7 00006 3715 20	epp5 	pr7|6,*
003254  aa  5 77777 4501 00	stz  	pr5|-1		reason
						STATEMENT 1 ON LINE 1908
	ec = 0;

003255  aa  7 00010 4501 20	stz  	pr7|8,*		ec
						STATEMENT 1 ON LINE 1909
	return;

003256  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1911
bad_io_type:
	reason = "invalid I/O type";

003257  aa   000020 2360 07	ldq  	16,dl
003260  aa  6 00713 1161 00	cmpq 	pr6|459
003261  aa   000002 6040 04	tmi  	2,ic		003263
003262  aa  6 00713 2361 00	ldq  	pr6|459
003263  aa  5 00006 3535 20	epp3 	pr5|6,*
003264  aa  3 77777 7561 00	stq  	pr3|-1		reason
003265  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
003266  aa   775107 00 0006	desc9a	-1465,ql		000374 = 151156166141
003267  aa  3 00000 00 0006	desc9a	pr3|0,ql		reason
						STATEMENT 1 ON LINE 1913
	ec = error_table_$bad_arg;

003270  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
003271  aa  5 00010 7561 20	stq  	pr5|8,*		ec
						STATEMENT 1 ON LINE 1914
	return;

003272  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1916
bad_map_type:
	reason = "invalid map I/O type";

003273  aa   000024 2360 07	ldq  	20,dl
003274  aa  6 00713 1161 00	cmpq 	pr6|459
003275  aa   000002 6040 04	tmi  	2,ic		003277
003276  aa  6 00713 2361 00	ldq  	pr6|459
003277  aa  5 00006 3735 20	epp7 	pr5|6,*
003300  aa  7 77777 7561 00	stq  	pr7|-1		reason
003301  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
003302  aa   775111 00 0006	desc9a	-1463,ql		000412 = 151156166141
003303  aa  7 00000 00 0006	desc9a	pr7|0,ql		reason
						STATEMENT 1 ON LINE 1918
	ec = error_table_$bad_arg;

003304  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
003305  aa  5 00010 7561 20	stq  	pr5|8,*		ec
						STATEMENT 1 ON LINE 1919
	return;

003306  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1921
bad_io_sub_sys:
	reason = "unknown subsystem";

003307  aa   000021 2360 07	ldq  	17,dl
003310  aa  6 00713 1161 00	cmpq 	pr6|459
003311  aa   000002 6040 04	tmi  	2,ic		003313
003312  aa  6 00713 2361 00	ldq  	pr6|459
003313  aa  6 00032 3735 20	epp7 	pr6|26,*
003314  aa  7 00006 3715 20	epp5 	pr7|6,*
003315  aa  5 77777 7561 00	stq  	pr5|-1		reason
003316  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
003317  aa   775067 00 0006	desc9a	-1481,ql		000405 = 165156153156
003320  aa  5 00000 00 0006	desc9a	pr5|0,ql		reason
						STATEMENT 1 ON LINE 1923
	ec = error_table_$bad_arg;

003321  aa  6 00044 3701 20	epp4 	pr6|36,*
003322  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
003323  aa  7 00010 7561 20	stq  	pr7|8,*		ec
						STATEMENT 1 ON LINE 1924
	return;

003324  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1926
bad_io_dev:
	reason = "invalid device number";

003325  aa   000025 2360 07	ldq  	21,dl
003326  aa  6 00713 1161 00	cmpq 	pr6|459
003327  aa   000002 6040 04	tmi  	2,ic		003331
003330  aa  6 00713 2361 00	ldq  	pr6|459
003331  aa  6 00032 3715 20	epp5 	pr6|26,*
003332  aa  5 00006 3535 20	epp3 	pr5|6,*
003333  aa  3 77777 7561 00	stq  	pr3|-1		reason
003334  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
003335  aa   775105 00 0006	desc9a	-1467,ql		000441 = 151156166141
003336  aa  3 00000 00 0006	desc9a	pr3|0,ql		reason
						STATEMENT 1 ON LINE 1928
	ec = error_table_$bad_arg;

003337  aa  6 00044 3701 20	epp4 	pr6|36,*
003340  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
003341  aa  5 00010 7561 20	stq  	pr5|8,*		ec
						STATEMENT 1 ON LINE 1929
	return;

003342  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1931
response_range:
	reason = "response value must be >= 1";

003343  aa   000033 2360 07	ldq  	27,dl
003344  aa  6 00713 1161 00	cmpq 	pr6|459
003345  aa   000002 6040 04	tmi  	2,ic		003347
003346  aa  6 00713 2361 00	ldq  	pr6|459
003347  aa  6 00032 3535 20	epp3 	pr6|26,*
003350  aa  3 00006 3515 20	epp1 	pr3|6,*
003351  aa  1 77777 7561 00	stq  	pr1|-1		reason
003352  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
003353  aa   775112 00 0006	desc9a	-1462,ql		000464 = 162145163160
003354  aa  1 00000 00 0006	desc9a	pr1|0,ql		reason
						STATEMENT 1 ON LINE 1933
	ec = error_table_$bad_arg;

003355  aa  6 00044 3701 20	epp4 	pr6|36,*
003356  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
003357  aa  3 00010 7561 20	stq  	pr3|8,*		ec
						STATEMENT 1 ON LINE 1934
	return;

003360  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2442
     end disk_control;

BEGIN PROCEDURE run
ENTRY TO run                                                STATEMENT 1 ON LINE 758
run:
     proc;

003361  aa  6 00360 6501 00	spri4	pr6|240
						STATEMENT 1 ON LINE 763
	do i = 1 to disktab.nchan;

003362  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003363  aa  7 00001 2361 00	ldq  	pr7|1		disktab.nchan
003364  aa  6 00366 7561 00	stq  	pr6|246
003365  aa   000001 2360 07	ldq  	1,dl
003366  aa  6 00127 7561 00	stq  	pr6|87		i
003367  aa   000000 0110 03	nop  	0,du
003370  aa  6 00127 2361 00	ldq  	pr6|87		i
003371  aa  6 00366 1161 00	cmpq 	pr6|246
003372  aa   000221 6054 04	tpnz 	145,ic		003613
						STATEMENT 1 ON LINE 764
	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));

003373  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003374  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
003375  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
003376  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
003377  aa   000000 3120 01	eawp2	0,au
003400  aa  6 00127 2361 00	ldq  	pr6|87		i
003401  aa   000005 7360 00	qls  	5
003402  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
003403  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 767
	     if chantab.inop & ^chantab.in_use then	/* If channel is inoperative ... */
		if clock () - chantab.connect_time > CHANNEL_POLLING_TIME then do;

003404  aa  5 00006 2351 00	lda  	pr5|6		chantab.inop
003405  aa   020000 3150 07	cana 	8192,dl
003406  aa   000017 6000 04	tze  	15,ic		003425
003407  aa  5 00006 2351 00	lda  	pr5|6		chantab.in_use
003410  aa   400000 3150 07	cana 	131072,dl
003411  aa   000014 6010 04	tnz  	12,ic		003425
003412  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
003413  aa  5 00014 1771 00	sbaq 	pr5|12		chantab.connect_time
003414  aa  6 00716 7571 00	staq 	pr6|462
003415  aa   774665 2350 04	lda  	-1611,ic		000302 = 000344703400
003416  aa   000044 7330 00	lrs  	36
003417  aa  6 00716 1171 00	cmpaq	pr6|462
003420  aa   000005 6050 04	tpl  	5,ic		003425
						STATEMENT 1 ON LINE 769
		     chantab.in_use = "1"b;

003421  aa   400000 2350 07	lda  	131072,dl
003422  aa  5 00006 2551 00	orsa 	pr5|6		chantab.in_use
						STATEMENT 1 ON LINE 770
		     disktab.channels_online = disktab.channels_online + 1;

003423  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003424  aa  7 00003 0541 00	aos  	pr7|3		disktab.channels_online
						STATEMENT 1 ON LINE 771
		end;

						STATEMENT 1 ON LINE 782
	     if ^chantab.active then			/* If channel is inactive ... */
		call getwork;

003425  aa  5 00006 2351 00	lda  	pr5|6		chantab.active
003426  aa   200000 3150 07	cana 	65536,dl
003427  aa   000003 6010 04	tnz  	3,ic		003432
003430  aa   002526 6700 04	tsp4 	1366,ic		006156
003431  aa   000160 7100 04	tra  	112,ic		003611
						STATEMENT 1 ON LINE 785
	     else do;

						STATEMENT 1 ON LINE 786
		status_time = clock ();

003432  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
003433  aa  6 00160 7571 00	staq 	pr6|112		status_time
						STATEMENT 1 ON LINE 787
		io_status_entry_ptr = addr (stat_entry);

003434  aa  6 00207 3735 00	epp7 	pr6|135		stat_entry
003435  aa  6 00302 6535 00	spri7	pr6|194		io_status_entry_ptr
						STATEMENT 1 ON LINE 788
		call io_manager$get_status ((chantab.chx), io_status_entry_ptr);

003436  aa  5 00000 2361 00	ldq  	pr5|0		chantab.chx
003437  aa  6 00720 7561 00	stq  	pr6|464
003440  aa  6 00720 3521 00	epp2 	pr6|464
003441  aa  6 00724 2521 00	spri2	pr6|468
003442  aa  6 00302 3521 00	epp2 	pr6|194		io_status_entry_ptr
003443  aa  6 00726 2521 00	spri2	pr6|470
003444  aa  6 00722 6211 00	eax1 	pr6|466
003445  aa   010000 4310 07	fld  	4096,dl
003446  aa  6 00044 3701 20	epp4 	pr6|36,*
003447  la  4 00054 3521 20	epp2 	pr4|44,*		io_manager$get_status
003450  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 790
		io_status_word_ptr = addr (stat_entry.word1);

003451  aa  6 00207 3735 00	epp7 	pr6|135		stat_entry.word1
003452  aa  6 00304 6535 00	spri7	pr6|196		io_status_word_ptr
						STATEMENT 1 ON LINE 791
		if /* case */ io_status_word.t then do;

003453  aa  7 00000 2351 00	lda  	pr7|0		io_status_word.t
003454  aa   400000 3150 03	cana 	131072,du
003455  aa   000023 6000 04	tze  	19,ic		003500
						STATEMENT 1 ON LINE 792
		     chantab.status_from_run = chantab.status_from_run + 1;

003456  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
003457  aa  5 00037 2351 00	lda  	pr5|31		chantab.status_from_run
003460  aa   000044 7330 00	lrs  	36
003461  aa   000001 0330 07	adl  	1,dl
003462  aa  5 00037 7561 00	stq  	pr5|31		chantab.status_from_run
						STATEMENT 1 ON LINE 793
		     level = 3;

003463  aa   000003 2360 07	ldq  	3,dl
003464  aa  6 00134 7561 00	stq  	pr6|92		level
						STATEMENT 1 ON LINE 794
		     call check_stat;

003465  aa   000433 6700 04	tsp4 	283,ic		004120
						STATEMENT 1 ON LINE 796
		     if post_sw then do;

003466  aa  6 00146 2351 00	lda  	pr6|102		post_sw
003467  aa   000122 6000 04	tze  	82,ic		003611
						STATEMENT 1 ON LINE 797
			call unlock;

003470  aa   003723 6700 04	tsp4 	2003,ic		007413
						STATEMENT 1 ON LINE 798
			call post;

003471  aa   003434 6700 04	tsp4 	1820,ic		007125
						STATEMENT 1 ON LINE 799
			call lock (addr (disktab.call_lock_meters));

003472  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003473  aa  7 00016 3735 00	epp7 	pr7|14		disktab.call_lock_meters
003474  aa  6 00716 6535 00	spri7	pr6|462
003475  aa   004673 3520 04	epp2 	2491,ic		010370 = 000002000000
003476  aa   003655 6700 04	tsp4 	1965,ic		007353
						STATEMENT 1 ON LINE 801
		     end;

						STATEMENT 1 ON LINE 802
		end;

003477  aa   000112 7100 04	tra  	74,ic		003611
						STATEMENT 1 ON LINE 804
		else if chantab.connect_time + DISK_POLLING_TIME < status_time then do;

003500  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
003501  aa  5 00014 2371 00	ldaq 	pr5|12		chantab.connect_time
003502  aa   774603 0330 04	adl  	-1661,ic		000305 = 000007502200
003503  aa  6 00160 1171 00	cmpaq	pr6|112		status_time
003504  aa   000105 6050 04	tpl  	69,ic		003611
						STATEMENT 1 ON LINE 806
		     idcwp = addr (chantab.scdcw);

003505  aa  5 00024 3535 00	epp3 	pr5|20		chantab.scdcw
003506  aa  6 00310 2535 00	spri3	pr6|200		idcwp
						STATEMENT 1 ON LINE 807
		     dev = fixed (idcw.device, 6);

003507  aa  3 00000 2351 00	lda  	pr3|0		idcw.device
003510  aa   000006 7350 00	als  	6
003511  aa   000102 7730 00	lrl  	66
003512  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 808
		     pdi = disktab.devtab (dev).pdi;

003513  aa   000120 4020 07	mpy  	80,dl
003514  aa  6 00260 3515 20	epp1 	pr6|176,*		diskp
003515  aa  1 00036 2361 06	ldq  	pr1|30,ql		disktab.pdi
003516  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
003517  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 809
		     if chantab.reconnect_announce_time < status_time then do;

003520  aa  5 00012 2371 00	ldaq 	pr5|10		chantab.reconnect_announce_time
003521  aa  6 00160 1171 00	cmpaq	pr6|112		status_time
003522  aa   000007 6050 04	tpl  	7,ic		003531
						STATEMENT 1 ON LINE 810
			chantab.reconnect_announce_time = status_time + ANNOUNCE_RECONNECT_DELTA;

003523  aa  6 00160 2371 00	ldaq 	pr6|112		status_time
003524  aa   774562 0330 04	adl  	-1678,ic		000306 = 000162341600
003525  aa  5 00012 7571 00	staq 	pr5|10		chantab.reconnect_announce_time
						STATEMENT 1 ON LINE 811
			sysc = ANNOUNCE;

003526  aa   000000 2360 07	ldq  	0,dl
003527  aa  6 00163 7561 00	stq  	pr6|115		sysc
						STATEMENT 1 ON LINE 812
		     end;

003530  aa   000003 7100 04	tra  	3,ic		003533
						STATEMENT 1 ON LINE 813
		     else sysc = LOG;

003531  aa   000004 2360 07	ldq  	4,dl
003532  aa  6 00163 7561 00	stq  	pr6|115		sysc
						STATEMENT 1 ON LINE 814
		     call syserr (sysc, "^a: Reconnected ^a I/O on ^a (channel ^a).", ME,
			IO_TYPE (ptr (disksp, chantab.qrp) -> quentry.type), disk_name (SINGLE), chantab.chanid);

003533  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003534  aa   774770 00 0054	desc9a	-1544,44		000523 = 136141072040
003535  aa  6 00730 00 0054	desc9a	pr6|472,44
003536  aa  5 00007 2351 00	lda  	pr5|7		chantab.qrp
003537  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
003540  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
003541  aa   000000 3120 01	eawp2	0,au
003542  aa  2 00001 2351 00	lda  	pr2|1		quentry.type
003543  aa   000002 7350 00	als  	2
003544  aa   000104 7730 00	lrl  	68
003545  aa   000002 7360 00	qls  	2
003546  aa   004614 3520 04	epp2 	2444,ic		010362 = 000004000000
003547  aa  6 00720 7561 00	stq  	pr6|464
003550  aa   003444 6700 04	tsp4 	1828,ic		007214
003551  aa  6 00163 3521 00	epp2 	pr6|115		sysc
003552  aa  6 00746 2521 00	spri2	pr6|486
003553  aa  6 00730 3521 00	epp2 	pr6|472
003554  aa  6 00750 2521 00	spri2	pr6|488
003555  aa   774521 3520 04	epp2 	-1711,ic		000276 = 144151163153
003556  aa  6 00752 2521 00	spri2	pr6|490
003557  aa  6 00720 7271 00	lxl7 	pr6|464
003560  ta   000025 3520 17	epp2 	21,7
003561  aa  6 00754 2521 00	spri2	pr6|492
003562  aa  6 00722 3521 00	epp2 	pr6|466
003563  aa  6 00756 2521 00	spri2	pr6|494
003564  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
003565  aa  7 00004 3521 00	epp2 	pr7|4		chantab.chanid
003566  aa  6 00760 2521 00	spri2	pr6|496
003567  aa   774567 3520 04	epp2 	-1673,ic		000356 = 404000000021
003570  aa  6 00762 2521 00	spri2	pr6|498
003571  aa   774536 3520 04	epp2 	-1698,ic		000327 = 524000000052
003572  aa  6 00764 2521 00	spri2	pr6|500
003573  aa   774537 3520 04	epp2 	-1697,ic		000332 = 526000000020
003574  aa  6 00766 2521 00	spri2	pr6|502
003575  aa  6 00770 2521 00	spri2	pr6|504
003576  aa   774541 3520 04	epp2 	-1695,ic		000337 = 524000000025
003577  aa  6 00772 2521 00	spri2	pr6|506
003600  aa   774531 3520 04	epp2 	-1703,ic		000331 = 524000000010
003601  aa  6 00774 2521 00	spri2	pr6|508
003602  aa  6 00744 6211 00	eax1 	pr6|484
003603  aa   030000 4310 07	fld  	12288,dl
003604  aa  6 00044 3701 20	epp4 	pr6|36,*
003605  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
003606  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 816
		     call connect (idcwp);

003607  aa   004547 3520 04	epp2 	2407,ic		010356 = 000002000000
003610  aa   003255 6700 04	tsp4 	1709,ic		007065
						STATEMENT 1 ON LINE 817
		end;

						STATEMENT 1 ON LINE 818
	     end;

						STATEMENT 1 ON LINE 819
	end;

003611  aa  6 00127 0541 00	aos  	pr6|87		i
003612  aa   777556 7100 04	tra  	-146,ic		003370
						STATEMENT 1 ON LINE 824
	do dev = disktab.first_dev to disktab.last_dev;

003613  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003614  aa  7 00002 2351 00	lda  	pr7|2		disktab.last_dev
003615  aa   000022 7350 00	als  	18
003616  aa   000066 7330 00	lrs  	54
003617  aa  6 00367 7561 00	stq  	pr6|247
003620  aa  7 00002 2351 00	lda  	pr7|2		disktab.first_dev
003621  aa   000066 7330 00	lrs  	54
003622  aa  6 00120 7561 00	stq  	pr6|80		dev
003623  aa   000000 0110 03	nop  	0,du
003624  aa  6 00120 2361 00	ldq  	pr6|80		dev
003625  aa  6 00367 1161 00	cmpq 	pr6|247
003626  aa   000072 6054 04	tpnz 	58,ic		003720
						STATEMENT 1 ON LINE 825
	     pdi = disktab.devtab (dev).pdi;

003627  aa   000120 4020 07	mpy  	80,dl
003630  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003631  aa  7 00036 2361 06	ldq  	pr7|30,ql		disktab.pdi
003632  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
003633  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 826
	     if pdi = dev then do;

003634  aa  6 00120 1161 00	cmpq 	pr6|80		dev
003635  aa   000061 6010 04	tnz  	49,ic		003716
						STATEMENT 1 ON LINE 827
		dp = addr (disktab.devtab (pdi));

003636  aa  6 00720 7561 00	stq  	pr6|464
003637  aa   000120 4020 07	mpy  	80,dl
003640  aa  7 00036 3715 06	epp5 	pr7|30,ql		disktab.devtab
003641  aa  6 00272 6515 00	spri5	pr6|186		dp
						STATEMENT 1 ON LINE 829
		if /* case */ devtab.inop then	/* If device is inoperative ... */
		     if clock () - devtab.time_inop > INOP_POLLING_TIME then do;

003642  aa  5 00000 2351 00	lda  	pr5|0		devtab.inop
003643  aa   000400 3150 03	cana 	256,du
003644  aa   000021 6000 04	tze  	17,ic		003665
003645  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
003646  aa  5 00004 1771 00	sbaq 	pr5|4		devtab.time_inop
003647  aa  6 00716 7571 00	staq 	pr6|462
003650  aa   774434 2350 04	lda  	-1764,ic		000304 = 000023045500
003651  aa   000044 7330 00	lrs  	36
003652  aa  6 00716 1171 00	cmpaq	pr6|462
003653  aa   000043 6050 04	tpl  	35,ic		003716
						STATEMENT 1 ON LINE 831
			disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);

003654  aa  6 00720 2361 00	ldq  	pr6|464
003655  aa   000001 7360 00	qls  	1
003656  ta   000076 2350 06	lda  	62,ql
003657  ta   000077 2360 06	ldq  	63,ql
003660  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
003661  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
003662  aa  7 00004 3551 00	ansa 	pr7|4		disktab.dev_busy
003663  aa  7 00005 3561 00	ansq 	pr7|5		disktab.dev_busy
						STATEMENT 1 ON LINE 832
		     end;

						STATEMENT 1 ON LINE 833
		     else ;

003664  aa   000032 7100 04	tra  	26,ic		003716
						STATEMENT 1 ON LINE 835
		else if devtab.broken then		/* If device is broken ... */
		     if clock () - devtab.time_inop > BROKEN_POLLING_TIME then do;

003665  aa  5 00000 2351 00	lda  	pr5|0		devtab.broken
003666  aa   000100 3150 03	cana 	64,du
003667  aa   000027 6000 04	tze  	23,ic		003716
003670  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
003671  aa  5 00004 1771 00	sbaq 	pr5|4		devtab.time_inop
003672  aa  6 00716 7571 00	staq 	pr6|462
003673  aa   774410 2350 04	lda  	-1784,ic		000303 = 001256512400
003674  aa   000044 7330 00	lrs  	36
003675  aa  6 00716 1171 00	cmpaq	pr6|462
003676  aa   000020 6050 04	tpl  	16,ic		003716
						STATEMENT 1 ON LINE 837
			devtab.inop = "1"b;

003677  aa   000400 2350 03	lda  	256,du
003700  aa  5 00000 2551 00	orsa 	pr5|0		devtab.inop
						STATEMENT 1 ON LINE 838
			devtab.was_broken = "1"b;

003701  aa   000200 2350 03	lda  	128,du
003702  aa  5 00000 2551 00	orsa 	pr5|0		devtab.was_broken
						STATEMENT 1 ON LINE 839
			pvtep = addr (addr (pvt$array) -> pvt_array (devtab.pvtx));

003703  aa  5 00000 2351 00	lda  	pr5|0		devtab.pvtx
003704  aa   000077 7330 00	lrs  	63
003705  aa   000034 4020 07	mpy  	28,dl
003706  aa  6 00044 3701 20	epp4 	pr6|36,*
003707  la  4 00056 3735 20	epp7 	pr4|46,*
003710  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
003711  aa  6 00314 6535 00	spri7	pr6|204		pvtep
						STATEMENT 1 ON LINE 840
			call set_pvte_inop (OFF);

003712  aa   004440 3520 04	epp2 	2336,ic		010352 = 000002000000
003713  aa   004263 6700 04	tsp4 	2227,ic		010176
						STATEMENT 1 ON LINE 841
			devtab.broken = "0"b;

003714  aa   004467 2350 04	lda  	2359,ic		010403 = 777677777777
003715  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.broken
						STATEMENT 1 ON LINE 842
		     end;

						STATEMENT 1 ON LINE 844
	     end;

						STATEMENT 1 ON LINE 845
	end;

003716  aa  6 00120 0541 00	aos  	pr6|80		dev
003717  aa   777705 7100 04	tra  	-59,ic		003624
						STATEMENT 1 ON LINE 847
	return;

003720  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 850
     end run;

  END PROCEDURE run
BEGIN PROCEDURE check_special_stat
ENTRY TO check_special_stat                                 STATEMENT 1 ON LINE 913
check_special_stat:
     proc;

003721  aa  6 00412 6501 00	spri4	pr6|266
						STATEMENT 1 ON LINE 916
	io_special_status_ptr = addr (stat);

003722  aa  6 00157 3735 00	epp7 	pr6|111		stat
003723  aa  6 00300 6535 00	spri7	pr6|192		io_special_status_ptr
						STATEMENT 1 ON LINE 917
	if ^io_special_status.t then
	     return;

003724  aa  7 00000 2351 00	lda  	pr7|0		io_special_status.t
003725  aa   400000 3150 03	cana 	131072,du
003726  aa   000002 6010 04	tnz  	2,ic		003730
003727  aa  6 00412 6101 00	rtcd 	pr6|266
						STATEMENT 1 ON LINE 920
	dev = fixed (io_special_status.device, 6);

003730  aa  7 00000 2351 00	lda  	pr7|0		io_special_status.device
003731  aa   000014 7350 00	als  	12
003732  aa   000102 7730 00	lrl  	66
003733  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 921
	if dev = 0 & disktab.first_dev ^= 0 then	/* If special for disk controller ... */
	     go to ioi_special;

003734  aa  6 00120 2361 00	ldq  	pr6|80		dev
003735  aa   000005 6010 04	tnz  	5,ic		003742
003736  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
003737  aa  5 00002 2351 00	lda  	pr5|2		disktab.first_dev
003740  aa   000066 7330 00	lrs  	54
003741  aa   000140 6010 04	tnz  	96,ic		004101
						STATEMENT 1 ON LINE 923
	if dev > disktab.last_dev then
	     return;

003742  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
003743  aa  5 00002 2351 00	lda  	pr5|2		disktab.last_dev
003744  aa   000022 7350 00	als  	18
003745  aa   000066 7330 00	lrs  	54
003746  aa  6 00120 1161 00	cmpq 	pr6|80		dev
003747  aa   000002 6050 04	tpl  	2,ic		003751
003750  aa  6 00412 6101 00	rtcd 	pr6|266
						STATEMENT 1 ON LINE 926
	dp = addr (disktab.devtab (dev));

003751  aa  6 00120 2361 00	ldq  	pr6|80		dev
003752  aa   000120 4020 07	mpy  	80,dl
003753  aa  5 00036 3535 06	epp3 	pr5|30,ql		disktab.devtab
003754  aa  6 00272 2535 00	spri3	pr6|186		dp
						STATEMENT 1 ON LINE 927
	pdi = devtab.pdi;

003755  aa  3 00000 2361 00	ldq  	pr3|0		devtab.pdi
003756  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
003757  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 929
	pvtx = devtab.pvtx;

003760  aa  3 00000 2351 00	lda  	pr3|0		devtab.pvtx
003761  aa   000077 7330 00	lrs  	63
003762  aa  6 00100 7561 00	stq  	pr6|64		pvtx
						STATEMENT 1 ON LINE 930
	if pvtx = 0 then
	     return;

003763  aa   000002 6010 04	tnz  	2,ic		003765
003764  aa  6 00412 6101 00	rtcd 	pr6|266
						STATEMENT 1 ON LINE 935
	pvtep = addr (pvt_array (pvtx));

003765  aa   000034 4020 07	mpy  	28,dl
003766  aa  6 00312 3515 20	epp1 	pr6|202,*		pvt_arrayp
003767  aa  1 77744 3515 06	epp1 	pr1|-28,ql	pvt_array
003770  aa  6 00314 2515 00	spri1	pr6|204		pvtep
						STATEMENT 1 ON LINE 937
	if pvte.storage_system then do;

003771  aa  1 00004 2351 00	lda  	pr1|4		pvte.storage_system
003772  aa   200000 3150 07	cana 	65536,dl
003773  aa   000106 6000 04	tze  	70,ic		004101
						STATEMENT 1 ON LINE 938
	     call lock (addr (disktab.int_lock_meters));

003774  aa  5 00022 3735 00	epp7 	pr5|18		disktab.int_lock_meters
003775  aa  6 00776 6535 00	spri7	pr6|510
003776  aa   004350 3520 04	epp2 	2280,ic		010346 = 000002000000
003777  aa   003354 6700 04	tsp4 	1772,ic		007353
						STATEMENT 1 ON LINE 940
	     dp = addr (disktab.devtab (pdi));

004000  aa  6 00145 2361 00	ldq  	pr6|101		pdi
004001  aa  6 01000 7561 00	stq  	pr6|512
004002  aa   000120 4020 07	mpy  	80,dl
004003  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
004004  aa  7 00036 3735 06	epp7 	pr7|30,ql		disktab.devtab
004005  aa  6 00272 6535 00	spri7	pr6|186		dp
						STATEMENT 1 ON LINE 941
	     if /* case */ devtab.broken then do;

004006  aa  7 00000 2351 00	lda  	pr7|0		devtab.broken
004007  aa   000100 3150 03	cana 	64,du
004010  aa   000044 6000 04	tze  	36,ic		004054
						STATEMENT 1 ON LINE 942
		call syserr (ANNOUNCE, "^a: Placing ^a in operation.", ME, disk_name (BOTH));

004011  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004012  aa   774444 00 0034	desc9a	-1756,28		000455 = 136141072040
004013  aa  6 01002 00 0034	desc9a	pr6|514,28
004014  aa   004324 3520 04	epp2 	2260,ic		010340 = 000004000000
004015  aa   003177 6700 04	tsp4 	1663,ic		007214
004016  aa   773762 3520 04	epp2 	-2062,ic		000000 = 000000000000
004017  aa  6 01022 2521 00	spri2	pr6|530
004020  aa  6 01002 3521 00	epp2 	pr6|514
004021  aa  6 01024 2521 00	spri2	pr6|532
004022  aa   774254 3520 04	epp2 	-1876,ic		000276 = 144151163153
004023  aa  6 01026 2521 00	spri2	pr6|534
004024  aa  6 01012 3521 00	epp2 	pr6|522
004025  aa  6 01030 2521 00	spri2	pr6|536
004026  aa   774330 3520 04	epp2 	-1832,ic		000356 = 404000000021
004027  aa  6 01032 2521 00	spri2	pr6|538
004030  aa   774276 3520 04	epp2 	-1858,ic		000326 = 524000000034
004031  aa  6 01034 2521 00	spri2	pr6|540
004032  aa   774300 3520 04	epp2 	-1856,ic		000332 = 526000000020
004033  aa  6 01036 2521 00	spri2	pr6|542
004034  aa   774303 3520 04	epp2 	-1853,ic		000337 = 524000000025
004035  aa  6 01040 2521 00	spri2	pr6|544
004036  aa  6 01020 6211 00	eax1 	pr6|528
004037  aa   020000 4310 07	fld  	8192,dl
004040  aa  6 00044 3701 20	epp4 	pr6|36,*
004041  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
004042  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 943
		call set_pvte_inop (OFF);

004043  aa   004307 3520 04	epp2 	2247,ic		010352 = 000002000000
004044  aa   004132 6700 04	tsp4 	2138,ic		010176
						STATEMENT 1 ON LINE 944
		devtab.inop = "1"b;

004045  aa   000400 2350 03	lda  	256,du
004046  aa  6 00272 2551 20	orsa 	pr6|186,*		devtab.inop
						STATEMENT 1 ON LINE 945
		devtab.was_broken = "1"b;

004047  aa   000200 2350 03	lda  	128,du
004050  aa  6 00272 2551 20	orsa 	pr6|186,*		devtab.was_broken
						STATEMENT 1 ON LINE 946
		devtab.broken = "0"b;

004051  aa   004332 2350 04	lda  	2266,ic		010403 = 777677777777
004052  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.broken
						STATEMENT 1 ON LINE 947
	     end;

004053  aa   000016 7100 04	tra  	14,ic		004071
						STATEMENT 1 ON LINE 949
	     else if devtab.inop then do;

004054  aa  7 00000 2351 00	lda  	pr7|0		devtab.inop
004055  aa   000400 3150 03	cana 	256,du
004056  aa   000013 6000 04	tze  	11,ic		004071
						STATEMENT 1 ON LINE 950
		devtab.inop = "0"b;

004057  aa   004322 2350 04	lda  	2258,ic		010401 = 777377777777
004060  aa  7 00000 3551 00	ansa 	pr7|0		devtab.inop
						STATEMENT 1 ON LINE 951
		disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);

004061  aa  6 01000 2361 00	ldq  	pr6|512
004062  aa   000001 7360 00	qls  	1
004063  ta   000076 2350 06	lda  	62,ql
004064  ta   000077 2360 06	ldq  	63,ql
004065  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
004066  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
004067  aa  5 00004 3551 00	ansa 	pr5|4		disktab.dev_busy
004070  aa  5 00005 3561 00	ansq 	pr5|5		disktab.dev_busy
						STATEMENT 1 ON LINE 952
	     end;

						STATEMENT 1 ON LINE 954
	     call call_run (sx);

004071  aa  6 00162 3521 00	epp2 	pr6|114		sx
004072  aa  6 01014 2521 00	spri2	pr6|524
004073  aa  6 01012 6211 00	eax1 	pr6|522
004074  aa   004000 4310 07	fld  	2048,dl
004075  aa   776252 3520 04	epp2 	-854,ic		002347 = 001520627000
004076  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 956
	     call unlock;

004077  aa   003314 6700 04	tsp4 	1740,ic		007413
						STATEMENT 1 ON LINE 957
	end;

004100  aa   000017 7100 04	tra  	15,ic		004117
						STATEMENT 1 ON LINE 959
	else do;

						STATEMENT 1 ON LINE 960
ioi_special:
	     call ioi_masked$interrupt ((chantab.ioi_ctx), level, stat);

004101  aa  6 00270 3535 20	epp3 	pr6|184,*		cp
004102  aa  3 00001 2361 00	ldq  	pr3|1		chantab.ioi_ctx
004103  aa  6 01000 7561 00	stq  	pr6|512
004104  aa  6 01000 3521 00	epp2 	pr6|512
004105  aa  6 01022 2521 00	spri2	pr6|530
004106  aa  6 00134 3521 00	epp2 	pr6|92		level
004107  aa  6 01024 2521 00	spri2	pr6|532
004110  aa  6 00157 3521 00	epp2 	pr6|111		stat
004111  aa  6 01026 2521 00	spri2	pr6|534
004112  aa  6 01020 6211 00	eax1 	pr6|528
004113  aa   014000 4310 07	fld  	6144,dl
004114  aa  6 00044 3701 20	epp4 	pr6|36,*
004115  la  4 00044 3521 20	epp2 	pr4|36,*		ioi_masked$interrupt
004116  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 962
	end;

						STATEMENT 1 ON LINE 964
	return;

004117  aa  6 00412 6101 00	rtcd 	pr6|266
						STATEMENT 1 ON LINE 966
     end check_special_stat;

  END PROCEDURE check_special_stat
BEGIN PROCEDURE check_stat
ENTRY TO check_stat                                         STATEMENT 1 ON LINE 970
check_stat:
     procedure;

004120  aa  6 00420 6501 00	spri4	pr6|272
						STATEMENT 1 ON LINE 973
	errcd = 0;

004121  aa  6 00126 4501 00	stz  	pr6|86		errcd
						STATEMENT 1 ON LINE 974
	erfp = addr (errcd);

004122  aa  6 00126 3735 00	epp7 	pr6|86		errcd
004123  aa  6 00246 6535 00	spri7	pr6|166		erfp
						STATEMENT 1 ON LINE 975
	post_sw = "0"b;

004124  aa  6 00146 4501 00	stz  	pr6|102		post_sw
						STATEMENT 1 ON LINE 977
	if ^chantab.active then do;

004125  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
004126  aa  5 00006 2351 00	lda  	pr5|6		chantab.active
004127  aa   200000 3150 07	cana 	65536,dl
004130  aa   000053 6010 04	tnz  	43,ic		004203
						STATEMENT 1 ON LINE 978
	     chantab.terminate_not_active = chantab.terminate_not_active + 1;

004131  aa  5 00035 2351 00	lda  	pr5|29		chantab.terminate_not_active
004132  aa   000044 7330 00	lrs  	36
004133  aa   000001 0330 07	adl  	1,dl
004134  aa  5 00035 7561 00	stq  	pr5|29		chantab.terminate_not_active
						STATEMENT 1 ON LINE 979
	     call syserr (JUST_LOG, "^a: Unexpected IOM status ^24.3b for ^a (channel ^a).", ME,
		string (io_status_word), disk_data.name (sx), chantab.chanid);

004135  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004136  aa   774401 00 0070	desc9a	-1791,56		000536 = 136141072040
004137  aa  6 01042 00 0070	desc9a	pr6|546,56
004140  aa  6 00304 2351 20	lda  	pr6|196,*
004141  aa  6 01060 7551 00	sta  	pr6|560
004142  aa  6 00162 2361 00	ldq  	pr6|114		sx
004143  aa   000001 7360 00	qls  	1
004144  aa   774204 3520 04	epp2 	-1916,ic		000350 = 000000000005
004145  aa  6 01064 2521 00	spri2	pr6|564
004146  aa  6 01042 3521 00	epp2 	pr6|546
004147  aa  6 01066 2521 00	spri2	pr6|566
004150  aa   774126 3520 04	epp2 	-1962,ic		000276 = 144151163153
004151  aa  6 01070 2521 00	spri2	pr6|568
004152  aa  6 01060 3521 00	epp2 	pr6|560
004153  aa  6 01072 2521 00	spri2	pr6|570
004154  aa  6 00256 3535 20	epp3 	pr6|174,*		disksp
004155  aa  3 00010 3521 06	epp2 	pr3|8,ql		disk_data.name
004156  aa  6 01074 2521 00	spri2	pr6|572
004157  aa  5 00004 3521 00	epp2 	pr5|4		chantab.chanid
004160  aa  6 01076 2521 00	spri2	pr6|574
004161  aa   774175 3520 04	epp2 	-1923,ic		000356 = 404000000021
004162  aa  6 01100 2521 00	spri2	pr6|576
004163  aa   774142 3520 04	epp2 	-1950,ic		000325 = 524000000065
004164  aa  6 01102 2521 00	spri2	pr6|578
004165  aa   774145 3520 04	epp2 	-1947,ic		000332 = 526000000020
004166  aa  6 01104 2521 00	spri2	pr6|580
004167  aa   774154 3520 04	epp2 	-1940,ic		000343 = 514000000044
004170  aa  6 01106 2521 00	spri2	pr6|582
004171  aa   774143 3520 04	epp2 	-1949,ic		000334 = 526000000004
004172  aa  6 01110 2521 00	spri2	pr6|584
004173  aa   774136 3520 04	epp2 	-1954,ic		000331 = 524000000010
004174  aa  6 01112 2521 00	spri2	pr6|586
004175  aa  6 01062 6211 00	eax1 	pr6|562
004176  aa   030000 4310 07	fld  	12288,dl
004177  aa  6 00044 3701 20	epp4 	pr6|36,*
004200  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
004201  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 981
	     return;

004202  aa  6 00420 6101 00	rtcd 	pr6|272
						STATEMENT 1 ON LINE 982
	end;

						STATEMENT 1 ON LINE 984
	status_time = clock ();

004203  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
004204  aa  6 00160 7571 00	staq 	pr6|112		status_time
						STATEMENT 1 ON LINE 986
	qrp = chantab.qrp;

004205  aa  5 00007 2351 00	lda  	pr5|7		chantab.qrp
004206  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
004207  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 987
	qp = ptr (disksp, qrp);

004210  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
004211  aa   000000 3120 01	eawp2	0,au
004212  aa  6 00266 2521 00	spri2	pr6|182		qp
						STATEMENT 1 ON LINE 988
	dev = quentry.dev;

004213  aa  2 00002 2351 00	lda  	pr2|2		quentry.dev
004214  aa   000016 7350 00	als  	14
004215  aa   000102 7730 00	lrl  	66
004216  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 989
	pdi = quentry.pdi;

004217  aa  2 00002 2351 00	lda  	pr2|2		quentry.pdi
004220  aa   000010 7350 00	als  	8
004221  aa   000102 7730 00	lrl  	66
004222  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 990
	coreadd = bin (quentry.coreadd, 24);

004223  aa  2 00001 2361 00	ldq  	pr2|1		quentry.coreadd
004224  aa  0 00360 3771 00	anaq 	pr0|240		= 000000000000 000077777777
004225  aa  6 00101 7561 00	stq  	pr6|65		coreadd
						STATEMENT 1 ON LINE 991
	pvtx = quentry.pvtx;

004226  aa  2 00002 2351 00	lda  	pr2|2		quentry.pvtx
004227  aa   000100 7730 00	lrl  	64
004230  aa  6 00100 7561 00	stq  	pr6|64		pvtx
						STATEMENT 1 ON LINE 992
	sect_sw = sector_map (quentry.type);

004231  aa  2 00001 2351 00	lda  	pr2|1		quentry.type
004232  aa   000002 7350 00	als  	2
004233  aa   000104 7730 00	lrl  	68
004234  aa  6 00156 4501 00	stz  	pr6|110		sect_sw
004235  aa  003 100 060 406	csl  	(ql),(pr),fill(0),bool(move)
004236  ta   000023 00 0001	descb	19,1
004237  aa  6 00156 00 0001	descb	pr6|110,1		sect_sw
						STATEMENT 1 ON LINE 993
	bootload_sw = bootload_map (quentry.type);

004240  aa  6 00105 4501 00	stz  	pr6|69		bootload_sw
004241  aa  003 100 060 406	csl  	(ql),(pr),fill(0),bool(move)
004242  ta   000022 00 0001	descb	18,1
004243  aa  6 00105 00 0001	descb	pr6|69,1		bootload_sw
						STATEMENT 1 ON LINE 995
	pvtep = addr (addr (pvt$array) -> pvt_array (pvtx));

004244  aa  6 01060 7561 00	stq  	pr6|560		quentry.type
004245  aa  6 00100 2361 00	ldq  	pr6|64		pvtx
004246  aa   000034 4020 07	mpy  	28,dl
004247  aa  6 00044 3701 20	epp4 	pr6|36,*
004250  la  4 00056 3735 20	epp7 	pr4|46,*
004251  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
004252  aa  6 00314 6535 00	spri7	pr6|204		pvtep
						STATEMENT 1 ON LINE 997
	dp = addr (disktab.devtab (pdi));

004253  aa  6 00145 2361 00	ldq  	pr6|101		pdi
004254  aa  6 01061 7561 00	stq  	pr6|561
004255  aa   000120 4020 07	mpy  	80,dl
004256  aa  6 00260 3535 20	epp3 	pr6|176,*		diskp
004257  aa  3 00036 3535 06	epp3 	pr3|30,ql		disktab.devtab
004260  aa  6 00272 2535 00	spri3	pr6|186		dp
						STATEMENT 1 ON LINE 1002
	io_type = quentry.type;

004261  aa  6 01060 2361 00	ldq  	pr6|560		quentry.type
004262  aa  6 00131 7561 00	stq  	pr6|89		io_type
						STATEMENT 1 ON LINE 1007
	if level = 3 then do;

004263  aa  6 00134 2361 00	ldq  	pr6|92		level
004264  aa   000003 1160 07	cmpq 	3,dl
004265  aa   000221 6010 04	tnz  	145,ic		004506
						STATEMENT 1 ON LINE 1008
	     chantab.active = "0"b;

004266  aa   004112 2350 04	lda  	2122,ic		010400 = 777777577777
004267  aa  5 00006 3551 00	ansa 	pr5|6		chantab.active
						STATEMENT 1 ON LINE 1009
	     disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);

004270  aa  6 01061 2361 00	ldq  	pr6|561
004271  aa   000001 7360 00	qls  	1
004272  ta   000076 2350 06	lda  	62,ql
004273  ta   000077 2360 06	ldq  	63,ql
004274  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
004275  aa  6 00260 3515 20	epp1 	pr6|176,*		diskp
004276  aa  1 00004 3551 00	ansa 	pr1|4		disktab.dev_busy
004277  aa  1 00005 3561 00	ansq 	pr1|5		disktab.dev_busy
						STATEMENT 1 ON LINE 1014
	     if /* case */ chantab.rsr then do;

004300  aa  5 00006 2351 00	lda  	pr5|6		chantab.rsr
004301  aa   100000 3150 07	cana 	32768,dl
004302  aa   000027 6000 04	tze  	23,ic		004331
						STATEMENT 1 ON LINE 1015
		if (string (io_status_word) & disk_data.status_mask) then
						/* Don't print bad RSR's */
		     chantab.rsr = "0"b;

004303  aa  6 00304 2351 20	lda  	pr6|196,*
004304  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
004305  aa  7 00002 3151 00	cana 	pr7|2		disk_data.status_mask
004306  aa   000003 6000 04	tze  	3,ic		004311
004307  aa   004027 2350 04	lda  	2071,ic		010336 = 777777677777
004310  aa  5 00006 3551 00	ansa 	pr5|6		chantab.rsr
						STATEMENT 1 ON LINE 1018
		unspec (io_status_entry.detailed_status (*)) = unspec (chantab.detailed_status (*));

004311  aa  6 00302 3535 20	epp3 	pr6|194,*		io_status_entry_ptr
004312  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004313  aa  5 00017 00 0220	descb	pr5|15,144
004314  aa  3 00010 00 0440	descb	pr3|8,288
						STATEMENT 1 ON LINE 1021
		io_status_word_ptr = addr (chantab.status);

004315  aa  5 00033 3515 00	epp1 	pr5|27		chantab.status
004316  aa  6 00304 2515 00	spri1	pr6|196		io_status_word_ptr
						STATEMENT 1 ON LINE 1023
		command = chantab.command;

004317  aa  5 00007 2351 00	lda  	pr5|7		chantab.command
004320  aa   000025 7350 00	als  	21
004321  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004322  aa  6 00112 7551 00	sta  	pr6|74		command
						STATEMENT 1 ON LINE 1024
		call extract_status;

004323  aa   000260 6700 04	tsp4 	176,ic		004603
						STATEMENT 1 ON LINE 1025
		call handle_error;

004324  aa   001057 6700 04	tsp4 	559,ic		005403
						STATEMENT 1 ON LINE 1027
		chantab.rsr = "0"b;

004325  aa   004011 2350 04	lda  	2057,ic		010336 = 777777677777
004326  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
004327  aa  7 00006 3551 00	ansa 	pr7|6		chantab.rsr
						STATEMENT 1 ON LINE 1028
	     end;

004330  aa   000200 7100 04	tra  	128,ic		004530
						STATEMENT 1 ON LINE 1032
	     else if string (io_status_word) & disk_data.status_mask then do;

004331  aa  6 00304 2351 20	lda  	pr6|196,*
004332  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
004333  aa  7 00002 3151 00	cana 	pr7|2		disk_data.status_mask
004334  aa   000044 6000 04	tze  	36,ic		004400
						STATEMENT 1 ON LINE 1033
		call extract_status;

004335  aa   000246 6700 04	tsp4 	166,ic		004603
						STATEMENT 1 ON LINE 1034
		call interpret_status;

004336  aa   000310 6700 04	tsp4 	200,ic		004646
						STATEMENT 1 ON LINE 1035
		call get_disk_command;

004337  aa   000402 6700 04	tsp4 	258,ic		004741
						STATEMENT 1 ON LINE 1037
		if disk_error_interp.rsr & (io_status_entry.detailed_status (1) = ""b) then do;

004340  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.rsr
004341  aa   200000 3150 07	cana 	65536,dl
004342  aa   000034 6000 04	tze  	28,ic		004376
004343  aa  6 00302 3735 20	epp7 	pr6|194,*		io_status_entry_ptr
004344  aa  7 00010 2351 00	lda  	pr7|8		io_status_entry.detailed_status
004345  aa   000031 6010 04	tnz  	25,ic		004376
						STATEMENT 1 ON LINE 1039
		     chantab.rsr = "1"b;

004346  aa   100000 2350 07	lda  	32768,dl
004347  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
004350  aa  5 00006 2551 00	orsa 	pr5|6		chantab.rsr
						STATEMENT 1 ON LINE 1040
		     chantab.status = string (io_status_word);

004351  aa  6 00304 2351 20	lda  	pr6|196,*
004352  aa  5 00033 7551 00	sta  	pr5|27		chantab.status
						STATEMENT 1 ON LINE 1042
		     chantab.action_code = io_status_entry.action_code;

004353  aa  7 00003 2351 00	lda  	pr7|3		io_status_entry.action_code
004354  aa   000002 7710 00	arl  	2
004355  aa  5 00006 6751 00	era  	pr5|6		chantab.action_code
004356  aa   006000 3750 07	ana  	3072,dl
004357  aa  5 00006 6551 00	ersa 	pr5|6		chantab.action_code
						STATEMENT 1 ON LINE 1043
		     chantab.command = command;

004360  aa  6 00112 2351 00	lda  	pr6|74		command
004361  aa   000025 7710 00	arl  	21
004362  aa  5 00007 6751 00	era  	pr5|7		chantab.command
004363  aa   077000 3750 07	ana  	32256,dl
004364  aa  5 00007 6551 00	ersa 	pr5|7		chantab.command
						STATEMENT 1 ON LINE 1045
		     idcwp = addr (chantab.dscdcw);

004365  aa  5 00030 3535 00	epp3 	pr5|24		chantab.dscdcw
004366  aa  6 00310 2535 00	spri3	pr6|200		idcwp
						STATEMENT 1 ON LINE 1046
		     idcw.device = bit (dev);

004367  aa  6 00120 2351 00	lda  	pr6|80		dev
004370  aa   000036 7350 00	als  	30
004371  aa   000006 7710 00	arl  	6
004372  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
						STATEMENT 1 ON LINE 1047
		     call connect (idcwp);

004373  aa   003763 3520 04	epp2 	2035,ic		010356 = 000002000000
004374  aa   002471 6700 04	tsp4 	1337,ic		007065
						STATEMENT 1 ON LINE 1048
		end;

004375  aa   000133 7100 04	tra  	91,ic		004530
						STATEMENT 1 ON LINE 1050
		else				/* If no RSR required ... */
		     call handle_error;

004376  aa   001005 6700 04	tsp4 	517,ic		005403
						STATEMENT 1 ON LINE 1052
	     end;

004377  aa   000131 7100 04	tra  	89,ic		004530
						STATEMENT 1 ON LINE 1056
	     else if io_status_entry.tally_residue ^= 0 then do;

004400  aa  6 00302 3535 20	epp3 	pr6|194,*		io_status_entry_ptr
004401  aa  3 00003 2361 00	ldq  	pr3|3		io_status_entry.tally_residue
004402  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
004403  aa   000006 6000 04	tze  	6,ic		004411
						STATEMENT 1 ON LINE 1057
		majstat = 20;

004404  aa   000024 2360 07	ldq  	20,dl
004405  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1058
		substat = ANY;

004406  aa  6 00164 4501 00	stz  	pr6|116		substat
						STATEMENT 1 ON LINE 1059
		call handle_error;

004407  aa   000774 6700 04	tsp4 	508,ic		005403
						STATEMENT 1 ON LINE 1060
	     end;

004410  aa   000120 7100 04	tra  	80,ic		004530
						STATEMENT 1 ON LINE 1064
	     else do;

						STATEMENT 1 ON LINE 1065
		post_sw = "1"b;

004411  aa   400000 2350 03	lda  	131072,du
004412  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1067
		if io_status_word.sub & "010011"b then do;

004413  aa  6 00304 2351 20	lda  	pr6|196,*		io_status_word.sub
004414  aa   000006 7350 00	als  	6
004415  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004416  aa   230000 3150 03	cana 	77824,du
004417  aa   000016 6000 04	tze  	14,ic		004435
						STATEMENT 1 ON LINE 1069
		     disktab.edac_errors = disktab.edac_errors + 1;

004420  aa  1 00014 0541 00	aos  	pr1|12		disktab.edac_errors
						STATEMENT 1 ON LINE 1071
		     if io_status_word.sub & "010000"b then
						/* If EDAC performed ... */
			majstat = 22;

004421  aa  6 01060 7551 00	sta  	pr6|560		io_status_word.sub
004422  aa   200000 3150 03	cana 	65536,du
004423  aa   000004 6000 04	tze  	4,ic		004427
004424  aa   000026 2360 07	ldq  	22,dl
004425  aa  6 00135 7561 00	stq  	pr6|93		majstat
004426  aa   000003 7100 04	tra  	3,ic		004431
						STATEMENT 1 ON LINE 1074
		     else				/* If auto retries performed ... */
			majstat = 21;

004427  aa   000025 2360 07	ldq  	21,dl
004430  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1076
		     substat = ANY;

004431  aa  6 00164 4501 00	stz  	pr6|116		substat
						STATEMENT 1 ON LINE 1077
		     call interpret_status;

004432  aa   000214 6700 04	tsp4 	140,ic		004646
						STATEMENT 1 ON LINE 1078
		     call get_disk_command ();

004433  aa   000306 6700 04	tsp4 	198,ic		004741
						STATEMENT 1 ON LINE 1079
		     call printerr;

004434  aa   000335 6700 04	tsp4 	221,ic		004771
						STATEMENT 1 ON LINE 1080
		end;

						STATEMENT 1 ON LINE 1082
		devtab.inop = "0"b;

004435  aa   003744 2350 04	lda  	2020,ic		010401 = 777377777777
004436  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.inop
						STATEMENT 1 ON LINE 1084
		if devtab.was_broken | devtab.broken then do;

004437  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.broken
004440  aa   000300 3150 03	cana 	192,du
004441  aa   000041 6000 04	tze  	33,ic		004502
						STATEMENT 1 ON LINE 1086
		     devtab.was_broken = "0"b;

004442  aa   003740 2350 04	lda  	2016,ic		010402 = 777577777777
004443  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.was_broken
						STATEMENT 1 ON LINE 1087
		     devtab.broken = "0"b;

004444  aa   003737 2350 04	lda  	2015,ic		010403 = 777677777777
004445  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.broken
						STATEMENT 1 ON LINE 1088
		     call set_pvte_inop (OFF);

004446  aa   003704 3520 04	epp2 	1988,ic		010352 = 000002000000
004447  aa   003527 6700 04	tsp4 	1879,ic		010176
						STATEMENT 1 ON LINE 1089
		     call syserr (ANNOUNCE, "^a: ^a now operational.", ME, disk_name (BOTH));

004450  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004451  aa   773763 00 0030	desc9a	-2061,24		000433 = 136141072040
004452  aa  6 01042 00 0030	desc9a	pr6|546,24
004453  aa   003655 3520 04	epp2 	1965,ic		010330 = 000004000000
004454  aa   002540 6700 04	tsp4 	1376,ic		007214
004455  aa   773323 3520 04	epp2 	-2349,ic		000000 = 000000000000
004456  aa  6 01116 2521 00	spri2	pr6|590
004457  aa  6 01042 3521 00	epp2 	pr6|546
004460  aa  6 01120 2521 00	spri2	pr6|592
004461  aa   773615 3520 04	epp2 	-2163,ic		000276 = 144151163153
004462  aa  6 01122 2521 00	spri2	pr6|594
004463  aa  6 01062 3521 00	epp2 	pr6|562
004464  aa  6 01124 2521 00	spri2	pr6|596
004465  aa   773671 3520 04	epp2 	-2119,ic		000356 = 404000000021
004466  aa  6 01126 2521 00	spri2	pr6|598
004467  aa   773635 3520 04	epp2 	-2147,ic		000324 = 524000000027
004470  aa  6 01130 2521 00	spri2	pr6|600
004471  aa   773641 3520 04	epp2 	-2143,ic		000332 = 526000000020
004472  aa  6 01132 2521 00	spri2	pr6|602
004473  aa   773644 3520 04	epp2 	-2140,ic		000337 = 524000000025
004474  aa  6 01134 2521 00	spri2	pr6|604
004475  aa  6 01114 6211 00	eax1 	pr6|588
004476  aa   020000 4310 07	fld  	8192,dl
004477  aa  6 00044 3701 20	epp4 	pr6|36,*
004500  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
004501  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1090
		end;

						STATEMENT 1 ON LINE 1091
		chantab.inop = "0"b;

004502  aa   003675 2350 04	lda  	1981,ic		010377 = 777777757777
004503  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
004504  aa  7 00006 3551 00	ansa 	pr7|6		chantab.inop
						STATEMENT 1 ON LINE 1092
	     end;

						STATEMENT 1 ON LINE 1094
	end;

004505  aa   000023 7100 04	tra  	19,ic		004530
						STATEMENT 1 ON LINE 1098
	else if level = 1 then do;

004506  aa   000001 1160 07	cmpq 	1,dl
004507  aa   000020 6010 04	tnz  	16,ic		004527
						STATEMENT 1 ON LINE 1099
	     chantab.active = "0"b;

004510  aa   003670 2350 04	lda  	1976,ic		010400 = 777777577777
004511  aa  5 00006 3551 00	ansa 	pr5|6		chantab.active
						STATEMENT 1 ON LINE 1100
	     disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);

004512  aa  6 01061 2361 00	ldq  	pr6|561
004513  aa   000001 7360 00	qls  	1
004514  ta   000076 2350 06	lda  	62,ql
004515  ta   000077 2360 06	ldq  	63,ql
004516  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
004517  aa  6 00260 3515 20	epp1 	pr6|176,*		diskp
004520  aa  1 00004 3551 00	ansa 	pr1|4		disktab.dev_busy
004521  aa  1 00005 3561 00	ansq 	pr1|5		disktab.dev_busy
						STATEMENT 1 ON LINE 1102
	     majstat = 19;

004522  aa   000023 2360 07	ldq  	19,dl
004523  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1103
	     substat = ANY;

004524  aa  6 00164 4501 00	stz  	pr6|116		substat
						STATEMENT 1 ON LINE 1104
	     call handle_error;

004525  aa   000656 6700 04	tsp4 	430,ic		005403
						STATEMENT 1 ON LINE 1105
	end;

004526  aa   000002 7100 04	tra  	2,ic		004530
						STATEMENT 1 ON LINE 1108
	else return;

004527  aa  6 00420 6101 00	rtcd 	pr6|272
						STATEMENT 1 ON LINE 1112
	if post_sw then do;

004530  aa  6 00146 2351 00	lda  	pr6|102		post_sw
004531  aa   000044 6000 04	tze  	36,ic		004575
						STATEMENT 1 ON LINE 1113
	     if io_type = TEST then do;

004532  aa  6 00131 2361 00	ldq  	pr6|89		io_type
004533  aa   000004 1160 07	cmpq 	4,dl
004534  aa   000006 6010 04	tnz  	6,ic		004542
						STATEMENT 1 ON LINE 1114
		pvte.testing = "0"b;

004535  aa   003637 2350 04	lda  	1951,ic		010374 = 777777737777
004536  aa  6 00314 3735 20	epp7 	pr6|204,*		pvtep
004537  aa  7 00004 3551 00	ansa 	pr7|4		pvte.testing
						STATEMENT 1 ON LINE 1115
		post_sw = "0"b;

004540  aa  6 00146 4501 00	stz  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1116
	     end;

004541  aa   000033 7100 04	tra  	27,ic		004574
						STATEMENT 1 ON LINE 1117
	     else do;

						STATEMENT 1 ON LINE 1118
		status_time = clock ();

004542  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
004543  aa  6 00160 7571 00	staq 	pr6|112		status_time
						STATEMENT 1 ON LINE 1119
		channel_time = status_time - chantab.connect_time;

004544  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
004545  aa  7 00014 1771 00	sbaq 	pr7|12		chantab.connect_time
004546  aa  6 00110 7571 00	staq 	pr6|72		channel_time
						STATEMENT 1 ON LINE 1121
		wait_time = status_time - quentry.time;

004547  aa  6 00160 2371 00	ldaq 	pr6|112		status_time
004550  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
004551  aa  5 00004 1771 00	sbaq 	pr5|4		quentry.time
004552  aa  6 00172 7571 00	staq 	pr6|122		wait_time
						STATEMENT 1 ON LINE 1123
		optp = addr (devtab.opt_info (quentry.type));

004553  aa  5 00001 2351 00	lda  	pr5|1		quentry.type
004554  aa   000002 7350 00	als  	2
004555  aa   000104 7730 00	lrl  	68
004556  aa   000012 4020 07	mpy  	10,dl
004557  aa  6 00272 3535 20	epp3 	pr6|186,*		dp
004560  aa  3 00012 3535 06	epp3 	pr3|10,ql		devtab.opt_info
004561  aa  6 00262 2535 00	spri3	pr6|178		optp
						STATEMENT 1 ON LINE 1126
		opt_info.channel_wait = opt_info.channel_wait + channel_time;

004562  aa  3 00004 2371 00	ldaq 	pr3|4		opt_info.channel_wait
004563  aa  6 00110 0771 00	adaq 	pr6|72		channel_time
004564  aa  3 00004 7571 00	staq 	pr3|4		opt_info.channel_wait
						STATEMENT 1 ON LINE 1127
		opt_info.queue_wait = opt_info.queue_wait + wait_time;

004565  aa  3 00006 2371 00	ldaq 	pr3|6		opt_info.queue_wait
004566  aa  6 00172 0771 00	adaq 	pr6|122		wait_time
004567  aa  3 00006 7571 00	staq 	pr3|6		opt_info.queue_wait
						STATEMENT 1 ON LINE 1131
		if errcd ^= 0			/* count a fatal error */
		     then
		     disktab.ferrors = disktab.ferrors + 1;

004570  aa  6 00126 2361 00	ldq  	pr6|86		errcd
004571  aa   000003 6000 04	tze  	3,ic		004574
004572  aa  6 00260 3515 20	epp1 	pr6|176,*		diskp
004573  aa  1 00013 0541 00	aos  	pr1|11		disktab.ferrors
						STATEMENT 1 ON LINE 1134
	     end;

						STATEMENT 1 ON LINE 1136
	     call add_free_q;

004574  aa   002776 6700 04	tsp4 	1534,ic		007572
						STATEMENT 1 ON LINE 1137
	end;

						STATEMENT 1 ON LINE 1139
	if ^chantab.active then			/* If channel is now free ... */
	     call getwork;

004575  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
004576  aa  7 00006 2351 00	lda  	pr7|6		chantab.active
004577  aa   200000 3150 07	cana 	65536,dl
004600  aa   000002 6010 04	tnz  	2,ic		004602
004601  aa   001355 6700 04	tsp4 	749,ic		006156
						STATEMENT 1 ON LINE 1142
	return;

004602  aa  6 00420 6101 00	rtcd 	pr6|272
						STATEMENT 1 ON LINE 1462
     end check_stat;

BEGIN PROCEDURE extract_status
ENTRY TO extract_status                                     STATEMENT 1 ON LINE 1146
extract_status:
	proc;

004603  aa  6 00426 6501 00	spri4	pr6|278
						STATEMENT 1 ON LINE 1149
	     if /* case */ io_status_word.power then do;

004604  aa  6 00304 2351 20	lda  	pr6|196,*		io_status_word.power
004605  aa   200000 3150 03	cana 	65536,du
004606  aa   000005 6000 04	tze  	5,ic		004613
						STATEMENT 1 ON LINE 1150
		majstat = 16;

004607  aa   000020 2360 07	ldq  	16,dl
004610  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1151
		substat = ANY;

004611  aa  6 00164 4501 00	stz  	pr6|116		substat
						STATEMENT 1 ON LINE 1152
	     end;

004612  aa   000033 7100 04	tra  	27,ic		004645
						STATEMENT 1 ON LINE 1153
	     else if io_status_word.channel_stat then do;

004613  aa  6 00304 2351 20	lda  	pr6|196,*		io_status_word.channel_stat
004614  aa   000022 7350 00	als  	18
004615  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
004616  aa  6 01136 7551 00	sta  	pr6|606		io_status_word.channel_stat
004617  aa   000005 6000 04	tze  	5,ic		004624
						STATEMENT 1 ON LINE 1154
		majstat = 17;

004620  aa   000021 2360 07	ldq  	17,dl
004621  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1155
		substat = io_status_word.channel_stat;

004622  aa  6 00164 7551 00	sta  	pr6|116		substat
						STATEMENT 1 ON LINE 1156
	     end;

004623  aa   000022 7100 04	tra  	18,ic		004645
						STATEMENT 1 ON LINE 1157
	     else if io_status_word.central_stat then do;

004624  aa  6 00304 2351 20	lda  	pr6|196,*		io_status_word.central_stat
004625  aa   000025 7350 00	als  	21
004626  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
004627  aa  6 01136 7551 00	sta  	pr6|606		io_status_word.central_stat
004630  aa   000005 6000 04	tze  	5,ic		004635
						STATEMENT 1 ON LINE 1158
		majstat = 18;

004631  aa   000022 2360 07	ldq  	18,dl
004632  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1159
		substat = io_status_word.central_stat;

004633  aa  6 00164 7551 00	sta  	pr6|116		substat
						STATEMENT 1 ON LINE 1160
	     end;

004634  aa   000011 7100 04	tra  	9,ic		004645
						STATEMENT 1 ON LINE 1161
	     else do;

						STATEMENT 1 ON LINE 1162
		majstat = bin (io_status_word.major, 4);

004635  aa  6 00304 2351 20	lda  	pr6|196,*		io_status_word.major
004636  aa   000002 7350 00	als  	2
004637  aa   000104 7730 00	lrl  	68
004640  aa  6 00135 7561 00	stq  	pr6|93		majstat
						STATEMENT 1 ON LINE 1163
		substat = io_status_word.sub;

004641  aa  6 00304 2351 20	lda  	pr6|196,*		io_status_word.sub
004642  aa   000006 7350 00	als  	6
004643  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004644  aa  6 00164 7551 00	sta  	pr6|116		substat
						STATEMENT 1 ON LINE 1164
	     end;

						STATEMENT 1 ON LINE 1167
	end extract_status;

004645  aa  6 00426 6101 00	rtcd 	pr6|278
  END PROCEDURE extract_status
BEGIN PROCEDURE interpret_status
ENTRY TO interpret_status                                   STATEMENT 1 ON LINE 1173
interpret_status:
	proc;

004646  aa  6 00434 6501 00	spri4	pr6|284
						STATEMENT 1 ON LINE 1177
	     dedp = addr (disk_error_data$);

004647  aa  6 00044 3701 20	epp4 	pr6|36,*
004650  la  4 00046 3735 20	epp7 	pr4|38,*		disk_error_data$
004651  aa  6 00250 6535 00	spri7	pr6|168		dedp
						STATEMENT 1 ON LINE 1178
	     if pvte.is_sv then
		dskerap = addrel (dedp, disk_error_data (majstat).finterp);

004652  aa  6 00314 3715 20	epp5 	pr6|204,*		pvtep
004653  aa  5 00002 2351 00	lda  	pr5|2		pvte.is_sv
004654  aa   040000 3150 03	cana 	16384,du
004655  aa   000011 6000 04	tze  	9,ic		004666
004656  aa  6 00135 2361 00	ldq  	pr6|93		majstat
004657  aa   000001 7360 00	qls  	1
004660  aa  7 00001 2351 06	lda  	pr7|1,ql		disk_error_data.finterp
004661  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
004662  aa  7 00000 3521 01	epp2 	pr7|0,au
004663  aa   000000 0520 03	adwp2	0,du
004664  aa  6 00252 2521 00	spri2	pr6|170		dskerap
004665  aa   000010 7100 04	tra  	8,ic		004675
						STATEMENT 1 ON LINE 1180
	     else dskerap = addrel (dedp, disk_error_data (majstat).interp);

004666  aa  6 00135 2361 00	ldq  	pr6|93		majstat
004667  aa   000001 7360 00	qls  	1
004670  aa  7 00000 2351 06	lda  	pr7|0,ql		disk_error_data.interp
004671  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
004672  aa  7 00000 3521 01	epp2 	pr7|0,au
004673  aa   000000 0520 03	adwp2	0,du
004674  aa  6 00252 2521 00	spri2	pr6|170		dskerap
						STATEMENT 1 ON LINE 1183
	     name_rel = fixed (rel (addrel (dedp, disk_error_data (lbound (disk_error_data, 1)).namep)), 17);

004675  aa   000000 2360 07	ldq  	0,dl
004676  aa  7 00000 2351 06	lda  	pr7|0,ql		disk_error_data.namep
004677  aa   000022 7350 00	als  	18
004700  aa  7 00000 3515 01	epp1 	pr7|0,au
004701  aa   000000 0510 03	adwp1	0,du
004702  aa  1 00000 6351 00	eaa  	pr1|0
004703  aa   000066 7730 00	lrl  	54
004704  aa  6 00144 7561 00	stq  	pr6|100		name_rel
						STATEMENT 1 ON LINE 1184
	     dskerp = addr (disk_status_interp_array (lbound (disk_status_interp_array, 1)));

004705  aa  2 00000 3535 00	epp3 	pr2|0		disk_status_interp_array
004706  aa  6 00254 2535 00	spri3	pr6|172		dskerp
						STATEMENT 1 ON LINE 1185
	     do i = lbound (disk_status_interp_array, 1) by 1 while (bin (rel (dskerp), 18) < name_rel);

004707  aa   000001 2360 07	ldq  	1,dl
004710  aa  6 00127 7561 00	stq  	pr6|87		i
004711  aa   000000 0110 03	nop  	0,du
004712  aa  6 01140 2515 00	spri1	pr6|608
004713  aa  6 00254 6351 20	eaa  	pr6|172,*		dskerp
004714  aa   000066 7730 00	lrl  	54
004715  aa  6 00144 1161 00	cmpq 	pr6|100		name_rel
004716  aa   000022 6050 04	tpl  	18,ic		004740
						STATEMENT 1 ON LINE 1186
		dskerp = addr (disk_status_interp_array (i));

004717  aa  6 00127 2361 00	ldq  	pr6|87		i
004720  aa   000001 7360 00	qls  	1
004721  aa  6 00252 3735 20	epp7 	pr6|170,*		dskerap
004722  aa  7 77776 3735 06	epp7 	pr7|-2,ql		disk_status_interp_array
004723  aa  6 00254 6535 00	spri7	pr6|172		dskerp
						STATEMENT 1 ON LINE 1187
		if (substat & disk_error_interp.bitmask) = disk_error_interp.bitson then
		     return;

004724  aa  7 00000 2351 00	lda  	pr7|0		disk_error_interp.bitson
004725  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004726  aa  6 01137 7551 00	sta  	pr6|607		disk_error_interp.bitson
004727  aa  7 00000 2351 00	lda  	pr7|0		disk_error_interp.bitmask
004730  aa   000006 7350 00	als  	6
004731  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004732  aa  6 00164 3751 00	ana  	pr6|116		substat
004733  aa  6 01137 1151 00	cmpa 	pr6|607		disk_error_interp.bitson
004734  aa   000002 6010 04	tnz  	2,ic		004736
004735  aa  6 00434 6101 00	rtcd 	pr6|284
						STATEMENT 1 ON LINE 1189
	     end;

004736  aa  6 00127 0541 00	aos  	pr6|87		i
004737  aa   777753 7100 04	tra  	-21,ic		004712
						STATEMENT 1 ON LINE 1192
	end interpret_status;

004740  aa  6 00434 6101 00	rtcd 	pr6|284
  END PROCEDURE interpret_status
BEGIN PROCEDURE get_disk_command
ENTRY TO get_disk_command                                   STATEMENT 1 ON LINE 1198
get_disk_command:
	proc;

004741  aa  6 00442 6501 00	spri4	pr6|290
						STATEMENT 1 ON LINE 1201
	     idcwp = addrel (diskp, bin (io_status_entry.next_lpw_offset, 18) - disktab.abs_mem_addr - 1);

004742  aa  6 00302 3735 20	epp7 	pr6|194,*		io_status_entry_ptr
004743  aa  7 00001 2351 00	lda  	pr7|1		io_status_entry.next_lpw_offset
004744  aa   000066 7730 00	lrl  	54
004745  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
004746  aa  5 00010 1761 00	sbq  	pr5|8		disktab.abs_mem_addr
004747  aa   000001 1760 07	sbq  	1,dl
004750  aa  5 00000 3521 06	epp2 	pr5|0,ql
004751  aa   000000 0520 03	adwp2	0,du
004752  aa  6 00310 2521 00	spri2	pr6|200		idcwp
						STATEMENT 1 ON LINE 1203
	     do while (idcw.code ^= IDCW);

004753  aa   000000 0110 03	nop  	0,du
004754  aa  6 00310 2351 20	lda  	pr6|200,*		idcw.code
004755  aa   000022 7350 00	als  	18
004756  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
004757  aa   700000 1150 03	cmpa 	229376,du
004760  aa   000005 6000 04	tze  	5,ic		004765
						STATEMENT 1 ON LINE 1204
		idcwp = addrel (idcwp, -1);

004761  aa  6 00310 3521 20	epp2 	pr6|200,*		idcwp
004762  aa   777777 0520 03	adwp2	262143,du
004763  aa  6 00310 2521 00	spri2	pr6|200		idcwp
						STATEMENT 1 ON LINE 1205
	     end;

004764  aa   777770 7100 04	tra  	-8,ic		004754
						STATEMENT 1 ON LINE 1206
	     command = idcw.command;

004765  aa  6 00310 2351 20	lda  	pr6|200,*		idcw.command
004766  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004767  aa  6 00112 7551 00	sta  	pr6|74		command
						STATEMENT 1 ON LINE 1209
	end get_disk_command;

004770  aa  6 00442 6101 00	rtcd 	pr6|290
  END PROCEDURE get_disk_command
BEGIN PROCEDURE printerr
ENTRY TO printerr                                           STATEMENT 1 ON LINE 1213
printerr:
	proc;

004771  aa  6 00450 6501 00	spri4	pr6|296
						STATEMENT 1 ON LINE 1225
	     if devtab.broken then
		return;

004772  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.broken
004773  aa   000100 3150 03	cana 	64,du
004774  aa   000002 6000 04	tze  	2,ic		004776
004775  aa  6 00450 6101 00	rtcd 	pr6|296
						STATEMENT 1 ON LINE 1228
	     sector = bin (chantab.select_data.sector);

004776  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
004777  aa  7 00010 2361 00	ldq  	pr7|8		chantab.sector
005000  aa  0 00366 3771 00	anaq 	pr0|246		= 000000000000 000007777777
005001  aa  6 00155 7561 00	stq  	pr6|109		sector
						STATEMENT 1 ON LINE 1229
	     type = pvte.device_type;

005002  aa  6 00314 3715 20	epp5 	pr6|204,*		pvtep
005003  aa  5 00004 2351 00	lda  	pr5|4		pvte.device_type
005004  aa   000077 7330 00	lrs  	63
005005  aa  6 00456 7561 00	stq  	pr6|302		type
						STATEMENT 1 ON LINE 1230
	     pvtdip = addr (pvte.dim_info);

005006  aa  5 00010 3535 00	epp3 	pr5|8		pvte.dim_info
005007  aa  6 00274 2535 00	spri3	pr6|188		pvtdip
						STATEMENT 1 ON LINE 1231
	     record_address =
		divide (sector - (divide (sector, sect_per_cyl (type), 17, 0) * pvtdi.unused_sect_per_cyl),
		sect_per_rec (type), 17, 0);

005010  aa  3 00000 2351 00	lda  	pr3|0		pvtdi.unused_sect_per_cyl
005011  aa   000030 7350 00	als  	24
005012  aa   000074 7330 00	lrs  	60
005013  aa  6 01142 7561 00	stq  	pr6|610		pvtdi.unused_sect_per_cyl
005014  aa  6 00155 2361 00	ldq  	pr6|109		sector
005015  aa  6 00456 7271 00	lxl7 	pr6|302		type
005016  ta   000010 5060 17	div  	8,7
005017  aa  6 01142 4021 00	mpy  	pr6|610		pvtdi.unused_sect_per_cyl
005020  aa  6 01142 7561 00	stq  	pr6|610
005021  aa  6 00155 2361 00	ldq  	pr6|109		sector
005022  aa  6 01142 1761 00	sbq  	pr6|610
005023  ta   777777 5060 17	div  	-1,7
005024  aa  6 00457 7561 00	stq  	pr6|303		record_address
						STATEMENT 1 ON LINE 1235
	     if pvte.is_sv then do;

005025  aa  5 00002 2351 00	lda  	pr5|2		pvte.is_sv
005026  aa   000003 7350 00	als  	3
005027  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
005030  aa  6 01142 7551 00	sta  	pr6|610		pvte.is_sv
005031  aa   000040 6000 04	tze  	32,ic		005071
						STATEMENT 1 ON LINE 1236
		record_offset = mod (record_address, pvte.records_per_cyl);

005032  aa  6 00457 2361 00	ldq  	pr6|303		record_address
005033  aa  5 00013 3521 00	epp2 	pr5|11		pvte.records_per_cyl
005034  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005035  aa  6 00104 7561 00	stq  	pr6|68		record_offset
						STATEMENT 1 ON LINE 1237
		logical_rec_addr =
		     divide ((record_address - pvte.record_factor - record_offset), pvte.num_of_svs, 17)
		     + record_offset;

005036  aa  6 00457 2361 00	ldq  	pr6|303		record_address
005037  aa  5 00014 1761 00	sbq  	pr5|12		pvte.record_factor
005040  aa  6 00104 1761 00	sbq  	pr6|68		record_offset
005041  aa  5 00012 5061 00	div  	pr5|10		pvte.num_of_svs
005042  aa  6 00104 0761 00	adq  	pr6|68		record_offset
005043  aa  6 00464 7561 00	stq  	pr6|308		logical_rec_addr
						STATEMENT 1 ON LINE 1240
		sector_offset = mod (sector, sect_per_cyl (type));

005044  aa  6 00155 2361 00	ldq  	pr6|109		sector
005045  ta   000010 3520 17	epp2 	8,7
005046  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005047  aa  6 00466 7561 00	stq  	pr6|310		sector_offset
						STATEMENT 1 ON LINE 1241
		logical_sector =
		     divide ((sector - (pvte.sv_num * sect_per_cyl (type)) - sector_offset), pvte.num_of_svs, 17)
		     + sector_offset;

005050  aa  5 00011 2361 00	ldq  	pr5|9		pvte.sv_num
005051  aa  2 00000 4021 00	mpy  	pr2|0		sect_per_cyl
005052  aa  6 01143 7561 00	stq  	pr6|611
005053  aa  6 00155 3361 00	lcq  	pr6|109		sector
005054  aa   000044 7770 00	llr  	36
005055  aa   000044 7330 00	lrs  	36
005056  aa  6 01143 0331 00	adl  	pr6|611
005057  aa   000000 5330 00	negl 	0
005060  aa   000000 5330 00	negl 	0
005061  aa  6 00466 0331 00	adl  	pr6|310		sector_offset
005062  aa   000000 5330 00	negl 	0
005063  aa  5 00012 3521 00	epp2 	pr5|10		pvte.num_of_svs
005064  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
005065  aa     000000000000
005066  aa  6 00466 0761 00	adq  	pr6|310		sector_offset
005067  aa  6 00465 7561 00	stq  	pr6|309		logical_sector
						STATEMENT 1 ON LINE 1244
	     end;

005070  aa   000005 7100 04	tra  	5,ic		005075
						STATEMENT 1 ON LINE 1245
	     else do;

						STATEMENT 1 ON LINE 1246
		logical_rec_addr = record_address;

005071  aa  6 00457 2361 00	ldq  	pr6|303		record_address
005072  aa  6 00464 7561 00	stq  	pr6|308		logical_rec_addr
						STATEMENT 1 ON LINE 1247
		logical_sector = sector;

005073  aa  6 00155 2361 00	ldq  	pr6|109		sector
005074  aa  6 00465 7561 00	stq  	pr6|309		logical_sector
						STATEMENT 1 ON LINE 1248
	     end;

						STATEMENT 1 ON LINE 1251
	     if pvte.is_sv then
		mjsdp = addrel (dedp, disk_error_data (majstat).fnamep);

005075  aa  6 01142 2351 00	lda  	pr6|610		pvte.is_sv
005076  aa   000012 6000 04	tze  	10,ic		005110
005077  aa  6 00135 2361 00	ldq  	pr6|93		majstat
005100  aa   000001 7360 00	qls  	1
005101  aa  6 00250 3515 20	epp1 	pr6|168,*		dedp
005102  aa  1 00001 2351 06	lda  	pr1|1,ql		disk_error_data.fnamep
005103  aa   000022 7350 00	als  	18
005104  aa  1 00000 3521 01	epp2 	pr1|0,au
005105  aa   000000 0520 03	adwp2	0,du
005106  aa  6 00460 2521 00	spri2	pr6|304		mjsdp
005107  aa   000010 7100 04	tra  	8,ic		005117
						STATEMENT 1 ON LINE 1253
	     else mjsdp = addrel (dedp, disk_error_data (majstat).namep);

005110  aa  6 00135 2361 00	ldq  	pr6|93		majstat
005111  aa   000001 7360 00	qls  	1
005112  aa  6 00250 2351 66	lda  	pr6|168,*ql	disk_error_data.namep
005113  aa   000022 7350 00	als  	18
005114  aa  6 00250 3521 61	epp2 	pr6|168,*au	dedp
005115  aa   000000 0520 03	adwp2	0,du
005116  aa  6 00460 2521 00	spri2	pr6|304		mjsdp
						STATEMENT 1 ON LINE 1254
	     ssdp = addrel (dedp, disk_error_interp.namep);

005117  aa  6 00254 3515 20	epp1 	pr6|172,*		dskerp
005120  aa  1 00001 2351 00	lda  	pr1|1		disk_error_interp.namep
005121  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
005122  aa  6 00250 3521 61	epp2 	pr6|168,*au	dedp
005123  aa   000000 0520 03	adwp2	0,du
005124  aa  6 00462 2521 00	spri2	pr6|306		ssdp
						STATEMENT 1 ON LINE 1256
	     unspec (msg_buf) = "0"b;

005125  aa  000 100 100 400	mlr  	(),(pr),fill(000)
005126  aa   000000 00 0000	desc9a	0,0
005127  aa  6 00174 00 0054	desc9a	pr6|124,44
						STATEMENT 1 ON LINE 1257
	     io_msgp = addr (msg_buf);

005130  aa  6 00174 3735 00	epp7 	pr6|124		msg_buf
005131  aa  6 00306 6535 00	spri7	pr6|198		io_msgp
						STATEMENT 1 ON LINE 1258
	     io_msg.level = bit (level, 3);

005132  aa  6 00134 2351 00	lda  	pr6|92		level
005133  aa   000002 6050 04	tpl  	2,ic		005135
005134  aa   000000 5310 00	neg  	0
005135  aa   000041 7350 00	als  	33
005136  aa  7 00000 6751 00	era  	pr7|0		io_msg.level
005137  aa  0 00006 3751 00	ana  	pr0|6		= 700000000000
005140  aa  7 00000 6551 00	ersa 	pr7|0		io_msg.level
						STATEMENT 1 ON LINE 1259
	     io_msg.channel = chantab.chanid;

005141  aa  6 00270 3535 20	epp3 	pr6|184,*		cp
005142  aa  3 00004 2351 00	lda  	pr3|4		chantab.chanid
005143  aa  3 00005 2361 00	ldq  	pr3|5		chantab.chanid
005144  aa  7 00001 7551 00	sta  	pr7|1		io_msg.channel
005145  aa  7 00002 7561 00	stq  	pr7|2		io_msg.channel
						STATEMENT 1 ON LINE 1260
	     io_msg.device = bit (dev);

005146  aa  6 00120 2351 00	lda  	pr6|80		dev
005147  aa   000036 7350 00	als  	30
005150  aa   000014 7710 00	arl  	12
005151  aa  7 00000 7511 10	stca 	pr7|0,10		io_msg.device
						STATEMENT 1 ON LINE 1261
	     io_msg.type = chantab.action_code;

005152  aa  3 00006 2351 00	lda  	pr3|6		chantab.action_code
005153  aa   000005 7350 00	als  	5
005154  aa  7 00000 6751 00	era  	pr7|0		io_msg.type
005155  aa   300000 3750 07	ana  	98304,dl
005156  aa  7 00000 6551 00	ersa 	pr7|0		io_msg.type
						STATEMENT 1 ON LINE 1262
	     io_msg.command = command;

005157  aa  6 00112 2351 00	lda  	pr6|74		command
005160  aa   000025 7710 00	arl  	21
005161  aa  7 00000 6751 00	era  	pr7|0		io_msg.command
005162  aa   077000 3750 07	ana  	32256,dl
005163  aa  7 00000 6551 00	ersa 	pr7|0		io_msg.command
						STATEMENT 1 ON LINE 1263
	     io_msg.status = string (io_status_word);

005164  aa  6 00304 2351 20	lda  	pr6|196,*
005165  aa  7 00003 7551 00	sta  	pr7|3		io_msg.status
						STATEMENT 1 ON LINE 1264
	     io_msg.devname = disk_data.name (sx);

005166  aa  6 00162 2361 00	ldq  	pr6|114		sx
005167  aa   000001 7360 00	qls  	1
005170  aa  6 00256 3715 20	epp5 	pr6|174,*		disksp
005171  aa  5 00010 2351 06	lda  	pr5|8,ql		disk_data.name
005172  aa  7 00004 7551 00	sta  	pr7|4		io_msg.devname
						STATEMENT 1 ON LINE 1266
	     if /* case */ devtab.broken | disk_error_interp.just_log then
		sysc = JUST_LOG;

005173  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.broken
005174  aa   000100 3150 03	cana 	64,du
005175  aa   000004 6010 04	tnz  	4,ic		005201
005176  aa  1 00000 2351 00	lda  	pr1|0		disk_error_interp.just_log
005177  aa   004000 3150 07	cana 	2048,dl
005200  aa   000004 6000 04	tze  	4,ic		005204
005201  aa   000005 2360 07	ldq  	5,dl
005202  aa  6 00163 7561 00	stq  	pr6|115		sysc
005203  aa   000015 7100 04	tra  	13,ic		005220
						STATEMENT 1 ON LINE 1268
	     else if mod (chantab.erct, 5) = 1 then
		sysc = ANNOUNCE;

005204  aa  3 00007 2351 00	lda  	pr3|7		chantab.erct
005205  aa   000033 7350 00	als  	27
005206  aa   000077 7330 00	lrs  	63
005207  aa   773141 3520 04	epp2 	-2463,ic		000350 = 000000000005
005210  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005211  aa   000001 1160 07	cmpq 	1,dl
005212  aa   000004 6010 04	tnz  	4,ic		005216
005213  aa   000000 2360 07	ldq  	0,dl
005214  aa  6 00163 7561 00	stq  	pr6|115		sysc
005215  aa   000003 7100 04	tra  	3,ic		005220
						STATEMENT 1 ON LINE 1270
	     else sysc = JUST_LOG;

005216  aa   000005 2360 07	ldq  	5,dl
005217  aa  6 00163 7561 00	stq  	pr6|115		sysc
						STATEMENT 1 ON LINE 1271
	     call syserr$binary (sysc, io_msgp, SB_disk_err, SBL_disk_err,
		"^a: ^a ^[^12.3b^1s^;^1s^a^] for ^a (channel ^a).^/^2-rec ^o, sect ^o, main ^o^[^/^2-subvol ^a, logical rec ^o, logical sect ^o^;^3s^]^[^/^2-detailed status:^24( ^2.4b^).^;^s^]",
		ME, mjsdp -> disk_status_descrip.chr, (level = 1), stat, ssdp -> disk_status_descrip.chr,
		disk_name (SINGLE), chantab.chanid, record_address, sector, coreadd, pvte.is_sv, pvte.sv_name,
		logical_rec_addr, logical_sector, (io_status_entry.detailed_status (1) ^= ""b),
		addr (io_status_entry.detailed_status) -> imu_detailed_status);

005220  aa  6 00460 2351 20	lda  	pr6|304,*		disk_status_descrip.lth
005221  aa   000077 7330 00	lrs  	63
005222  aa  6 01143 7561 00	stq  	pr6|611
005223  aa   526000 2760 03	orq  	175104,du
005224  aa  6 01142 7561 00	stq  	pr6|610
005225  aa  6 00462 2351 20	lda  	pr6|306,*		disk_status_descrip.lth
005226  aa   000077 7330 00	lrs  	63
005227  aa  6 01145 7561 00	stq  	pr6|613
005230  aa   526000 2760 03	orq  	175104,du
005231  aa  6 01144 7561 00	stq  	pr6|612
005232  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005233  aa   773322 00 0260	desc9a	-2350,176		000554 = 136141072040
005234  aa  6 01146 00 0260	desc9a	pr6|614,176
005235  aa  6 00134 2361 00	ldq  	pr6|92		level
005236  aa   000001 1160 07	cmpq 	1,dl
005237  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
005240  aa  6 01222 7551 00	sta  	pr6|658
005241  aa   003061 3520 04	epp2 	1585,ic		010322 = 000004000000
005242  aa   001752 6700 04	tsp4 	1002,ic		007214
005243  aa  6 00302 3735 20	epp7 	pr6|194,*		io_status_entry_ptr
005244  aa  7 00010 2351 00	lda  	pr7|8		io_status_entry.detailed_status
005245  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
005246  aa  6 01223 7551 00	sta  	pr6|659
005247  aa  6 00163 3521 00	epp2 	pr6|115		sysc
005250  aa  6 01234 2521 00	spri2	pr6|668
005251  aa  6 00306 3521 00	epp2 	pr6|198		io_msgp
005252  aa  6 01236 2521 00	spri2	pr6|670
005253  aa   773104 3520 04	epp2 	-2492,ic		000357 = 000000000001
005254  aa  6 01240 2521 00	spri2	pr6|672
005255  aa   773073 3520 04	epp2 	-2501,ic		000350 = 000000000005
005256  aa  6 01242 2521 00	spri2	pr6|674
005257  aa  6 01146 3521 00	epp2 	pr6|614
005260  aa  6 01244 2521 00	spri2	pr6|676
005261  aa   773015 3520 04	epp2 	-2547,ic		000276 = 144151163153
005262  aa  6 01246 2521 00	spri2	pr6|678
005263  aa   000001 7270 07	lxl7 	1,dl
005264  aa  6 00460 3521 20	epp2 	pr6|304,*		disk_status_descrip.chr
005265  aa  2 00000 5005 17	a9bd 	pr2|0,7
005266  aa  6 01250 2521 00	spri2	pr6|680
005267  aa  6 01222 3521 00	epp2 	pr6|658
005270  aa  6 01252 2521 00	spri2	pr6|682
005271  aa  6 00157 3521 00	epp2 	pr6|111		stat
005272  aa  6 01254 2521 00	spri2	pr6|684
005273  aa  6 00462 3521 20	epp2 	pr6|306,*		disk_status_descrip.chr
005274  aa  2 00000 5005 17	a9bd 	pr2|0,7
005275  aa  6 01256 2521 00	spri2	pr6|686
005276  aa  6 01224 3521 00	epp2 	pr6|660
005277  aa  6 01260 2521 00	spri2	pr6|688
005300  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
005301  aa  5 00004 3521 00	epp2 	pr5|4		chantab.chanid
005302  aa  6 01262 2521 00	spri2	pr6|690
005303  aa  6 00457 3521 00	epp2 	pr6|303		record_address
005304  aa  6 01264 2521 00	spri2	pr6|692
005305  aa  6 00155 3521 00	epp2 	pr6|109		sector
005306  aa  6 01266 2521 00	spri2	pr6|694
005307  aa  6 00101 3521 00	epp2 	pr6|65		coreadd
005310  aa  6 01270 2521 00	spri2	pr6|696
005311  aa   000003 7260 07	lxl6 	3,dl
005312  aa  6 00314 3535 20	epp3 	pr6|204,*		pvtep
005313  aa  3 00002 3521 00	epp2 	pr3|2		pvte.is_sv
005314  aa  2 00000 5035 16	abd  	pr2|0,6
005315  aa  6 01272 2521 00	spri2	pr6|698
005316  aa  3 00015 3521 00	epp2 	pr3|13		pvte.sv_name
005317  aa  6 01274 2521 00	spri2	pr6|700
005320  aa  6 00464 3521 00	epp2 	pr6|308		logical_rec_addr
005321  aa  6 01276 2521 00	spri2	pr6|702
005322  aa  6 00465 3521 00	epp2 	pr6|309		logical_sector
005323  aa  6 01300 2521 00	spri2	pr6|704
005324  aa  6 01223 3521 00	epp2 	pr6|659
005325  aa  6 01302 2521 00	spri2	pr6|706
005326  aa  7 00010 3521 00	epp2 	pr7|8		imu_detailed_status
005327  aa  6 01304 2521 00	spri2	pr6|708
005330  aa   773026 3520 04	epp2 	-2538,ic		000356 = 404000000021
005331  aa  6 01306 2521 00	spri2	pr6|710
005332  aa  6 01312 2521 00	spri2	pr6|714
005333  aa  6 01314 2521 00	spri2	pr6|716
005334  aa  6 01350 2521 00	spri2	pr6|744
005335  aa   773007 3520 04	epp2 	-2553,ic		000344 = 464000000000
005336  aa  6 01310 2521 00	spri2	pr6|712
005337  aa   772764 3520 04	epp2 	-2572,ic		000323 = 524000000257
005340  aa  6 01316 2521 00	spri2	pr6|718
005341  aa   772771 3520 04	epp2 	-2567,ic		000332 = 526000000020
005342  aa  6 01320 2521 00	spri2	pr6|720
005343  aa  6 01142 3521 00	epp2 	pr6|610
005344  aa  6 01322 2521 00	spri2	pr6|722
005345  aa   773000 3520 04	epp2 	-2560,ic		000345 = 514000000001
005346  aa  6 01324 2521 00	spri2	pr6|724
005347  aa  6 01354 2521 00	spri2	pr6|748
005350  aa   772773 3520 04	epp2 	-2565,ic		000343 = 514000000044
005351  aa  6 01326 2521 00	spri2	pr6|726
005352  aa  6 01144 3521 00	epp2 	pr6|612
005353  aa  6 01330 2521 00	spri2	pr6|728
005354  aa   772763 3520 04	epp2 	-2573,ic		000337 = 524000000025
005355  aa  6 01332 2521 00	spri2	pr6|730
005356  aa   772753 3520 04	epp2 	-2581,ic		000331 = 524000000010
005357  aa  6 01334 2521 00	spri2	pr6|732
005360  aa   772741 3520 04	epp2 	-2591,ic		000321 = 404000000022
005361  aa  6 01336 2521 00	spri2	pr6|734
005362  aa   772736 3520 04	epp2 	-2594,ic		000320 = 404000000025
005363  aa  6 01340 2521 00	spri2	pr6|736
005364  aa  6 01352 2521 00	spri2	pr6|746
005365  aa   772770 3520 04	epp2 	-2568,ic		000355 = 404000000030
005366  aa  6 01342 2521 00	spri2	pr6|738
005367  aa   772730 3520 04	epp2 	-2600,ic		000317 = 516000000001
005370  aa  6 01344 2521 00	spri2	pr6|740
005371  aa   772725 3520 04	epp2 	-2603,ic		000316 = 524000000002
005372  aa  6 01346 2521 00	spri2	pr6|742
005373  aa   772775 3520 04	epp2 	-2563,ic		000370 = 516100000010
005374  aa  6 01356 2521 00	spri2	pr6|750
005375  aa  6 01232 6211 00	eax1 	pr6|666
005376  aa   124000 4310 07	fld  	43008,dl
005377  aa  6 00044 3701 20	epp4 	pr6|36,*
005400  la  4 00026 3521 20	epp2 	pr4|22,*		syserr$binary
005401  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1278
	     return;

005402  aa  6 00450 6101 00	rtcd 	pr6|296
						STATEMENT 1 ON LINE 1281
	end printerr;

  END PROCEDURE printerr
BEGIN PROCEDURE handle_error
ENTRY TO handle_error                                       STATEMENT 1 ON LINE 1285
handle_error:
	proc;

005403  aa  6 00470 6501 00	spri4	pr6|312
						STATEMENT 1 ON LINE 1289
	     chantab.erct = chantab.erct + 1;

005404  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
005405  aa  7 00007 2351 00	lda  	pr7|7		chantab.erct
005406  aa   000033 7350 00	als  	27
005407  aa   000077 7330 00	lrs  	63
005410  aa   000001 0760 07	adq  	1,dl
005411  aa  7 00007 5521 04	stbq 	pr7|7,04		chantab.erct
						STATEMENT 1 ON LINE 1290
	     disktab.errors = disktab.errors + 1;

005412  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
005413  aa  5 00012 0541 00	aos  	pr5|10		disktab.errors
						STATEMENT 1 ON LINE 1292
	     call interpret_status;

005414  aa   777232 6700 04	tsp4 	-358,ic		004646
						STATEMENT 1 ON LINE 1293
	     if io_type = TEST then
		idcwp = addr (chantab.rssdcw);

005415  aa  6 00131 2361 00	ldq  	pr6|89		io_type
005416  aa   000004 1160 07	cmpq 	4,dl
005417  aa   000005 6010 04	tnz  	5,ic		005424
005420  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
005421  aa  7 00032 3735 00	epp7 	pr7|26		chantab.rssdcw
005422  aa  6 00310 6535 00	spri7	pr6|200		idcwp
005423  aa   000004 7100 04	tra  	4,ic		005427
						STATEMENT 1 ON LINE 1295
	     else idcwp = addr (chantab.scdcw);

005424  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
005425  aa  7 00024 3735 00	epp7 	pr7|20		chantab.scdcw
005426  aa  6 00310 6535 00	spri7	pr6|200		idcwp
						STATEMENT 1 ON LINE 1297
	     if ^(io_type = TEST & ^disk_error_interp.bad_path) then
		call printerr;

005427  aa   000004 6010 04	tnz  	4,ic		005433
005430  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.bad_path
005431  aa   020000 3150 07	cana 	8192,dl
005432  aa   000002 6000 04	tze  	2,ic		005434
005433  aa   777336 6700 04	tsp4 	-290,ic		004771
						STATEMENT 1 ON LINE 1300
	     if /* case */ chantab.erct <= disk_error_interp.max_retries & io_type ^= TEST then do;

005434  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.max_retries
005435  aa   000014 7350 00	als  	12
005436  aa   000102 7330 00	lrs  	66
005437  aa  6 01360 7561 00	stq  	pr6|752		disk_error_interp.max_retries
005440  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
005441  aa  7 00007 2351 00	lda  	pr7|7		chantab.erct
005442  aa   000033 7350 00	als  	27
005443  aa   000077 7330 00	lrs  	63
005444  aa  6 01360 1161 00	cmpq 	pr6|752		disk_error_interp.max_retries
005445  aa   000037 6054 04	tpnz 	31,ic		005504
005446  aa  6 00131 2361 00	ldq  	pr6|89		io_type
005447  aa   000004 1160 07	cmpq 	4,dl
005450  aa   000034 6000 04	tze  	28,ic		005504
						STATEMENT 1 ON LINE 1301
		if disk_error_interp.reseek then do;

005451  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.reseek
005452  aa   400000 3150 07	cana 	131072,dl
005453  aa   000012 6000 04	tze  	10,ic		005465
						STATEMENT 1 ON LINE 1302
		     idcwp = addr (chantab.rstdcw);

005454  aa  7 00023 3715 00	epp5 	pr7|19		chantab.rstdcw
005455  aa  6 00310 6515 00	spri5	pr6|200		idcwp
						STATEMENT 1 ON LINE 1303
		     idcw.device = bit (dev);

005456  aa  6 00120 2351 00	lda  	pr6|80		dev
005457  aa   000036 7350 00	als  	30
005460  aa   000006 7710 00	arl  	6
005461  aa  5 00000 7511 20	stca 	pr5|0,20		idcw.device
						STATEMENT 1 ON LINE 1304
		     call connect (idcwp);

005462  aa   002674 3520 04	epp2 	1468,ic		010356 = 000002000000
005463  aa   001402 6700 04	tsp4 	770,ic		007065
						STATEMENT 1 ON LINE 1305
		end;

005464  aa   000471 7100 04	tra  	313,ic		006155
						STATEMENT 1 ON LINE 1306
		else do;

						STATEMENT 1 ON LINE 1307
		     if disk_error_interp.bad_path then do;

005465  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.bad_path
005466  aa   020000 3150 07	cana 	8192,dl
005467  aa   000012 6000 04	tze  	10,ic		005501
						STATEMENT 1 ON LINE 1309
			temp_time = clock ();

005470  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
005471  aa  6 00166 7571 00	staq 	pr6|118		temp_time
						STATEMENT 1 ON LINE 1310
			do while (clock () < temp_time + 750000);

005472  aa  6 00166 2371 00	ldaq 	pr6|118		temp_time
005473  aa   772622 0330 04	adl  	-2670,ic		000315 = 000002670660
005474  aa  6 01362 7571 00	staq 	pr6|754
005475  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
005476  aa  6 01362 1171 00	cmpaq	pr6|754
005477  aa   000002 6050 04	tpl  	2,ic		005501
						STATEMENT 1 ON LINE 1312
			end;

005500  aa   777772 7100 04	tra  	-6,ic		005472
						STATEMENT 1 ON LINE 1313
		     end;

						STATEMENT 1 ON LINE 1314
		     call connect (idcwp);

005501  aa   002655 3520 04	epp2 	1453,ic		010356 = 000002000000
005502  aa   001363 6700 04	tsp4 	755,ic		007065
						STATEMENT 1 ON LINE 1315
		end;

						STATEMENT 1 ON LINE 1316
	     end;

005503  aa   000452 7100 04	tra  	298,ic		006155
						STATEMENT 1 ON LINE 1318
	     else if disk_error_interp.bad_dev then do;

005504  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.bad_dev
005505  aa   040000 3150 07	cana 	16384,dl
005506  aa   000134 6000 04	tze  	92,ic		005642
						STATEMENT 1 ON LINE 1319
		if /* case */ devtab.inop | devtab.broken | io_type = TEST then do;

005507  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.broken
005510  aa   000013 7350 00	als  	11
005511  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
005512  aa  6 01361 7551 00	sta  	pr6|753		devtab.broken
005513  aa   000007 6010 04	tnz  	7,ic		005522
005514  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.inop
005515  aa   000400 3150 03	cana 	256,du
005516  aa   000004 6010 04	tnz  	4,ic		005522
005517  aa  6 00131 2361 00	ldq  	pr6|89		io_type
005520  aa   000004 1160 07	cmpq 	4,dl
005521  aa   000063 6010 04	tnz  	51,ic		005604
						STATEMENT 1 ON LINE 1321
		     if ^devtab.broken then		/* If not already broken ... */
			if quentry.type ^= TEST then
			     call syserr (BEEP, "^a: ^a requires intervention.", ME, disk_name (SINGLE));

005522  aa  6 01361 2351 00	lda  	pr6|753		devtab.broken
005523  aa   000041 6010 04	tnz  	33,ic		005564
005524  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
005525  aa  5 00001 2351 00	lda  	pr5|1		quentry.type
005526  aa   000002 7350 00	als  	2
005527  aa   000104 7730 00	lrl  	68
005530  aa   000004 1160 07	cmpq 	4,dl
005531  aa   000033 6000 04	tze  	27,ic		005564
005532  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005533  aa   772750 00 0040	desc9a	-2584,32		000502 = 136141072040
005534  aa  6 01364 00 0040	desc9a	pr6|756,32
005535  aa   002557 3520 04	epp2 	1391,ic		010314 = 000004000000
005536  aa   001456 6700 04	tsp4 	814,ic		007214
005537  aa   772614 3520 04	epp2 	-2676,ic		000353 = 000000000003
005540  aa  6 01404 2521 00	spri2	pr6|772
005541  aa  6 01364 3521 00	epp2 	pr6|756
005542  aa  6 01406 2521 00	spri2	pr6|774
005543  aa   772533 3520 04	epp2 	-2725,ic		000276 = 144151163153
005544  aa  6 01410 2521 00	spri2	pr6|776
005545  aa  6 01374 3521 00	epp2 	pr6|764
005546  aa  6 01412 2521 00	spri2	pr6|778
005547  aa   772607 3520 04	epp2 	-2681,ic		000356 = 404000000021
005550  aa  6 01414 2521 00	spri2	pr6|780
005551  aa   772543 3520 04	epp2 	-2717,ic		000314 = 524000000035
005552  aa  6 01416 2521 00	spri2	pr6|782
005553  aa   772557 3520 04	epp2 	-2705,ic		000332 = 526000000020
005554  aa  6 01420 2521 00	spri2	pr6|784
005555  aa   772562 3520 04	epp2 	-2702,ic		000337 = 524000000025
005556  aa  6 01422 2521 00	spri2	pr6|786
005557  aa  6 01402 6211 00	eax1 	pr6|770
005560  aa   020000 4310 07	fld  	8192,dl
005561  aa  6 00044 3701 20	epp4 	pr6|36,*
005562  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
005563  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1324
		     devtab.broken = "1"b;

005564  aa   000100 2350 03	lda  	64,du
005565  aa  6 00272 2551 20	orsa 	pr6|186,*		devtab.broken
						STATEMENT 1 ON LINE 1325
		     call set_pvte_inop (ON);

005566  aa   002522 3520 04	epp2 	1362,ic		010310 = 000002000000
005567  aa   002407 6700 04	tsp4 	1287,ic		010176
						STATEMENT 1 ON LINE 1326
		     devtab.was_broken = "0"b;

005570  aa   002612 2350 04	lda  	1418,ic		010402 = 777577777777
005571  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.was_broken
						STATEMENT 1 ON LINE 1327
		     devtab.inop = "0"b;

005572  aa   002607 2350 04	lda  	1415,ic		010401 = 777377777777
005573  aa  6 00272 3551 20	ansa 	pr6|186,*		devtab.inop
						STATEMENT 1 ON LINE 1328
		     devtab.time_inop = clock ();

005574  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
005575  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
005576  aa  7 00004 7571 00	staq 	pr7|4		devtab.time_inop
						STATEMENT 1 ON LINE 1330
		     errflags.device_inoperative = "1"b;

005577  aa   000020 2350 07	lda  	16,dl
005600  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.device_inoperative
						STATEMENT 1 ON LINE 1331
		     post_sw = "1"b;

005601  aa   400000 2350 03	lda  	131072,du
005602  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1332
		end;

005603  aa   000352 7100 04	tra  	234,ic		006155
						STATEMENT 1 ON LINE 1334
		else if tc_data$system_shutdown = 0 then do;

005604  aa  6 00044 3701 20	epp4 	pr6|36,*
005605  la  4 00020 2361 20	ldq  	pr4|16,*		tc_data$system_shutdown
005606  aa   000017 6010 04	tnz  	15,ic		005625
						STATEMENT 1 ON LINE 1336
		     devtab.inop = "1"b;

005607  aa   000400 2350 03	lda  	256,du
005610  aa  6 00272 2551 20	orsa 	pr6|186,*		devtab.inop
						STATEMENT 1 ON LINE 1337
		     disktab.dev_busy = disktab.dev_busy | dev_mask (pdi);

005611  aa  6 00145 2361 00	ldq  	pr6|101		pdi
005612  aa   000001 7360 00	qls  	1
005613  ta   000076 2350 06	lda  	62,ql
005614  ta   000077 2360 06	ldq  	63,ql
005615  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
005616  aa  5 00004 2551 00	orsa 	pr5|4		disktab.dev_busy
005617  aa  5 00005 2561 00	orsq 	pr5|5		disktab.dev_busy
						STATEMENT 1 ON LINE 1339
		     devtab.time_inop = clock ();

005620  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
005621  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
005622  aa  7 00004 7571 00	staq 	pr7|4		devtab.time_inop
						STATEMENT 1 ON LINE 1340
		     call add_wq;

005623  aa   002031 6700 04	tsp4 	1049,ic		007654
						STATEMENT 1 ON LINE 1341
		end;

005624  aa   000331 7100 04	tra  	217,ic		006155
						STATEMENT 1 ON LINE 1343
		else do;

						STATEMENT 1 ON LINE 1344
		     if quentry.type = TEST then
			call set_pvte_inop (ON);

005625  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
005626  aa  5 00001 2351 00	lda  	pr5|1		quentry.type
005627  aa   000002 7350 00	als  	2
005630  aa   000104 7730 00	lrl  	68
005631  aa   000004 1160 07	cmpq 	4,dl
005632  aa   000003 6010 04	tnz  	3,ic		005635
005633  aa   002455 3520 04	epp2 	1325,ic		010310 = 000002000000
005634  aa   002342 6700 04	tsp4 	1250,ic		010176
						STATEMENT 1 ON LINE 1346
		     errflags.device_inoperative = "1"b;

005635  aa   000020 2350 07	lda  	16,dl
005636  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.device_inoperative
						STATEMENT 1 ON LINE 1347
		     post_sw = "1"b;

005637  aa   400000 2350 03	lda  	131072,du
005640  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1348
		end;

						STATEMENT 1 ON LINE 1349
	     end;

005641  aa   000314 7100 04	tra  	204,ic		006155
						STATEMENT 1 ON LINE 1350
	     else if disk_error_interp.bad_addr then do;

005642  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.bad_addr
005643  aa   100000 3150 07	cana 	32768,dl
005644  aa   000022 6000 04	tze  	18,ic		005666
						STATEMENT 1 ON LINE 1351
		if write_map (quentry.type) then	/* If writing ... */
		     errflags.reassign_address = "1"b;

005645  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
005646  aa  5 00001 2351 00	lda  	pr5|1		quentry.type
005647  aa   000002 7350 00	als  	2
005650  aa   000104 7730 00	lrl  	68
005651  aa  6 01361 7561 00	stq  	pr6|753
005652  aa  000 000 066 406	cmpb 	(ql),(),fill(0)
005653  ta   000024 00 0001	descb	20,1
005654  aa   000000 00 0000	descb	0,0
005655  aa   000004 6000 04	tze  	4,ic		005661
005656  aa   000010 2350 07	lda  	8,dl
005657  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.reassign_address
005660  aa   000003 7100 04	tra  	3,ic		005663
						STATEMENT 1 ON LINE 1353
		else				/* If reading ... */
		     errflags.seg_unusable = "1"b;

005661  aa   000004 2350 07	lda  	4,dl
005662  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.seg_unusable
						STATEMENT 1 ON LINE 1355
		post_sw = "1"b;

005663  aa   400000 2350 03	lda  	131072,du
005664  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1356
	     end;

005665  aa   000270 7100 04	tra  	184,ic		006155
						STATEMENT 1 ON LINE 1358
	     else if disk_error_interp.bad_path then do;

005666  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.bad_path
005667  aa   020000 3150 07	cana 	8192,dl
005670  aa   000247 6000 04	tze  	167,ic		006137
						STATEMENT 1 ON LINE 1359
		if chantab.inop then do;

005671  aa  7 00006 2351 00	lda  	pr7|6		chantab.inop
005672  aa   020000 3150 07	cana 	8192,dl
005673  aa   000006 6000 04	tze  	6,ic		005701
						STATEMENT 1 ON LINE 1360
		     chantab.broken = "1"b;

005674  aa   010000 2350 07	lda  	4096,dl
005675  aa  7 00006 2551 00	orsa 	pr7|6		chantab.broken
						STATEMENT 1 ON LINE 1361
		     chantab.inop = "0"b;

005676  aa   002501 2350 04	lda  	1345,ic		010377 = 777777757777
005677  aa  7 00006 3551 00	ansa 	pr7|6		chantab.inop
						STATEMENT 1 ON LINE 1362
		end;

005700  aa   000006 7100 04	tra  	6,ic		005706
						STATEMENT 1 ON LINE 1363
		else do;

						STATEMENT 1 ON LINE 1364
		     chantab.inop = "1"b;

005701  aa   020000 2350 07	lda  	8192,dl
005702  aa  7 00006 2551 00	orsa 	pr7|6		chantab.inop
						STATEMENT 1 ON LINE 1365
		     chantab.connect_time = clock ();

005703  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
005704  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
005705  aa  7 00014 7571 00	staq 	pr7|12		chantab.connect_time
						STATEMENT 1 ON LINE 1366
		end;

						STATEMENT 1 ON LINE 1368
		if disktab.channels_online > 1 then do;

005706  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
005707  aa  5 00003 2361 00	ldq  	pr5|3		disktab.channels_online
005710  aa   000001 1160 07	cmpq 	1,dl
005711  aa   000040 6044 04	tmoz 	32,ic		005751
						STATEMENT 1 ON LINE 1369
		     call syserr (BEEP, "^a: Removing channel ^a.", ME, chantab.chanid);

005712  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005713  aa   772513 00 0030	desc9a	-2741,24		000425 = 136141072040
005714  aa  6 01374 00 0030	desc9a	pr6|764,24
005715  aa   772436 3520 04	epp2 	-2786,ic		000353 = 000000000003
005716  aa  6 01404 2521 00	spri2	pr6|772
005717  aa  6 01374 3521 00	epp2 	pr6|764
005720  aa  6 01406 2521 00	spri2	pr6|774
005721  aa   772355 3520 04	epp2 	-2835,ic		000276 = 144151163153
005722  aa  6 01410 2521 00	spri2	pr6|776
005723  aa  7 00004 3521 00	epp2 	pr7|4		chantab.chanid
005724  aa  6 01412 2521 00	spri2	pr6|778
005725  aa   772431 3520 04	epp2 	-2791,ic		000356 = 404000000021
005726  aa  6 01414 2521 00	spri2	pr6|780
005727  aa   772364 3520 04	epp2 	-2828,ic		000313 = 524000000030
005730  aa  6 01416 2521 00	spri2	pr6|782
005731  aa   772401 3520 04	epp2 	-2815,ic		000332 = 526000000020
005732  aa  6 01420 2521 00	spri2	pr6|784
005733  aa   772376 3520 04	epp2 	-2818,ic		000331 = 524000000010
005734  aa  6 01422 2521 00	spri2	pr6|786
005735  aa  6 01402 6211 00	eax1 	pr6|770
005736  aa   020000 4310 07	fld  	8192,dl
005737  aa  6 00044 3701 20	epp4 	pr6|36,*
005740  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
005741  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1370
		     chantab.in_use = "0"b;

005742  aa   002433 2350 04	lda  	1307,ic		010375 = 777777377777
005743  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
005744  aa  7 00006 3551 00	ansa 	pr7|6		chantab.in_use
						STATEMENT 1 ON LINE 1371
		     disktab.channels_online = disktab.channels_online - 1;

005745  aa   000001 3360 07	lcq  	1,dl
005746  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
005747  aa  5 00003 0561 00	asq  	pr5|3		disktab.channels_online
						STATEMENT 1 ON LINE 1372
		end;

005750  aa   000130 7100 04	tra  	88,ic		006100
						STATEMENT 1 ON LINE 1373
		else do;

						STATEMENT 1 ON LINE 1374
		     if bootload_sw then do;

005751  aa  6 00105 2351 00	lda  	pr6|69		bootload_sw
005752  aa   000006 6000 04	tze  	6,ic		005760
						STATEMENT 1 ON LINE 1375
			errflags.all_paths_bad = "1"b;

005753  aa   000100 2350 07	lda  	64,dl
005754  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.all_paths_bad
						STATEMENT 1 ON LINE 1376
			post_sw = "1"b;

005755  aa   400000 2350 03	lda  	131072,du
005756  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1377
		     end;

005757  aa   000043 7100 04	tra  	35,ic		006022
						STATEMENT 1 ON LINE 1378
		     else if io_type = TEST then do;

005760  aa  6 00131 2361 00	ldq  	pr6|89		io_type
005761  aa   000004 1160 07	cmpq 	4,dl
005762  aa   000016 6010 04	tnz  	14,ic		006000
						STATEMENT 1 ON LINE 1379
			call set_pvte_inop (ON);

005763  aa   002325 3520 04	epp2 	1237,ic		010310 = 000002000000
005764  aa   002212 6700 04	tsp4 	1162,ic		010176
						STATEMENT 1 ON LINE 1380
                              if (tc_data$system_shutdown ^= 0) then do;

005765  aa  6 00044 3701 20	epp4 	pr6|36,*
005766  la  4 00020 2361 20	ldq  	pr4|16,*		tc_data$system_shutdown
005767  aa   000033 6000 04	tze  	27,ic		006022
						STATEMENT 1 ON LINE 1381
                                  post_sw = "1"b;

005770  aa   400000 2350 03	lda  	131072,du
005771  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1382
                                  errflags.device_inoperative = "1"b;

005772  aa   000020 2350 07	lda  	16,dl
005773  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.device_inoperative
						STATEMENT 1 ON LINE 1383
                                  errflags.all_paths_bad = "1"b;

005774  aa   000100 2350 07	lda  	64,dl
005775  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.all_paths_bad
						STATEMENT 1 ON LINE 1384
                                  return;

005776  aa  6 00470 6101 00	rtcd 	pr6|312
						STATEMENT 1 ON LINE 1385
                              end;

						STATEMENT 1 ON LINE 1387
		     end;

005777  aa   000023 7100 04	tra  	19,ic		006022
						STATEMENT 1 ON LINE 1388
		     else if tc_data$system_shutdown ^= 0 then do;

006000  aa  6 00044 3701 20	epp4 	pr6|36,*
006001  la  4 00020 2361 20	ldq  	pr4|16,*		tc_data$system_shutdown
006002  aa   000010 6000 04	tze  	8,ic		006012
						STATEMENT 1 ON LINE 1389
			errflags.device_inoperative = "1"b;

006003  aa   000020 2350 07	lda  	16,dl
006004  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.device_inoperative
						STATEMENT 1 ON LINE 1391
			errflags.all_paths_bad = "1"b;

006005  aa   000100 2350 07	lda  	64,dl
006006  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.all_paths_bad
						STATEMENT 1 ON LINE 1392
			post_sw = "1"b;

006007  aa   400000 2350 03	lda  	131072,du
006010  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1393
		     end;

006011  aa   000011 7100 04	tra  	9,ic		006022
						STATEMENT 1 ON LINE 1394
		     else do;

						STATEMENT 1 ON LINE 1395
			chantab.erct = 0;

006012  aa   000000 2350 03	lda  	0,du
006013  aa  7 00007 5511 04	stba 	pr7|7,04		chantab.erct
						STATEMENT 1 ON LINE 1396
			chantab.inop = "0"b;

006014  aa   002363 2350 04	lda  	1267,ic		010377 = 777777757777
006015  aa  7 00006 3551 00	ansa 	pr7|6		chantab.inop
						STATEMENT 1 ON LINE 1397
			call connect (addr (chantab.scdcw));

006016  aa  7 00024 3535 00	epp3 	pr7|20		chantab.scdcw
006017  aa  6 01362 2535 00	spri3	pr6|754
006020  aa   002264 3520 04	epp2 	1204,ic		010304 = 000002000000
006021  aa   001044 6700 04	tsp4 	548,ic		007065
						STATEMENT 1 ON LINE 1398
		     end;

						STATEMENT 1 ON LINE 1403
		     do i = 1 to disktab.nchan;

006022  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
006023  aa  7 00001 2361 00	ldq  	pr7|1		disktab.nchan
006024  aa  6 00476 7561 00	stq  	pr6|318
006025  aa   000001 2360 07	ldq  	1,dl
006026  aa  6 00127 7561 00	stq  	pr6|87		i
006027  aa   000000 0110 03	nop  	0,du
006030  aa  6 00127 2361 00	ldq  	pr6|87		i
006031  aa  6 00476 1161 00	cmpq 	pr6|318
006032  aa   000045 6054 04	tpnz 	37,ic		006077
						STATEMENT 1 ON LINE 1404
			lcp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));

006033  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
006034  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
006035  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
006036  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
006037  aa   000000 3120 01	eawp2	0,au
006040  aa  6 00127 2361 00	ldq  	pr6|87		i
006041  aa   000005 7360 00	qls  	5
006042  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
006043  aa  6 00132 6515 00	spri5	pr6|90		lcp
						STATEMENT 1 ON LINE 1405
			if ^(lcp -> chantab.ioi_use) then do;

006044  aa  5 00006 2351 00	lda  	pr5|6		chantab.ioi_use
006045  aa   040000 3150 07	cana 	16384,dl
006046  aa   000027 6010 04	tnz  	23,ic		006075
						STATEMENT 1 ON LINE 1407
			     if (lcp -> chantab.connect_time + CHANNEL_POLLING_TIME < clock ())
				| post_sw /* time to give up */ then do;

006047  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
006050  aa  6 01362 7571 00	staq 	pr6|754
006051  aa  5 00014 2371 00	ldaq 	pr5|12		chantab.connect_time
006052  aa   772230 0330 04	adl  	-2920,ic		000302 = 000344703400
006053  aa  6 01362 1171 00	cmpaq	pr6|754
006054  aa  0 00474 7001 00	tsx0 	pr0|316		r_l_a
006055  aa  6 00146 2751 00	ora  	pr6|102		post_sw
006056  aa   000017 6000 04	tze  	15,ic		006075
						STATEMENT 1 ON LINE 1411
				lcp -> chantab.broken = "0"b;

006057  aa   002317 2350 04	lda  	1231,ic		010376 = 777777767777
006060  aa  5 00006 3551 00	ansa 	pr5|6		chantab.broken
						STATEMENT 1 ON LINE 1413
				lcp -> chantab.inop = "0"b;

006061  aa   002316 2350 04	lda  	1230,ic		010377 = 777777757777
006062  aa  5 00006 3551 00	ansa 	pr5|6		chantab.inop
						STATEMENT 1 ON LINE 1415
				lcp -> chantab.erct = 0;

006063  aa   000000 2350 03	lda  	0,du
006064  aa  5 00007 5511 04	stba 	pr5|7,04		chantab.erct
						STATEMENT 1 ON LINE 1417
				lcp -> chantab.active = "0"b;

006065  aa   002313 2350 04	lda  	1227,ic		010400 = 777777577777
006066  aa  5 00006 3551 00	ansa 	pr5|6		chantab.active
						STATEMENT 1 ON LINE 1420
				lcp -> chantab.in_use = "1"b;

006067  aa   400000 2350 07	lda  	131072,dl
006070  aa  5 00006 2551 00	orsa 	pr5|6		chantab.in_use
						STATEMENT 1 ON LINE 1423
				lcp -> chantab.connect_time = clock ();

006071  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
006072  aa  5 00014 7571 00	staq 	pr5|12		chantab.connect_time
						STATEMENT 1 ON LINE 1424
				disktab.channels_online = disktab.channels_online + 1;

006073  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
006074  aa  7 00003 0541 00	aos  	pr7|3		disktab.channels_online
						STATEMENT 1 ON LINE 1426
			     end;

						STATEMENT 1 ON LINE 1427
			end;

						STATEMENT 1 ON LINE 1428
		     end;

006075  aa  6 00127 0541 00	aos  	pr6|87		i
006076  aa   777732 7100 04	tra  	-38,ic		006030
						STATEMENT 1 ON LINE 1429
		     return;

006077  aa  6 00470 6101 00	rtcd 	pr6|312
						STATEMENT 1 ON LINE 1430
		end;

						STATEMENT 1 ON LINE 1432
		post_sw = "0"b;

006100  aa  6 00146 4501 00	stz  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1433
		call add_wq;

006101  aa   001553 6700 04	tsp4 	875,ic		007654
						STATEMENT 1 ON LINE 1438
		do i = 1 to disktab.nchan;

006102  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
006103  aa  7 00001 2361 00	ldq  	pr7|1		disktab.nchan
006104  aa  6 00477 7561 00	stq  	pr6|319
006105  aa   000001 2360 07	ldq  	1,dl
006106  aa  6 00127 7561 00	stq  	pr6|87		i
006107  aa   000000 0110 03	nop  	0,du
006110  aa  6 00127 2361 00	ldq  	pr6|87		i
006111  aa  6 00477 1161 00	cmpq 	pr6|319
006112  aa   000043 6054 04	tpnz 	35,ic		006155
						STATEMENT 1 ON LINE 1439
		     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));

006113  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
006114  aa  7 00011 2351 00	lda  	pr7|9		disktab.channels
006115  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
006116  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
006117  aa   000000 3120 01	eawp2	0,au
006120  aa  6 00127 2361 00	ldq  	pr6|87		i
006121  aa   000005 7360 00	qls  	5
006122  aa  2 77740 3715 06	epp5 	pr2|-32,ql	disk_channel_table
006123  aa  6 00270 6515 00	spri5	pr6|184		cp
						STATEMENT 1 ON LINE 1441
		     if chantab.in_use & ^chantab.active then do;

006124  aa  5 00006 2351 00	lda  	pr5|6		chantab.in_use
006125  aa   400000 3150 07	cana 	131072,dl
006126  aa   000006 6000 04	tze  	6,ic		006134
006127  aa  5 00006 2351 00	lda  	pr5|6		chantab.active
006130  aa   200000 3150 07	cana 	65536,dl
006131  aa   000003 6010 04	tnz  	3,ic		006134
						STATEMENT 1 ON LINE 1442
			call getwork;

006132  aa   000024 6700 04	tsp4 	20,ic		006156
						STATEMENT 1 ON LINE 1443
			return;

006133  aa  6 00470 6101 00	rtcd 	pr6|312
						STATEMENT 1 ON LINE 1444
		     end;

						STATEMENT 1 ON LINE 1445
		end;

006134  aa  6 00127 0541 00	aos  	pr6|87		i
006135  aa   777753 7100 04	tra  	-21,ic		006110
						STATEMENT 1 ON LINE 1446
	     end;

006136  aa   000017 7100 04	tra  	15,ic		006155
						STATEMENT 1 ON LINE 1447
	     else if disk_error_interp.bad_mem then do;

006137  aa  6 00254 2351 20	lda  	pr6|172,*		disk_error_interp.bad_mem
006140  aa   010000 3150 07	cana 	4096,dl
006141  aa   000010 6000 04	tze  	8,ic		006151
						STATEMENT 1 ON LINE 1448
		errflags.fatal_error = "1"b;

006142  aa   000001 2350 07	lda  	1,dl
006143  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.fatal_error
						STATEMENT 1 ON LINE 1449
		errflags.memory_unusable = "1"b;

006144  aa   000040 2350 07	lda  	32,dl
006145  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.memory_unusable
						STATEMENT 1 ON LINE 1450
		post_sw = "1"b;

006146  aa   400000 2350 03	lda  	131072,du
006147  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1451
	     end;

006150  aa   000005 7100 04	tra  	5,ic		006155
						STATEMENT 1 ON LINE 1452
	     else do;

						STATEMENT 1 ON LINE 1453
		errflags.fatal_error = "1"b;

006151  aa   000001 2350 07	lda  	1,dl
006152  aa  6 00246 2551 20	orsa 	pr6|166,*		errflags.fatal_error
						STATEMENT 1 ON LINE 1454
		post_sw = "1"b;

006153  aa   400000 2350 03	lda  	131072,du
006154  aa  6 00146 7551 00	sta  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1455
	     end;

						STATEMENT 1 ON LINE 1457
	     return;

006155  aa  6 00470 6101 00	rtcd 	pr6|312
						STATEMENT 1 ON LINE 1460
	end handle_error;

  END PROCEDURE handle_error
  END PROCEDURE check_stat
BEGIN PROCEDURE getwork
ENTRY TO getwork                                            STATEMENT 1 ON LINE 1466
getwork:
     proc;

006156  aa  6 00500 6501 00	spri4	pr6|320
						STATEMENT 1 ON LINE 1469
	if ^chantab.in_use then
	     return;

006157  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
006160  aa  7 00006 2351 00	lda  	pr7|6		chantab.in_use
006161  aa   400000 3150 07	cana 	131072,dl
006162  aa   000002 6010 04	tnz  	2,ic		006164
006163  aa  6 00500 6101 00	rtcd 	pr6|320
						STATEMENT 1 ON LINE 1472
	if ^disktab.dev_busy & disktab.dev_queued = "0"b then
	     return;

006164  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
006165  aa  5 00006 2351 00	lda  	pr5|6		disktab.dev_queued
006166  aa  5 00007 2361 00	ldq  	pr5|7		disktab.dev_queued
006167  aa  0 00000 1171 00	cmpaq	pr0|0		= 000000000000 000000000000
006170  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
006171  aa  6 01424 7551 00	sta  	pr6|788
006172  aa  5 00004 2351 00	lda  	pr5|4		disktab.dev_busy
006173  aa  5 00005 2361 00	ldq  	pr5|5		disktab.dev_busy
006174  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
006175  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
006176  aa  6 01424 3151 00	cana 	pr6|788
006177  aa   000002 6000 04	tze  	2,ic		006201
006200  aa  6 00500 6101 00	rtcd 	pr6|320
						STATEMENT 1 ON LINE 1477
	do dev_count = lbound (disktab.devtab, 1) to hbound (disktab.devtab, 1);

006201  aa  5 00002 2351 00	lda  	pr5|2		disktab.last_dev
006202  aa   000022 7350 00	als  	18
006203  aa   000066 7330 00	lrs  	54
006204  aa  6 00506 7561 00	stq  	pr6|326
006205  aa  6 00122 4501 00	stz  	pr6|82		dev_count
006206  aa  6 00122 2361 00	ldq  	pr6|82		dev_count
006207  aa  6 00506 1161 00	cmpq 	pr6|326
006210  aa   000106 6054 04	tpnz 	70,ic		006316
						STATEMENT 1 ON LINE 1478
	     disktab.dev_index = disktab.dev_index + 1;

006211  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
006212  aa  7 00011 2351 00	lda  	pr7|9		disktab.dev_index
006213  aa   000022 7350 00	als  	18
006214  aa   000066 7330 00	lrs  	54
006215  aa   000001 0760 07	adq  	1,dl
006216  aa  7 00011 5521 14	stbq 	pr7|9,14		disktab.dev_index
						STATEMENT 1 ON LINE 1479
	     if disktab.dev_index > hbound (disktab.devtab, 1) then
		disktab.dev_index = lbound (disktab.devtab, 1);

006217  aa  7 00002 2351 00	lda  	pr7|2		disktab.last_dev
006220  aa   000022 7350 00	als  	18
006221  aa   000066 7330 00	lrs  	54
006222  aa  6 01424 7561 00	stq  	pr6|788
006223  aa  7 00011 2351 00	lda  	pr7|9		disktab.dev_index
006224  aa   000022 7350 00	als  	18
006225  aa   000066 7330 00	lrs  	54
006226  aa  6 01424 1161 00	cmpq 	pr6|788
006227  aa   000003 6044 04	tmoz 	3,ic		006232
006230  aa   000000 2350 03	lda  	0,du
006231  aa  7 00011 5511 14	stba 	pr7|9,14		disktab.dev_index
						STATEMENT 1 ON LINE 1482
	     dev = disktab.dev_index;

006232  aa  7 00011 2351 00	lda  	pr7|9		disktab.dev_index
006233  aa   000022 7350 00	als  	18
006234  aa   000066 7330 00	lrs  	54
006235  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 1483
	     pdi = disktab.devtab (dev).pdi;

006236  aa   000120 4020 07	mpy  	80,dl
006237  aa  7 00036 2361 06	ldq  	pr7|30,ql		disktab.pdi
006240  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
006241  aa  6 00145 7561 00	stq  	pr6|101		pdi
						STATEMENT 1 ON LINE 1485
	     if ^disktab.dev_busy & dev_mask (pdi) then do;

006242  aa  6 01424 7561 00	stq  	pr6|788
006243  aa   000001 7360 00	qls  	1
006244  aa   000000 6270 06	eax7 	0,ql
006245  aa  7 00004 2351 00	lda  	pr7|4		disktab.dev_busy
006246  aa  7 00005 2361 00	ldq  	pr7|5		disktab.dev_busy
006247  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
006250  ta   000076 3750 17	ana  	62,7
006251  ta   000077 3760 17	anq  	63,7
006252  aa  0 00000 1171 00	cmpaq	pr0|0		= 000000000000 000000000000
006253  aa   000041 6000 04	tze  	33,ic		006314
						STATEMENT 1 ON LINE 1487
		dp = addr (disktab.devtab (pdi));

006254  aa  6 01424 2361 00	ldq  	pr6|788
006255  aa   000120 4020 07	mpy  	80,dl
006256  aa  7 00036 3715 06	epp5 	pr7|30,ql		disktab.devtab
006257  aa  6 00272 6515 00	spri5	pr6|186		dp
						STATEMENT 1 ON LINE 1488
		if ^devtab.broken			/* Device usable */
		     then
		     if devtab.wq.depth > 0		/* work to do */
		     then do;

006260  aa  5 00000 2351 00	lda  	pr5|0		devtab.broken
006261  aa   000100 3150 03	cana 	64,du
006262  aa   000032 6010 04	tnz  	26,ic		006314
006263  aa  5 00010 2351 00	lda  	pr5|8		devtab.depth
006264  aa   000022 7350 00	als  	18
006265  aa   000066 7330 00	lrs  	54
006266  aa  6 01424 7561 00	stq  	pr6|788		devtab.depth
006267  aa   000025 6044 04	tmoz 	21,ic		006314
						STATEMENT 1 ON LINE 1492
			qp = ptr (disksp, devtab.wq.head);

006270  aa  5 00011 2351 00	lda  	pr5|9		devtab.head
006271  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
006272  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
006273  aa   000000 3120 01	eawp2	0,au
006274  aa  6 00266 2521 00	spri2	pr6|182		qp
						STATEMENT 1 ON LINE 1498
			if devtab.wq.depth > 1 then
			     if quentry.time >= (clock () - disk_data.stagnate_time) then
				call find_shortest_seek;

006275  aa  6 01424 2361 00	ldq  	pr6|788		devtab.depth
006276  aa   000001 1160 07	cmpq 	1,dl
006277  aa   000013 6044 04	tmoz 	11,ic		006312
006300  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
006301  aa   000000 5330 00	negl 	0
006302  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
006303  aa  7 00111 0331 00	adl  	pr7|73		disk_data.stagnate_time
006304  aa   000000 5330 00	negl 	0
006305  aa  2 00004 1171 00	cmpaq	pr2|4		quentry.time
006306  aa   000003 6054 04	tpnz 	3,ic		006311
006307  aa   000411 6700 04	tsp4 	265,ic		006720
006310  aa   000002 7100 04	tra  	2,ic		006312
						STATEMENT 1 ON LINE 1501
			     else call comb;

006311  aa   000461 6700 04	tsp4 	305,ic		006772
						STATEMENT 1 ON LINE 1503
			call del_q;

006312  aa   001543 6700 04	tsp4 	867,ic		010055
						STATEMENT 1 ON LINE 1504
			go to xfer_join;

006313  aa   000005 7100 04	tra  	5,ic		006320
						STATEMENT 1 ON LINE 1505
		     end;

						STATEMENT 1 ON LINE 1506
	     end;

						STATEMENT 1 ON LINE 1507
	end;

006314  aa  6 00122 0541 00	aos  	pr6|82		dev_count
006315  aa   777671 7100 04	tra  	-71,ic		006206
						STATEMENT 1 ON LINE 1509
	return;

006316  aa  6 00500 6101 00	rtcd 	pr6|320
ENTRY TO gotwork                                            STATEMENT 1 ON LINE 1620
gotwork:
     entry;

006317  aa  6 00500 6501 00	spri4	pr6|320
						STATEMENT 1 ON LINE 1623
xfer_join:
	if ^quentry.used then			/* This must never happen. */
	     call syserr (CRASH, "^a: Queuing error.", ME);

006320  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
006321  aa  7 00001 2351 00	lda  	pr7|1		quentry.used
006322  aa   200000 3150 03	cana 	65536,du
006323  aa   000030 6010 04	tnz  	24,ic		006353
006324  aa   772054 2370 04	ldaq 	-3028,ic		000400 = 136141072040 121165145165
006325  aa  6 01426 7571 00	staq 	pr6|790
006326  aa   772054 2370 04	ldaq 	-3028,ic		000402 = 151156147040 145162162157
006327  aa  6 01430 7571 00	staq 	pr6|792
006330  aa   162056 2350 03	lda  	58414,du
006331  aa  6 01432 7551 00	sta  	pr6|794
006332  aa   772025 3520 04	epp2 	-3051,ic		000357 = 000000000001
006333  aa  6 01436 2521 00	spri2	pr6|798
006334  aa  6 01426 3521 00	epp2 	pr6|790
006335  aa  6 01440 2521 00	spri2	pr6|800
006336  aa   771740 3520 04	epp2 	-3104,ic		000276 = 144151163153
006337  aa  6 01442 2521 00	spri2	pr6|802
006340  aa   772016 3520 04	epp2 	-3058,ic		000356 = 404000000021
006341  aa  6 01444 2521 00	spri2	pr6|804
006342  aa   771750 3520 04	epp2 	-3096,ic		000312 = 524000000022
006343  aa  6 01446 2521 00	spri2	pr6|806
006344  aa   771766 3520 04	epp2 	-3082,ic		000332 = 526000000020
006345  aa  6 01450 2521 00	spri2	pr6|808
006346  aa  6 01434 6211 00	eax1 	pr6|796
006347  aa   014000 4310 07	fld  	6144,dl
006350  aa  6 00044 3701 20	epp4 	pr6|36,*
006351  la  4 00024 3521 20	epp2 	pr4|20,*		syserr
006352  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1627
	chantab.qrp = rel (qp);

006353  aa  6 00266 6351 20	eaa  	pr6|182,*		qp
006354  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
006355  aa  7 00007 5511 60	stba 	pr7|7,60		chantab.qrp
						STATEMENT 1 ON LINE 1628
	chantab.erct = 0;

006356  aa   000000 2350 03	lda  	0,du
006357  aa  7 00007 5511 04	stba 	pr7|7,04		chantab.erct
						STATEMENT 1 ON LINE 1629
	chantab.reconnect_announce_time = 0;

006360  aa   772006 2370 04	ldaq 	-3066,ic		000366 = 000000000000 000000000000
006361  aa  7 00012 7571 00	staq 	pr7|10		chantab.reconnect_announce_time
						STATEMENT 1 ON LINE 1631
	dev = quentry.dev;

006362  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
006363  aa  5 00002 2351 00	lda  	pr5|2		quentry.dev
006364  aa   000016 7350 00	als  	14
006365  aa   000102 7730 00	lrl  	66
006366  aa  6 00120 7561 00	stq  	pr6|80		dev
						STATEMENT 1 ON LINE 1633
	if quentry.type = TEST then do;

006367  aa  5 00001 2351 00	lda  	pr5|1		quentry.type
006370  aa   000002 7350 00	als  	2
006371  aa   000104 7730 00	lrl  	68
006372  aa  6 01433 7561 00	stq  	pr6|795		quentry.type
006373  aa   000004 1160 07	cmpq 	4,dl
006374  aa   000043 6010 04	tnz  	35,ic		006437
						STATEMENT 1 ON LINE 1634
	     idcwp = addr (chantab.rssdcw);

006375  aa  7 00032 3535 00	epp3 	pr7|26		chantab.rssdcw
006376  aa  6 00310 2535 00	spri3	pr6|200		idcwp
						STATEMENT 1 ON LINE 1635
	     idcw.command = substr (quentry.coreadd, 19, 6);

006377  aa  5 00001 2351 00	lda  	pr5|1		quentry.coreadd
006400  aa   000036 7350 00	als  	30
006401  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
						STATEMENT 1 ON LINE 1636
	     idcw.device = bit (dev);

006402  aa  6 00120 2351 00	lda  	pr6|80		dev
006403  aa   000036 7350 00	als  	30
006404  aa   000006 7710 00	arl  	6
006405  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
						STATEMENT 1 ON LINE 1640
	     optp = addr (disktab.devtab (dev).opt_info (quentry.type));

006406  aa  6 00120 2361 00	ldq  	pr6|80		dev
006407  aa   000120 4020 07	mpy  	80,dl
006410  aa  6 01424 7561 00	stq  	pr6|788
006411  aa  6 01433 2361 00	ldq  	pr6|795		quentry.type
006412  aa   000012 4020 07	mpy  	10,dl
006413  aa  6 01424 0761 00	adq  	pr6|788
006414  aa  6 00260 3515 20	epp1 	pr6|176,*		diskp
006415  aa  1 00050 3515 06	epp1 	pr1|40,ql		disktab.opt_info
006416  aa  6 00262 2515 00	spri1	pr6|178		optp
						STATEMENT 1 ON LINE 1641
	     if bin (quentry.coreadd, 24) = 58 then
		opt_info.seek_sum = opt_info.seek_sum + 1;

006417  aa  5 00001 2361 00	ldq  	pr5|1		quentry.coreadd
006420  aa  0 00360 3771 00	anaq 	pr0|240		= 000000000000 000077777777
006421  aa   000072 1160 07	cmpq 	58,dl
006422  aa   000006 6010 04	tnz  	6,ic		006430
006423  aa  1 00010 2351 00	lda  	pr1|8		opt_info.seek_sum
006424  aa   000044 7330 00	lrs  	36
006425  aa   000001 0330 07	adl  	1,dl
006426  aa  1 00010 7561 00	stq  	pr1|8		opt_info.seek_sum
006427  aa   000005 7100 04	tra  	5,ic		006434
						STATEMENT 1 ON LINE 1644
	     else opt_info.seek_count = opt_info.seek_count + 1;

006430  aa  1 00011 2351 00	lda  	pr1|9		opt_info.seek_count
006431  aa   000044 7330 00	lrs  	36
006432  aa   000001 0330 07	adl  	1,dl
006433  aa  1 00011 7561 00	stq  	pr1|9		opt_info.seek_count
						STATEMENT 1 ON LINE 1648
	     call connect (idcwp);

006434  aa   001722 3520 04	epp2 	978,ic		010356 = 000002000000
006435  aa   000430 6700 04	tsp4 	280,ic		007065
						STATEMENT 1 ON LINE 1649
	end;

006436  aa   000261 7100 04	tra  	177,ic		006717
						STATEMENT 1 ON LINE 1651
	else do;

						STATEMENT 1 ON LINE 1652
	     dcdcwp = addr (chantab.dcdcw);

006437  aa  7 00026 3535 00	epp3 	pr7|22		chantab.dcdcw
006440  aa  6 00114 2535 00	spri3	pr6|76		dcdcwp
						STATEMENT 1 ON LINE 1653
	     dddcwp = addr (chantab.dddcw);

006441  aa  7 00027 3515 00	epp1 	pr7|23		chantab.dddcw
006442  aa  6 00116 2515 00	spri1	pr6|78		dddcwp
						STATEMENT 1 ON LINE 1654
	     idcwp = addr (chantab.scdcw);

006443  aa  7 00024 3715 00	epp5 	pr7|20		chantab.scdcw
006444  aa  6 00310 6515 00	spri5	pr6|200		idcwp
						STATEMENT 1 ON LINE 1656
	     idcw.device = bit (dev);

006445  aa  6 00120 2351 00	lda  	pr6|80		dev
006446  aa   000036 7350 00	als  	30
006447  aa   000006 7710 00	arl  	6
006450  aa  5 00000 7511 20	stca 	pr5|0,20		idcw.device
						STATEMENT 1 ON LINE 1658
	     unspec (dcdcwp -> idcw) = "0"b;

006451  aa  3 00000 4501 00	stz  	pr3|0
						STATEMENT 1 ON LINE 1659
	     dcdcwp -> idcw.code = IDCW;

006452  aa   700000 2350 07	lda  	229376,dl
006453  aa  3 00000 2551 00	orsa 	pr3|0		idcw.code
						STATEMENT 1 ON LINE 1660
	     dcdcwp -> idcw.ext_ctl = "1"b;

006454  aa   040000 2350 07	lda  	16384,dl
006455  aa  3 00000 2551 00	orsa 	pr3|0		idcw.ext_ctl
						STATEMENT 1 ON LINE 1661
	     if write_map (quentry.type) then		/* set data transfer direction */
		dcdcwp -> idcw.command = WRITE;

006456  aa   000000 6270 06	eax7 	0,ql
006457  aa  6 01424 7471 00	stx7 	pr6|788
006460  aa  000 000 066 417	cmpb 	(x7),(),fill(0)
006461  ta   000024 00 0001	descb	20,1
006462  aa   000000 00 0000	descb	0,0
006463  aa   000004 6000 04	tze  	4,ic		006467
006464  aa   310000 2350 03	lda  	102400,du
006465  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
006466  aa   000003 7100 04	tra  	3,ic		006471
						STATEMENT 1 ON LINE 1663
	     else dcdcwp -> idcw.command = READ;

006467  aa   250000 2350 03	lda  	86016,du
006470  aa  3 00000 7511 40	stca 	pr3|0,40		idcw.command
						STATEMENT 1 ON LINE 1665
	     dcdcwp -> idcw.ext = substr (quentry.coreadd, 1, length (idcw.ext));

006471  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
006472  aa  7 00001 2351 00	lda  	pr7|1		quentry.coreadd
006473  aa  3 00000 7511 10	stca 	pr3|0,10		idcw.ext
						STATEMENT 1 ON LINE 1667
	     dddcwp -> dcw.address = substr (quentry.coreadd, 7);

006474  aa  7 00001 2351 00	lda  	pr7|1		quentry.coreadd
006475  aa   000022 7350 00	als  	18
006476  aa  1 00000 5511 60	stba 	pr1|0,60		dcw.address
						STATEMENT 1 ON LINE 1669
	     dcdcwp -> idcw.device = bit (dev);

006477  aa  6 00120 2351 00	lda  	pr6|80		dev
006500  aa   000036 7350 00	als  	30
006501  aa   000006 7710 00	arl  	6
006502  aa  3 00000 7511 20	stca 	pr3|0,20		idcw.device
						STATEMENT 1 ON LINE 1673
	     chantab.select_data.sector = quentry.sector;

006503  aa  7 00003 2351 00	lda  	pr7|3		quentry.sector
006504  aa  6 00270 3715 20	epp5 	pr6|184,*		cp
006505  aa  5 00010 6751 00	era  	pr5|8		chantab.sector
006506  aa   001676 3750 04	ana  	958,ic		010404 = 000007777777
006507  aa  5 00010 6551 00	ersa 	pr5|8		chantab.sector
						STATEMENT 1 ON LINE 1675
	     if idcw.command = seek_512 then do;

006510  aa  6 00310 2351 20	lda  	pr6|200,*		idcw.command
006511  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
006512  aa   300000 1150 03	cmpa 	98304,du
006513  aa   000065 6010 04	tnz  	53,ic		006600
						STATEMENT 1 ON LINE 1676
		if quentry.type = VTOC_READ | quentry.type = VTOC_WRITE then do;

006514  aa  6 01433 2361 00	ldq  	pr6|795		quentry.type
006515  aa   000002 1160 07	cmpq 	2,dl
006516  aa   000003 6000 04	tze  	3,ic		006521
006517  aa   000003 1160 07	cmpq 	3,dl
006520  aa   000014 6010 04	tnz  	12,ic		006534
						STATEMENT 1 ON LINE 1677
		     dddcwp -> dcw.tally = bit (bin (192, 12));

006521  aa   000300 2350 07	lda  	192,dl
006522  aa   000002 6050 04	tpl  	2,ic		006524
006523  aa   000000 5310 00	neg  	0
006524  aa  0 00300 3771 00	anaq 	pr0|192		= 000000007777 777777777777
006525  aa  1 00000 7511 03	stca 	pr1|0,03		dcw.tally
						STATEMENT 1 ON LINE 1678
		     chantab.select_data.limit = bit (bin (1, 12));

006526  aa   000001 2350 07	lda  	1,dl
006527  aa   000002 6050 04	tpl  	2,ic		006531
006530  aa   000000 5310 00	neg  	0
006531  aa   000030 7350 00	als  	24
006532  aa  5 00010 7511 60	stca 	pr5|8,60		chantab.limit
						STATEMENT 1 ON LINE 1679
		end;

006533  aa   000104 7100 04	tra  	68,ic		006637
						STATEMENT 1 ON LINE 1680
		else if quentry.type = PAGE_READ | quentry.type = PAGE_WRITE then do;

006534  aa  6 01433 2361 00	ldq  	pr6|795		quentry.type
006535  aa   000003 6000 04	tze  	3,ic		006540
006536  aa   000001 1160 07	cmpq 	1,dl
006537  aa   000014 6010 04	tnz  	12,ic		006553
						STATEMENT 1 ON LINE 1681
		     dddcwp -> dcw.tally = bit (bin (1024, 12));

006540  aa   002000 2350 07	lda  	1024,dl
006541  aa   000002 6050 04	tpl  	2,ic		006543
006542  aa   000000 5310 00	neg  	0
006543  aa  0 00300 3771 00	anaq 	pr0|192		= 000000007777 777777777777
006544  aa  1 00000 7511 03	stca 	pr1|0,03		dcw.tally
						STATEMENT 1 ON LINE 1682
		     chantab.select_data.limit = bit (bin (2, 12));

006545  aa   000002 2350 07	lda  	2,dl
006546  aa   000002 6050 04	tpl  	2,ic		006550
006547  aa   000000 5310 00	neg  	0
006550  aa   000030 7350 00	als  	24
006551  aa  5 00010 7511 60	stca 	pr5|8,60		chantab.limit
						STATEMENT 1 ON LINE 1683
		end;

006552  aa   000065 7100 04	tra  	53,ic		006637
						STATEMENT 1 ON LINE 1684
		else if sector_map (quentry.type) then do;

006553  aa  000 000 066 417	cmpb 	(x7),(),fill(0)
006554  ta   000023 00 0001	descb	19,1
006555  aa   000000 00 0000	descb	0,0
006556  aa   000061 6000 04	tze  	49,ic		006637
						STATEMENT 1 ON LINE 1685
		     dddcwp -> dcw.tally = bit (bin ((512 * quentry.n_sectors), 12));

006557  aa  7 00003 2351 00	lda  	pr7|3		quentry.n_sectors
006560  aa   000102 7730 00	lrl  	66
006561  aa  6 01433 7561 00	stq  	pr6|795		quentry.n_sectors
006562  aa   000011 7360 00	qls  	9
006563  aa  0 00000 1161 00	cmpq 	pr0|0		= 000000000000
006564  aa   000003 6050 04	tpl  	3,ic		006567
006565  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
006566  aa   000001 0760 07	adq  	1,dl
006567  aa   000074 7370 00	lls  	60
006570  aa   000030 7730 00	lrl  	24
006571  aa  1 00000 7511 03	stca 	pr1|0,03		dcw.tally
						STATEMENT 1 ON LINE 1686
		     chantab.select_data.limit = bit (bin (quentry.n_sectors, 12));

006572  aa  6 01433 2351 00	lda  	pr6|795		quentry.n_sectors
006573  aa   000002 6050 04	tpl  	2,ic		006575
006574  aa   000000 5310 00	neg  	0
006575  aa   000030 7350 00	als  	24
006576  aa  5 00010 7511 60	stca 	pr5|8,60		chantab.limit
						STATEMENT 1 ON LINE 1687
		end;

						STATEMENT 1 ON LINE 1688
	     end;

006577  aa   000040 7100 04	tra  	32,ic		006637
						STATEMENT 1 ON LINE 1689
	     else do;

						STATEMENT 1 ON LINE 1690
		if sector_map (quentry.type) then do;

006600  aa  000 000 066 417	cmpb 	(x7),(),fill(0)
006601  ta   000023 00 0001	descb	19,1
006602  aa   000000 00 0000	descb	0,0
006603  aa   000022 6000 04	tze  	18,ic		006625
						STATEMENT 1 ON LINE 1691
		     dddcwp -> dcw.tally = bit (bin (64 * quentry.n_sectors, 12));

006604  aa  7 00003 2351 00	lda  	pr7|3		quentry.n_sectors
006605  aa   000102 7730 00	lrl  	66
006606  aa  6 01424 7561 00	stq  	pr6|788		quentry.n_sectors
006607  aa   000006 7360 00	qls  	6
006610  aa  0 00000 1161 00	cmpq 	pr0|0		= 000000000000
006611  aa   000003 6050 04	tpl  	3,ic		006614
006612  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
006613  aa   000001 0760 07	adq  	1,dl
006614  aa   000074 7370 00	lls  	60
006615  aa   000030 7730 00	lrl  	24
006616  aa  1 00000 7511 03	stca 	pr1|0,03		dcw.tally
						STATEMENT 1 ON LINE 1693
		     chantab.select_data.limit = bit (bin (quentry.n_sectors, 12));

006617  aa  6 01424 2351 00	lda  	pr6|788		quentry.n_sectors
006620  aa   000002 6050 04	tpl  	2,ic		006622
006621  aa   000000 5310 00	neg  	0
006622  aa   000030 7350 00	als  	24
006623  aa  5 00010 7511 60	stca 	pr5|8,60		chantab.limit
						STATEMENT 1 ON LINE 1695
		end;

006624  aa   000013 7100 04	tra  	11,ic		006637
						STATEMENT 1 ON LINE 1696
		else do;

						STATEMENT 1 ON LINE 1697
		     dddcwp -> dcw.tally = bit (bin (1024, 12));

006625  aa   002000 2350 07	lda  	1024,dl
006626  aa   000002 6050 04	tpl  	2,ic		006630
006627  aa   000000 5310 00	neg  	0
006630  aa  0 00300 3771 00	anaq 	pr0|192		= 000000007777 777777777777
006631  aa  1 00000 7511 03	stca 	pr1|0,03		dcw.tally
						STATEMENT 1 ON LINE 1699
		     chantab.select_data.limit = bit (bin (16, 12));

006632  aa   000020 2350 07	lda  	16,dl
006633  aa   000002 6050 04	tpl  	2,ic		006635
006634  aa   000000 5310 00	neg  	0
006635  aa   000030 7350 00	als  	24
006636  aa  5 00010 7511 60	stca 	pr5|8,60		chantab.limit
						STATEMENT 1 ON LINE 1701
		end;

						STATEMENT 1 ON LINE 1702
	     end;

						STATEMENT 1 ON LINE 1704
	     call connect (addr (chantab.scdcw));

006637  aa  5 00024 3535 00	epp3 	pr5|20		chantab.scdcw
006640  aa  6 01452 2535 00	spri3	pr6|810
006641  aa   001437 3520 04	epp2 	799,ic		010300 = 000002000000
006642  aa   000223 6700 04	tsp4 	147,ic		007065
						STATEMENT 1 ON LINE 1708
	     optp = addr (disktab.devtab (dev).opt_info (quentry.type));

006643  aa  6 00120 2361 00	ldq  	pr6|80		dev
006644  aa   000120 4020 07	mpy  	80,dl
006645  aa  6 01424 7561 00	stq  	pr6|788
006646  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
006647  aa  7 00001 2351 00	lda  	pr7|1		quentry.type
006650  aa   000002 7350 00	als  	2
006651  aa   000104 7730 00	lrl  	68
006652  aa   000012 4020 07	mpy  	10,dl
006653  aa  6 01424 0761 00	adq  	pr6|788
006654  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
006655  aa  5 00050 3715 06	epp5 	pr5|40,ql		disktab.opt_info
006656  aa  6 00262 6515 00	spri5	pr6|178		optp
						STATEMENT 1 ON LINE 1709
	     cylinder = devtab.cylinder - quentry.cylinder;

006657  aa  7 00002 2361 00	ldq  	pr7|2		quentry.cylinder
006660  aa  0 00412 3771 00	anaq 	pr0|266		= 000000000000 000000003777
006661  aa  6 01424 7561 00	stq  	pr6|788		quentry.cylinder
006662  aa  6 00272 3535 20	epp3 	pr6|186,*		dp
006663  aa  3 00001 3361 00	lcq  	pr3|1		devtab.cylinder
006664  aa   000044 7770 00	llr  	36
006665  aa   000044 7330 00	lrs  	36
006666  aa  6 01424 0331 00	adl  	pr6|788		quentry.cylinder
006667  aa   000000 5330 00	negl 	0
006670  aa  6 00113 7561 00	stq  	pr6|75		cylinder
						STATEMENT 1 ON LINE 1710
	     devtab.cylinder = quentry.cylinder;

006671  aa  6 01424 2361 00	ldq  	pr6|788		quentry.cylinder
006672  aa  3 00001 7561 00	stq  	pr3|1		devtab.cylinder
						STATEMENT 1 ON LINE 1717
	     if cylinder > 0			/* Backward comb */
		then
		devtab.forward = "0"b;

006673  aa  6 00113 2361 00	ldq  	pr6|75		cylinder
006674  aa   000004 6044 04	tmoz 	4,ic		006700
006675  aa   001401 2350 04	lda  	769,ic		010276 = 777757777777
006676  aa  3 00000 3551 00	ansa 	pr3|0		devtab.forward
006677  aa   000004 7100 04	tra  	4,ic		006703
						STATEMENT 1 ON LINE 1720
	     else if cylinder < 0			/* Forward comb */
		then
		devtab.forward = "1"b;

006700  aa   000003 6050 04	tpl  	3,ic		006703
006701  aa   000020 2350 03	lda  	16,du
006702  aa  3 00000 2551 00	orsa 	pr3|0		devtab.forward
						STATEMENT 1 ON LINE 1724
	     opt_info.seek_sum = opt_info.seek_sum + abs (cylinder);

006703  aa  6 00113 2361 00	ldq  	pr6|75		cylinder
006704  aa   000003 6050 04	tpl  	3,ic		006707
006705  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
006706  aa   000001 0760 07	adq  	1,dl
006707  aa   000044 7770 00	llr  	36
006710  aa   000044 7330 00	lrs  	36
006711  aa  5 00010 0331 00	adl  	pr5|8		opt_info.seek_sum
006712  aa  5 00010 7561 00	stq  	pr5|8		opt_info.seek_sum
						STATEMENT 1 ON LINE 1725
	     opt_info.seek_count = opt_info.seek_count + 1;

006713  aa  5 00011 2351 00	lda  	pr5|9		opt_info.seek_count
006714  aa   000044 7330 00	lrs  	36
006715  aa   000001 0330 07	adl  	1,dl
006716  aa  5 00011 7561 00	stq  	pr5|9		opt_info.seek_count
						STATEMENT 1 ON LINE 1726
	end;

						STATEMENT 1 ON LINE 1727
     end getwork;

006717  aa  6 00500 6101 00	rtcd 	pr6|320
BEGIN PROCEDURE find_shortest_seek
ENTRY TO find_shortest_seek                                 STATEMENT 1 ON LINE 1513
find_shortest_seek:
	proc;

006720  aa  6 00510 6501 00	spri4	pr6|328
						STATEMENT 1 ON LINE 1529
	     cylinder = devtab.cylinder;

006721  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
006722  aa  7 00001 2361 00	ldq  	pr7|1		devtab.cylinder
006723  aa  6 00113 7561 00	stq  	pr6|75		cylinder
						STATEMENT 1 ON LINE 1530
	     best_seek = 1.0e+30;

006724  aa   771365 4310 04	fld  	-3339,ic		000311 = 310623713116
006725  aa  6 00516 4551 00	fst  	pr6|334		best_seek
						STATEMENT 1 ON LINE 1535
seek_loop:
	     type = quentry.type;

006726  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
006727  aa  7 00001 2351 00	lda  	pr7|1		quentry.type
006730  aa   000002 7350 00	als  	2
006731  aa   000104 7730 00	lrl  	68
006732  aa  6 00530 7561 00	stq  	pr6|344		type
						STATEMENT 1 ON LINE 1537
	     this_seek = float (abs (quentry.cylinder - cylinder) * devtab.opt_info (type).multiplier);

006733  aa   000012 4020 07	mpy  	10,dl
006734  aa  7 00002 2351 00	lda  	pr7|2		quentry.cylinder
006735  aa   000031 7350 00	als  	25
006736  aa   000000 6270 06	eax7 	0,ql
006737  aa   000075 7730 00	lrl  	61
006740  aa  6 00113 1761 00	sbq  	pr6|75		cylinder
006741  aa   000003 6050 04	tpl  	3,ic		006744
006742  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
006743  aa   000001 0760 07	adq  	1,dl
006744  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
006745  aa  6 00272 3715 20	epp5 	pr6|186,*		dp
006746  aa  5 00012 4611 17	fmp  	pr5|10,7		devtab.multiplier
006747  aa  6 00517 4551 00	fst  	pr6|335		this_seek
						STATEMENT 1 ON LINE 1538
	     if this_seek = 0.0 then
		goto seek_on_cylinder;

006750  aa   000017 6000 04	tze  	15,ic		006767
						STATEMENT 1 ON LINE 1541
	     if this_seek < best_seek then do;

006751  aa  6 00516 5151 00	fcmp 	pr6|334		best_seek
006752  aa   000003 6050 04	tpl  	3,ic		006755
						STATEMENT 1 ON LINE 1542
		best_seek = this_seek;

006753  aa  6 00516 4551 00	fst  	pr6|334		best_seek
						STATEMENT 1 ON LINE 1543
		best_qp = qp;

006754  aa  6 00524 6535 00	spri7	pr6|340		best_qp
						STATEMENT 1 ON LINE 1544
	     end;

						STATEMENT 1 ON LINE 1548
	     qrp = quentry.next;

006755  aa  7 00000 2351 00	lda  	pr7|0		quentry.next
006756  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
006757  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 1549
	     if qrp = "0"b then
		goto seek_found;

006760  aa   000005 6000 04	tze  	5,ic		006765
						STATEMENT 1 ON LINE 1552
	     qp = ptr (disksp, qrp);

006761  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
006762  aa   000000 3120 01	eawp2	0,au
006763  aa  6 00266 2521 00	spri2	pr6|182		qp
						STATEMENT 1 ON LINE 1553
	     goto seek_loop;

006764  aa   777742 7100 04	tra  	-30,ic		006726
						STATEMENT 1 ON LINE 1556
seek_found:
	     qp = best_qp;

006765  aa  6 00524 3535 20	epp3 	pr6|340,*		best_qp
006766  aa  6 00266 2535 00	spri3	pr6|182		qp
						STATEMENT 1 ON LINE 1558
seek_on_cylinder:					/* qp -> entry */
	     qrp = rel (qp);

006767  aa  6 00266 6351 20	eaa  	pr6|182,*		qp
006770  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 1560
	     return;

006771  aa  6 00510 6101 00	rtcd 	pr6|328
ENTRY TO comb                                               STATEMENT 1 ON LINE 1565
comb:
	entry;

006772  aa  6 00510 6501 00	spri4	pr6|328
						STATEMENT 1 ON LINE 1568
	     devtab.comb = devtab.comb + 1;

006773  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
006774  aa  7 00002 2351 00	lda  	pr7|2		devtab.comb
006775  aa   000044 7330 00	lrs  	36
006776  aa   000001 0330 07	adl  	1,dl
006777  aa  7 00002 7561 00	stq  	pr7|2		devtab.comb
						STATEMENT 1 ON LINE 1569
	     cylinder = devtab.cylinder;

007000  aa  7 00001 2361 00	ldq  	pr7|1		devtab.cylinder
007001  aa  6 00113 7561 00	stq  	pr6|75		cylinder
						STATEMENT 1 ON LINE 1570
	     best_pos_comb = 34359738367;

007002  aa   771306 2360 04	ldq  	-3386,ic		000310 = 377777777777
007003  aa  6 00520 7561 00	stq  	pr6|336		best_pos_comb
						STATEMENT 1 ON LINE 1571
	     best_neg_comb = -34359738367;

007004  aa   771303 2360 04	ldq  	-3389,ic		000307 = 400000000001
007005  aa  6 00521 7561 00	stq  	pr6|337		best_neg_comb
						STATEMENT 1 ON LINE 1576
comb_loop:
	     if devtab.forward then
		this_comb = quentry.cylinder - cylinder;

007006  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.forward
007007  aa   000020 3150 03	cana 	16,du
007010  aa   000007 6000 04	tze  	7,ic		007017
007011  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
007012  aa  7 00002 2361 00	ldq  	pr7|2		quentry.cylinder
007013  aa  0 00412 3771 00	anaq 	pr0|266		= 000000000000 000000003777
007014  aa  6 00113 1761 00	sbq  	pr6|75		cylinder
007015  aa  6 00522 7561 00	stq  	pr6|338		this_comb
007016  aa   000010 7100 04	tra  	8,ic		007026
						STATEMENT 1 ON LINE 1579
	     else this_comb = cylinder - quentry.cylinder;

007017  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
007020  aa  7 00002 2361 00	ldq  	pr7|2		quentry.cylinder
007021  aa  0 00412 3771 00	anaq 	pr0|266		= 000000000000 000000003777
007022  aa  6 01454 7561 00	stq  	pr6|812		quentry.cylinder
007023  aa  6 00113 2361 00	ldq  	pr6|75		cylinder
007024  aa  6 01454 1761 00	sbq  	pr6|812		quentry.cylinder
007025  aa  6 00522 7561 00	stq  	pr6|338		this_comb
						STATEMENT 1 ON LINE 1581
	     if this_comb = 0 then			/* ON-CYLINDER */
		goto seek_on_cylinder;

007026  aa   777741 6000 04	tze  	-31,ic		006767
						STATEMENT 1 ON LINE 1583
	     else if this_comb > 0			/* same direction */
	     then do;

007027  aa   000006 6044 04	tmoz 	6,ic		007035
						STATEMENT 1 ON LINE 1585
		if this_comb < best_pos_comb then do;

007030  aa  6 00520 1161 00	cmpq 	pr6|336		best_pos_comb
007031  aa   000010 6050 04	tpl  	8,ic		007041
						STATEMENT 1 ON LINE 1586
		     best_pos_comb = this_comb;

007032  aa  6 00520 7561 00	stq  	pr6|336		best_pos_comb
						STATEMENT 1 ON LINE 1587
		     best_qp = qp;

007033  aa  6 00524 6535 00	spri7	pr6|340		best_qp
						STATEMENT 1 ON LINE 1588
		end;

						STATEMENT 1 ON LINE 1589
	     end;

007034  aa   000005 7100 04	tra  	5,ic		007041
						STATEMENT 1 ON LINE 1590
	     else do;

						STATEMENT 1 ON LINE 1591
		if this_comb > best_neg_comb then do;

007035  aa  6 00521 1161 00	cmpq 	pr6|337		best_neg_comb
007036  aa   000003 6044 04	tmoz 	3,ic		007041
						STATEMENT 1 ON LINE 1592
		     best_neg_comb = this_comb;

007037  aa  6 00521 7561 00	stq  	pr6|337		best_neg_comb
						STATEMENT 1 ON LINE 1593
		     best_neg_qp = qp;

007040  aa  6 00526 6535 00	spri7	pr6|342		best_neg_qp
						STATEMENT 1 ON LINE 1594
		end;

						STATEMENT 1 ON LINE 1595
	     end;

						STATEMENT 1 ON LINE 1597
	     qrp = quentry.next;

007041  aa  7 00000 2351 00	lda  	pr7|0		quentry.next
007042  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
007043  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 1598
	     if qrp = "0"b then
		goto comb_found;

007044  aa   000005 6000 04	tze  	5,ic		007051
						STATEMENT 1 ON LINE 1600
	     qp = ptr (disksp, qrp);

007045  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
007046  aa   000000 3120 01	eawp2	0,au
007047  aa  6 00266 2521 00	spri2	pr6|182		qp
						STATEMENT 1 ON LINE 1601
	     goto comb_loop;

007050  aa   777736 7100 04	tra  	-34,ic		007006
						STATEMENT 1 ON LINE 1604
comb_found:
	     if best_pos_comb ^= 34359738367 then	/* if we found forward. */
		qp = best_qp;

007051  aa  6 00520 2351 00	lda  	pr6|336		best_pos_comb
007052  aa   000044 7330 00	lrs  	36
007053  aa   771307 1170 04	cmpaq	-3385,ic		000362 = 000000000000 377777777777
007054  aa   000004 6000 04	tze  	4,ic		007060
007055  aa  6 00524 3715 20	epp5 	pr6|340,*		best_qp
007056  aa  6 00266 6515 00	spri5	pr6|182		qp
007057  aa   000003 7100 04	tra  	3,ic		007062
						STATEMENT 1 ON LINE 1607
	     else qp = best_neg_qp;

007060  aa  6 00526 3715 20	epp5 	pr6|342,*		best_neg_qp
007061  aa  6 00266 6515 00	spri5	pr6|182		qp
						STATEMENT 1 ON LINE 1608
	     qrp = rel (qp);

007062  aa  6 00266 6351 20	eaa  	pr6|182,*		qp
007063  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 1609
	     return;

007064  aa  6 00510 6101 00	rtcd 	pr6|328
						STATEMENT 1 ON LINE 1610
	end find_shortest_seek;

  END PROCEDURE find_shortest_seek
  END PROCEDURE getwork
BEGIN PROCEDURE connect
ENTRY TO connect                                            STATEMENT 1 ON LINE 1731
connect:
     procedure (listp);

007065  aa  6 00532 6501 00	spri4	pr6|346
007066  aa  6 00534 2521 00	spri2	pr6|348
						STATEMENT 1 ON LINE 1737
	ima.chx = chantab.chx;

007067  aa  6 00270 2361 20	ldq  	pr6|184,*		chantab.chx
007070  aa  6 00540 7561 00	stq  	pr6|352		ima.chx
						STATEMENT 1 ON LINE 1738
	ima.pcw = ""b;

007071  aa  6 00542 4501 00	stz  	pr6|354		ima.pcw
						STATEMENT 1 ON LINE 1739
	ima.ptp = null ();

007072  aa   771272 2370 04	ldaq 	-3398,ic		000364 = 077777000043 000001000000
007073  aa  6 00544 7571 00	staq 	pr6|356		ima.ptp
						STATEMENT 1 ON LINE 1740
	ima.listp = listp;

007074  aa  2 00002 3735 20	epp7 	pr2|2,*		listp
007075  aa  7 00000 3735 20	epp7 	pr7|0,*		listp
007076  aa  6 00546 6535 00	spri7	pr6|358		ima.listp
						STATEMENT 1 ON LINE 1741
	call io_manager$connect_abs (ima);

007077  aa  6 00540 3521 00	epp2 	pr6|352		ima
007100  aa  6 01460 2521 00	spri2	pr6|816
007101  aa  6 01456 6211 00	eax1 	pr6|814
007102  aa   004000 4310 07	fld  	2048,dl
007103  aa  6 00044 3701 20	epp4 	pr6|36,*
007104  la  4 00052 3521 20	epp2 	pr4|42,*		io_manager$connect_abs
007105  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1743
	chantab.connects = chantab.connects + 1;

007106  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
007107  aa  7 00016 0541 00	aos  	pr7|14		chantab.connects
						STATEMENT 1 ON LINE 1744
	chantab.active = "1"b;

007110  aa   200000 2350 07	lda  	65536,dl
007111  aa  7 00006 2551 00	orsa 	pr7|6		chantab.active
						STATEMENT 1 ON LINE 1745
	chantab.connect_time = clock ();

007112  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
007113  aa  6 00270 3735 20	epp7 	pr6|184,*		cp
007114  aa  7 00014 7571 00	staq 	pr7|12		chantab.connect_time
						STATEMENT 1 ON LINE 1747
	disktab.dev_busy = disktab.dev_busy | dev_mask (pdi);

007115  aa  6 00145 2361 00	ldq  	pr6|101		pdi
007116  aa   000001 7360 00	qls  	1
007117  ta   000076 2350 06	lda  	62,ql
007120  ta   000077 2360 06	ldq  	63,ql
007121  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
007122  aa  5 00004 2551 00	orsa 	pr5|4		disktab.dev_busy
007123  aa  5 00005 2561 00	orsq 	pr5|5		disktab.dev_busy
						STATEMENT 1 ON LINE 1750
	return;

007124  aa  6 00532 6101 00	rtcd 	pr6|346
						STATEMENT 1 ON LINE 1753
     end connect;

  END PROCEDURE connect
BEGIN PROCEDURE post
ENTRY TO post                                               STATEMENT 1 ON LINE 1759
post:
     proc;

007125  aa  6 00552 6501 00	spri4	pr6|362
						STATEMENT 1 ON LINE 1762
	if /* case */ io_type = TEST then do;

007126  aa  6 00131 2361 00	ldq  	pr6|89		io_type
007127  aa   000004 1160 07	cmpq 	4,dl
007130  aa   000003 6010 04	tnz  	3,ic		007133
						STATEMENT 1 ON LINE 1765
	     post_sw = "0"b;

007131  aa  6 00146 4501 00	stz  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1766
	     return;

007132  aa  6 00552 6101 00	rtcd 	pr6|362
						STATEMENT 1 ON LINE 1767
	end;

						STATEMENT 1 ON LINE 1770
	if sect_sw then				/* If 64-word I/O ... */
	     if bootload_sw then
		call bootload_disk_post (coreadd, errcd);

007133  aa  6 00156 2351 00	lda  	pr6|110		sect_sw
007134  aa   000027 6000 04	tze  	23,ic		007163
007135  aa  6 00105 2351 00	lda  	pr6|69		bootload_sw
007136  aa   000013 6000 04	tze  	11,ic		007151
007137  aa  6 00101 3521 00	epp2 	pr6|65		coreadd
007140  aa  6 01464 2521 00	spri2	pr6|820
007141  aa  6 00126 3521 00	epp2 	pr6|86		errcd
007142  aa  6 01466 2521 00	spri2	pr6|822
007143  aa  6 01462 6211 00	eax1 	pr6|818
007144  aa   010000 4310 07	fld  	4096,dl
007145  aa  6 00044 3701 20	epp4 	pr6|36,*
007146  la  4 00022 3521 20	epp2 	pr4|18,*		bootload_disk_post
007147  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
007150  aa   000024 7100 04	tra  	20,ic		007174
						STATEMENT 1 ON LINE 1773
	     else call vtoc_interrupt (coreadd, errcd);

007151  aa  6 00101 3521 00	epp2 	pr6|65		coreadd
007152  aa  6 01464 2521 00	spri2	pr6|820
007153  aa  6 00126 3521 00	epp2 	pr6|86		errcd
007154  aa  6 01466 2521 00	spri2	pr6|822
007155  aa  6 01462 6211 00	eax1 	pr6|818
007156  aa   010000 4310 07	fld  	4096,dl
007157  aa  6 00044 3701 20	epp4 	pr6|36,*
007160  la  4 00040 3521 20	epp2 	pr4|32,*		vtoc_interrupt
007161  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
007162  aa   000012 7100 04	tra  	10,ic		007174
						STATEMENT 1 ON LINE 1774
	else					/* If page I/O ... */
	     call page$done (coreadd, errcd);

007163  aa  6 00101 3521 00	epp2 	pr6|65		coreadd
007164  aa  6 01464 2521 00	spri2	pr6|820
007165  aa  6 00126 3521 00	epp2 	pr6|86		errcd
007166  aa  6 01466 2521 00	spri2	pr6|822
007167  aa  6 01462 6211 00	eax1 	pr6|818
007170  aa   010000 4310 07	fld  	4096,dl
007171  aa  6 00044 3701 20	epp4 	pr6|36,*
007172  la  4 00032 3521 20	epp2 	pr4|26,*		page$done
007173  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1777
	post_sw = "0"b;

007174  aa  6 00146 4501 00	stz  	pr6|102		post_sw
						STATEMENT 1 ON LINE 1779
	return;

007175  aa  6 00552 6101 00	rtcd 	pr6|362
						STATEMENT 1 ON LINE 1782
     end post;

  END PROCEDURE post
BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 1938
setup:
     proc;

007176  aa  6 00560 6501 00	spri4	pr6|368
						STATEMENT 1 ON LINE 1942
	disksp = addr (disk_seg$);

007177  aa  6 00044 3701 20	epp4 	pr6|36,*
007200  la  4 00050 3735 20	epp7 	pr4|40,*		disk_seg$
007201  aa  6 00256 6535 00	spri7	pr6|174		disksp
						STATEMENT 1 ON LINE 1943
	pvt_arrayp = addr (pvt$array);

007202  la  4 00056 3715 20	epp5 	pr4|46,*		pvt$array
007203  aa  6 00312 6515 00	spri5	pr6|202		pvt_arrayp
						STATEMENT 1 ON LINE 1944
	diskp = ptr (disksp, disk_data.offset (sx));

007204  aa  6 00162 2361 00	ldq  	pr6|114		sx
007205  aa   000001 7360 00	qls  	1
007206  aa  7 00007 2351 06	lda  	pr7|7,ql		disk_data.offset
007207  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
007210  aa  7 00000 3521 00	epp2 	pr7|0
007211  aa   000000 3120 01	eawp2	0,au
007212  aa  6 00260 2521 00	spri2	pr6|176		diskp
						STATEMENT 1 ON LINE 1946
	return;

007213  aa  6 00560 6101 00	rtcd 	pr6|368
						STATEMENT 1 ON LINE 1949
     end setup;

  END PROCEDURE setup
BEGIN PROCEDURE disk_name
ENTRY TO disk_name                                          STATEMENT 1 ON LINE 1955
disk_name:
     proc (both) returns (char (21) aligned);

007214  aa  6 00566 6501 00	spri4	pr6|374
007215  aa  6 00570 2521 00	spri2	pr6|376
						STATEMENT 1 ON LINE 1965
	if dev = pdi				/* If this is the priamry, we must rely on buddy */
	     then
	     other_dev = disktab.devtab (pdi).buddy;

007216  aa  6 00120 2361 00	ldq  	pr6|80		dev
007217  aa  6 00145 1161 00	cmpq 	pr6|101		pdi
007220  aa   000011 6010 04	tnz  	9,ic		007231
007221  aa  6 00145 2361 00	ldq  	pr6|101		pdi
007222  aa   000120 4020 07	mpy  	80,dl
007223  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
007224  aa  7 00036 2351 06	lda  	pr7|30,ql		disktab.buddy
007225  aa   000030 7350 00	als  	24
007226  aa   000102 7730 00	lrl  	66
007227  aa  6 00601 7561 00	stq  	pr6|385		other_dev
007230  aa   000003 7100 04	tra  	3,ic		007233
						STATEMENT 1 ON LINE 1968
	else other_dev = pdi;

007231  aa  6 00145 2361 00	ldq  	pr6|101		pdi
007232  aa  6 00601 7561 00	stq  	pr6|385		other_dev
						STATEMENT 1 ON LINE 1970
	this_name = disk_data.name (sx) || "_" || convert (pic99, dev);

007233  aa  6 00162 2361 00	ldq  	pr6|114		sx
007234  aa   000001 7360 00	qls  	1
007235  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
007236  aa  7 00010 2351 06	lda  	pr7|8,ql		disk_data.name
007237  aa  6 01470 7561 00	stq  	pr6|824
007240  aa   137000 2360 03	ldq  	48640,du
007241  aa  6 01472 7571 00	staq 	pr6|826
007242  aa  000 100 301 500	btd  	(pr),(pr)
007243  aa  6 00120 00 0004	desc9a	pr6|80,4		dev
007244  aa  6 01471 01 0003	desc9ls	pr6|825,3,0
007245  aa  6 01474 4501 00	stz  	pr6|828
007246  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
007247  aa  6 01471 01 0003	desc9ls	pr6|825,3,0
007250  aa   001027 00 0002	desc9a	535,2		010275 = 070322000000
007251  aa  6 01474 00 0002	desc9a	pr6|828,2
007252  aa  6 01474 2351 00	lda  	pr6|828
007253  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
007254  aa   000055 7730 00	lrl  	45
007255  aa  6 01472 2771 00	oraq 	pr6|826
007256  aa  0 00456 2771 00	oraq 	pr0|302		= 000000000000 000000000040
007257  aa  6 00574 7571 00	staq 	pr6|380		this_name
						STATEMENT 1 ON LINE 1971
	if other_dev = 0 then
	     other_name = "";

007260  aa  6 00601 2361 00	ldq  	pr6|385		other_dev
007261  aa   000005 6010 04	tnz  	5,ic		007266
007262  aa  040 100 100 400	mlr  	(),(pr),fill(040)
007263  aa   000000 00 0000	desc9a	0,0
007264  aa  6 00576 00 0014	desc9a	pr6|382,12	other_name
007265  aa   000036 7100 04	tra  	30,ic		007323
						STATEMENT 1 ON LINE 1973
	else other_name = " and " || disk_data.name (sx) || "_" || convert (pic99, other_dev);

007266  aa  000 100 301 500	btd  	(pr),(pr)
007267  aa  6 00601 00 0004	desc9a	pr6|385,4		other_dev
007270  aa  6 01475 01 0003	desc9ls	pr6|829,3,0
007271  aa  6 01471 4501 00	stz  	pr6|825
007272  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
007273  aa  6 01475 01 0003	desc9ls	pr6|829,3,0
007274  aa   001003 00 0002	desc9a	515,2		010275 = 070322000000
007275  aa  6 01471 00 0002	desc9a	pr6|825,2
007276  aa   000011 2360 07	ldq  	9,dl
007277  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
007300  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
007301  aa   771060 00 0005	desc9a	-3536,5		000360 = 040141156144
007302  aa  2 00000 00 0005	desc9a	pr2|0,5
007303  aa  6 01470 7271 00	lxl7 	pr6|824
007304  aa  7 00010 3715 17	epp5 	pr7|8,7		disk_data.name
007305  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007306  aa  5 00000 00 0004	desc9a	pr5|0,4		disk_data.name
007307  aa  2 00001 20 0004	desc9a	pr2|1(1),4
007310  aa   000012 2360 07	ldq  	10,dl
007311  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
007312  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
007313  aa   001104 00 0001	desc9a	580,1		010416 = 137000000000
007314  aa  2 00002 20 0001	desc9a	pr2|2(1),1
007315  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007316  aa  2 00000 00 0012	desc9a	pr2|0,10
007317  aa  6 00576 00 0012	desc9a	pr6|382,10	other_name
007320  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007321  aa  6 01471 00 0002	desc9a	pr6|825,2
007322  aa  6 00600 40 0002	desc9a	pr6|384(2),2	other_name
						STATEMENT 1 ON LINE 1975
	if both					/* return both device names, if appropriate */
	     then
	     return (this_name || other_name);

007323  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
007324  aa  6 00570 3715 20	epp5 	pr6|376,*
007325  aa  5 00002 2351 20	lda  	pr5|2,*		both
007326  aa   400000 3150 03	cana 	131072,du
007327  aa   000017 6000 04	tze  	15,ic		007346
007330  aa   000024 2360 07	ldq  	20,dl
007331  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
007332  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007333  aa  6 00574 00 0010	desc9a	pr6|380,8		this_name
007334  aa  2 00000 00 0010	desc9a	pr2|0,8
007335  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007336  aa  6 00576 00 0014	desc9a	pr6|382,12	other_name
007337  aa  2 00002 00 0014	desc9a	pr2|2,12
007340  aa  5 00004 3535 20	epp3 	pr5|4,*
007341  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007342  aa  2 00000 00 0024	desc9a	pr2|0,20
007343  aa  3 00000 00 0025	desc9a	pr3|0,21
007344  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
007345  aa  6 00566 6101 00	rtcd 	pr6|374
						STATEMENT 1 ON LINE 1978
	else return (this_name);

007346  aa  5 00004 3535 20	epp3 	pr5|4,*
007347  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
007350  aa  6 00574 00 0010	desc9a	pr6|380,8		this_name
007351  aa  3 00000 00 0025	desc9a	pr3|0,21
007352  aa  6 00566 6101 00	rtcd 	pr6|374
						STATEMENT 1 ON LINE 1981
     end disk_name;

  END PROCEDURE disk_name
BEGIN PROCEDURE lock
ENTRY TO lock                                               STATEMENT 1 ON LINE 1986
lock:
     proc (lmp);

007353  aa  6 00602 6501 00	spri4	pr6|386
007354  aa  6 00604 2521 00	spri2	pr6|388
						STATEMENT 1 ON LINE 1994
	dlm.count = dlm.count + 1;

007355  aa  2 00002 3735 20	epp7 	pr2|2,*		lmp
007356  aa  7 00000 0541 20	aos  	pr7|0,*		dlm.count
						STATEMENT 1 ON LINE 1995
	if ^stacq (disktab.lock, pds$processid, UNLOCK) then do;

007357  aa  6 00044 3701 20	epp4 	pr6|36,*
007360  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
007361  aa  6 00260 3521 20	epp2 	pr6|176,*		disktab.lock
007362  aa   000000 2360 07	ldq  	0,dl
007363  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007364  aa   000026 6010 04	tnz  	22,ic		007412
						STATEMENT 1 ON LINE 1997
	     call lock_meter_start (lmp);

007365  aa  6 00604 3715 20	epp5 	pr6|388,*
007366  aa  5 00002 3521 20	epp2 	pr5|2,*		lmp
007367  aa  6 01500 2521 00	spri2	pr6|832
007370  aa  6 01476 3521 00	epp2 	pr6|830
007371  aa   004000 4310 07	fld  	2048,dl
007372  aa  2 00000 7571 00	staq 	pr2|0
007373  aa   000027 6700 04	tsp4 	23,ic		007422
						STATEMENT 1 ON LINE 1998
	     do while (^stacq (disktab.lock, pds$processid, UNLOCK));

007374  aa  6 00044 3701 20	epp4 	pr6|36,*
007375  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
007376  aa  6 00260 3521 20	epp2 	pr6|176,*		disktab.lock
007377  aa   000000 2360 07	ldq  	0,dl
007400  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007401  aa   000002 6010 04	tnz  	2,ic		007403
						STATEMENT 1 ON LINE 1999
	     end;

007402  aa   777772 7100 04	tra  	-6,ic		007374
						STATEMENT 1 ON LINE 2000
	     call lock_meter_stop (lmp);

007403  aa  6 00604 3735 20	epp7 	pr6|388,*
007404  aa  7 00002 3521 20	epp2 	pr7|2,*		lmp
007405  aa  6 01500 2521 00	spri2	pr6|832
007406  aa  6 01476 3521 00	epp2 	pr6|830
007407  aa   004000 4310 07	fld  	2048,dl
007410  aa  2 00000 7571 00	staq 	pr2|0
007411  aa   000021 6700 04	tsp4 	17,ic		007432
						STATEMENT 1 ON LINE 2001
	end;

						STATEMENT 1 ON LINE 2003
	return;

007412  aa  6 00602 6101 00	rtcd 	pr6|386
ENTRY TO unlock                                             STATEMENT 1 ON LINE 2006
unlock:
     entry;

007413  aa  6 00602 6501 00	spri4	pr6|386
						STATEMENT 1 ON LINE 2009
	if ^stacq (disktab.lock, UNLOCK, disktab.lock) then
	     ;

007414  aa   000000 2350 07	lda  	0,dl
007415  aa  6 00260 3521 20	epp2 	pr6|176,*		disktab.lock
007416  aa  2 00000 2361 00	ldq  	pr2|0		disktab.lock
007417  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007420  aa   000001 6010 04	tnz  	1,ic		007421
						STATEMENT 1 ON LINE 2012
	return;

007421  aa  6 00602 6101 00	rtcd 	pr6|386
						STATEMENT 1 ON LINE 2015
     end lock;

  END PROCEDURE lock
BEGIN PROCEDURE lock_meter_start
ENTRY TO lock_meter_start                                   STATEMENT 1 ON LINE 2021
lock_meter_start:
     proc (lmp);

007422  aa  6 00610 6501 00	spri4	pr6|392
007423  aa  6 00612 2521 00	spri2	pr6|394
						STATEMENT 1 ON LINE 2028
	meter_start_time = clock ();

007424  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
007425  aa  6 00142 7571 00	staq 	pr6|98		meter_start_time
						STATEMENT 1 ON LINE 2029
	dlm.waits = dlm.waits + 1;

007426  aa  2 00002 3735 20	epp7 	pr2|2,*		lmp
007427  aa  7 00000 3735 20	epp7 	pr7|0,*		lmp
007430  aa  7 00001 0541 00	aos  	pr7|1		dlm.waits
						STATEMENT 1 ON LINE 2031
	return;

007431  aa  6 00610 6101 00	rtcd 	pr6|392
ENTRY TO lock_meter_stop                                    STATEMENT 1 ON LINE 2034
lock_meter_stop:
     entry (lmp);

007432  aa  6 00610 6501 00	spri4	pr6|392
007433  aa  6 00612 2521 00	spri2	pr6|394
						STATEMENT 1 ON LINE 2037
	dlm.wait_time = dlm.wait_time + (clock () - meter_start_time);

007434  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
007435  aa  6 00142 1771 00	sbaq 	pr6|98		meter_start_time
007436  aa  6 00612 3735 20	epp7 	pr6|394,*
007437  aa  7 00002 3715 20	epp5 	pr7|2,*		lmp
007440  aa  5 00000 3715 20	epp5 	pr5|0,*		lmp
007441  aa  5 00002 0771 00	adaq 	pr5|2		dlm.wait_time
007442  aa  5 00002 7571 00	staq 	pr5|2		dlm.wait_time
						STATEMENT 1 ON LINE 2039
	return;

007443  aa  6 00610 6101 00	rtcd 	pr6|392
						STATEMENT 1 ON LINE 2042
     end lock_meter_start;

  END PROCEDURE lock_meter_start
BEGIN PROCEDURE get_free_q
ENTRY TO get_free_q                                         STATEMENT 1 ON LINE 2046
get_free_q:
     proc returns (bit (1) aligned);

007444  aa  6 00616 6501 00	spri4	pr6|398
007445  aa  6 00620 2521 00	spri2	pr6|400
007446  aa   000001 2360 07	ldq  	1,dl
007447  aa  6 00625 7561 00	stq  	pr6|405
						STATEMENT 1 ON LINE 2053
	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));

007450  aa  6 00044 3701 20	epp4 	pr6|36,*
007451  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
007452  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
007453  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
007454  aa   000000 2360 07	ldq  	0,dl
007455  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007456  aa   000002 6010 04	tnz  	2,ic		007460
						STATEMENT 1 ON LINE 2054
	end;

007457  aa   777771 7100 04	tra  	-7,ic		007450
						STATEMENT 1 ON LINE 2056
	qrp = disk_data.free_q.head;

007460  aa  7 00007 2351 00	lda  	pr7|7		disk_data.head
007461  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
007462  aa  6 00152 7551 00	sta  	pr6|106		qrp
						STATEMENT 1 ON LINE 2057
	if qrp then do;

007463  aa   000071 6000 04	tze  	57,ic		007554
						STATEMENT 1 ON LINE 2058
	     qp = ptr (disksp, qrp);

007464  aa  7 00000 3521 00	epp2 	pr7|0
007465  aa   000000 3120 01	eawp2	0,au
007466  aa  6 00266 2521 00	spri2	pr6|182		qp
						STATEMENT 1 ON LINE 2059
	     disk_data.free_q.head = quentry.next;

007467  aa  2 00000 2351 00	lda  	pr2|0		quentry.next
007470  aa  7 00007 5511 60	stba 	pr7|7,60		disk_data.head
						STATEMENT 1 ON LINE 2063
	     if disk_data.free_q.head = "0"b then
		disk_data.free_q.tail = "0"b;

007471  aa   777777 3150 03	cana 	262143,du
007472  aa   000004 6010 04	tnz  	4,ic		007476
007473  aa   777777 2350 03	lda  	262143,du
007474  aa  7 00007 3551 00	ansa 	pr7|7		disk_data.tail
007475  aa   000007 7100 04	tra  	7,ic		007504
						STATEMENT 1 ON LINE 2065
	     else ptr (disksp, quentry.next) -> quentry.prev = "0"b;

007476  aa  2 00000 2351 00	lda  	pr2|0		quentry.next
007477  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
007500  aa  7 00000 3515 00	epp1 	pr7|0
007501  aa   000000 3114 01	eawp1	0,au
007502  aa   777777 2350 03	lda  	262143,du
007503  aa  1 00000 3551 00	ansa 	pr1|0		quentry.prev
						STATEMENT 1 ON LINE 2069
	     disk_data.free_q.sum = disk_data.free_q.sum + disk_data.free_q.depth;

007504  aa  7 00006 2351 00	lda  	pr7|6		disk_data.depth
007505  aa   000022 7350 00	als  	18
007506  aa   000066 7330 00	lrs  	54
007507  aa  6 01504 7561 00	stq  	pr6|836		disk_data.depth
007510  aa   000044 7770 00	llr  	36
007511  aa   000044 7330 00	lrs  	36
007512  aa  7 00004 0331 00	adl  	pr7|4		disk_data.sum
007513  aa  7 00004 7561 00	stq  	pr7|4		disk_data.sum
						STATEMENT 1 ON LINE 2070
	     disk_data.free_q.depth = disk_data.free_q.depth + 1;

007514  aa  6 01504 2361 00	ldq  	pr6|836		disk_data.depth
007515  aa   000001 0760 07	adq  	1,dl
007516  aa  7 00006 5521 14	stbq 	pr7|6,14		disk_data.depth
						STATEMENT 1 ON LINE 2071
	     if disk_data.free_q.depth > disk_data.free_q.max_depth then
		disk_data.free_q.max_depth = disk_data.free_q.depth;

007517  aa  7 00006 2351 00	lda  	pr7|6		disk_data.max_depth
007520  aa   000066 7330 00	lrs  	54
007521  aa  6 01504 7561 00	stq  	pr6|836		disk_data.max_depth
007522  aa  7 00006 2351 00	lda  	pr7|6		disk_data.depth
007523  aa   000022 7350 00	als  	18
007524  aa   000066 7330 00	lrs  	54
007525  aa  6 01504 1161 00	cmpq 	pr6|836		disk_data.max_depth
007526  aa   000003 6044 04	tmoz 	3,ic		007531
007527  aa   000066 7370 00	lls  	54
007530  aa  7 00006 5511 60	stba 	pr7|6,60		disk_data.max_depth
						STATEMENT 1 ON LINE 2073
	     disk_data.free_q.count = disk_data.free_q.count + 1;

007531  aa  7 00005 2351 00	lda  	pr7|5		disk_data.count
007532  aa   000044 7330 00	lrs  	36
007533  aa   000001 0330 07	adl  	1,dl
007534  aa  7 00005 7561 00	stq  	pr7|5		disk_data.count
						STATEMENT 1 ON LINE 2075
	     if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
		;

007535  aa   000000 2350 07	lda  	0,dl
007536  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
007537  aa  2 00000 2361 00	ldq  	pr2|0		disk_data.lock
007540  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007541  aa   000001 6010 04	tnz  	1,ic		007542
						STATEMENT 1 ON LINE 2077
	     return (SUCCESS);

007542  aa  6 00625 2361 00	ldq  	pr6|405
007543  aa   000005 6010 04	tnz  	5,ic		007550
007544  aa   000027 7260 07	lxl6 	23,dl
007545  aa   770652 3520 04	epp2 	-3670,ic		000417 = 162145164165
007546  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
007547  aa  6 00616 6101 00	rtcd 	pr6|398
007550  aa   400000 2350 03	lda  	131072,du
007551  aa  6 00620 3715 20	epp5 	pr6|400,*
007552  aa  5 00002 7551 20	sta  	pr5|2,*
007553  aa  6 00616 6101 00	rtcd 	pr6|398
						STATEMENT 1 ON LINE 2078
	end;

						STATEMENT 1 ON LINE 2079
	else do;

						STATEMENT 1 ON LINE 2080
	     if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
		;

007554  aa   000000 2350 07	lda  	0,dl
007555  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
007556  aa  2 00000 2361 00	ldq  	pr2|0		disk_data.lock
007557  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007560  aa   000001 6010 04	tnz  	1,ic		007561
						STATEMENT 1 ON LINE 2082
	     return (FAILURE);

007561  aa  6 00625 2361 00	ldq  	pr6|405
007562  aa   000005 6010 04	tnz  	5,ic		007567
007563  aa   000027 7260 07	lxl6 	23,dl
007564  aa   770633 3520 04	epp2 	-3685,ic		000417 = 162145164165
007565  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
007566  aa  6 00616 6101 00	rtcd 	pr6|398
007567  aa  6 00620 3715 20	epp5 	pr6|400,*
007570  aa  5 00002 4501 20	stz  	pr5|2,*
007571  aa  6 00616 6101 00	rtcd 	pr6|398
						STATEMENT 1 ON LINE 2083
	end;

ENTRY TO add_free_q                                         STATEMENT 1 ON LINE 2087
add_free_q:
     entry;

007572  aa  6 00616 6501 00	spri4	pr6|398
007573  aa  6 00625 4501 00	stz  	pr6|405
						STATEMENT 1 ON LINE 2090
	quentry.used = "0"b;

007574  aa   000500 2350 04	lda  	320,ic		010274 = 577777777777
007575  aa  6 00266 3735 20	epp7 	pr6|182,*		qp
007576  aa  7 00001 3551 00	ansa 	pr7|1		quentry.used
						STATEMENT 1 ON LINE 2094
	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));

007577  aa   000000 0110 03	nop  	0,du
007600  aa  6 00044 3701 20	epp4 	pr6|36,*
007601  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
007602  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
007603  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
007604  aa   000000 2360 07	ldq  	0,dl
007605  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007606  aa   000002 6010 04	tnz  	2,ic		007610
						STATEMENT 1 ON LINE 2095
	end;

007607  aa   777771 7100 04	tra  	-7,ic		007600
						STATEMENT 1 ON LINE 2099
	if disk_data.free_q.tail ^= "0"b then
	     ptr (disksp, disk_data.free_q.tail) -> quentry.next = qrp;

007610  aa  7 00007 2351 00	lda  	pr7|7		disk_data.tail
007611  aa   000022 7350 00	als  	18
007612  aa  6 01504 7551 00	sta  	pr6|836		disk_data.tail
007613  aa   000006 6000 04	tze  	6,ic		007621
007614  aa  7 00000 3521 00	epp2 	pr7|0
007615  aa   000000 3120 01	eawp2	0,au
007616  aa  6 00152 2351 00	lda  	pr6|106		qrp
007617  aa  2 00000 5511 60	stba 	pr2|0,60		quentry.next
007620  aa   000003 7100 04	tra  	3,ic		007623
						STATEMENT 1 ON LINE 2101
	else disk_data.free_q.head = qrp;

007621  aa  6 00152 2351 00	lda  	pr6|106		qrp
007622  aa  7 00007 5511 60	stba 	pr7|7,60		disk_data.head
						STATEMENT 1 ON LINE 2103
	quentry.prev = disk_data.free_q.tail;

007623  aa  7 00007 2351 00	lda  	pr7|7		disk_data.tail
007624  aa  6 00266 3715 20	epp5 	pr6|182,*		quentry.prev
007625  aa  5 00000 5511 14	stba 	pr5|0,14		quentry.prev
						STATEMENT 1 ON LINE 2104
	disk_data.free_q.tail = qrp;

007626  aa  6 00152 2351 00	lda  	pr6|106		qrp
007627  aa   000022 7710 00	arl  	18
007630  aa  7 00007 5511 14	stba 	pr7|7,14		disk_data.tail
						STATEMENT 1 ON LINE 2105
	quentry.next = "0"b;

007631  aa   777777 2350 07	lda  	262143,dl
007632  aa  6 00266 3551 20	ansa 	pr6|182,*		quentry.next
						STATEMENT 1 ON LINE 2109
	disk_data.free_q.depth = disk_data.free_q.depth - 1;

007633  aa  7 00006 2351 00	lda  	pr7|6		disk_data.depth
007634  aa   000022 7350 00	als  	18
007635  aa   000066 7330 00	lrs  	54
007636  aa   000001 1760 07	sbq  	1,dl
007637  aa  7 00006 5521 14	stbq 	pr7|6,14		disk_data.depth
						STATEMENT 1 ON LINE 2111
	if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
	     ;

007640  aa   000000 2350 07	lda  	0,dl
007641  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
007642  aa  2 00000 2361 00	ldq  	pr2|0		disk_data.lock
007643  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007644  aa   000001 6010 04	tnz  	1,ic		007645
						STATEMENT 1 ON LINE 2113
	return;

007645  aa  6 00625 2361 00	ldq  	pr6|405
007646  aa   000002 6010 04	tnz  	2,ic		007650
007647  aa  6 00616 6101 00	rtcd 	pr6|398
007650  aa   000027 7260 07	lxl6 	23,dl
007651  aa   770546 3520 04	epp2 	-3738,ic		000417 = 162145164165
007652  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
007653  aa  6 00616 6101 00	rtcd 	pr6|398
ENTRY TO add_wq                                             STATEMENT 1 ON LINE 2117
add_wq:
     entry;

007654  aa  6 00616 6501 00	spri4	pr6|398
007655  aa  6 00625 4501 00	stz  	pr6|405
						STATEMENT 1 ON LINE 2123
	disktab.dev_queued = disktab.dev_queued | dev_mask (pdi);

007656  aa  6 00145 2361 00	ldq  	pr6|101		pdi
007657  aa   000001 7360 00	qls  	1
007660  ta   000076 2350 06	lda  	62,ql
007661  ta   000077 2360 06	ldq  	63,ql
007662  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
007663  aa  7 00006 2551 00	orsa 	pr7|6		disktab.dev_queued
007664  aa  7 00007 2561 00	orsq 	pr7|7		disktab.dev_queued
						STATEMENT 1 ON LINE 2124
	if devtab.wq.tail ^= "0"b then
	     ptr (disksp, devtab.wq.tail) -> quentry.next = qrp;

007665  aa  6 00272 3715 20	epp5 	pr6|186,*		dp
007666  aa  5 00011 2351 00	lda  	pr5|9		devtab.tail
007667  aa   000022 7350 00	als  	18
007670  aa  6 01504 7551 00	sta  	pr6|836		devtab.tail
007671  aa   000006 6000 04	tze  	6,ic		007677
007672  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
007673  aa   000000 3120 01	eawp2	0,au
007674  aa  6 00152 2351 00	lda  	pr6|106		qrp
007675  aa  2 00000 5511 60	stba 	pr2|0,60		quentry.next
007676  aa   000003 7100 04	tra  	3,ic		007701
						STATEMENT 1 ON LINE 2126
	else devtab.wq.head = qrp;

007677  aa  6 00152 2351 00	lda  	pr6|106		qrp
007700  aa  5 00011 5511 60	stba 	pr5|9,60		devtab.head
						STATEMENT 1 ON LINE 2128
	quentry.prev = devtab.wq.tail;

007701  aa  5 00011 2351 00	lda  	pr5|9		devtab.tail
007702  aa  6 00266 3535 20	epp3 	pr6|182,*		quentry.prev
007703  aa  3 00000 5511 14	stba 	pr3|0,14		quentry.prev
						STATEMENT 1 ON LINE 2129
	quentry.next = "0"b;

007704  aa   777777 2350 07	lda  	262143,dl
007705  aa  6 00266 3551 20	ansa 	pr6|182,*		quentry.next
						STATEMENT 1 ON LINE 2130
	devtab.wq.tail = qrp;

007706  aa  6 00152 2351 00	lda  	pr6|106		qrp
007707  aa   000022 7710 00	arl  	18
007710  aa  5 00011 5511 14	stba 	pr5|9,14		devtab.tail
						STATEMENT 1 ON LINE 2134
	devtab.wq.sum = devtab.wq.sum + devtab.wq.depth;

007711  aa  5 00010 2351 00	lda  	pr5|8		devtab.depth
007712  aa   000022 7350 00	als  	18
007713  aa   000066 7330 00	lrs  	54
007714  aa  6 01504 7561 00	stq  	pr6|836		devtab.depth
007715  aa   000044 7770 00	llr  	36
007716  aa   000044 7330 00	lrs  	36
007717  aa  5 00006 0331 00	adl  	pr5|6		devtab.sum
007720  aa  5 00006 7561 00	stq  	pr5|6		devtab.sum
						STATEMENT 1 ON LINE 2135
	devtab.wq.depth = devtab.wq.depth + 1;

007721  aa  6 01504 2361 00	ldq  	pr6|836		devtab.depth
007722  aa   000001 0760 07	adq  	1,dl
007723  aa  5 00010 5521 14	stbq 	pr5|8,14		devtab.depth
						STATEMENT 1 ON LINE 2136
	if devtab.wq.depth > devtab.wq.max_depth then
	     devtab.wq.max_depth = devtab.wq.depth;

007724  aa  5 00010 2351 00	lda  	pr5|8		devtab.max_depth
007725  aa   000066 7330 00	lrs  	54
007726  aa  6 01504 7561 00	stq  	pr6|836		devtab.max_depth
007727  aa  5 00010 2351 00	lda  	pr5|8		devtab.depth
007730  aa   000022 7350 00	als  	18
007731  aa   000066 7330 00	lrs  	54
007732  aa  6 01504 1161 00	cmpq 	pr6|836		devtab.max_depth
007733  aa   000003 6044 04	tmoz 	3,ic		007736
007734  aa   000066 7370 00	lls  	54
007735  aa  5 00010 5511 60	stba 	pr5|8,60		devtab.max_depth
						STATEMENT 1 ON LINE 2138
	devtab.wq.count = devtab.wq.count + 1;

007736  aa  5 00007 2351 00	lda  	pr5|7		devtab.count
007737  aa   000044 7330 00	lrs  	36
007740  aa   000001 0330 07	adl  	1,dl
007741  aa  5 00007 7561 00	stq  	pr5|7		devtab.count
						STATEMENT 1 ON LINE 2143
	type = quentry.type;

007742  aa  6 00266 3535 20	epp3 	pr6|182,*		qp
007743  aa  3 00001 2351 00	lda  	pr3|1		quentry.type
007744  aa   000002 7350 00	als  	2
007745  aa   000104 7730 00	lrl  	68
007746  aa  6 00624 7561 00	stq  	pr6|404		type
						STATEMENT 1 ON LINE 2144
	sysp = addr (disk_data.sys_info (type));

007747  aa   000002 7360 00	qls  	2
007750  aa  6 00256 3515 20	epp1 	pr6|174,*		disksp
007751  aa  1 00116 3515 06	epp1 	pr1|78,ql		disk_data.sys_info
007752  aa  6 00264 2515 00	spri1	pr6|180		sysp
						STATEMENT 1 ON LINE 2145
	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));

007753  aa   000000 0110 03	nop  	0,du
007754  aa  6 00044 3701 20	epp4 	pr6|36,*
007755  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
007756  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
007757  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
007760  aa   000000 2360 07	ldq  	0,dl
007761  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
007762  aa   000002 6010 04	tnz  	2,ic		007764
						STATEMENT 1 ON LINE 2146
	end;

007763  aa   777771 7100 04	tra  	-7,ic		007754
						STATEMENT 1 ON LINE 2147
	ptr (disksp, sys_info.depth_map) -> sys_info.depth = ptr (disksp, sys_info.depth_map) -> sys_info.depth + 1.0;

007764  aa  6 00264 3715 20	epp5 	pr6|180,*		sysp
007765  aa  5 00003 2351 00	lda  	pr5|3		sys_info.depth_map
007766  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
007767  aa  7 00000 3521 00	epp2 	pr7|0
007770  aa   000000 3120 01	eawp2	0,au
007771  aa  2 00000 4311 00	fld  	pr2|0		sys_info.depth
007772  aa   002400 4750 03	fad  	1280,du
007773  aa  2 00000 4551 00	fst  	pr2|0		sys_info.depth
						STATEMENT 1 ON LINE 2148
	optp = addr (devtab.opt_info (type));

007774  aa  6 00624 2361 00	ldq  	pr6|404		type
007775  aa   000012 4020 07	mpy  	10,dl
007776  aa  6 00272 3535 20	epp3 	pr6|186,*		dp
007777  aa  3 00012 3535 06	epp3 	pr3|10,ql		devtab.opt_info
010000  aa  6 00262 2535 00	spri3	pr6|178		optp
						STATEMENT 1 ON LINE 2149
	opt_info.depth = opt_info.depth + 1;

010001  aa  3 00003 2351 00	lda  	pr3|3		opt_info.depth
010002  aa   000022 7350 00	als  	18
010003  aa   000066 7330 00	lrs  	54
010004  aa   000001 0760 07	adq  	1,dl
010005  aa  3 00003 5521 14	stbq 	pr3|3,14		opt_info.depth
						STATEMENT 1 ON LINE 2153
wq_common:
	sys_info.fraction =
	     (sys_info.max_depth - ptr (disksp, sys_info.depth_map) -> sys_info.depth) / sys_info.max_depth;

010006  aa  6 00264 3735 20	epp7 	pr6|180,*		sysp
010007  aa  7 00003 2351 00	lda  	pr7|3		sys_info.depth_map
010010  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
010011  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
010012  aa   000000 3120 01	eawp2	0,au
010013  aa  7 00001 4311 00	fld  	pr7|1		sys_info.max_depth
010014  aa  2 00000 5751 00	fsb  	pr2|0		sys_info.depth
010015  aa  7 00001 5651 00	fdv  	pr7|1		sys_info.max_depth
010016  aa  7 00002 4551 00	fst  	pr7|2		sys_info.fraction
						STATEMENT 1 ON LINE 2156
	if sys_info.fraction < 0.0 then
	     sys_info.fraction = 0.0;

010017  aa   000003 6050 04	tpl  	3,ic		010022
010020  aa   400000 4310 03	fld  	131072,du
010021  aa  7 00002 4551 00	fst  	pr7|2		sys_info.fraction
						STATEMENT 1 ON LINE 2158
	if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
	     ;

010022  aa   000000 2350 07	lda  	0,dl
010023  aa  6 00256 3715 20	epp5 	pr6|174,*		disksp
010024  aa  5 00003 3521 00	epp2 	pr5|3		disk_data.lock
010025  aa  2 00000 2361 00	ldq  	pr2|0		disk_data.lock
010026  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
010027  aa   000001 6010 04	tnz  	1,ic		010030
						STATEMENT 1 ON LINE 2164
	opt_info.multiplier = (opt_info.intercept - float (opt_info.depth) * opt_info.slope) * sys_info.fraction;

010030  aa  6 00262 3535 20	epp3 	pr6|178,*		optp
010031  aa  3 00003 2351 00	lda  	pr3|3		opt_info.depth
010032  aa   000022 7350 00	als  	18
010033  aa   000066 7330 00	lrs  	54
010034  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
010035  aa  3 00001 4611 00	fmp  	pr3|1		opt_info.slope
010036  aa   000000 5130 00	fneg 	0
010037  aa  3 00002 4751 00	fad  	pr3|2		opt_info.intercept
010040  aa  7 00002 4611 00	fmp  	pr7|2		sys_info.fraction
010041  aa  3 00000 4551 00	fst  	pr3|0		opt_info.multiplier
						STATEMENT 1 ON LINE 2165
	if opt_info.multiplier < 1.0 then
	     opt_info.multiplier = 1.0;

010042  aa   002400 5150 03	fcmp 	1280,du
010043  aa   000003 6050 04	tpl  	3,ic		010046
010044  aa   002400 4310 03	fld  	1280,du
010045  aa  3 00000 4551 00	fst  	pr3|0		opt_info.multiplier
						STATEMENT 1 ON LINE 2167
	return;

010046  aa  6 00625 2361 00	ldq  	pr6|405
010047  aa   000002 6010 04	tnz  	2,ic		010051
010050  aa  6 00616 6101 00	rtcd 	pr6|398
010051  aa   000027 7260 07	lxl6 	23,dl
010052  aa   770345 3520 04	epp2 	-3867,ic		000417 = 162145164165
010053  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
010054  aa  6 00616 6101 00	rtcd 	pr6|398
ENTRY TO del_q                                              STATEMENT 1 ON LINE 2171
del_q:
     entry;

010055  aa  6 00616 6501 00	spri4	pr6|398
010056  aa  6 00625 4501 00	stz  	pr6|405
						STATEMENT 1 ON LINE 2176
	if quentry.prev = "0"b then			/* head is prev */
	     devtab.wq.head = quentry.next;

010057  aa  6 00266 2351 20	lda  	pr6|182,*		quentry.prev
010060  aa   000022 7350 00	als  	18
010061  aa  6 01504 7551 00	sta  	pr6|836		quentry.prev
010062  aa   000005 6010 04	tnz  	5,ic		010067
010063  aa  6 00266 2351 20	lda  	pr6|182,*		quentry.next
010064  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
010065  aa  7 00011 5511 60	stba 	pr7|9,60		devtab.head
010066  aa   000005 7100 04	tra  	5,ic		010073
						STATEMENT 1 ON LINE 2178
	else ptr (disksp, quentry.prev) -> quentry.next = quentry.next;

010067  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
010070  aa   000000 3120 01	eawp2	0,au
010071  aa  6 00266 2351 20	lda  	pr6|182,*		quentry.next
010072  aa  2 00000 5511 60	stba 	pr2|0,60		quentry.next
						STATEMENT 1 ON LINE 2180
	if quentry.next = "0"b then			/* tail is next */
	     devtab.wq.tail = quentry.prev;

010073  aa  6 00266 2351 20	lda  	pr6|182,*		quentry.next
010074  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
010075  aa  6 01504 7551 00	sta  	pr6|836		quentry.next
010076  aa   000005 6010 04	tnz  	5,ic		010103
010077  aa  6 00266 2351 20	lda  	pr6|182,*		quentry.prev
010100  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
010101  aa  7 00011 5511 14	stba 	pr7|9,14		devtab.tail
010102  aa   000005 7100 04	tra  	5,ic		010107
						STATEMENT 1 ON LINE 2182
	else ptr (disksp, quentry.next) -> quentry.prev = quentry.prev;

010103  aa  6 00256 3521 20	epp2 	pr6|174,*		disksp
010104  aa   000000 3120 01	eawp2	0,au
010105  aa  6 00266 2351 20	lda  	pr6|182,*		quentry.prev
010106  aa  2 00000 5511 14	stba 	pr2|0,14		quentry.prev
						STATEMENT 1 ON LINE 2186
	devtab.wq.depth = devtab.wq.depth - 1;

010107  aa  6 00272 3735 20	epp7 	pr6|186,*		dp
010110  aa  7 00010 2351 00	lda  	pr7|8		devtab.depth
010111  aa   000022 7350 00	als  	18
010112  aa   000066 7330 00	lrs  	54
010113  aa   000001 1760 07	sbq  	1,dl
010114  aa  7 00010 5521 14	stbq 	pr7|8,14		devtab.depth
						STATEMENT 1 ON LINE 2187
	if devtab.wq.depth <= 0 then
	     disktab.dev_queued = disktab.dev_queued & ^dev_mask (pdi);

010115  aa   000011 6054 04	tpnz 	9,ic		010126
010116  aa  6 00145 2361 00	ldq  	pr6|101		pdi
010117  aa   000001 7360 00	qls  	1
010120  ta   000076 2350 06	lda  	62,ql
010121  ta   000077 2360 06	ldq  	63,ql
010122  aa  0 00220 6771 00	eraq 	pr0|144		= 777777777777 777777777777
010123  aa  6 00260 3715 20	epp5 	pr6|176,*		diskp
010124  aa  5 00006 3551 00	ansa 	pr5|6		disktab.dev_queued
010125  aa  5 00007 3561 00	ansq 	pr5|7		disktab.dev_queued
						STATEMENT 1 ON LINE 2192
	type = quentry.type;

010126  aa  6 00266 3715 20	epp5 	pr6|182,*		qp
010127  aa  5 00001 2351 00	lda  	pr5|1		quentry.type
010130  aa   000002 7350 00	als  	2
010131  aa   000104 7730 00	lrl  	68
010132  aa  6 00624 7561 00	stq  	pr6|404		type
						STATEMENT 1 ON LINE 2193
	sysp = addr (disk_data.sys_info (type));

010133  aa   000002 7360 00	qls  	2
010134  aa  6 00256 3535 20	epp3 	pr6|174,*		disksp
010135  aa  3 00116 3535 06	epp3 	pr3|78,ql		disk_data.sys_info
010136  aa  6 00264 2535 00	spri3	pr6|180		sysp
						STATEMENT 1 ON LINE 2194
	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));

010137  aa   000000 0110 03	nop  	0,du
010140  aa  6 00044 3701 20	epp4 	pr6|36,*
010141  la  4 00014 2351 20	lda  	pr4|12,*		pds$processid
010142  aa  6 00256 3735 20	epp7 	pr6|174,*		disksp
010143  aa  7 00003 3521 00	epp2 	pr7|3		disk_data.lock
010144  aa   000000 2360 07	ldq  	0,dl
010145  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
010146  aa   000002 6010 04	tnz  	2,ic		010150
						STATEMENT 1 ON LINE 2195
	end;

010147  aa   777771 7100 04	tra  	-7,ic		010140
						STATEMENT 1 ON LINE 2199
	ptr (disksp, sys_info.depth_map) -> sys_info.depth =
	     max (0.0, ptr (disksp, sys_info.depth_map) -> sys_info.depth - 1.0);

010150  aa  6 00264 3715 20	epp5 	pr6|180,*		sysp
010151  aa  5 00003 2351 00	lda  	pr5|3		sys_info.depth_map
010152  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
010153  aa  7 00000 3521 00	epp2 	pr7|0
010154  aa   000000 3120 01	eawp2	0,au
010155  aa  2 00000 4311 00	fld  	pr2|0		sys_info.depth
010156  aa   002400 5750 03	fsb  	1280,du
010157  aa   400000 5150 03	fcmp 	131072,du
010160  aa   000002 6050 04	tpl  	2,ic		010162
010161  aa   400000 4310 03	fld  	131072,du
010162  aa  2 00000 4551 00	fst  	pr2|0		sys_info.depth
						STATEMENT 1 ON LINE 2202
	optp = addr (devtab.opt_info (type));

010163  aa  6 00624 2361 00	ldq  	pr6|404		type
010164  aa   000012 4020 07	mpy  	10,dl
010165  aa  6 00272 3535 20	epp3 	pr6|186,*		dp
010166  aa  3 00012 3535 06	epp3 	pr3|10,ql		devtab.opt_info
010167  aa  6 00262 2535 00	spri3	pr6|178		optp
						STATEMENT 1 ON LINE 2203
	opt_info.depth = opt_info.depth - 1;

010170  aa  3 00003 2351 00	lda  	pr3|3		opt_info.depth
010171  aa   000022 7350 00	als  	18
010172  aa   000066 7330 00	lrs  	54
010173  aa   000001 1760 07	sbq  	1,dl
010174  aa  3 00003 5521 14	stbq 	pr3|3,14		opt_info.depth
						STATEMENT 1 ON LINE 2204
	go to wq_common;

010175  aa   777611 7100 04	tra  	-119,ic		010006
						STATEMENT 1 ON LINE 2206
     end get_free_q;

  END PROCEDURE get_free_q
BEGIN PROCEDURE set_pvte_inop
ENTRY TO set_pvte_inop                                      STATEMENT 1 ON LINE 2211
set_pvte_inop:
     proc (setting);

010176  aa  6 00626 6501 00	spri4	pr6|406
010177  aa  6 00630 2521 00	spri2	pr6|408
						STATEMENT 1 ON LINE 2219
	call set (addr (addr (pvt$array) -> pvt_array (devtab.pvtx)));

010200  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.pvtx
010201  aa   000077 7330 00	lrs  	63
010202  aa   000034 4020 07	mpy  	28,dl
010203  aa  6 00044 3701 20	epp4 	pr6|36,*
010204  la  4 00056 3735 20	epp7 	pr4|46,*
010205  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
010206  aa  6 01506 6535 00	spri7	pr6|838
010207  aa   000061 3520 04	epp2 	49,ic		010270 = 000002000000
010210  aa   000021 6700 04	tsp4 	17,ic		010231
						STATEMENT 1 ON LINE 2221
	if devtab.buddy ^= 0			/* Must also do it to the buddy */
	     then
	     call set (addr (addr (pvt$array) -> pvt_array (disktab.devtab (devtab.buddy).pvtx)));

010211  aa  6 00272 2351 20	lda  	pr6|186,*		devtab.buddy
010212  aa   000030 7350 00	als  	24
010213  aa   000102 7730 00	lrl  	66
010214  aa   000014 6000 04	tze  	12,ic		010230
010215  aa   000120 4020 07	mpy  	80,dl
010216  aa  6 00260 3735 20	epp7 	pr6|176,*		diskp
010217  aa  7 00036 2351 06	lda  	pr7|30,ql		disktab.pvtx
010220  aa   000077 7330 00	lrs  	63
010221  aa   000034 4020 07	mpy  	28,dl
010222  aa  6 00044 3701 20	epp4 	pr6|36,*
010223  la  4 00056 3715 20	epp5 	pr4|46,*
010224  aa  5 77744 3715 06	epp5 	pr5|-28,ql	pvt_array
010225  aa  6 01506 6515 00	spri5	pr6|838
010226  aa   000042 3520 04	epp2 	34,ic		010270 = 000002000000
010227  aa   000002 6700 04	tsp4 	2,ic		010231
						STATEMENT 1 ON LINE 2242
     end set_pvte_inop;

010230  aa  6 00626 6101 00	rtcd 	pr6|406
BEGIN PROCEDURE set
ENTRY TO set                                                STATEMENT 1 ON LINE 2225
set:
	proc (pvte_ptr);

010231  aa  6 00634 6501 00	spri4	pr6|412
010232  aa  6 00636 2521 00	spri2	pr6|414
						STATEMENT 1 ON LINE 2231
	     if pvte_ptr -> pvte.device_inoperative & ^setting then do;

010233  aa  6 00630 3735 20	epp7 	pr6|408,*
010234  aa  7 00002 2351 20	lda  	pr7|2,*		setting
010235  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
010236  aa  6 01510 7551 00	sta  	pr6|840		setting
010237  aa  2 00002 3715 20	epp5 	pr2|2,*		pvte_ptr
010240  aa  5 00000 3715 20	epp5 	pr5|0,*		pvte_ptr
010241  aa  5 00004 2351 00	lda  	pr5|4		pvte.device_inoperative
010242  aa   002000 3150 07	cana 	1024,dl
010243  aa   000015 6000 04	tze  	13,ic		010260
010244  aa  6 01510 2351 00	lda  	pr6|840		setting
010245  aa   000013 6010 04	tnz  	11,ic		010260
						STATEMENT 1 ON LINE 2232
		pvte_ptr -> pvte.device_inoperative = "0"b;

010246  aa   000020 2350 04	lda  	16,ic		010266 = 777777775777
010247  aa  5 00004 3551 00	ansa 	pr5|4		pvte.device_inoperative
						STATEMENT 1 ON LINE 2233
		call pxss$notify (page_fault$disk_offline_event);

010250  aa  6 00044 3701 20	epp4 	pr6|36,*
010251  la  4 00016 3521 20	epp2 	pr4|14,*		page_fault$disk_offline_event
010252  aa  6 01514 2521 00	spri2	pr6|844
010253  aa  6 01512 6211 00	eax1 	pr6|842
010254  aa   004000 4310 07	fld  	2048,dl
010255  la  4 00030 3521 20	epp2 	pr4|24,*		pxss$notify
010256  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2234
	     end;

010257  aa   000006 7100 04	tra  	6,ic		010265
						STATEMENT 1 ON LINE 2235
	     else pvte_ptr -> pvte.device_inoperative = setting;

010260  aa  6 01510 2351 00	lda  	pr6|840		setting
010261  aa   000031 7710 00	arl  	25
010262  aa  5 00004 6751 00	era  	pr5|4		pvte.device_inoperative
010263  aa   002000 3750 07	ana  	1024,dl
010264  aa  5 00004 6551 00	ersa 	pr5|4		pvte.device_inoperative
						STATEMENT 1 ON LINE 2237
	     return;

010265  aa  6 00634 6101 00	rtcd 	pr6|412
						STATEMENT 1 ON LINE 2240
	end set;

  END PROCEDURE set
  END PROCEDURE set_pvte_inop
  END PROCEDURE disk_control


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
