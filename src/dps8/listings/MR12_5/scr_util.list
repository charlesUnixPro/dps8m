	COMPILATION LISTING OF SEGMENT scr_util
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0943.8 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* SCR_UTIL - Procedure to Manipulate System Controller Registers and Data.
        9*   coded 2/1/76 by Noel I. Morris
       10*   modified 5/11/78 by J. A. Bush for processor testing
       11*   modified 2/5/79 by B. Greenberg for port expanders.
       12*   modified May 1981 by J. Bongiovanni to set anti-hog switches,
       13*        validate sscr
       14**/
       15 
       16 
       17 /* ******************************************************
       18*   *                                                    *
       19*   *                                                    *
       20*   * Copyright (c) 1972 by Massachusetts Institute of   *
       21*   * Technology and Honeywell Information Systems, Inc. *
       22*   *                                                    *
       23*   *                                                    *
       24*   ****************************************************** */
       25 
       26 
       27 scr_util$read_cfg: proc (port);
       28 
       29 dcl  port fixed bin (3);				/* controller port number on active modules */
       30 
       31 dcl  mr_data fixed bin (71),				/* data from RSCR-MR */
       32      i fixed bin,					/* iteration variable */
       33      ctag fixed bin (3),				/* system controller tag */
       34      bitno fixed bin,				/* mask bit offset */
       35      iscu fixed bin (5),				/* ISOLTS SCU tag */
       36      icpu fixed bin (5),				/* ISOLTS CPU tag */
       37      mcpu fixed bin (5),				/* ISOLTS mask cpu */
       38     (maska, maskb) bit (9),				/* temporary mask reg storage */
       39     (store_a_size, store_b_size) fixed bin (17),		/* size of stores A & B */
       40     scr_cfg2_temp fixed bin (71) aligned,		/* temp rscr storage			*/
       41     set_cfg_try_count fixed bin,			/* number times tried sscr			*/
       42     set_cfg_ok bit (1) aligned,
       43     mask_a_val char (3),
       44     mask_b_val char (3),
       45     cycle_priority_bits (7) bit (1),
       46     port_enable_bits (8) bit (1),
       47     nea_bits (7) bit (1);
       48 
       49 	         
       50 	         
       51 
       52 dcl 1 cdata aligned like scs$controller_data based (cdp),	/* single element of scs$controller data */
       53      cdp ptr,					/* pointer to the above */
       54     1 pdata aligned like scs$processor_data based (pdp),	/* single element of scs$processor_data */
       55      pdp ptr;					/* pointer to the above */
       56 
       57 dcl  masks (3) bit (72) aligned based (mkp),		/* array of interrupt masks */
       58      mkp ptr;					/* pointer to the above */
       59 
       60 dcl  scr_cfg2_temp_overlay bit (72) aligned defined (scr_cfg2_temp);
       61 	         
       62 
       63 dcl  SCR_CFG2_PROGRAM_MASK bit (72) aligned int static options (constant)
       64         init ("777774037777777000077417"b3);		/* program settable bits in config register	*/
       65 dcl  SET_CFG_TRY_LIMIT fixed bin int static options (constant)
       66         init (10);					/* number sscr attempts before punting		*/
       67 dcl  LETTERS char (8) int static options (constant) init ("ABCDEFGH");
       68 
       69 dcl  privileged_mode_ut$cioc entry (ptr),
       70      privileged_mode_ut$rscr entry (fixed bin (3), fixed bin (6), fixed bin (71)),
       71      privileged_mode_ut$sscr entry (fixed bin (3), fixed bin (6), fixed bin (71)),
       72      privileged_mode_ut$smcm entry (fixed bin (3), bit (72) aligned),
       73      syserr entry options (variable);
       74 	         
       75 
       76 dcl (addr, bin, bit, convert, index, mod, string, substr, unspec) builtin;
       77 
       78 
       79 
  1     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  1     2 /* format: style4 */
  1     3 
  1     4 /* Information about system controllers */
  1     5 
  1     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  1     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  1     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  1     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  1    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  1    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  1    12          3 mbz bit (3) unaligned,
  1    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  1    14        2 info aligned,
  1    15          3 online bit (1) unaligned,			/* ON if controller is online */
  1    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  1    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  1    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  1    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  1    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  1    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  1    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  1    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  1    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  1    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  1    26          3 type bit (4) unaligned,			/* Model number for this controller */
  1    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  1    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  1    29          3 mbz bit (13) unaligned,
  1    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  1    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  1    32 
  1    33 /* Information about CPUs */
  1    34 
  1    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  1    36        (
  1    37        2 online bit (1),				/* "1"b if CPU is online */
  1    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  1    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  1    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  1    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  1    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  1    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  1    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  1    45        2 mbz1 bit (6),
  1    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  1    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  1    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  1    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  1    50        2 mbz2 bit (12),
  1    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  1    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  1    53        2 controller_port fixed bin (3) unsigned
  1    54        ) unaligned;					/* Port on controller */
  1    55 
  1    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  1    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  1    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  1    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  1    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  1    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  1    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  1    63        2 pad bit (12) unaligned;
  1    64 
  1    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  1    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  1    67        2 cow,
  1    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  1    69          3 mbz1 bit (13) unaligned,
  1    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  1    71          3 mbz2 bit (2) unaligned,
  1    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  1    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  1    74          3 mbz3 bit (3) unaligned,
  1    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  1    76 
  1    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  1    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  1    79        2 pad bit (12) unal,
  1    80        2 tag bit (6) unal;				/* Better be zero. */
  1    81 
  1    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  1    83        2 pad bit (36) aligned,
  1    84        2 cow,					/* Connect operand word, in odd location. */
  1    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  1    86          3 mbz1 bit (13) unaligned,
  1    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  1    88          3 mbz2 bit (9) unaligned,
  1    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  1    90 
  1    91 /* MASKS and PATTERNS */
  1    92 
  1    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  1    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  1    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  1    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  1    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  1    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  1    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  1   100 
  1   101 /* CAM and CACHE clear info */
  1   102 
  1   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  1   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  1   105 
  1   106 /* MASKING INSTRUCTIONS & POINTERS */
  1   107 
  1   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  1   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  1   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  1   111 
  1   112 /* MISCELLANEOUS */
  1   113 
  1   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  1   115        (
  1   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  1   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  1   118        2 pad1 bit (4),
  1   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  1   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  1   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  1   122        2 mask_cpu fixed bin (5)
  1   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  1   124 
  1   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  1   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  1   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  1   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  1   129 
  1   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  1   131 
  1   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  1   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  1   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  1   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  1   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  1   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  1   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  1   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  1   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  1   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  1   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  1   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  1   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  1   145 
  1   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  1   147 
  1   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  1   149 
  1   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  1   151 
  1   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  1   153 
  1   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  1   155 						/* Which ports have expanders */
  1   156 
  1   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  1   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  1   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  1   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  1   161 
  1   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  1   163 
  1   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  1   165 						/* Controller size on config card */
  1   166 
  1   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  1   168 
  1   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  1   170 						/* PTWs for SCAS pages */
  1   171 
  1   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  1   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  1   174 
  1   175 
  1   176 dcl  (
  1   177      IOM_PORT init (1),
  1   178      CPU_PORT init (2),
  1   179      BULK_PORT init (3)
  1   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  1   181 
  1   182 
  1   183 /* END INCLUDE FILE scs.incl.pl1 */
       80 
       81 
       82 
  2     1 /* Begin include file ...... scr.incl.pl1
  2     2*   modified 5/75 by Noel I. Morris
  2     3*   modified 10/81 by M.R. Jordan for 64K chip, M64 memory 
  2     4*   modified '83 to make values constant */
  2     5 
  2     6 /* This include file is to be used in conjunction with pmut$rscr and pmut$sscr.
  2     7*   Wherever possible the terms in the processor manual are used in the declaration. */
  2     8 
  2     9 dcl (SC_MR init (0),				/* SC Mode Register */
  2    10      SC_CFG init (1),				/* SC Configuration Switches */
  2    11      SC_MSK init (2),				/* SC Interrupt Mask */
  2    12      SC_IC init (3),				/* SC Interrupt Cells */
  2    13      SC_ETC init (4),				/* SC Elapsed Time Clock */
  2    14      SC_SU init (6)) fixed bin (6) static options (constant); /* SU Mode Register */
  2    15 
  2    16 
  2    17 dcl  scrp ptr;					/* pointer to SC data */
  2    18 
  2    19 dcl 1 scr_cfg1 based (scrp) aligned,			/* configuration data for 6000 SC */
  2    20 
  2    21    (2 mode_a bit (3),				/* 000 => on-line
  2    22*						   001 => test mode
  2    23*						   010 => off-line */
  2    24     2 bdry_a bit (3),				/* 000 => 32K, 001 => 64K, etc */
  2    25     2 mode_b bit (3),				/* see mode_a */
  2    26     2 bdry_b bit (3),				/* see bdry_a */
  2    27     2 int bit (1),					/* 1 => stores are internally interlaced */
  2    28     2 lwr bit (1),					/* 1 => store B is low */
  2    29     2 addr_offset bit (2),				/* 00 => no offset, 01 => 32K offset, etc. */
  2    30     2 port_no bit (4),				/* requester's port number */
  2    31     2 port_enable (0:7) bit (2),			/* 00 => port disabled
  2    32*						   01 => port under program control
  2    33*						   11 => port enabled */
  2    34     2 pima (4) bit (9)) unaligned;			/* program interrupt mask assignments
  2    35*						   000 => unassigned
  2    36*						   400 => assigned to port 0
  2    37*						   200 => assigned to port 1
  2    38*						   .
  2    39*						   .
  2    40*						   .
  2    41*						   002 => assigned to port 7
  2    42*						   001 => assigned to maint. panel */
  2    43 
  2    44 
  2    45 dcl 1 scr_cfg2 based (scrp) aligned,			/* configuration data for 4MW SCU */
  2    46 
  2    47    (2 mask_a_assign bit (9),				/* interrupt mask "A" port assignment
  2    48*						   400 => assigned to port 0
  2    49*						   .
  2    50*						   .
  2    51*						   002 => assigned to port 7
  2    52*						   001 => mask off */
  2    53     2 size bit (3),					/* size of lower store */
  2    54     2 a_online bit (1),				/* 1 => store A online */
  2    55     2 a1_online bit (1),				/* 1 => store A1 online */
  2    56     2 b_online bit (1),				/* 1 => store B online */
  2    57     2 b1_online bit (1),				/* 1 => store B1 online */
  2    58     2 port_no bit (4),				/* requester's port number */
  2    59     2 pad1 bit (1),
  2    60     2 mode bit (1),					/* 1 => programmable mode */
  2    61     2 nea_enabled bit (1),				/* 1 => non-existent address logic enabled */
  2    62     2 nea bit (7),					/* 001 => 32K, 002 => 64K, 003 => 96K, etc. */
  2    63     2 int bit (1),					/* 1 => stores are internally interlaced */
  2    64     2 lwr bit (1),					/* 1 => store B is low */
  2    65     2 port_mask_0_3 bit (4),				/* 1 => corresponding port enabled */
  2    66 
  2    67     2 mask_b_assign bit (9),				/* interrupt mask "B" port assignment */
  2    68     2 pad2 bit (12),
  2    69     2 cyclic_prior bit (7),				/* cyclic port priority switches */
  2    70     2 pad3 bit (4),
  2    71     2 port_mask_4_7 bit (4)) unal;			/* 1 => corresponding port enabled */
  2    72 
  2    73 
  2    74 dcl 1 scr_mr based (scrp) aligned,			/* SC mode register */
  2    75 
  2    76    (2 pad1 bit (50),
  2    77     2 identification bit (4),				/* 0000 => 8034, 8035
  2    78*						   0001 => 6000 SC
  2    79*						   0010 => 4MW SCU */
  2    80     2 TS_strobe_margin bit (2),			/* 00 => normal timing
  2    81*						   01 => slow timing
  2    82*						   10 => inhibit strobe
  2    83*						   11 => fast timing */
  2    84     2 G0_strobe_margin bit (2),
  2    85     2 ANSWER_strobe_margin bit (2),
  2    86     2 DA_strobe_margin bit (2),
  2    87     2 EOC_strobe_margin bit (2),
  2    88     2 PLUS_5_VOLT_margin bit (2),			/* 00 => normal voltage
  2    89*						   01 => -5%
  2    90*						   10 => normal voltage
  2    91*						   11 => +5% */
  2    92     2 parity_override bit (1),			/* 1 => SU forced to accept data with incorrect parity */
  2    93     2 parity_disable bit (1),				/* 1 => disable data and ZAC parity checking */
  2    94     2 store_IA_disable bit (1),			/* 1 => disable illegal action indication */
  2    95     2 ZAC_parity_error bit (1),			/* 1 => cause ZAC parity error */
  2    96     2 SGR_accepted bit (1),				/* 1 => SGR command accepted by SC */
  2    97     2 pad2 bit (1)) unal;
  2    98 
  2    99 
  2   100 dcl 1 scr_msk based (scrp) aligned,			/* SC mask register */
  2   101 
  2   102    (2 interrupt_mask_1 bit (16),			/* mask bits for interrupts 0 thru 15 */
  2   103     2 pad1 bit (16),
  2   104     2 port_mask_1 bit (4),				/* mask bits for ports 0 thru 3 */
  2   105 
  2   106     2 interrupt_mask_2 bit (16),			/* mask bits for interrupts 16 thru 31 */
  2   107     2 pad2 bit (16),
  2   108     2 port_mask_2 bit (4)) unal;			/* mask bits for ports 4 thru 7 */
  2   109 
  2   110 
  2   111 dcl 1 scr_su based (scrp) aligned,			/* store unit mode register */
  2   112 
  2   113    (2 pad1 bit (36),
  2   114     2 ZAC_line bit (6),				/* EDAC mode only - address field */
  2   115     2 syndrome bit (8),				/* EDAC mode only - failure syndrome */
  2   116     2 identification bit (4),				/* 0000 => High Speed Core Model AA1
  2   117*						   0001 => High Speed Core Model AA3
  2   118*						   0011 => 4K, 16 pin chip, MOS memory, M32 boards
  2   119*						   0100 => 1K chip MOS memory with EDAC enabled
  2   120*						   1010 => 64K, 16 pin chip, MOS memory, M64 boards
  2   121*						   1011 => 16K, 16 pin chip, MOS memory, M264 boards
  2   122*						   1100 => 1K chip MOS memory with EDAC disabled
  2   123*						   1110 => 16K, 16 pin chip, MOS memory, M128 boards
  2   124*						   1111 => 4K, 22 pin chip MOS memory, M16 boards */
  2   125     2 EDAC_disabled bit (1),				/* 1 => correction disabled but detection still enabled */
  2   126     2 pad2 bit (4),
  2   127     2 MINUS_5_VOLT_margin bit (2),
  2   128     2 PLUS_5_VOLT_margin bit (2),
  2   129     2 spare_margin bit (2),
  2   130     2 PLUS_19_VOLT_margin bit (2),
  2   131     2 pad3 bit (1),
  2   132     2 SENSE_strobe_margin bit (2),			/* core only */
  2   133     2 pad4 bit (1),
  2   134     2 maint_functions_enabled bit (1)) unal;		/* 1 => maintenance functions enabled */
  2   135 
  2   136 /* End of include file ...... scr.incl.pl1 */
  2   137 
       83 
       84 
       85 
       86 
       87 	cdp = addr (scs$controller_data (port));	/* Get pointer to appropriate element of array. */
       88 
       89 	call privileged_mode_ut$rscr (port, SC_MR, mr_data); /* Read the controller mode register. */
       90 	scrp = addr (mr_data);			/* Set pointer to data read. */
       91 	cdata.type = scr_mr.identification;		/* Extract the controller ID code. */
       92 
       93 	call privileged_mode_ut$rscr (port, SC_CFG, scs$cfg_data (port));
       94 	scrp = addr (scs$cfg_data (port));		/* Read configuration data from controller. */
       95 
       96 	if cdata.type >= "0010"b then do;		/* If 4MW SCU ... */
       97 	     cdata.store_a_online = scr_cfg2.a_online;
       98 	     cdata.store_a1_online = scr_cfg2.a1_online;
       99 	     cdata.store_b_online = scr_cfg2.b_online;
      100 	     cdata.store_b1_online = scr_cfg2.b1_online;
      101 	     cdata.store_b_is_lower = scr_cfg2.lwr;
      102 	     cdata.int_interlaced = scr_cfg2.int;
      103 	     cdata.lower_store_size = power_of_two (bin (scr_cfg2.size, 3) + 5);
      104 	     if (cdata.store_b_is_lower & cdata.store_a_online) |
      105 	     (^cdata.store_b_is_lower & cdata.store_b_online) then
      106 		if scr_cfg2.nea_enabled then		/* Compute size of upper store. */
      107 		     cdata.upper_store_size =
      108 		     bin (bit (scr_cfg2.nea, 12)) - mod (cdata.base, 4096) - cdata.lower_store_size;
      109 		else
      110 		cdata.upper_store_size = cdata.lower_store_size;
      111 	     else
      112 	     cdata.upper_store_size = 0;
      113 	     string (cdata.cyclic_priority) = scr_cfg2.cyclic_prior;
      114 	     call interpret_eima (1, scr_cfg2.mask_a_assign);
      115 	     call interpret_eima (2, scr_cfg2.mask_b_assign);
      116 	     cdata.eima_data (1).mask_available,
      117 		cdata.eima_data (2).mask_available = "1"b;
      118 	     cdata.eima_data (3).mask_available,
      119 		cdata.eima_data (4).mask_available = "0"b;
      120 
      121 	     cdata.program = scr_cfg2.mode;
      122 	end;
      123 
      124 
      125 
      126 	else do;					/* If 6000 SC ... */
      127 	     cdata.store_a_online = (scr_cfg1.mode_a = "000"b);
      128 	     cdata.store_b_online = (scr_cfg1.mode_b = "000"b);
      129 	     cdata.store_b_is_lower = scr_cfg1.lwr;
      130 	     cdata.int_interlaced = scr_cfg1.int;
      131 	     if cdata.store_a_online then
      132 		store_a_size = (bin (scr_cfg1.bdry_a, 3) + 1) * 32;
      133 	     else
      134 	     store_a_size = 0;
      135 	     if store_a_size = 128 then
      136 		cdata.store_a1_online = "1"b;		/* Two ports for 128K store. */
      137 	     else
      138 	     cdata.store_a1_online = "0"b;
      139 	     if cdata.store_b_online then
      140 		store_b_size = (bin (scr_cfg1.bdry_b, 3) + 1) * 32;
      141 	     else
      142 	     store_b_size = 0;
      143 	     if store_b_size = 128 then
      144 		cdata.store_b1_online = "1"b;		/* Two ports for 128K store. */
      145 	     else
      146 	     cdata.store_b1_online = "0"b;
      147 	     if cdata.store_b_is_lower then do;
      148 		cdata.lower_store_size = store_b_size;
      149 		cdata.upper_store_size = store_a_size;
      150 	     end;
      151 	     else do;
      152 		cdata.lower_store_size = store_a_size;
      153 		cdata.upper_store_size = store_b_size;
      154 	     end;
      155 	     string (cdata.cyclic_priority) = (7)"0"b;
      156 	     do i = 1 to 4;
      157 		call interpret_eima (i, scr_cfg1.pima (i));
      158 		cdata.eima_data (i).mask_available = "1"b;
      159 	     end;
      160 
      161 	     cdata.program = "1"b;
      162 	end;
      163 
      164 	return;
      165 
      166 
      167 
      168 set_port_enable: entry (port, enable_sw);		/* entry to enable a controller port */
      169 
      170 dcl  enable_sw bit (1) unal;				/* 1 => enable corresponding port */
      171 
      172 
      173 	call set_port_enable_bit (port, enable_sw);	/* Set the bit first. */
      174 
      175 	do ctag = 0 to 7;				/* Set ports in all controllers. */
      176 	     cdp = addr (scs$controller_data (ctag));	/* Get pointer to controller data for this port. */
      177 
      178 	     if cdata.online then			/* If controller is in use ... */
      179 		call enable_ports (ctag);		/* Go set the port enable bits. */
      180 	end;
      181 
      182 	return;
      183 
      184 
      185 
      186 set_port_enable_bit: entry (port, enable_sw);		/* entry to only set port enable bits */
      187 
      188 
      189 	mkp = addr (scs$sys_level);			/* Get pointer to array of masks. */
      190 
      191 	do i = 1 to scs$number_of_masks;		/* Modify all masks. */
      192 	     scrp = addr (masks (i));			/* Get pointer to mask. */
      193 	     if port < 4 then			/* If ports 0 thru 3 ... */
      194 		substr (scr_msk.port_mask_1, port + 1, 1) = enable_sw;
      195 	     else					/* If ports 4 thru 7 ... */
      196 	     substr (scr_msk.port_mask_2, port - 3, 1) = enable_sw;
      197 	end;
      198 
      199 	return;
      200 
      201 
      202 
      203 enable_ports: entry (port);				/* entry to set port enable bits in a controller */
      204 
      205 
      206 	cdp = addr (scs$controller_data (port));	/* Get pointer to data for this controller. */
      207 	scrp = addr (scs$cfg_data (port));		/* Get pointer to CFG data for this controller. */
      208 	mkp = addr (scs$sys_level);			/* Get pointer to a mask. */
      209 
      210 	if cdata.type >= "0010"b then do;		/* If 4MW SCU ... */
      211 	     scr_cfg2.port_mask_0_3 = mkp -> scr_msk.port_mask_1;
      212 	     scr_cfg2.port_mask_4_7 = mkp -> scr_msk.port_mask_2;
      213 	     call set_cfg (port);			/* Actually set the controller. */
      214 	end;
      215 
      216 	else					/* If 6000 SC ... */
      217 	if port = scs$interrupt_controller then		/* If bootload controller, allow interrupts. */
      218 	     call privileged_mode_ut$smcm (port, scs$open_level);
      219 	else					/* If not bootload controller, prevent interrupts. */
      220 	call privileged_mode_ut$smcm (port, scs$sys_level);
      221 
      222 	return;
      223 
      224 
      225 
      226 disable_ports: entry (port);				/* entry to clear all port enable bits in a controller */
      227 
      228 
      229 	cdp = addr (scs$controller_data (port));	/* Get pointer to data for this controller. */
      230 	scrp = addr (scs$cfg_data (port));		/* Get pointer to CFG data for this controller. */
      231 
      232 	if cdata.type >= "0010"b then do;		/* If 4MW SCU ... */
      233 	     scr_cfg2.port_mask_0_3 = "0000"b;
      234 	     scr_cfg2.port_mask_4_7 = "0000"b;
      235 	     call set_cfg (port);			/* Actually set the controller. */
      236 	end;
      237 
      238 	else					/* If 6000 SC ... */
      239 	call privileged_mode_ut$smcm (port, unspec (bin (0, 71)));
      240 
      241 	return;
      242 
      243 
      244 
      245 assign_mask: entry (port, target);			/* entry to assign a mask to a port */
      246 
      247 dcl  target fixed bin (3);				/* port to which mask will be assigned */
      248 
      249 dcl  mask_assignment bit (9);				/* mask assignment bits */
      250 
      251 
      252 	cdp = addr (scs$controller_data (port));	/* Get pointer to correct array element. */
      253 	scrp = addr (scs$cfg_data (port));		/* Get pointer to correct CFG data. */
      254 
      255 	if cdata.type >= "0010"b then do i = 1 to 2;	/* Do this only for 4MW SCU. */
      256 	     if ^cdata.eima_data (i).mask_assigned then do; /* Look for unused mask. */
      257 		cdata.eima_data (i).mask_assignment = target;
      258 		cdata.eima_data (i).mask_assigned = "1"b;
      259 		mask_assignment = set_mask_assignment (target + 1);
      260 		if i = 1 then			/* Set appropriate field in CFG data. */
      261 		     scr_cfg2.mask_a_assign = mask_assignment;
      262 		else
      263 		scr_cfg2.mask_b_assign = mask_assignment;
      264 	     end;
      265 	end;
      266 
      267 	return;
      268 
      269 
      270 
      271 unassign_mask: entry (port, target);			/* entry to unassign a mask from a port */
      272 
      273 
      274 	cdp = addr (scs$controller_data (port));	/* Get pointer to correct array element. */
      275 	scrp = addr (scs$cfg_data (port));		/* Get pointer to correct CFG data. */
      276 
      277 	if cdata.type >= "0010"b then do i = 1 to 2;	/* Do this only for 4MW SCU. */
      278 	     if cdata.eima_data (i).mask_assigned &	/* Look for mask used for this target. */
      279 	     (cdata.eima_data (i).mask_assignment = target) then do;
      280 		cdata.eima_data (i).mask_assigned = "0"b;
      281 		mask_assignment = set_mask_assignment (9);
      282 		if i = 1 then			/* Set appropriate field in CFG data. */
      283 		     scr_cfg2.mask_a_assign = mask_assignment;
      284 		else
      285 		scr_cfg2.mask_b_assign = mask_assignment;
      286 	     end;
      287 	end;
      288 
      289 	return;
      290 
      291 
      292 
      293 
      294 reassign_mask: entry (tag1, tag2);			/* entry to reassign mask to another port */
      295 
      296 dcl  tag1 fixed bin (3),				/* processor tag of assigned mask */
      297      tag2 fixed bin (3);				/* processor tag for new assignment */
      298 
      299 
      300 	ctag = scs$interrupt_controller;		/* Change bootload controller only. */
      301 
      302 	if tag1 ^= -1 then do;			/* If assignment to be removed ... */	
      303 	     pdp = addr (scs$processor_data (tag1));	/* Get pointer to data for this processor. */
      304 
      305 	     if tag2 ^= -1 then 			/* Check for same-port (poss. expander) case and punt */
      306 		if pdata.controller_port = scs$processor_data (tag2).controller_port then return;
      307 	     call set_mask (ctag, (pdata.controller_port), 0);
      308 						/* Clear the mask. */
      309 	     call unassign_mask (ctag, (pdata.controller_port));
      310 						/* Unassign the mask. */
      311 	end;
      312 	if tag2 ^= -1 then do;			/* If new assignment to be made ... */
      313 	     pdp = addr (scs$processor_data (tag2));	/* Get pointer to data for this processor. */
      314 
      315 	     call assign_mask (ctag, (pdata.controller_port));
      316 						/* Make new mask assignment. */
      317 	     call set_cfg (ctag);			/* Set switches in controller. */
      318 	end;
      319 
      320 	return;
      321 
      322 
      323 update_export_xipmsk:
      324 	entry (port);				/* Update port-expander XIP masks */
      325 
      326 dcl 1 rcow based (addr (scs$reconfig_general_cow)) aligned like scs$reconfig_general_cow;
      327 
      328 	unspec (rcow) = ""b;			/* Zero the cow. */
      329 	do i = 0 to 7;
      330 	     pdp = addr (scs$processor_data (i));	/* Address proc data element */
      331 	     if pdata.expanded_port & pdata.controller_port = port
      332 		then substr (rcow.sub_mask, pdata.expander_port + 1, 1) =  pdata.interrupt_cpu;
      333 	end;
      334 	rcow.expander_command = "2"b3;		/* Set XIP register */
      335 	rcow.controller_port = port;
      336 	call privileged_mode_ut$cioc (addr (rcow.cow));	/* We rely on this living in the bootload controller */
      337 	return;
      338 
      339 set_export_enable:
      340 	entry (port, subport, enable_sw);
      341 
      342 dcl  subport fixed bin (3);
      343 
      344 	unspec (rcow) = ""b;			/* Clear out sutff */
      345 	do i = 0 to 7;				/* Scan CPU's */
      346 	     pdp = addr (scs$processor_data (i));
      347 	     if pdata.expanded_port & pdata.controller_port = port
      348 		then if pdata.expander_port = subport
      349 		     then substr (rcow.sub_mask, pdata.expander_port + 1, 1) = enable_sw;
      350 		     else substr (rcow.sub_mask, pdata.expander_port + 1, 1) = pdata.online;
      351          end;
      352 	substr (rcow.sub_mask, 5, 1) = "1"b;		/* T. Ohlin wants exerciser bit on. */
      353          rcow.expander_command = "1"b3;			/* Set subport enables */
      354          rcow.controller_port = port;
      355          call privileged_mode_ut$cioc (addr (rcow.cow));	/* Zap the bootload SCU */
      356 /* The enables on all the other SCU's will be left enabled */
      357          return;
      358 		     
      359 	
      360 
      361 set_cfg:	entry (port);				/* entry to set CFG data in controller */
      362 
      363 
      364 	if scs$controller_data (port).type >= "0010"b then do; /* If 4MW SCU ... */
      365 	     if scs$set_cycle_switches then
      366 		string (addr (scs$cfg_data (port)) -> scr_cfg2.cyclic_prior) = scs$cycle_priority_template;
      367 try_to_set_cfg:
      368 	     scrp = addr (scs$cfg_data (port));
      369 	     unspec (port_enable_bits) = scr_cfg2.port_mask_0_3 || scr_cfg2.port_mask_4_7;
      370 	     set_cfg_ok = "0"b;
      371 	     do set_cfg_try_count = 1 repeat set_cfg_try_count + 1
      372 		while (set_cfg_try_count <= SET_CFG_TRY_LIMIT & ^set_cfg_ok);
      373 		call privileged_mode_ut$sscr (port, SC_CFG, scs$cfg_data (port));
      374 		if unspec (port_enable_bits) = "0"b then set_cfg_ok = "1"b;     /* if we can't check, assume OK	*/
      375 		else do;
      376 		     call privileged_mode_ut$rscr (port, SC_CFG, scr_cfg2_temp); /* read to make sure it took	*/
      377 		     if (unspec (scr_cfg2_temp) & SCR_CFG2_PROGRAM_MASK)
      378 			= (unspec (scs$cfg_data (port)) & SCR_CFG2_PROGRAM_MASK)    /* check all program-settable bits*/
      379 			then set_cfg_ok = "1"b;
      380 		end;
      381 	     end;
      382 	     
      383 /* If the sscr did not take within the requisite number of tries, we
      384*   punt by printing instructions to the operator to clear the SCU
      385*   manually.  This involves setting switches, flipping the mode into
      386*   MANUAL, then back into PROGRAM.  When these two actions have happened,
      387*   we check again, repeating the process if necessary						*/
      388 	     
      389 	     if ^set_cfg_ok then do;			/* drastic manual intervention		*/
      390 		call syserr (3, "scr_util: error setting configuration register. SCU ^a must be set manually",
      391 		     substr (LETTERS, port+1, 1));
      392 		call syserr (0, "Set the following switches on SCU ^a",
      393 		     substr (LETTERS, port+1,1));
      394 		
      395 		unspec (cycle_priority_bits) = scr_cfg2.cyclic_prior;
      396 		unspec (nea_bits) = scr_cfg2.nea;
      397 		mask_a_val = convert_to_mask_val (substr (scr_cfg2.mask_a_assign, 1, 8));
      398 		mask_b_val = convert_to_mask_val (substr (scr_cfg2.mask_b_assign, 1, 8));
      399 		
      400 		call syserr (0, "^/^12x--PORT ENABLE--  --CYCLIC PRIORITY---^/^12x0 1 2 3 4 5 6 7  0/1 1/2 2/3 3/4 4/5 5/6 6/7^/^8xON  ^8(^[X^; ^] ^) ^7( ^[X^; ^]  ^)^/^8xOFF ^8(^[ ^;X^] ^) ^7( ^[ ^;X^]  ^)",
      401 		     port_enable_bits, cycle_priority_bits, 
      402 		     port_enable_bits, cycle_priority_bits);
      403 		call syserr (0, "^/^8xNON-EXISTENT ADDRESS^/^17x2 3 4 5 6 7 8^/^8xON  ^[X^; ^]  1 ^7(^[X^; ^] ^)^/^8xOFF ^[ ^;X^]  0 ^7(^[ ^;X^] ^)",
      404 		     scr_cfg2.nea_enabled, nea_bits,
      405 		     scr_cfg2.nea_enabled, nea_bits);
      406 		call syserr (0, "^/^8xSTORE A  A1 B  B1^/^8xON    ^4(^[X^; ^]  ^)^/^8xOFF   ^4(^[ ^;X^]  ^)",
      407 		     scr_cfg2.a_online, scr_cfg2.a1_online, scr_cfg2.b_online, scr_cfg2.b1_online,
      408 		     scr_cfg2.a_online, scr_cfg2.a1_online, scr_cfg2.b_online, scr_cfg2.b1_online);
      409 		call syserr (0, "^/^8xLWR STORE SIZE - ^d^/^8xINTERLACE - ^[ON^;OFF^]^/^8xLWR STORE - ^[B^;A^]^/^8xMASK A - ^a^/^8xMASK B - ^a",
      410 		     bin (scr_cfg2.size), scr_cfg2.int, scr_cfg2.lwr,
      411 		     mask_a_val, mask_b_val);
      412 		
      413 		call syserr (0, "After setting the switches for SCU ^a place SCU ^a into Manual Mode and then into Program Mode",
      414 		     substr (LETTERS, port+1, 1), substr (LETTERS, port+1, 1));
      415 
      416 /* Wait for SCU to go into Manual Mode								*/
      417 		
      418 		do while (addr (scr_cfg2_temp) -> scr_cfg2.mode);
      419 		     call privileged_mode_ut$rscr (port, SC_CFG, scr_cfg2_temp);
      420 		end;
      421 		
      422 /* Wait for SCU to go into Program Mode								*/
      423 		
      424 		do while (^addr (scr_cfg2_temp) -> scr_cfg2.mode);
      425 		     call privileged_mode_ut$rscr (port, SC_CFG, scr_cfg2_temp);
      426 		end;
      427 		
      428 
      429 /* Check whether SCU cleared properly								*/
      430 		
      431 		if (unspec (scr_cfg2_temp) & SCR_CFG2_PROGRAM_MASK)
      432 		     ^= (unspec (scs$cfg_data (port)) & SCR_CFG2_PROGRAM_MASK)
      433 		     then goto try_to_set_cfg;
      434 	     end;
      435 	     
      436 
      437 		
      438 		
      439 
      440 	end;
      441 						/* Set CFG data in controller. */
      442 	return;
      443 
      444 
      445 
      446 set_mask:	entry (port, target, mask);			/* entry to set mask for controller port */
      447 
      448 dcl  mask fixed bin (71);				/* mask to be set */
      449 
      450 
      451 	call privileged_mode_ut$sscr (port, SC_MSK + 8 * target, mask);
      452 						/* Set the mask. */
      453 
      454 	return;
      455 
      456 
      457 
      458 
      459 convert_to_mask_val:
      460 	proc (scu_mask_bits) returns (char (*));	/* procedure to convert a mask to printable form	*/
      461 	
      462 dcl  scu_mask_bits bit (*) unaligned,
      463      mask_val pic "9";
      464 	
      465 	
      466 	if index (scu_mask_bits, "1"b) >0 then do;
      467 	     mask_val = index (scu_mask_bits, "1"b) - 1;
      468 	     return (mask_val);
      469 	end;
      470 	else return ("Off");
      471 	
      472 	
      473 end convert_to_mask_val;
      474 
      475 	
      476 
      477 
      478 
      479 interpret_eima: proc (n, eima);			/* procedure to determine port assignment from bits */
      480 
      481 dcl  n fixed bin,					/* EIMA number */
      482      eima bit (9);					/* mask assignment bits */
      483 
      484 dcl  x fixed bin;					/* port mask assigned to */
      485 
      486 
      487 	     x = index (eima, "1"b);			/* Look for bit ON. */
      488 	     if (x = 0) | (x = 9) then		/* If no bits ON, or last bit ON ... */
      489 		cdata.eima_data (n).mask_assigned = "0"b; /* Mask is not assigned to any port. */
      490 	     else do;				/* Mask is assigned. */
      491 		cdata.eima_data (n).mask_assigned = "1"b;
      492 		cdata.eima_data (n).mask_assignment = x - 1; /* Remember port to which mask is assigned. */
      493 	     end;
      494 
      495 	     return;
      496 
      497 	end interpret_eima;
      498 
      499 
      500 
      501 set_mask_assignment: proc (n) returns (bit (9) unal);	/* procedure to set correct mask assignment bit */
      502 
      503 dcl  n fixed bin;					/* bit to be set */
      504 
      505 dcl  m bit (9) aligned;				/* prototype mask assignment bits */
      506 
      507 
      508 	     m = "0"b;				/* Clear all bits. */
      509 	     substr (m, n, 1) = "1"b;			/* Set the desired bit. */
      510 
      511 	     return (m);				/* Return assignment bits. */
      512 
      513 
      514 	end set_mask_assignment;
      515 
      516 
      517 
      518 
      519 power_of_two: proc (e) returns (fixed bin);		/* procedure to compute power of two */
      520 
      521 dcl  e fixed bin;					/* exponent */
      522 
      523 dcl  p fixed bin;					/* power of two */
      524 
      525 
      526 	     p = 0;				/* Clear the result. */
      527 	     substr (unspec (p), 36 - e, 1) = "1"b;	/* Very quick, and extremely dirty. */
      528 
      529 	     return (p);
      530 
      531 
      532 	end power_of_two;
      533 
      534 /*  */
      535 
      536 /* isolts_scu_p1 - entry to set config data in the SCU being used for ISOLTS, to isolate the processor under test */
      537 
      538 isolts_scu_p1: entry;
      539 
      540 	iscu = scs$processor_test_data.scu_tag;		/* pick up scu_tag, cpu_tag, and mask cpu tag */
      541 	icpu = scs$processor_test_data.cpu_tag;		/* from processor test data structure */
      542 	mcpu = scs$processor_test_data.mask_cpu;
      543 	cdp = addr (scs$controller_data (iscu));
      544 	scrp = addr (scs$cfg_data (iscu));
      545 	pdp = addr (scs$processor_data (icpu));
      546 	mkp = addr (scs$cpu_test_mask);
      547 
      548 /* do the things common to both types of SCU's first */
      549 
      550 	maska = set_mask_assignment (scs$processor_data (mcpu).controller_port + 1);
      551 	maskb = set_mask_assignment (pdata.controller_port + 1);
      552 
      553 /* set up scs$cpu_test mask */
      554 
      555 	scs$cpu_test_mask = "0"b;			/* initialize it first */
      556 	mkp -> scr_msk.port_mask_1 = substr ((maska | maskb), 1, 4); /* set port mask fields */
      557 	mkp -> scr_msk.port_mask_2 = substr ((maska | maskb), 5, 4);
      558 
      559 	if cdata.type >= "0010"b then do;		/* if 4MW SCU ... */
      560 
      561 	     scr_cfg2.mask_a_assign = maska;		/* set up config data */
      562 	     scr_cfg2.mask_b_assign = maskb;
      563 	     scr_cfg2.port_mask_0_3 = mkp -> scr_msk.port_mask_1;
      564 	     scr_cfg2.port_mask_4_7 = mkp -> scr_msk.port_mask_2;
      565 
      566 	     call set_cfg ((iscu));			/* actually set config data in SCU */
      567 
      568 	end;
      569 
      570 	else call privileged_mode_ut$smcm ((iscu), scs$cpu_test_mask); /* 6000 SCU, just set port mask  */
      571 	call set_mask ((iscu), (scs$processor_data (mcpu).controller_port), /* mask off interrupts */
      572 	     fixed (scs$cpu_test_mask, 71));		/* in mask cpu */
      573 	mkp -> scr_msk.interrupt_mask_1 = "1001000000001000"b; /* set int mask for cells 0 and 12 */
      574 						/* and cell 3 for test progras */
      575 	scs$processor_test_data.scu_state = "10"b;	/* set scu state to indicate where we are at */
      576 
      577 	return;					/* thats all folks */
      578 
      579 /*  */
      580 
      581 /* isolts_scu_p2 - entry to re-enable original SCU ports + port for test cpu */
      582 
      583 isolts_scu_p2: entry;
      584 
      585 	iscu = scs$processor_test_data.scu_tag;		/* pick up scu_tag, cpu_tag, and mask cpu tag */
      586 	icpu = scs$processor_test_data.cpu_tag;		/* from processor test data structure */
      587 	mcpu = scs$processor_test_data.mask_cpu;
      588 	cdp = addr (scs$controller_data (iscu));
      589 	scrp = addr (scs$cfg_data (iscu));
      590 	pdp = addr (scs$processor_data (icpu));
      591 	mkp = addr (scs$cpu_test_mask);
      592 
      593 /* do the things common to both types of SCU's first */
      594 
      595 	maska = set_mask_assignment (pdata.controller_port + 1);
      596 	pdp = addr (scs$sys_level);			/* get a pointer to a mask */
      597 	mkp -> scr_msk.port_mask_1 = pdp -> scr_msk.port_mask_1 | substr (maska, 1, 4);
      598 	mkp -> scr_msk.port_mask_2 = pdp -> scr_msk.port_mask_2 | substr (maska, 5, 4);
      599 
      600 	if cdata.type >= "0010"b then do;		/* if 4MW SCU ... */
      601 
      602 	     scr_cfg2.port_mask_0_3 = mkp -> scr_msk.port_mask_1;
      603 	     scr_cfg2.port_mask_4_7 = mkp -> scr_msk.port_mask_2;
      604 
      605 	     call set_cfg ((iscu));			/* actually set config data in SCU */
      606 
      607 	end;
      608 
      609 	else call privileged_mode_ut$smcm ((iscu),
      610 	     "000000000017000000000017"b3 & scs$cpu_test_mask); /* 6000 SCU, set port mask */
      611 	call set_mask ((iscu), (scs$processor_data (mcpu).controller_port), /* mask off interrupts */
      612 	     fixed ("000000000017000000000017"b3 & scs$cpu_test_mask, 71)); /* in mask cpu */
      613 
      614 	return;					/* thats all folks */
      615 
      616 
      617 /*  */
      618 
      619 /* isolts_scu_p3 - entry to restore orignial SCU port masks upon termination of ISOLTS CPU testing */
      620 
      621 isolts_scu_p3: entry;
      622 
      623 	iscu = scs$processor_test_data.scu_tag;		/* pick up scu_tag */
      624 	cdp = addr (scs$controller_data (iscu));
      625 
      626 	scs$cfg_data (iscu) = scs$cfg_data_save;	/* restoe orignial config data */
      627 
      628 	if cdata.type >= "0010"b then			/* if 4MW SCU */
      629 	     call set_cfg ((iscu));			/* actually set config data */
      630 	else call privileged_mode_ut$smcm ((iscu), scs$sys_level); /* if 6000 SC */
      631 
      632 	return;					/* thats all */
      633 
      634 
      635 /* BEGIN MESSAGE DOCUMENTATION
      636*
      637*   Message:
      638*   scr_util: error setting configuration register. SCU X must be set manually.
      639*   Set the following switches on SCU X
      640*   < Diagram of SCU Maintenance Panel is Printed Here>
      641*   After setting the switches for SCU X place SCU S into Manual Mode and then into Program Mode
      642*   
      643*   S: $beep
      644*
      645*   T: Reconfiguration (e.g., adding or deleting a CPU)
      646*
      647*   M: The supervisor was unable to set the configuration register in the SCU
      648*   indicated after 10 attempts.  To avoid a system crash, the SCU must be
      649*   cleared manually.  In this message, the supervisor will print a diagram
      650*   of the SCU Maintenance Panel, indicating how each switch should be set.
      651*   
      652*   A: The operator should copy the diagram of the SCU Maintenance Panel
      653*   printed by the supervisor (or take the copy printed, if possible).  The
      654*   operator should then go to the Maintenance Panel of the SCU indicated
      655*   and set each switch on the diagram to the indicated position, and then
      656*   verify that each switch is in the correct position.  Following this, the
      657*   operator should set the Program/Manual switch into the Manual position
      658*   briefly, and then return it to the Program position.  If this procedure
      659*   does not remedy the problem, the message will be repeated, and the
      660*   System Programming Staff should be contacted.
      661*
      662*   END MESSAGE DOCUMENTATION */
      663    
      664      end scr_util$read_cfg;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0853.8  scr_util.pl1                      >spec>install>1115>scr_util.pl1
80           1    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
83           2    08/17/83  1135.7  scr.incl.pl1                      >ldd>include>scr.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LETTERS                         000000 constant        char(8)                  initial packed unaligned dcl 67 ref 390 390 392 392
                                                                                  413 413 413 413
SCR_CFG2_PROGRAM_MASK           000002 constant        bit(72)                  initial dcl 63 ref 377 377 431 431
SC_CFG                          000030 constant        fixed bin(6,0)           initial dcl 2-9 set ref 93* 373* 376* 419* 425*
SC_MR                           000023 constant        fixed bin(6,0)           initial dcl 2-9 set ref 89*
SC_MSK                                 constant        fixed bin(6,0)           initial dcl 2-9 ref 451
SET_CFG_TRY_LIMIT                      constant        fixed bin(17,0)          initial dcl 65 ref 371
a1_online                 0(13)        based           bit(1)                   level 2 packed packed unaligned dcl 2-45 set ref 98
                                                                                  406* 406*
a_online                  0(12)        based           bit(1)                   level 2 packed packed unaligned dcl 2-45 set ref 97
                                                                                  406* 406*
addr                                                   builtin function         dcl 76 ref 87 90 94 176 189 192 206 207 208 229 230
                                                                                  252 253 274 275 303 313 328 330 331 334 335 336
                                                                                  336 336 336 344 346 347 350 352 353 354 355 355
                                                                                  355 355 365 367 418 424 543 544 545 546 588 589
                                                                                  590 591 596 624
b1_online                 0(15)        based           bit(1)                   level 2 packed packed unaligned dcl 2-45 set ref 100
                                                                                  406* 406*
b_online                  0(14)        based           bit(1)                   level 2 packed packed unaligned dcl 2-45 set ref 99
                                                                                  406* 406*
base                      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 52 ref 104
bdry_a                    0(03)        based           bit(3)                   level 2 packed packed unaligned dcl 2-19 ref 131
bdry_b                    0(09)        based           bit(3)                   level 2 packed packed unaligned dcl 2-19 ref 139
bin                                                    builtin function         dcl 76 ref 103 104 131 139 238 238 409 409
bit                                                    builtin function         dcl 76 ref 104
cdata                                  based           structure                level 1 dcl 52
cdp                             000126 automatic       pointer                  dcl 52 set ref 87* 91 96 97 98 99 100 101 102 103
                                                                                  104 104 104 104 104 104 104 109 109 111 113 116
                                                                                  116 118 118 121 127 128 129 130 131 135 137 139
                                                                                  143 145 147 148 149 152 153 155 158 161 176* 178
                                                                                  206* 210 229* 232 252* 255 256 257 258 274* 277
                                                                                  278 278 280 488 491 492 543* 559 588* 600 624* 628
controller_port           1(33)        based           fixed bin(3,0)           level 3 in structure "rcow" packed packed unsigned
                                                                                  unaligned dcl 326 in procedure "scr_util$read_cfg"
                                                                                  set ref 335* 354*
controller_port           0(33)        based           fixed bin(3,0)           level 2 in structure "pdata" packed packed unsigned
                                                                                  unaligned dcl 52 in procedure "scr_util$read_cfg"
                                                                                  ref 305 307 309 315 331 347 551 595
controller_port           0(33) 000024 external static fixed bin(3,0)           array level 2 in structure "scs$processor_data"
                                                                                  packed packed unsigned unaligned dcl 1-35
                                                                                  in procedure "scr_util$read_cfg" set ref 305 550
                                                                                  571 611
cow                       1            based           structure                level 2 dcl 326 set ref 336 336 355 355
cpu_tag                   0(18) 000040 external static fixed bin(5,0)           level 2 packed packed unaligned dcl 1-114 ref 541
                                                                                  586
ctag                            000103 automatic       fixed bin(3,0)           dcl 31 set ref 175* 176 178* 300* 307* 309* 315*
                                                                                  317*
cycle_priority_bits             000122 automatic       bit(1)                   array packed unaligned dcl 31 set ref 395* 400* 400*
cyclic_prior              1(21)        based           bit(7)                   level 2 packed packed unaligned dcl 2-45 set ref 113
                                                                                  365* 395
cyclic_priority           2(10)        based           bit(1)                   array level 3 packed packed unaligned dcl 52 set ref
                                                                                  113* 155*
e                                      parameter       fixed bin(17,0)          dcl 521 ref 519 527
eima                                   parameter       bit(9)                   packed unaligned dcl 481 ref 479 487
eima_data                 1            based           structure                array level 2 packed packed unaligned dcl 52
enable_sw                              parameter       bit(1)                   packed unaligned dcl 170 set ref 168 173* 186 193
                                                                                  195 339 347
expanded_port             0(30)        based           bit(1)                   level 2 packed packed unaligned dcl 52 ref 331 347
expander_command          1(21)        based           bit(3)                   level 3 packed packed unaligned dcl 326 set ref 334*
                                                                                  353*
expander_port             0(31)        based           fixed bin(2,0)           level 2 packed packed unsigned unaligned dcl 52 ref
                                                                                  331 347 347 350
i                               000102 automatic       fixed bin(17,0)          dcl 31 set ref 156* 157* 157 158* 191* 192* 255* 256
                                                                                  257 258 260* 277* 278 278 280 282* 329* 330* 345*
                                                                                  346*
icpu                            000105 automatic       fixed bin(5,0)           dcl 31 set ref 541* 545 586* 590
identification            1(14)        based           bit(4)                   level 2 packed packed unaligned dcl 2-74 ref 91
index                                                  builtin function         dcl 76 ref 466 467 487
info                      2            based           structure                level 2 in structure "cdata" dcl 52 in procedure
                                                                                  "scr_util$read_cfg"
info                      2     000022 external static structure                array level 2 in structure "scs$controller_data"
                                                                                  dcl 1-6 in procedure "scr_util$read_cfg"
int                       0(30)        based           bit(1)                   level 2 in structure "scr_cfg2" packed packed
                                                                                  unaligned dcl 2-45 in procedure
                                                                                  "scr_util$read_cfg" set ref 102 409*
int                       0(12)        based           bit(1)                   level 2 in structure "scr_cfg1" packed packed
                                                                                  unaligned dcl 2-19 in procedure
                                                                                  "scr_util$read_cfg" ref 130
int_interlaced            2(08)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 102*
                                                                                  130*
interrupt_cpu             0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 52 ref 331
interrupt_mask_1                       based           bit(16)                  level 2 packed packed unaligned dcl 2-100 set ref
                                                                                  573*
iscu                            000104 automatic       fixed bin(5,0)           dcl 31 set ref 540* 543 544 566 570 571 585* 588 589
                                                                                  605 609 611 623* 624 626 628 630
lower_store_size          3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 52 set ref 103*
                                                                                  104 109 148* 152*
lwr                       0(31)        based           bit(1)                   level 2 in structure "scr_cfg2" packed packed
                                                                                  unaligned dcl 2-45 in procedure
                                                                                  "scr_util$read_cfg" set ref 101 409*
lwr                       0(13)        based           bit(1)                   level 2 in structure "scr_cfg1" packed packed
                                                                                  unaligned dcl 2-19 in procedure
                                                                                  "scr_util$read_cfg" ref 129
m                               000162 automatic       bit(9)                   dcl 505 set ref 508* 509* 511
mask                                   parameter       fixed bin(71,0)          dcl 448 set ref 446 451*
mask_a_assign                          based           bit(9)                   level 2 packed packed unaligned dcl 2-45 set ref
                                                                                  114* 260* 282* 397 397 561*
mask_a_val                      000120 automatic       char(3)                  packed unaligned dcl 31 set ref 397* 409*
mask_assigned             1(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 52 set ref
                                                                                  256 258* 278 280* 488* 491*
mask_assignment           1(05)        based           fixed bin(3,0)           array level 3 in structure "cdata" packed packed
                                                                                  unaligned dcl 52 in procedure "scr_util$read_cfg"
                                                                                  set ref 257* 278 492*
mask_assignment                 000136 automatic       bit(9)                   packed unaligned dcl 249 in procedure
                                                                                  "scr_util$read_cfg" set ref 259* 260 262 281* 282
                                                                                  284
mask_available            1            based           bit(1)                   array level 3 packed packed unaligned dcl 52 set ref
                                                                                  116* 116* 118* 118* 158*
mask_b_assign             1            based           bit(9)                   level 2 packed packed unaligned dcl 2-45 set ref
                                                                                  115* 262* 284* 398 398 562*
mask_b_val                      000121 automatic       char(3)                  packed unaligned dcl 31 set ref 398* 409*
mask_cpu                  0(30) 000040 external static fixed bin(5,0)           level 2 packed packed unaligned dcl 1-114 ref 542
                                                                                  587
mask_val                        000100 automatic       picture(1)               packed unaligned dcl 462 set ref 467* 468
maska                           000107 automatic       bit(9)                   packed unaligned dcl 31 set ref 550* 556 557 561
                                                                                  595* 597 598
maskb                           000110 automatic       bit(9)                   packed unaligned dcl 31 set ref 551* 556 557 562
masks                                  based           bit(72)                  array dcl 57 set ref 192
mcpu                            000106 automatic       fixed bin(5,0)           dcl 31 set ref 542* 550 571 587* 611
mkp                             000132 automatic       pointer                  dcl 57 set ref 189* 192 208* 211 212 546* 556 557
                                                                                  563 564 573 591* 597 598 602 603
mod                                                    builtin function         dcl 76 ref 104
mode                      0(21)        based           bit(1)                   level 2 packed packed unaligned dcl 2-45 ref 121 418
                                                                                  424
mode_a                                 based           bit(3)                   level 2 packed packed unaligned dcl 2-19 ref 127
mode_b                    0(06)        based           bit(3)                   level 2 packed packed unaligned dcl 2-19 ref 128
mr_data                         000100 automatic       fixed bin(71,0)          dcl 31 set ref 89* 90
n                                      parameter       fixed bin(17,0)          dcl 503 in procedure "set_mask_assignment" ref 501
                                                                                  509
n                                      parameter       fixed bin(17,0)          dcl 481 in procedure "interpret_eima" ref 479 488
                                                                                  491 492
nea                       0(23)        based           bit(7)                   level 2 packed packed unaligned dcl 2-45 ref 104 396
nea_bits                        000124 automatic       bit(1)                   array packed unaligned dcl 31 set ref 396* 403* 403*
nea_enabled               0(22)        based           bit(1)                   level 2 packed packed unaligned dcl 2-45 set ref 104
                                                                                  403* 403*
online                    2            based           bit(1)                   level 3 in structure "cdata" packed packed unaligned
                                                                                  dcl 52 in procedure "scr_util$read_cfg" ref 178
online                                 based           bit(1)                   level 2 in structure "pdata" packed packed unaligned
                                                                                  dcl 52 in procedure "scr_util$read_cfg" ref 350
p                               000172 automatic       fixed bin(17,0)          dcl 523 set ref 526* 527 529
pdata                                  based           structure                level 1 dcl 52
pdp                             000130 automatic       pointer                  dcl 52 set ref 303* 305 307 309 313* 315 330* 331
                                                                                  331 331 331 346* 347 347 347 347 350 350 545* 551
                                                                                  590* 595 596* 597 598
pima                      1            based           bit(9)                   array level 2 packed packed unaligned dcl 2-19 set
                                                                                  ref 157*
port                                   parameter       fixed bin(3,0)           dcl 29 set ref 27 87 89* 93* 93 94 168 173* 186 193
                                                                                  193 195 203 206 207 213* 216 216* 219* 226 229 230
                                                                                  235* 238* 245 252 253 271 274 275 323 331 335 339
                                                                                  347 354 361 364 365 367 373* 373 376* 377 390 390
                                                                                  392 392 413 413 413 413 419* 425* 431 446 451*
port_enable_bits                000123 automatic       bit(1)                   array packed unaligned dcl 31 set ref 369* 374 400*
                                                                                  400*
port_mask_0_3             0(32)        based           bit(4)                   level 2 packed packed unaligned dcl 2-45 set ref
                                                                                  211* 233* 369 563* 602*
port_mask_1               0(32)        based           bit(4)                   level 2 packed packed unaligned dcl 2-100 set ref
                                                                                  193* 211 556* 563 597* 597 602
port_mask_2               1(32)        based           bit(4)                   level 2 packed packed unaligned dcl 2-100 set ref
                                                                                  195* 212 557* 564 598* 598 603
port_mask_4_7             1(32)        based           bit(4)                   level 2 packed packed unaligned dcl 2-45 set ref
                                                                                  212* 234* 369 564* 603*
privileged_mode_ut$cioc         000010 constant        entry                    external dcl 69 ref 336 355
privileged_mode_ut$rscr         000012 constant        entry                    external dcl 69 ref 89 93 376 419 425
privileged_mode_ut$smcm         000016 constant        entry                    external dcl 69 ref 216 219 238 570 609 630
privileged_mode_ut$sscr         000014 constant        entry                    external dcl 69 ref 373 451
program                   2(22)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 121*
                                                                                  161*
rcow                                   based           structure                level 1 dcl 326 set ref 328* 344*
scr_cfg1                               based           structure                level 1 dcl 2-19
scr_cfg2                               based           structure                level 1 dcl 2-45
scr_cfg2_temp                   000114 automatic       fixed bin(71,0)          dcl 31 set ref 376* 377 418 419* 424 425* 431
scr_mr                                 based           structure                level 1 dcl 2-74
scr_msk                                based           structure                level 1 dcl 2-100
scrp                            000134 automatic       pointer                  dcl 2-17 set ref 90* 91 94* 97 98 99 100 101 102 103
                                                                                  104 104 113 114 115 121 127 128 129 130 131 139
                                                                                  157 192* 193 195 207* 211 212 230* 233 234 253*
                                                                                  260 262 275* 282 284 367* 369 369 395 396 397 397
                                                                                  398 398 403 403 406 406 406 406 406 406 406 406
                                                                                  409 409 409 409 544* 561 562 563 564 589* 602 603
scs$cfg_data                    000044 external static fixed bin(71,0)          array dcl 1-150 set ref 93* 94 207 230 253 275 365
                                                                                  367 373* 377 431 544 589 626*
scs$cfg_data_save               000046 external static fixed bin(71,0)          dcl 1-152 ref 626
scs$controller_data             000022 external static structure                array level 1 dcl 1-6 set ref 87 176 206 229 252 274
                                                                                  543 588 624
scs$cpu_test_mask               000034 external static bit(72)                  dcl 1-96 set ref 546 555* 570* 571 571 591 609 611
                                                                                  611
scs$cycle_priority_template     000050 external static bit(7)                   dcl 1-172 ref 365
scs$interrupt_controller        000042 external static fixed bin(3,0)           dcl 1-141 ref 216 300
scs$number_of_masks             000036 external static fixed bin(17,0)          dcl 1-97 ref 191
scs$open_level                  000032 external static bit(72)                  dcl 1-94 set ref 216*
scs$processor_data              000024 external static structure                array level 1 dcl 1-35 set ref 303 313 330 346 545
                                                                                  590
scs$processor_test_data         000040 external static structure                level 1 dcl 1-114
scs$reconfig_general_cow        000026 external static structure                level 1 dcl 1-82 set ref 328 331 334 335 336 336 344
                                                                                  347 350 352 353 354 355 355
scs$set_cycle_switches          000052 external static bit(1)                   dcl 1-173 ref 365
scs$sys_level                   000030 external static bit(72)                  dcl 1-93 set ref 189 208 219* 596 630*
scu_mask_bits                          parameter       bit                      packed unaligned dcl 462 ref 459 466 467
scu_state                 0(01) 000040 external static bit(2)                   level 2 packed packed unaligned dcl 1-114 set ref
                                                                                  575*
scu_tag                   0(24) 000040 external static fixed bin(5,0)           level 2 packed packed unaligned dcl 1-114 ref 540
                                                                                  585 623
set_cfg_ok                      000117 automatic       bit(1)                   dcl 31 set ref 370* 371 374* 377* 389
set_cfg_try_count               000116 automatic       fixed bin(17,0)          dcl 31 set ref 371* 371* 381
size                      0(09)        based           bit(3)                   level 2 packed packed unaligned dcl 2-45 ref 103 409
                                                                                  409
store_a1_online           2(03)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 98*
                                                                                  135* 137*
store_a_online            2(02)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 97*
                                                                                  104 127* 131
store_a_size                    000111 automatic       fixed bin(17,0)          dcl 31 set ref 131* 133* 135 149 152
store_b1_online           2(05)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 100*
                                                                                  143* 145*
store_b_is_lower          2(06)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 101*
                                                                                  104 104 129* 147
store_b_online            2(04)        based           bit(1)                   level 3 packed packed unaligned dcl 52 set ref 99*
                                                                                  104 128* 139
store_b_size                    000112 automatic       fixed bin(17,0)          dcl 31 set ref 139* 141* 143 148 153
string                                                 builtin function         dcl 76 set ref 113* 155* 365*
sub_mask                  1            based           bit(8)                   level 3 packed packed unaligned dcl 326 set ref 331*
                                                                                  347* 350* 352*
subport                                parameter       fixed bin(3,0)           dcl 342 ref 339 347
substr                                                 builtin function         dcl 76 set ref 193* 195* 331* 347* 350* 352* 390 390
                                                                                  392 392 397 397 398 398 413 413 413 413 509* 527*
                                                                                  556 557 597 598
syserr                          000020 constant        entry                    external dcl 69 ref 390 392 400 403 406 409 413
tag1                                   parameter       fixed bin(3,0)           dcl 296 ref 294 302 303
tag2                                   parameter       fixed bin(3,0)           dcl 296 ref 294 305 305 312 313
target                                 parameter       fixed bin(3,0)           dcl 247 ref 245 257 259 271 278 446 451
type                      2(17) 000022 external static bit(4)                   array level 3 in structure "scs$controller_data"
                                                                                  packed packed unaligned dcl 1-6 in procedure
                                                                                  "scr_util$read_cfg" set ref 364
type                      2(17)        based           bit(4)                   level 3 in structure "cdata" packed packed unaligned
                                                                                  dcl 52 in procedure "scr_util$read_cfg" set ref
                                                                                  91* 96 210 232 255 277 559 600 628
unspec                                                 builtin function         dcl 76 set ref 238 238 328* 344* 369* 374 377 377
                                                                                  395* 396* 431 431 527
upper_store_size          3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 52 set ref 104*
                                                                                  109* 111* 149* 153*
x                               000152 automatic       fixed bin(17,0)          dcl 484 set ref 487* 488 488 492

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 1-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 1-176
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 1-176
SC_ETC                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_IC                                  internal static fixed bin(6,0)           initial dcl 2-9
SC_SU                                  internal static fixed bin(6,0)           initial dcl 2-9
bitno                                  automatic       fixed bin(17,0)          dcl 31
convert                                                builtin function         dcl 76
scr_cfg2_temp_overlay                  defined         bit(72)                  dcl 60
scr_su                                 based           structure                level 1 dcl 2-111
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 1-137
scs$bos_restart_flags                  external static bit(8)                   dcl 1-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 1-103
scs$cam_wait                           external static bit(8)                   dcl 1-104
scs$connect_lock                       external static bit(36)                  dcl 1-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 1-164
scs$cow                                external static structure                array level 1 dcl 1-65
scs$cow_ptrs                           external static structure                array level 1 dcl 1-77
scs$cpu_test_pattern                   external static bit(36)                  dcl 1-99
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 1-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 1-140
scs$faults_initialized                 external static bit(1)                   dcl 1-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 1-130
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 1-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 1-136
scs$port_addressing_word               external static bit(3)                   array dcl 1-148
scs$port_data                          external static structure                array level 1 dcl 1-56
scs$processor                          external static bit(8)                   dcl 1-143
scs$processor_data_switch_value        external static bit(36)                  dcl 1-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 1-142
scs$processor_start_mask               external static bit(72)                  dcl 1-95
scs$processor_start_pattern            external static bit(36)                  dcl 1-98
scs$processor_start_wait               external static bit(8)                   dcl 1-144
scs$processor_switch_compare           external static bit(36)                  array dcl 1-159
scs$processor_switch_data              external static bit(36)                  array dcl 1-157
scs$processor_switch_mask              external static bit(36)                  array dcl 1-160
scs$processor_switch_template          external static bit(36)                  array dcl 1-158
scs$read_mask                          external static bit(36)                  array dcl 1-109
scs$reconfig_lock                      external static bit(36)                  dcl 1-133
scs$reconfig_locker_id                 external static char(32)                 dcl 1-167
scs$scas_page_table                    external static bit(36)                  array dcl 1-169
scs$set_mask                           external static bit(36)                  array dcl 1-108
scs$sys_trouble_pending                external static bit(1)                   dcl 1-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 1-146
scs$trouble_flags                      external static bit(8)                   dcl 1-134

NAMES DECLARED BY EXPLICIT CONTEXT.
assign_mask                     001256 constant        entry                    external dcl 245 ref 315
convert_to_mask_val             003430 constant        entry                    internal dcl 459 ref 397 398
disable_ports                   001201 constant        entry                    external dcl 226
enable_ports                    001105 constant        entry                    external dcl 203 ref 178
interpret_eima                  003501 constant        entry                    internal dcl 479 ref 114 115 157
isolts_scu_p1                   002747 constant        entry                    external dcl 538
isolts_scu_p2                   003157 constant        entry                    external dcl 583
isolts_scu_p3                   003354 constant        entry                    external dcl 621
power_of_two                    003557 constant        entry                    internal dcl 519 ref 103
reassign_mask                   001453 constant        entry                    external dcl 294
scr_util$read_cfg               000325 constant        entry                    external dcl 27
set_cfg                         001774 constant        entry                    external dcl 361 ref 213 235 317 566 605 628
set_export_enable               001663 constant        entry                    external dcl 339
set_mask                        002720 constant        entry                    external dcl 446 ref 307 571 611
set_mask_assignment             003543 constant        entry                    internal dcl 501 ref 259 281 550 551 595
set_port_enable                 000766 constant        entry                    external dcl 168
set_port_enable_bit             001035 constant        entry                    external dcl 186 ref 173
try_to_set_cfg                  002026 constant        label                    dcl 367 set ref 431
unassign_mask                   001354 constant        entry                    external dcl 271 ref 309
update_export_xipmsk            001570 constant        entry                    external dcl 323

NAME DECLARED BY CONTEXT OR IMPLICATION.
fixed                                                  builtin function         ref 571 571 611 611

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4254        4330    3643        4264
Length      4644    3643        54         300     410           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
scr_util$read_cfg                   271 external procedure  is an external procedure.  
convert_to_mask_val                  68 internal procedure  uses returns(char(*)) or returns(bit(*)).  
interpret_eima                          internal procedure  shares stack frame of external procedure scr_util$read_cfg.  
set_mask_assignment                     internal procedure  shares stack frame of external procedure scr_util$read_cfg.  
power_of_two                            internal procedure  shares stack frame of external procedure scr_util$read_cfg.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_to_mask_val      000100 mask_val                    convert_to_mask_val
scr_util$read_cfg        000100 mr_data                     scr_util$read_cfg
                         000102 i                           scr_util$read_cfg
                         000103 ctag                        scr_util$read_cfg
                         000104 iscu                        scr_util$read_cfg
                         000105 icpu                        scr_util$read_cfg
                         000106 mcpu                        scr_util$read_cfg
                         000107 maska                       scr_util$read_cfg
                         000110 maskb                       scr_util$read_cfg
                         000111 store_a_size                scr_util$read_cfg
                         000112 store_b_size                scr_util$read_cfg
                         000114 scr_cfg2_temp               scr_util$read_cfg
                         000116 set_cfg_try_count           scr_util$read_cfg
                         000117 set_cfg_ok                  scr_util$read_cfg
                         000120 mask_a_val                  scr_util$read_cfg
                         000121 mask_b_val                  scr_util$read_cfg
                         000122 cycle_priority_bits         scr_util$read_cfg
                         000123 port_enable_bits            scr_util$read_cfg
                         000124 nea_bits                    scr_util$read_cfg
                         000126 cdp                         scr_util$read_cfg
                         000130 pdp                         scr_util$read_cfg
                         000132 mkp                         scr_util$read_cfg
                         000134 scrp                        scr_util$read_cfg
                         000136 mask_assignment             scr_util$read_cfg
                         000152 x                           interpret_eima
                         000162 m                           set_mask_assignment
                         000172 p                           power_of_two

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_in         call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac
mdfx1               shorten_stack       ext_entry           int_entry_desc      index_bs_1_eis      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
privileged_mode_ut$cioc       privileged_mode_ut$rscr       privileged_mode_ut$smcm       privileged_mode_ut$sscr
syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
scs$cfg_data                  scs$cfg_data_save             scs$controller_data           scs$cpu_test_mask
scs$cycle_priority_template   scs$interrupt_controller      scs$number_of_masks           scs$open_level
scs$processor_data            scs$processor_test_data       scs$reconfig_general_cow      scs$set_cycle_switches
scs$sys_level


CONSTANTS
003572  aa  070 321 000 000	8

003574  aa     000004000000
003575  aa     000000000000
003576  aa     600000000041
003577  aa     000173000000
003600  aa     600000000041
003601  aa     000107000000

003602  aa     000004000000
003603  aa     000000000000
003604  aa     600000000041
003605  aa     000233000000
003606  aa     600000000041
003607  aa     000110000000

003610  aa     000004000000
003611  aa     000000000000
003612  aa     600000000041
003613  aa     000233000000
003614  aa     600000000041
003615  aa     000107000000

003616  aa     000004000000
003617  aa     000000000000
003620  aa     600000000041
003621  aa     000205000000
003622  aa     600000000041
003623  aa     000136000000

003624  aa     777777777760

003625  aa     777401777777

003626  aa     767777777777

003627  aa     737777777777

003630  aa     777777777377

003631  aa     777777377777

003632  aa     000004000000
003633  aa     000000000000
003634  aa     600000000041
003635  aa     000173000000
003636  aa     600000000041
003637  aa     000204000000

003640  aa     000001700000

000000  aa  101 102 103 104	ABCD
000001  aa  105 106 107 110	EFGH

000002  aa     777774037777
000003  aa     777000077417

000004  aa  117 146 146 000	Off

000005  aa     526000000000

000006  aa     516077777777

000007  aa     526077777777

000010  aa     524000000136

000011  aa     526000000003

000012  aa     524000000155

000013  aa     524000000112

000014  aa     524000000162

000015  aa     524000000255

000016  aa     514000000010

000017  aa     524000000044

000020  aa     524000000001

000021  aa     524000000113

000022  aa     404000000005

003641  aa     777777777777

000023  aa     000000000000

003642  aa     000000010000

000024  aa     404000000021

000025  aa     516000000011

000026  aa     410000000107

000027  aa     516000000001

000030  aa     000000000001

000031  aa     404000000003

000032  aa     000000000017
000033  aa     000000000017

000034  aa     000000000000
000035  aa     000000000000

000036  aa     516100000001
000037  aa     000000000001
000040  aa     000000000007
000041  aa     000000000001

000042  aa     516100000001
000043  aa     000000000001
000044  aa     000000000010
000045  aa     000000000001

000046  aa  123 145 164 040	Set 
000047  aa  164 150 145 040	the 
000050  aa  146 157 154 154	foll
000051  aa  157 167 151 156	owin
000052  aa  147 040 163 167	g sw
000053  aa  151 164 143 150	itch
000054  aa  145 163 040 157	es o
000055  aa  156 040 123 103	n SC
000056  aa  125 040 136 141	U ^a

000057  aa  136 057 136 070	^/^8
000060  aa  170 123 124 117	xSTO
000061  aa  122 105 040 101	RE A
000062  aa  040 040 101 061	  A1
000063  aa  040 102 040 040	 B  
000064  aa  102 061 136 057	B1^/
000065  aa  136 070 170 117	^8xO
000066  aa  116 040 040 040	N   
000067  aa  040 136 064 050	 ^4(
000070  aa  136 133 130 136	^[X^
000071  aa  073 040 136 135	; ^]
000072  aa  040 040 136 051	  ^)
000073  aa  136 057 136 070	^/^8
000074  aa  170 117 106 106	xOFF
000075  aa  040 040 040 136	   ^
000076  aa  064 050 136 133	4(^[
000077  aa  040 136 073 130	 ^;X
000100  aa  136 135 040 040	^]  
000101  aa  136 051 000 000	^)

000102  aa  163 143 162 137	scr_
000103  aa  165 164 151 154	util
000104  aa  072 040 145 162	: er
000105  aa  162 157 162 040	ror 
000106  aa  163 145 164 164	sett
000107  aa  151 156 147 040	ing 
000110  aa  143 157 156 146	conf
000111  aa  151 147 165 162	igur
000112  aa  141 164 151 157	atio
000113  aa  156 040 162 145	n re
000114  aa  147 151 163 164	gist
000115  aa  145 162 056 040	er. 
000116  aa  123 103 125 040	SCU 
000117  aa  136 141 040 155	^a m
000120  aa  165 163 164 040	ust 
000121  aa  142 145 040 163	be s
000122  aa  145 164 040 155	et m
000123  aa  141 156 165 141	anua
000124  aa  154 154 171 000	lly

000125  aa  101 146 164 145	Afte
000126  aa  162 040 163 145	r se
000127  aa  164 164 151 156	ttin
000130  aa  147 040 164 150	g th
000131  aa  145 040 163 167	e sw
000132  aa  151 164 143 150	itch
000133  aa  145 163 040 146	es f
000134  aa  157 162 040 123	or S
000135  aa  103 125 040 136	CU ^
000136  aa  141 040 160 154	a pl
000137  aa  141 143 145 040	ace 
000140  aa  123 103 125 040	SCU 
000141  aa  136 141 040 151	^a i
000142  aa  156 164 157 040	nto 
000143  aa  115 141 156 165	Manu
000144  aa  141 154 040 115	al M
000145  aa  157 144 145 040	ode 
000146  aa  141 156 144 040	and 
000147  aa  164 150 145 156	then
000150  aa  040 151 156 164	 int
000151  aa  157 040 120 162	o Pr
000152  aa  157 147 162 141	ogra
000153  aa  155 040 115 157	m Mo
000154  aa  144 145 000 000	de

000155  aa  136 057 136 070	^/^8
000156  aa  170 114 127 122	xLWR
000157  aa  040 123 124 117	 STO
000160  aa  122 105 040 123	RE S
000161  aa  111 132 105 040	IZE 
000162  aa  055 040 136 144	- ^d
000163  aa  136 057 136 070	^/^8
000164  aa  170 111 116 124	xINT
000165  aa  105 122 114 101	ERLA
000166  aa  103 105 040 055	CE -
000167  aa  040 136 133 117	 ^[O
000170  aa  116 136 073 117	N^;O
000171  aa  106 106 136 135	FF^]
000172  aa  136 057 136 070	^/^8
000173  aa  170 114 127 122	xLWR
000174  aa  040 123 124 117	 STO
000175  aa  122 105 040 055	RE -
000176  aa  040 136 133 102	 ^[B
000177  aa  136 073 101 136	^;A^
000200  aa  135 136 057 136	]^/^
000201  aa  070 170 115 101	8xMA
000202  aa  123 113 040 101	SK A
000203  aa  040 055 040 136	 - ^
000204  aa  141 136 057 136	a^/^
000205  aa  070 170 115 101	8xMA
000206  aa  123 113 040 102	SK B
000207  aa  040 055 040 136	 - ^
000210  aa  141 000 000 000	a

000211  aa  136 057 136 070	^/^8
000212  aa  170 116 117 116	xNON
000213  aa  055 105 130 111	-EXI
000214  aa  123 124 105 116	STEN
000215  aa  124 040 101 104	T AD
000216  aa  104 122 105 123	DRES
000217  aa  123 136 057 136	S^/^
000220  aa  061 067 170 062	17x2
000221  aa  040 063 040 064	 3 4
000222  aa  040 065 040 066	 5 6
000223  aa  040 067 040 070	 7 8
000224  aa  136 057 136 070	^/^8
000225  aa  170 117 116 040	xON 
000226  aa  040 136 133 130	 ^[X
000227  aa  136 073 040 136	^; ^
000230  aa  135 040 040 061	]  1
000231  aa  040 136 067 050	 ^7(
000232  aa  136 133 130 136	^[X^
000233  aa  073 040 136 135	; ^]
000234  aa  040 136 051 136	 ^)^
000235  aa  057 136 070 170	/^8x
000236  aa  117 106 106 040	OFF 
000237  aa  136 133 040 136	^[ ^
000240  aa  073 130 136 135	;X^]
000241  aa  040 040 060 040	  0 
000242  aa  136 067 050 136	^7(^
000243  aa  133 040 136 073	[ ^;
000244  aa  130 136 135 040	X^] 
000245  aa  136 051 000 000	^)

000246  aa  136 057 136 061	^/^1
000247  aa  062 170 055 055	2x--
000250  aa  120 117 122 124	PORT
000251  aa  040 105 116 101	 ENA
000252  aa  102 114 105 055	BLE-
000253  aa  055 040 040 055	-  -
000254  aa  055 103 131 103	-CYC
000255  aa  114 111 103 040	LIC 
000256  aa  120 122 111 117	PRIO
000257  aa  122 111 124 131	RITY
000260  aa  055 055 055 136	---^
000261  aa  057 136 061 062	/^12
000262  aa  170 060 040 061	x0 1
000263  aa  040 062 040 063	 2 3
000264  aa  040 064 040 065	 4 5
000265  aa  040 066 040 067	 6 7
000266  aa  040 040 060 057	  0/
000267  aa  061 040 061 057	1 1/
000270  aa  062 040 062 057	2 2/
000271  aa  063 040 063 057	3 3/
000272  aa  064 040 064 057	4 4/
000273  aa  065 040 065 057	5 5/
000274  aa  066 040 066 057	6 6/
000275  aa  067 136 057 136	7^/^
000276  aa  070 170 117 116	8xON
000277  aa  040 040 136 070	  ^8
000300  aa  050 136 133 130	(^[X
000301  aa  136 073 040 136	^; ^
000302  aa  135 040 136 051	] ^)
000303  aa  040 136 067 050	 ^7(
000304  aa  040 136 133 130	 ^[X
000305  aa  136 073 040 136	^; ^
000306  aa  135 040 040 136	]  ^
000307  aa  051 136 057 136	)^/^
000310  aa  070 170 117 106	8xOF
000311  aa  106 040 136 070	F ^8
000312  aa  050 136 133 040	(^[ 
000313  aa  136 073 130 136	^;X^
000314  aa  135 040 136 051	] ^)
000315  aa  040 136 067 050	 ^7(
000316  aa  040 136 133 040	 ^[ 
000317  aa  136 073 130 136	^;X^
000320  aa  135 040 040 136	]  ^
000321  aa  051 000 000 000	)

BEGIN PROCEDURE scr_util$read_cfg
ENTRY TO scr_util$read_cfg                                  STATEMENT 1 ON LINE 27
scr_util$read_cfg: proc (port);

000322  at     000001000031
000323  ta     000322000000
000324  da     000232300000
000325  aa   000420 6270 00	eax7 	272
000326  aa  7 00034 3521 20	epp2 	pr7|28,*
000327  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000330  aa     000002000000
000331  aa     000000000000
						STATEMENT 1 ON LINE 87
	cdp = addr (scs$controller_data (port));

000332  aa  6 00032 3735 20	epp7 	pr6|26,*
000333  aa  7 00002 2361 20	ldq  	pr7|2,*		port
000334  aa   000002 7360 00	qls  	2
000335  la  4 00022 3715 66	epp5 	pr4|18,*ql	scs$controller_data
000336  aa  6 00126 6515 00	spri5	pr6|86		cdp
						STATEMENT 1 ON LINE 89
	call privileged_mode_ut$rscr (port, SC_MR, mr_data);

000337  aa  7 00002 3521 20	epp2 	pr7|2,*		port
000340  aa  6 00176 2521 00	spri2	pr6|126
000341  aa   777462 3520 04	epp2 	-206,ic		000023 = 000000000000
000342  aa  6 00200 2521 00	spri2	pr6|128
000343  aa  6 00100 3521 00	epp2 	pr6|64		mr_data
000344  aa  6 00202 2521 00	spri2	pr6|130
000345  aa  6 00174 6211 00	eax1 	pr6|124
000346  aa   014000 4310 07	fld  	6144,dl
000347  la  4 00012 3521 20	epp2 	pr4|10,*		privileged_mode_ut$rscr
000350  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 90
	scrp = addr (mr_data);

000351  aa  6 00100 3735 00	epp7 	pr6|64		mr_data
000352  aa  6 00134 6535 00	spri7	pr6|92		scrp
						STATEMENT 1 ON LINE 91
	cdata.type = scr_mr.identification;

000353  aa  7 00001 2351 00	lda  	pr7|1		scr_mr.identification
000354  aa   000003 7710 00	arl  	3
000355  aa  6 00126 3715 20	epp5 	pr6|86,*		cdp
000356  aa  5 00002 6751 00	era  	pr5|2		cdata.type
000357  aa   003261 3750 04	ana  	1713,ic		003640 = 000001700000
000360  aa  5 00002 6551 00	ersa 	pr5|2		cdata.type
						STATEMENT 1 ON LINE 93
	call privileged_mode_ut$rscr (port, SC_CFG, scs$cfg_data (port));

000361  aa  6 00032 3535 20	epp3 	pr6|26,*
000362  aa  3 00002 2361 20	ldq  	pr3|2,*		port
000363  aa   000001 7360 00	qls  	1
000364  aa  3 00002 3521 20	epp2 	pr3|2,*		port
000365  aa  6 00176 2521 00	spri2	pr6|126
000366  aa   777442 3520 04	epp2 	-222,ic		000030 = 000000000001
000367  aa  6 00200 2521 00	spri2	pr6|128
000370  aa  6 00044 3701 20	epp4 	pr6|36,*
000371  la  4 00044 3521 66	epp2 	pr4|36,*ql	scs$cfg_data
000372  aa  6 00202 2521 00	spri2	pr6|130
000373  aa  6 00174 6211 00	eax1 	pr6|124
000374  aa   014000 4310 07	fld  	6144,dl
000375  la  4 00012 3521 20	epp2 	pr4|10,*		privileged_mode_ut$rscr
000376  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 94
	scrp = addr (scs$cfg_data (port));

000377  aa  6 00032 3735 20	epp7 	pr6|26,*
000400  aa  7 00002 2361 20	ldq  	pr7|2,*		port
000401  aa   000001 7360 00	qls  	1
000402  aa  6 00044 3701 20	epp4 	pr6|36,*
000403  la  4 00044 3715 66	epp5 	pr4|36,*ql	scs$cfg_data
000404  aa  6 00134 6515 00	spri5	pr6|92		scrp
						STATEMENT 1 ON LINE 96
	if cdata.type >= "0010"b then do;

000405  aa  6 00126 3535 20	epp3 	pr6|86,*		cdp
000406  aa  3 00002 2351 00	lda  	pr3|2		cdata.type
000407  aa   000021 7350 00	als  	17
000410  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
000411  aa   100000 1150 03	cmpa 	32768,du
000412  aa   000176 6020 04	tnc  	126,ic		000610
						STATEMENT 1 ON LINE 97
	     cdata.store_a_online = scr_cfg2.a_online;

000413  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.a_online
000414  aa   000012 7350 00	als  	10
000415  aa  3 00002 6751 00	era  	pr3|2		cdata.store_a_online
000416  aa   100000 3750 03	ana  	32768,du
000417  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_a_online
						STATEMENT 1 ON LINE 98
	     cdata.store_a1_online = scr_cfg2.a1_online;

000420  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.a1_online
000421  aa   000012 7350 00	als  	10
000422  aa  3 00002 6751 00	era  	pr3|2		cdata.store_a1_online
000423  aa   040000 3750 03	ana  	16384,du
000424  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_a1_online
						STATEMENT 1 ON LINE 99
	     cdata.store_b_online = scr_cfg2.b_online;

000425  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.b_online
000426  aa   000012 7350 00	als  	10
000427  aa  3 00002 6751 00	era  	pr3|2		cdata.store_b_online
000430  aa   020000 3750 03	ana  	8192,du
000431  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_b_online
						STATEMENT 1 ON LINE 100
	     cdata.store_b1_online = scr_cfg2.b1_online;

000432  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.b1_online
000433  aa   000012 7350 00	als  	10
000434  aa  3 00002 6751 00	era  	pr3|2		cdata.store_b1_online
000435  aa   010000 3750 03	ana  	4096,du
000436  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_b1_online
						STATEMENT 1 ON LINE 101
	     cdata.store_b_is_lower = scr_cfg2.lwr;

000437  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.lwr
000440  aa   000031 7350 00	als  	25
000441  aa  3 00002 6751 00	era  	pr3|2		cdata.store_b_is_lower
000442  aa   004000 3750 03	ana  	2048,du
000443  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_b_is_lower
						STATEMENT 1 ON LINE 102
	     cdata.int_interlaced = scr_cfg2.int;

000444  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.int
000445  aa   000026 7350 00	als  	22
000446  aa  3 00002 6751 00	era  	pr3|2		cdata.int_interlaced
000447  aa   001000 3750 03	ana  	512,du
000450  aa  3 00002 6551 00	ersa 	pr3|2		cdata.int_interlaced
						STATEMENT 1 ON LINE 103
	     cdata.lower_store_size = power_of_two (bin (scr_cfg2.size, 3) + 5);

000451  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.size
000452  aa   000011 7350 00	als  	9
000453  aa   000105 7730 00	lrl  	69
000454  aa   000005 0760 07	adq  	5,dl
000455  aa  6 00173 7561 00	stq  	pr6|123
000456  aa   003154 3520 04	epp2 	1644,ic		003632 = 000004000000
000457  aa   003100 6700 04	tsp4 	1600,ic		003557
000460  aa  6 00204 2361 00	ldq  	pr6|132
000461  aa   000066 7370 00	lls  	54
000462  aa  6 00126 3735 20	epp7 	pr6|86,*		cdp
000463  aa  7 00003 5511 60	stba 	pr7|3,60		cdata.lower_store_size
						STATEMENT 1 ON LINE 104
	     if (cdata.store_b_is_lower & cdata.store_a_online) |
	     (^cdata.store_b_is_lower & cdata.store_b_online) then
		if scr_cfg2.nea_enabled then		/* Compute size of upper store. */
		     cdata.upper_store_size =
		     bin (bit (scr_cfg2.nea, 12)) - mod (cdata.base, 4096) - cdata.lower_store_size;

000464  aa  7 00003 2351 00	lda  	pr7|3		cdata.lower_store_size
000465  aa   000066 7330 00	lrs  	54
000466  aa  6 00204 7561 00	stq  	pr6|132		cdata.lower_store_size
000467  aa  7 00002 2351 00	lda  	pr7|2		cdata.store_b_is_lower
000470  aa   000006 7350 00	als  	6
000471  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000472  aa  6 00173 7551 00	sta  	pr6|123		cdata.store_b_is_lower
000473  aa   000004 6000 04	tze  	4,ic		000477
000474  aa  7 00002 2351 00	lda  	pr7|2		cdata.store_a_online
000475  aa   100000 3150 03	cana 	32768,du
000476  aa   000006 6010 04	tnz  	6,ic		000504
000477  aa  6 00173 2351 00	lda  	pr6|123		cdata.store_b_is_lower
000500  aa   000034 6010 04	tnz  	28,ic		000534
000501  aa  7 00002 2351 00	lda  	pr7|2		cdata.store_b_online
000502  aa   020000 3150 03	cana 	8192,du
000503  aa   000031 6000 04	tze  	25,ic		000534
000504  aa  6 00134 2351 20	lda  	pr6|92,*		scr_cfg2.nea_enabled
000505  aa   020000 3150 07	cana 	8192,dl
000506  aa   000023 6000 04	tze  	19,ic		000531
000507  aa  7 00000 2351 00	lda  	pr7|0		cdata.base
000510  aa   000022 7350 00	als  	18
000511  aa   000066 7330 00	lrs  	54
000512  aa   003130 3520 04	epp2 	1624,ic		003642 = 000000010000
000513  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
000514  aa  6 00173 7561 00	stq  	pr6|123
000515  aa  6 00134 2351 20	lda  	pr6|92,*		scr_cfg2.nea
000516  aa   000027 7350 00	als  	23
000517  aa  0 00016 3771 00	anaq 	pr0|14		= 774000000000 000000000000
000520  aa   000074 7730 00	lrl  	60
000521  aa   000000 5330 00	negl 	0
000522  aa  6 00173 0331 00	adl  	pr6|123
000523  aa   000000 5330 00	negl 	0
000524  aa   000000 5330 00	negl 	0
000525  aa  6 00204 0331 00	adl  	pr6|132		cdata.lower_store_size
000526  aa   000000 5330 00	negl 	0
000527  aa  7 00003 5521 14	stbq 	pr7|3,14		cdata.upper_store_size
000530  aa   000006 7100 04	tra  	6,ic		000536
						STATEMENT 1 ON LINE 109
		else
		cdata.upper_store_size = cdata.lower_store_size;

000531  aa  6 00204 2361 00	ldq  	pr6|132		cdata.lower_store_size
000532  aa  7 00003 5521 14	stbq 	pr7|3,14		cdata.upper_store_size
000533  aa   000003 7100 04	tra  	3,ic		000536
						STATEMENT 1 ON LINE 111
	     else
	     cdata.upper_store_size = 0;

000534  aa   000000 2350 03	lda  	0,du
000535  aa  7 00003 5511 14	stba 	pr7|3,14		cdata.upper_store_size
						STATEMENT 1 ON LINE 113
	     string (cdata.cyclic_priority) = scr_cfg2.cyclic_prior;

000536  aa  6 00134 3715 20	epp5 	pr6|92,*		scrp
000537  aa  5 00001 2351 00	lda  	pr5|1		scr_cfg2.cyclic_prior
000540  aa   000013 7350 00	als  	11
000541  aa  7 00002 6751 00	era  	pr7|2
000542  aa   000376 3750 03	ana  	254,du
000543  aa  7 00002 6551 00	ersa 	pr7|2
						STATEMENT 1 ON LINE 114
	     call interpret_eima (1, scr_cfg2.mask_a_assign);

000544  aa   000001 2360 07	ldq  	1,dl
000545  aa  6 00204 7561 00	stq  	pr6|132
000546  aa  6 00204 3521 00	epp2 	pr6|132
000547  aa  6 00176 2521 00	spri2	pr6|126
000550  aa  5 00000 3521 00	epp2 	pr5|0		scr_cfg2.mask_a_assign
000551  aa  6 00200 2521 00	spri2	pr6|128
000552  aa  6 00174 3521 00	epp2 	pr6|124
000553  aa   010000 4310 07	fld  	4096,dl
000554  aa  2 00000 7571 00	staq 	pr2|0
000555  aa   002724 6700 04	tsp4 	1492,ic		003501
						STATEMENT 1 ON LINE 115
	     call interpret_eima (2, scr_cfg2.mask_b_assign);

000556  aa   000002 2360 07	ldq  	2,dl
000557  aa  6 00204 7561 00	stq  	pr6|132
000560  aa  6 00204 3521 00	epp2 	pr6|132
000561  aa  6 00176 2521 00	spri2	pr6|126
000562  aa  6 00134 3735 20	epp7 	pr6|92,*		scrp
000563  aa  7 00001 3521 00	epp2 	pr7|1		scr_cfg2.mask_b_assign
000564  aa  6 00200 2521 00	spri2	pr6|128
000565  aa  6 00174 3521 00	epp2 	pr6|124
000566  aa   010000 4310 07	fld  	4096,dl
000567  aa  2 00000 7571 00	staq 	pr2|0
000570  aa   002711 6700 04	tsp4 	1481,ic		003501
						STATEMENT 1 ON LINE 116
	     cdata.eima_data (1).mask_available,
		cdata.eima_data (2).mask_available = "1"b;

000571  aa   400000 2350 03	lda  	131072,du
000572  aa  6 00126 3735 20	epp7 	pr6|86,*		cdp
000573  aa  7 00001 2551 00	orsa 	pr7|1		cdata.mask_available
000574  aa   000400 2350 03	lda  	256,du
000575  aa  7 00001 2551 00	orsa 	pr7|1		cdata.mask_available
						STATEMENT 1 ON LINE 118
	     cdata.eima_data (3).mask_available,
		cdata.eima_data (4).mask_available = "0"b;

000576  aa   003033 2350 04	lda  	1563,ic		003631 = 777777377777
000577  aa  7 00001 3551 00	ansa 	pr7|1		cdata.mask_available
000600  aa   003030 2350 04	lda  	1560,ic		003630 = 777777777377
000601  aa  7 00001 3551 00	ansa 	pr7|1		cdata.mask_available
						STATEMENT 1 ON LINE 121
	     cdata.program = scr_cfg2.mode;

000602  aa  6 00134 2351 20	lda  	pr6|92,*		scr_cfg2.mode
000603  aa   000001 7710 00	arl  	1
000604  aa  7 00002 6751 00	era  	pr7|2		cdata.program
000605  aa   020000 3750 07	ana  	8192,dl
000606  aa  7 00002 6551 00	ersa 	pr7|2		cdata.program
						STATEMENT 1 ON LINE 122
	end;

000607  aa   000152 7100 04	tra  	106,ic		000761
						STATEMENT 1 ON LINE 126
	else do;

						STATEMENT 1 ON LINE 127
	     cdata.store_a_online = (scr_cfg1.mode_a = "000"b);

000610  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg1.mode_a
000611  aa   700000 3150 03	cana 	229376,du
000612  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
000613  aa   000002 7710 00	arl  	2
000614  aa  3 00002 6751 00	era  	pr3|2		cdata.store_a_online
000615  aa   100000 3750 03	ana  	32768,du
000616  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_a_online
						STATEMENT 1 ON LINE 128
	     cdata.store_b_online = (scr_cfg1.mode_b = "000"b);

000617  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg1.mode_b
000620  aa   007000 3150 03	cana 	3584,du
000621  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
000622  aa   000004 7710 00	arl  	4
000623  aa  3 00002 6751 00	era  	pr3|2		cdata.store_b_online
000624  aa   020000 3750 03	ana  	8192,du
000625  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_b_online
						STATEMENT 1 ON LINE 129
	     cdata.store_b_is_lower = scr_cfg1.lwr;

000626  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg1.lwr
000627  aa   000007 7350 00	als  	7
000630  aa  3 00002 6751 00	era  	pr3|2		cdata.store_b_is_lower
000631  aa   004000 3750 03	ana  	2048,du
000632  aa  3 00002 6551 00	ersa 	pr3|2		cdata.store_b_is_lower
						STATEMENT 1 ON LINE 130
	     cdata.int_interlaced = scr_cfg1.int;

000633  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg1.int
000634  aa   000004 7350 00	als  	4
000635  aa  3 00002 6751 00	era  	pr3|2		cdata.int_interlaced
000636  aa   001000 3750 03	ana  	512,du
000637  aa  3 00002 6551 00	ersa 	pr3|2		cdata.int_interlaced
						STATEMENT 1 ON LINE 131
	     if cdata.store_a_online then
		store_a_size = (bin (scr_cfg1.bdry_a, 3) + 1) * 32;

000640  aa  3 00002 2351 00	lda  	pr3|2		cdata.store_a_online
000641  aa   100000 3150 03	cana 	32768,du
000642  aa   000010 6000 04	tze  	8,ic		000652
000643  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg1.bdry_a
000644  aa   000003 7350 00	als  	3
000645  aa   000105 7730 00	lrl  	69
000646  aa   000001 0760 07	adq  	1,dl
000647  aa   000005 7360 00	qls  	5
000650  aa  6 00111 7561 00	stq  	pr6|73		store_a_size
000651  aa   000002 7100 04	tra  	2,ic		000653
						STATEMENT 1 ON LINE 133
	     else
	     store_a_size = 0;

000652  aa  6 00111 4501 00	stz  	pr6|73		store_a_size
						STATEMENT 1 ON LINE 135
	     if store_a_size = 128 then
		cdata.store_a1_online = "1"b;

000653  aa  6 00111 2361 00	ldq  	pr6|73		store_a_size
000654  aa   000200 1160 07	cmpq 	128,dl
000655  aa   000004 6010 04	tnz  	4,ic		000661
000656  aa   040000 2350 03	lda  	16384,du
000657  aa  3 00002 2551 00	orsa 	pr3|2		cdata.store_a1_online
000660  aa   000003 7100 04	tra  	3,ic		000663
						STATEMENT 1 ON LINE 137
	     else
	     cdata.store_a1_online = "0"b;

000661  aa   002746 2350 04	lda  	1510,ic		003627 = 737777777777
000662  aa  3 00002 3551 00	ansa 	pr3|2		cdata.store_a1_online
						STATEMENT 1 ON LINE 139
	     if cdata.store_b_online then
		store_b_size = (bin (scr_cfg1.bdry_b, 3) + 1) * 32;

000663  aa  3 00002 2351 00	lda  	pr3|2		cdata.store_b_online
000664  aa   020000 3150 03	cana 	8192,du
000665  aa   000010 6000 04	tze  	8,ic		000675
000666  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg1.bdry_b
000667  aa   000011 7350 00	als  	9
000670  aa   000105 7730 00	lrl  	69
000671  aa   000001 0760 07	adq  	1,dl
000672  aa   000005 7360 00	qls  	5
000673  aa  6 00112 7561 00	stq  	pr6|74		store_b_size
000674  aa   000002 7100 04	tra  	2,ic		000676
						STATEMENT 1 ON LINE 141
	     else
	     store_b_size = 0;

000675  aa  6 00112 4501 00	stz  	pr6|74		store_b_size
						STATEMENT 1 ON LINE 143
	     if store_b_size = 128 then
		cdata.store_b1_online = "1"b;

000676  aa  6 00112 2361 00	ldq  	pr6|74		store_b_size
000677  aa   000200 1160 07	cmpq 	128,dl
000700  aa   000004 6010 04	tnz  	4,ic		000704
000701  aa   010000 2350 03	lda  	4096,du
000702  aa  3 00002 2551 00	orsa 	pr3|2		cdata.store_b1_online
000703  aa   000003 7100 04	tra  	3,ic		000706
						STATEMENT 1 ON LINE 145
	     else
	     cdata.store_b1_online = "0"b;

000704  aa   002722 2350 04	lda  	1490,ic		003626 = 767777777777
000705  aa  3 00002 3551 00	ansa 	pr3|2		cdata.store_b1_online
						STATEMENT 1 ON LINE 147
	     if cdata.store_b_is_lower then do;

000706  aa  3 00002 2351 00	lda  	pr3|2		cdata.store_b_is_lower
000707  aa   004000 3150 03	cana 	2048,du
000710  aa   000006 6000 04	tze  	6,ic		000716
						STATEMENT 1 ON LINE 148
		cdata.lower_store_size = store_b_size;

000711  aa   000066 7370 00	lls  	54
000712  aa  3 00003 5511 60	stba 	pr3|3,60		cdata.lower_store_size
						STATEMENT 1 ON LINE 149
		cdata.upper_store_size = store_a_size;

000713  aa  6 00111 2361 00	ldq  	pr6|73		store_a_size
000714  aa  3 00003 5521 14	stbq 	pr3|3,14		cdata.upper_store_size
						STATEMENT 1 ON LINE 150
	     end;

000715  aa   000006 7100 04	tra  	6,ic		000723
						STATEMENT 1 ON LINE 151
	     else do;

						STATEMENT 1 ON LINE 152
		cdata.lower_store_size = store_a_size;

000716  aa  6 00111 2361 00	ldq  	pr6|73		store_a_size
000717  aa   000066 7370 00	lls  	54
000720  aa  3 00003 5511 60	stba 	pr3|3,60		cdata.lower_store_size
						STATEMENT 1 ON LINE 153
		cdata.upper_store_size = store_b_size;

000721  aa  6 00112 2361 00	ldq  	pr6|74		store_b_size
000722  aa  3 00003 5521 14	stbq 	pr3|3,14		cdata.upper_store_size
						STATEMENT 1 ON LINE 154
	     end;

						STATEMENT 1 ON LINE 155
	     string (cdata.cyclic_priority) = (7)"0"b;

000723  aa   002702 2350 04	lda  	1474,ic		003625 = 777401777777
000724  aa  3 00002 3551 00	ansa 	pr3|2
						STATEMENT 1 ON LINE 156
	     do i = 1 to 4;

000725  aa   000001 2360 07	ldq  	1,dl
000726  aa  6 00102 7561 00	stq  	pr6|66		i
000727  aa   000000 0110 03	nop  	0,du
000730  aa  6 00102 2361 00	ldq  	pr6|66		i
000731  aa   000004 1160 07	cmpq 	4,dl
000732  aa   000024 6054 04	tpnz 	20,ic		000756
						STATEMENT 1 ON LINE 157
		call interpret_eima (i, scr_cfg1.pima (i));

000733  aa   000011 4020 07	mpy  	9,dl
000734  aa  6 00102 3521 00	epp2 	pr6|66		i
000735  aa  6 00176 2521 00	spri2	pr6|126
000736  aa   000033 6270 06	eax7 	27,ql
000737  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg1.pima
000740  aa  2 00000 5035 17	abd  	pr2|0,7
000741  aa  6 00200 2521 00	spri2	pr6|128
000742  aa  6 00174 3521 00	epp2 	pr6|124
000743  aa   010000 4310 07	fld  	4096,dl
000744  aa  2 00000 7571 00	staq 	pr2|0
000745  aa   002534 6700 04	tsp4 	1372,ic		003501
						STATEMENT 1 ON LINE 158
		cdata.eima_data (i).mask_available = "1"b;

000746  aa  6 00102 2361 00	ldq  	pr6|66		i
000747  aa   000011 4020 07	mpy  	9,dl
000750  aa  6 00126 3735 20	epp7 	pr6|86,*		cdp
000751  aa  403 106 060 400	csl  	(),(pr,ql),fill(1),bool(move)
000752  aa   000000 00 0000	descb	0,0
000753  aa  7 00000 60 0001	descb	pr7|0(27),1	cdata.mask_available
						STATEMENT 1 ON LINE 159
	     end;

000754  aa  6 00102 0541 00	aos  	pr6|66		i
000755  aa   777753 7100 04	tra  	-21,ic		000730
						STATEMENT 1 ON LINE 161
	     cdata.program = "1"b;

000756  aa   020000 2350 07	lda  	8192,dl
000757  aa  6 00126 3735 20	epp7 	pr6|86,*		cdp
000760  aa  7 00002 2551 00	orsa 	pr7|2		cdata.program
						STATEMENT 1 ON LINE 162
	end;

						STATEMENT 1 ON LINE 164
	return;

000761  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_port_enable                                    STATEMENT 1 ON LINE 168
set_port_enable: entry (port, enable_sw);

000762  at     000002000031
000763  ta     000027000000
000764  ta     000762000000
000765  da     000241300000
000766  aa   000420 6270 00	eax7 	272
000767  aa  7 00034 3521 20	epp2 	pr7|28,*
000770  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000771  aa     000004000000
000772  aa     000000000000
000773  aa  6 00032 3735 20	epp7 	pr6|26,*
000774  aa  7 00004 3715 20	epp5 	pr7|4,*
000775  aa  6 00140 6515 00	spri5	pr6|96
						STATEMENT 1 ON LINE 173
	call set_port_enable_bit (port, enable_sw);

000776  aa  6 00032 3735 20	epp7 	pr6|26,*
000777  aa  7 00002 3521 20	epp2 	pr7|2,*		port
001000  aa  6 00176 2521 00	spri2	pr6|126
001001  aa  6 00140 3521 20	epp2 	pr6|96,*		enable_sw
001002  aa  6 00200 2521 00	spri2	pr6|128
001003  aa  6 00174 6211 00	eax1 	pr6|124
001004  aa   010000 4310 07	fld  	4096,dl
001005  aa   000030 3520 04	epp2 	24,ic		001035 = 000420627000
001006  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 175
	do ctag = 0 to 7;

001007  aa  6 00103 4501 00	stz  	pr6|67		ctag
001010  aa  6 00103 2361 00	ldq  	pr6|67		ctag
001011  aa   000007 1160 07	cmpq 	7,dl
001012  aa   000020 6054 04	tpnz 	16,ic		001032
						STATEMENT 1 ON LINE 176
	     cdp = addr (scs$controller_data (ctag));

001013  aa   000002 7360 00	qls  	2
001014  aa  6 00044 3701 20	epp4 	pr6|36,*
001015  la  4 00022 3735 66	epp7 	pr4|18,*ql	scs$controller_data
001016  aa  6 00126 6535 00	spri7	pr6|86		cdp
						STATEMENT 1 ON LINE 178
	     if cdata.online then			/* If controller is in use ... */
		call enable_ports (ctag);

001017  aa  7 00002 2351 00	lda  	pr7|2		cdata.online
001020  aa   400000 3150 03	cana 	131072,du
001021  aa   000007 6000 04	tze  	7,ic		001030
001022  aa  6 00103 3521 00	epp2 	pr6|67		ctag
001023  aa  6 00176 2521 00	spri2	pr6|126
001024  aa  6 00174 6211 00	eax1 	pr6|124
001025  aa   004000 4310 07	fld  	2048,dl
001026  aa   000057 3520 04	epp2 	47,ic		001105 = 000420627000
001027  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 180
	end;

001030  aa  6 00103 0541 00	aos  	pr6|67		ctag
001031  aa   777757 7100 04	tra  	-17,ic		001010
						STATEMENT 1 ON LINE 182
	return;

001032  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_port_enable_bit                                STATEMENT 1 ON LINE 186
set_port_enable_bit: entry (port, enable_sw);

001033  ta     000762000000
001034  da     000251300000
001035  aa   000420 6270 00	eax7 	272
001036  aa  7 00034 3521 20	epp2 	pr7|28,*
001037  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001040  aa     000004000000
001041  aa     000000000000
001042  aa  6 00032 3735 20	epp7 	pr6|26,*
001043  aa  7 00004 3715 20	epp5 	pr7|4,*
001044  aa  6 00140 6515 00	spri5	pr6|96
						STATEMENT 1 ON LINE 189
	mkp = addr (scs$sys_level);

001045  aa  6 00044 3701 20	epp4 	pr6|36,*
001046  la  4 00030 3735 20	epp7 	pr4|24,*		scs$sys_level
001047  aa  6 00132 6535 00	spri7	pr6|90		mkp
						STATEMENT 1 ON LINE 191
	do i = 1 to scs$number_of_masks;

001050  la  4 00036 2361 20	ldq  	pr4|30,*		scs$number_of_masks
001051  aa  6 00142 7561 00	stq  	pr6|98
001052  aa   000001 2360 07	ldq  	1,dl
001053  aa  6 00102 7561 00	stq  	pr6|66		i
001054  aa  6 00102 2361 00	ldq  	pr6|66		i
001055  aa  6 00142 1161 00	cmpq 	pr6|98
001056  aa   000024 6054 04	tpnz 	20,ic		001102
						STATEMENT 1 ON LINE 192
	     scrp = addr (masks (i));

001057  aa   000001 7360 00	qls  	1
001060  aa  6 00132 3735 20	epp7 	pr6|90,*		mkp
001061  aa  7 77776 3735 06	epp7 	pr7|-2,ql		masks
001062  aa  6 00134 6535 00	spri7	pr6|92		scrp
						STATEMENT 1 ON LINE 193
	     if port < 4 then			/* If ports 0 thru 3 ... */
		substr (scr_msk.port_mask_1, port + 1, 1) = enable_sw;

001063  aa  6 00032 3715 20	epp5 	pr6|26,*
001064  aa  5 00002 2361 20	ldq  	pr5|2,*		port
001065  aa   000004 1160 07	cmpq 	4,dl
001066  aa   000006 6050 04	tpl  	6,ic		001074
001067  aa  6 00140 3535 20	epp3 	pr6|96,*
001070  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
001071  aa  3 00000 00 0001	descb	pr3|0,1		enable_sw
001072  aa  7 00000 65 0001	descb	pr7|0(32),1	scr_msk.port_mask_1
001073  aa   000005 7100 04	tra  	5,ic		001100
						STATEMENT 1 ON LINE 195
	     else					/* If ports 4 thru 7 ... */
	     substr (scr_msk.port_mask_2, port - 3, 1) = enable_sw;

001074  aa  6 00140 3535 20	epp3 	pr6|96,*
001075  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
001076  aa  3 00000 00 0001	descb	pr3|0,1		enable_sw
001077  aa  7 00001 61 0001	descb	pr7|1(28),1	scr_msk.port_mask_2
						STATEMENT 1 ON LINE 197
	end;

001100  aa  6 00102 0541 00	aos  	pr6|66		i
001101  aa   777753 7100 04	tra  	-21,ic		001054
						STATEMENT 1 ON LINE 199
	return;

001102  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO enable_ports                                       STATEMENT 1 ON LINE 203
enable_ports: entry (port);

001103  ta     000322000000
001104  da     000260300000
001105  aa   000420 6270 00	eax7 	272
001106  aa  7 00034 3521 20	epp2 	pr7|28,*
001107  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001110  aa     000002000000
001111  aa     000000000000
						STATEMENT 1 ON LINE 206
	cdp = addr (scs$controller_data (port));

001112  aa  6 00032 3735 20	epp7 	pr6|26,*
001113  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001114  aa   000002 7360 00	qls  	2
001115  aa  6 00044 3701 20	epp4 	pr6|36,*
001116  la  4 00022 3715 66	epp5 	pr4|18,*ql	scs$controller_data
001117  aa  6 00126 6515 00	spri5	pr6|86		cdp
						STATEMENT 1 ON LINE 207
	scrp = addr (scs$cfg_data (port));

001120  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001121  aa   000001 7360 00	qls  	1
001122  la  4 00044 3535 66	epp3 	pr4|36,*ql	scs$cfg_data
001123  aa  6 00134 2535 00	spri3	pr6|92		scrp
						STATEMENT 1 ON LINE 208
	mkp = addr (scs$sys_level);

001124  la  4 00030 3515 20	epp1 	pr4|24,*		scs$sys_level
001125  aa  6 00132 2515 00	spri1	pr6|90		mkp
						STATEMENT 1 ON LINE 210
	if cdata.type >= "0010"b then do;

001126  aa  5 00002 2351 00	lda  	pr5|2		cdata.type
001127  aa   000021 7350 00	als  	17
001130  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001131  aa   100000 1150 03	cmpa 	32768,du
001132  aa   000020 6020 04	tnc  	16,ic		001152
						STATEMENT 1 ON LINE 211
	     scr_cfg2.port_mask_0_3 = mkp -> scr_msk.port_mask_1;

001133  aa  1 00000 2351 00	lda  	pr1|0		scr_msk.port_mask_1
001134  aa  3 00000 6751 00	era  	pr3|0		scr_cfg2.port_mask_0_3
001135  aa   000017 3750 07	ana  	15,dl
001136  aa  3 00000 6551 00	ersa 	pr3|0		scr_cfg2.port_mask_0_3
						STATEMENT 1 ON LINE 212
	     scr_cfg2.port_mask_4_7 = mkp -> scr_msk.port_mask_2;

001137  aa  1 00001 2351 00	lda  	pr1|1		scr_msk.port_mask_2
001140  aa  3 00001 6751 00	era  	pr3|1		scr_cfg2.port_mask_4_7
001141  aa   000017 3750 07	ana  	15,dl
001142  aa  3 00001 6551 00	ersa 	pr3|1		scr_cfg2.port_mask_4_7
						STATEMENT 1 ON LINE 213
	     call set_cfg (port);

001143  aa  7 00002 3521 20	epp2 	pr7|2,*		port
001144  aa  6 00176 2521 00	spri2	pr6|126
001145  aa  6 00174 6211 00	eax1 	pr6|124
001146  aa   004000 4310 07	fld  	2048,dl
001147  aa   000625 3520 04	epp2 	405,ic		001774 = 000420627000
001150  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 214
	end;

001151  aa   000025 7100 04	tra  	21,ic		001176
						STATEMENT 1 ON LINE 216
	else					/* If 6000 SC ... */
	if port = scs$interrupt_controller then		/* If bootload controller, allow interrupts. */
	     call privileged_mode_ut$smcm (port, scs$open_level);

001152  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001153  la  4 00042 1161 20	cmpq 	pr4|34,*		scs$interrupt_controller
001154  aa   000012 6010 04	tnz  	10,ic		001166
001155  aa  7 00002 3521 20	epp2 	pr7|2,*		port
001156  aa  6 00176 2521 00	spri2	pr6|126
001157  la  4 00032 3521 20	epp2 	pr4|26,*		scs$open_level
001160  aa  6 00200 2521 00	spri2	pr6|128
001161  aa  6 00174 6211 00	eax1 	pr6|124
001162  aa   010000 4310 07	fld  	4096,dl
001163  la  4 00016 3521 20	epp2 	pr4|14,*		privileged_mode_ut$smcm
001164  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
001165  aa   000011 7100 04	tra  	9,ic		001176
						STATEMENT 1 ON LINE 219
	else					/* If not bootload controller, prevent interrupts. */
	call privileged_mode_ut$smcm (port, scs$sys_level);

001166  aa  7 00002 3521 20	epp2 	pr7|2,*		port
001167  aa  6 00176 2521 00	spri2	pr6|126
001170  la  4 00030 3521 20	epp2 	pr4|24,*		scs$sys_level
001171  aa  6 00200 2521 00	spri2	pr6|128
001172  aa  6 00174 6211 00	eax1 	pr6|124
001173  aa   010000 4310 07	fld  	4096,dl
001174  la  4 00016 3521 20	epp2 	pr4|14,*		privileged_mode_ut$smcm
001175  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 222
	return;

001176  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO disable_ports                                      STATEMENT 1 ON LINE 226
disable_ports: entry (port);

001177  ta     000322000000
001200  da     000267300000
001201  aa   000420 6270 00	eax7 	272
001202  aa  7 00034 3521 20	epp2 	pr7|28,*
001203  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001204  aa     000002000000
001205  aa     000000000000
						STATEMENT 1 ON LINE 229
	cdp = addr (scs$controller_data (port));

001206  aa  6 00032 3735 20	epp7 	pr6|26,*
001207  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001210  aa   000002 7360 00	qls  	2
001211  aa  6 00044 3701 20	epp4 	pr6|36,*
001212  la  4 00022 3715 66	epp5 	pr4|18,*ql	scs$controller_data
001213  aa  6 00126 6515 00	spri5	pr6|86		cdp
						STATEMENT 1 ON LINE 230
	scrp = addr (scs$cfg_data (port));

001214  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001215  aa   000001 7360 00	qls  	1
001216  la  4 00044 3535 66	epp3 	pr4|36,*ql	scs$cfg_data
001217  aa  6 00134 2535 00	spri3	pr6|92		scrp
						STATEMENT 1 ON LINE 232
	if cdata.type >= "0010"b then do;

001220  aa  5 00002 2351 00	lda  	pr5|2		cdata.type
001221  aa   000021 7350 00	als  	17
001222  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001223  aa   100000 1150 03	cmpa 	32768,du
001224  aa   000013 6020 04	tnc  	11,ic		001237
						STATEMENT 1 ON LINE 233
	     scr_cfg2.port_mask_0_3 = "0000"b;

001225  aa   002377 2350 04	lda  	1279,ic		003624 = 777777777760
001226  aa  3 00000 3551 00	ansa 	pr3|0		scr_cfg2.port_mask_0_3
						STATEMENT 1 ON LINE 234
	     scr_cfg2.port_mask_4_7 = "0000"b;

001227  aa  3 00001 3551 00	ansa 	pr3|1		scr_cfg2.port_mask_4_7
						STATEMENT 1 ON LINE 235
	     call set_cfg (port);

001230  aa  7 00002 3521 20	epp2 	pr7|2,*		port
001231  aa  6 00176 2521 00	spri2	pr6|126
001232  aa  6 00174 6211 00	eax1 	pr6|124
001233  aa   004000 4310 07	fld  	2048,dl
001234  aa   000540 3520 04	epp2 	352,ic		001774 = 000420627000
001235  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 236
	end;

001236  aa   000013 7100 04	tra  	11,ic		001251
						STATEMENT 1 ON LINE 238
	else					/* If 6000 SC ... */
	call privileged_mode_ut$smcm (port, unspec (bin (0, 71)));

001237  aa   776575 2370 04	ldaq 	-643,ic		000034 = 000000000000 000000000000
001240  aa  6 00206 7571 00	staq 	pr6|134
001241  aa  7 00002 3521 20	epp2 	pr7|2,*		port
001242  aa  6 00176 2521 00	spri2	pr6|126
001243  aa  6 00206 3521 00	epp2 	pr6|134
001244  aa  6 00200 2521 00	spri2	pr6|128
001245  aa  6 00174 6211 00	eax1 	pr6|124
001246  aa   010000 4310 07	fld  	4096,dl
001247  la  4 00016 3521 20	epp2 	pr4|14,*		privileged_mode_ut$smcm
001250  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 241
	return;

001251  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO assign_mask                                        STATEMENT 1 ON LINE 245
assign_mask: entry (port, target);

001252  at     000002000031
001253  ta     000031000000
001254  ta     001252000000
001255  da     000275300000
001256  aa   000420 6270 00	eax7 	272
001257  aa  7 00034 3521 20	epp2 	pr7|28,*
001260  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001261  aa     000004000000
001262  aa     000000000000
						STATEMENT 1 ON LINE 252
	cdp = addr (scs$controller_data (port));

001263  aa  6 00032 3735 20	epp7 	pr6|26,*
001264  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001265  aa   000002 7360 00	qls  	2
001266  aa  6 00044 3701 20	epp4 	pr6|36,*
001267  la  4 00022 3715 66	epp5 	pr4|18,*ql	scs$controller_data
001270  aa  6 00126 6515 00	spri5	pr6|86		cdp
						STATEMENT 1 ON LINE 253
	scrp = addr (scs$cfg_data (port));

001271  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001272  aa   000001 7360 00	qls  	1
001273  la  4 00044 3535 66	epp3 	pr4|36,*ql	scs$cfg_data
001274  aa  6 00134 2535 00	spri3	pr6|92		scrp
						STATEMENT 1 ON LINE 255
	if cdata.type >= "0010"b then do i = 1 to 2;

001275  aa  5 00002 2351 00	lda  	pr5|2		cdata.type
001276  aa   000021 7350 00	als  	17
001277  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001300  aa   100000 1150 03	cmpa 	32768,du
001301  aa   000050 6020 04	tnc  	40,ic		001351
001302  aa   000001 2360 07	ldq  	1,dl
001303  aa  6 00102 7561 00	stq  	pr6|66		i
001304  aa  6 00102 2361 00	ldq  	pr6|66		i
001305  aa   000002 1160 07	cmpq 	2,dl
001306  aa   000043 6054 04	tpnz 	35,ic		001351
						STATEMENT 1 ON LINE 256
	     if ^cdata.eima_data (i).mask_assigned then do;

001307  aa   000011 4020 07	mpy  	9,dl
001310  aa  6 00126 3735 20	epp7 	pr6|86,*		cdp
001311  aa  000 000 066 506	cmpb 	(pr,ql),(),fill(0)
001312  aa  7 00000 61 0001	descb	pr7|0(28),1	cdata.mask_assigned
001313  aa   000000 00 0000	descb	0,0
001314  aa   000033 6010 04	tnz  	27,ic		001347
						STATEMENT 1 ON LINE 257
		cdata.eima_data (i).mask_assignment = target;

001315  aa  6 00032 3715 20	epp5 	pr6|26,*
001316  aa   000000 6270 06	eax7 	0,ql
001317  aa  5 00004 2361 20	ldq  	pr5|4,*		target
001320  aa   000104 7370 00	lls  	68
001321  aa  6 00056 7551 00	sta  	pr6|46
001322  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001323  aa  6 00056 00 0004	descb	pr6|46,4
001324  aa  7 00000 65 0004	descb	pr7|0(32),4	cdata.mask_assignment
						STATEMENT 1 ON LINE 258
		cdata.eima_data (i).mask_assigned = "1"b;

001325  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
001326  aa   000000 00 0000	descb	0,0
001327  aa  7 00000 61 0001	descb	pr7|0(28),1	cdata.mask_assigned
						STATEMENT 1 ON LINE 259
		mask_assignment = set_mask_assignment (target + 1);

001330  aa  5 00004 2361 20	ldq  	pr5|4,*		target
001331  aa   000001 0760 07	adq  	1,dl
001332  aa  6 00205 7561 00	stq  	pr6|133
001333  aa   002263 3520 04	epp2 	1203,ic		003616 = 000004000000
001334  aa   002207 6700 04	tsp4 	1159,ic		003543
						STATEMENT 1 ON LINE 260
		if i = 1 then			/* Set appropriate field in CFG data. */
		     scr_cfg2.mask_a_assign = mask_assignment;

001335  aa  6 00102 2361 00	ldq  	pr6|66		i
001336  aa   000001 1160 07	cmpq 	1,dl
001337  aa   000005 6010 04	tnz  	5,ic		001344
001340  aa  6 00136 2351 00	lda  	pr6|94		mask_assignment
001341  aa  6 00134 3735 20	epp7 	pr6|92,*		scr_cfg2.mask_a_assign
001342  aa  7 00000 5511 40	stba 	pr7|0,40		scr_cfg2.mask_a_assign
001343  aa   000004 7100 04	tra  	4,ic		001347
						STATEMENT 1 ON LINE 262
		else
		scr_cfg2.mask_b_assign = mask_assignment;

001344  aa  6 00136 2351 00	lda  	pr6|94		mask_assignment
001345  aa  6 00134 3735 20	epp7 	pr6|92,*		scrp
001346  aa  7 00001 5511 40	stba 	pr7|1,40		scr_cfg2.mask_b_assign
						STATEMENT 1 ON LINE 264
	     end;

						STATEMENT 1 ON LINE 265
	end;

001347  aa  6 00102 0541 00	aos  	pr6|66		i
001350  aa   777734 7100 04	tra  	-36,ic		001304
						STATEMENT 1 ON LINE 267
	return;

001351  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO unassign_mask                                      STATEMENT 1 ON LINE 271
unassign_mask: entry (port, target);

001352  ta     001252000000
001353  da     000304300000
001354  aa   000420 6270 00	eax7 	272
001355  aa  7 00034 3521 20	epp2 	pr7|28,*
001356  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001357  aa     000004000000
001360  aa     000000000000
						STATEMENT 1 ON LINE 274
	cdp = addr (scs$controller_data (port));

001361  aa  6 00032 3735 20	epp7 	pr6|26,*
001362  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001363  aa   000002 7360 00	qls  	2
001364  aa  6 00044 3701 20	epp4 	pr6|36,*
001365  la  4 00022 3715 66	epp5 	pr4|18,*ql	scs$controller_data
001366  aa  6 00126 6515 00	spri5	pr6|86		cdp
						STATEMENT 1 ON LINE 275
	scrp = addr (scs$cfg_data (port));

001367  aa  7 00002 2361 20	ldq  	pr7|2,*		port
001370  aa   000001 7360 00	qls  	1
001371  la  4 00044 3535 66	epp3 	pr4|36,*ql	scs$cfg_data
001372  aa  6 00134 2535 00	spri3	pr6|92		scrp
						STATEMENT 1 ON LINE 277
	if cdata.type >= "0010"b then do i = 1 to 2;

001373  aa  5 00002 2351 00	lda  	pr5|2		cdata.type
001374  aa   000021 7350 00	als  	17
001375  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001376  aa   100000 1150 03	cmpa 	32768,du
001377  aa   000051 6020 04	tnc  	41,ic		001450
001400  aa   000001 2360 07	ldq  	1,dl
001401  aa  6 00102 7561 00	stq  	pr6|66		i
001402  aa  6 00102 2361 00	ldq  	pr6|66		i
001403  aa   000002 1160 07	cmpq 	2,dl
001404  aa   000044 6054 04	tpnz 	36,ic		001450
						STATEMENT 1 ON LINE 278
	     if cdata.eima_data (i).mask_assigned &	/* Look for mask used for this target. */
	     (cdata.eima_data (i).mask_assignment = target) then do;

001405  aa   000011 4020 07	mpy  	9,dl
001406  aa  6 00126 3735 20	epp7 	pr6|86,*		cdp
001407  aa  000 000 066 506	cmpb 	(pr,ql),(),fill(0)
001410  aa  7 00000 61 0001	descb	pr7|0(28),1	cdata.mask_assigned
001411  aa   000000 00 0000	descb	0,0
001412  aa   000034 6000 04	tze  	28,ic		001446
001413  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001414  aa  7 00000 65 0004	descb	pr7|0(32),4	cdata.mask_assignment
001415  aa  6 00056 00 0044	descb	pr6|46,36
001416  aa  6 00056 2351 00	lda  	pr6|46
001417  aa  6 00205 7561 00	stq  	pr6|133
001420  aa   000104 7330 00	lrs  	68
001421  aa  6 00032 3715 20	epp5 	pr6|26,*
001422  aa  5 00004 1161 20	cmpq 	pr5|4,*		target
001423  aa   000023 6010 04	tnz  	19,ic		001446
						STATEMENT 1 ON LINE 280
		cdata.eima_data (i).mask_assigned = "0"b;

001424  aa  6 00205 7271 00	lxl7 	pr6|133
001425  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
001426  aa   000000 00 0000	descb	0,0
001427  aa  7 00000 61 0001	descb	pr7|0(28),1	cdata.mask_assigned
						STATEMENT 1 ON LINE 281
		mask_assignment = set_mask_assignment (9);

001430  aa   000011 2360 07	ldq  	9,dl
001431  aa  6 00205 7561 00	stq  	pr6|133
001432  aa   002164 3520 04	epp2 	1140,ic		003616 = 000004000000
001433  aa   002110 6700 04	tsp4 	1096,ic		003543
						STATEMENT 1 ON LINE 282
		if i = 1 then			/* Set appropriate field in CFG data. */
		     scr_cfg2.mask_a_assign = mask_assignment;

001434  aa  6 00102 2361 00	ldq  	pr6|66		i
001435  aa   000001 1160 07	cmpq 	1,dl
001436  aa   000005 6010 04	tnz  	5,ic		001443
001437  aa  6 00136 2351 00	lda  	pr6|94		mask_assignment
001440  aa  6 00134 3735 20	epp7 	pr6|92,*		scr_cfg2.mask_a_assign
001441  aa  7 00000 5511 40	stba 	pr7|0,40		scr_cfg2.mask_a_assign
001442  aa   000004 7100 04	tra  	4,ic		001446
						STATEMENT 1 ON LINE 284
		else
		scr_cfg2.mask_b_assign = mask_assignment;

001443  aa  6 00136 2351 00	lda  	pr6|94		mask_assignment
001444  aa  6 00134 3735 20	epp7 	pr6|92,*		scrp
001445  aa  7 00001 5511 40	stba 	pr7|1,40		scr_cfg2.mask_b_assign
						STATEMENT 1 ON LINE 286
	     end;

						STATEMENT 1 ON LINE 287
	end;

001446  aa  6 00102 0541 00	aos  	pr6|66		i
001447  aa   777733 7100 04	tra  	-37,ic		001402
						STATEMENT 1 ON LINE 289
	return;

001450  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO reassign_mask                                      STATEMENT 1 ON LINE 294
reassign_mask: entry (tag1, tag2);

001451  ta     001252000000
001452  da     000313300000
001453  aa   000420 6270 00	eax7 	272
001454  aa  7 00034 3521 20	epp2 	pr7|28,*
001455  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001456  aa     000004000000
001457  aa     000000000000
						STATEMENT 1 ON LINE 300
	ctag = scs$interrupt_controller;

001460  aa  6 00044 3701 20	epp4 	pr6|36,*
001461  la  4 00042 2361 20	ldq  	pr4|34,*		scs$interrupt_controller
001462  aa  6 00103 7561 00	stq  	pr6|67		ctag
						STATEMENT 1 ON LINE 302
	if tag1 ^= -1 then do;

001463  aa  6 00032 3735 20	epp7 	pr6|26,*
001464  aa  7 00002 2361 20	ldq  	pr7|2,*		tag1
001465  aa   002154 1160 04	cmpq 	1132,ic		003641 = 777777777777
001466  aa   000047 6000 04	tze  	39,ic		001535
						STATEMENT 1 ON LINE 303
	     pdp = addr (scs$processor_data (tag1));

001467  la  4 00024 3715 66	epp5 	pr4|20,*ql	scs$processor_data
001470  aa  6 00130 6515 00	spri5	pr6|88		pdp
						STATEMENT 1 ON LINE 305
	     if tag2 ^= -1 then 			/* Check for same-port (poss. expander) case and punt */
		if pdata.controller_port = scs$processor_data (tag2).controller_port then return;

001471  aa  7 00004 2361 20	ldq  	pr7|4,*		tag2
001472  aa   002147 1160 04	cmpq 	1127,ic		003641 = 777777777777
001473  aa   000010 6000 04	tze  	8,ic		001503
001474  la  4 00024 2361 66	ldq  	pr4|20,*ql	scs$processor_data.controller_port
001475  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001476  aa  6 00205 7561 00	stq  	pr6|133		scs$processor_data.controller_port
001477  aa  5 00000 2361 00	ldq  	pr5|0		pdata.controller_port
001500  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001501  aa  6 00205 1161 00	cmpq 	pr6|133		scs$processor_data.controller_port
001502  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 307
	     call set_mask (ctag, (pdata.controller_port), 0);

001503  aa  5 00000 2361 00	ldq  	pr5|0		pdata.controller_port
001504  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001505  aa  6 00205 7561 00	stq  	pr6|133
001506  aa   776326 2370 04	ldaq 	-810,ic		000034 = 000000000000 000000000000
001507  aa  6 00206 7571 00	staq 	pr6|134
001510  aa  6 00103 3521 00	epp2 	pr6|67		ctag
001511  aa  6 00176 2521 00	spri2	pr6|126
001512  aa  6 00205 3521 00	epp2 	pr6|133
001513  aa  6 00200 2521 00	spri2	pr6|128
001514  aa  6 00206 3521 00	epp2 	pr6|134
001515  aa  6 00202 2521 00	spri2	pr6|130
001516  aa  6 00174 6211 00	eax1 	pr6|124
001517  aa   014000 4310 07	fld  	6144,dl
001520  aa   001200 3520 04	epp2 	640,ic		002720 = 000420627000
001521  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 309
	     call unassign_mask (ctag, (pdata.controller_port));

001522  aa  6 00130 2361 20	ldq  	pr6|88,*		pdata.controller_port
001523  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001524  aa  6 00205 7561 00	stq  	pr6|133
001525  aa  6 00103 3521 00	epp2 	pr6|67		ctag
001526  aa  6 00176 2521 00	spri2	pr6|126
001527  aa  6 00205 3521 00	epp2 	pr6|133
001530  aa  6 00200 2521 00	spri2	pr6|128
001531  aa  6 00174 6211 00	eax1 	pr6|124
001532  aa   010000 4310 07	fld  	4096,dl
001533  aa   777621 3520 04	epp2 	-111,ic		001354 = 000420627000
001534  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 311
	end;

						STATEMENT 1 ON LINE 312
	if tag2 ^= -1 then do;

001535  aa  6 00032 3735 20	epp7 	pr6|26,*
001536  aa  7 00004 2361 20	ldq  	pr7|4,*		tag2
001537  aa   002102 1160 04	cmpq 	1090,ic		003641 = 777777777777
001540  aa   000025 6000 04	tze  	21,ic		001565
						STATEMENT 1 ON LINE 313
	     pdp = addr (scs$processor_data (tag2));

001541  aa  6 00044 3701 20	epp4 	pr6|36,*
001542  la  4 00024 3715 66	epp5 	pr4|20,*ql	scs$processor_data
001543  aa  6 00130 6515 00	spri5	pr6|88		pdp
						STATEMENT 1 ON LINE 315
	     call assign_mask (ctag, (pdata.controller_port));

001544  aa  5 00000 2361 00	ldq  	pr5|0		pdata.controller_port
001545  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001546  aa  6 00205 7561 00	stq  	pr6|133
001547  aa  6 00103 3521 00	epp2 	pr6|67		ctag
001550  aa  6 00176 2521 00	spri2	pr6|126
001551  aa  6 00205 3521 00	epp2 	pr6|133
001552  aa  6 00200 2521 00	spri2	pr6|128
001553  aa  6 00174 6211 00	eax1 	pr6|124
001554  aa   010000 4310 07	fld  	4096,dl
001555  aa   777501 3520 04	epp2 	-191,ic		001256 = 000420627000
001556  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 317
	     call set_cfg (ctag);

001557  aa  6 00103 3521 00	epp2 	pr6|67		ctag
001560  aa  6 00176 2521 00	spri2	pr6|126
001561  aa  6 00174 6211 00	eax1 	pr6|124
001562  aa   004000 4310 07	fld  	2048,dl
001563  aa   000211 3520 04	epp2 	137,ic		001774 = 000420627000
001564  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 318
	end;

						STATEMENT 1 ON LINE 320
	return;

001565  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO update_export_xipmsk                               STATEMENT 1 ON LINE 323
update_export_xipmsk:
	entry (port);

001566  ta     000322000000
001567  da     000324300000
001570  aa   000420 6270 00	eax7 	272
001571  aa  7 00034 3521 20	epp2 	pr7|28,*
001572  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001573  aa     000002000000
001574  aa     000000000000
						STATEMENT 1 ON LINE 328
	unspec (rcow) = ""b;

001575  aa   776237 2370 04	ldaq 	-865,ic		000034 = 000000000000 000000000000
001576  aa  6 00044 3701 20	epp4 	pr6|36,*
001577  la  4 00026 3735 20	epp7 	pr4|22,*
001600  aa  7 00000 7551 00	sta  	pr7|0
001601  aa  7 00001 7561 00	stq  	pr7|1
						STATEMENT 1 ON LINE 329
	do i = 0 to 7;

001602  aa  6 00102 4501 00	stz  	pr6|66		i
001603  aa   000000 0110 03	nop  	0,du
001604  aa  6 00102 2361 00	ldq  	pr6|66		i
001605  aa   000007 1160 07	cmpq 	7,dl
001606  aa   000025 6054 04	tpnz 	21,ic		001633
						STATEMENT 1 ON LINE 330
	     pdp = addr (scs$processor_data (i));

001607  aa  6 00044 3701 20	epp4 	pr6|36,*
001610  la  4 00024 3735 66	epp7 	pr4|20,*ql	scs$processor_data
001611  aa  6 00130 6535 00	spri7	pr6|88		pdp
						STATEMENT 1 ON LINE 331
	     if pdata.expanded_port & pdata.controller_port = port
		then substr (rcow.sub_mask, pdata.expander_port + 1, 1) =  pdata.interrupt_cpu;

001612  aa  7 00000 2351 00	lda  	pr7|0		pdata.expanded_port
001613  aa   000040 3150 07	cana 	32,dl
001614  aa   000015 6000 04	tze  	13,ic		001631
001615  aa  7 00000 2361 00	ldq  	pr7|0		pdata.controller_port
001616  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001617  aa  6 00032 3715 20	epp5 	pr6|26,*
001620  aa  5 00002 1161 20	cmpq 	pr5|2,*		port
001621  aa   000010 6010 04	tnz  	8,ic		001631
001622  aa  7 00000 2351 00	lda  	pr7|0		pdata.expander_port
001623  aa   000037 7350 00	als  	31
001624  aa   000106 7730 00	lrl  	70
001625  la  4 00026 3535 20	epp3 	pr4|22,*
001626  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
001627  aa  7 00000 05 0001	descb	pr7|0(5),1	pdata.interrupt_cpu
001630  aa  3 00001 00 0001	descb	pr3|1,1		rcow.sub_mask
						STATEMENT 1 ON LINE 333
	end;

001631  aa  6 00102 0541 00	aos  	pr6|66		i
001632  aa   777752 7100 04	tra  	-22,ic		001604
						STATEMENT 1 ON LINE 334
	rcow.expander_command = "2"b3;

001633  aa   020000 2350 07	lda  	8192,dl
001634  aa  6 00044 3701 20	epp4 	pr6|36,*
001635  la  4 00026 3735 20	epp7 	pr4|22,*
001636  aa  7 00001 6751 00	era  	pr7|1		rcow.expander_command
001637  aa   070000 3750 07	ana  	28672,dl
001640  aa  7 00001 6551 00	ersa 	pr7|1		rcow.expander_command
						STATEMENT 1 ON LINE 335
	rcow.controller_port = port;

001641  aa  6 00032 3715 20	epp5 	pr6|26,*
001642  aa  5 00002 2361 20	ldq  	pr5|2,*		port
001643  aa  7 00001 6761 00	erq  	pr7|1		rcow.controller_port
001644  aa   000007 3760 07	anq  	7,dl
001645  aa  7 00001 6561 00	ersq 	pr7|1		rcow.controller_port
						STATEMENT 1 ON LINE 336
	call privileged_mode_ut$cioc (addr (rcow.cow));

001646  aa  7 00001 3535 00	epp3 	pr7|1		rcow.cow
001647  aa  6 00206 2535 00	spri3	pr6|134
001650  aa  6 00206 3521 00	epp2 	pr6|134
001651  aa  6 00176 2521 00	spri2	pr6|126
001652  aa  6 00174 6211 00	eax1 	pr6|124
001653  aa   004000 4310 07	fld  	2048,dl
001654  la  4 00010 3521 20	epp2 	pr4|8,*		privileged_mode_ut$cioc
001655  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 337
	return;

001656  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_export_enable                                  STATEMENT 1 ON LINE 339
set_export_enable:
	entry (port, subport, enable_sw);

001657  at     000003000031
001660  tt     000031000027
001661  ta     001657000000
001662  da     000334300000
001663  aa   000420 6270 00	eax7 	272
001664  aa  7 00034 3521 20	epp2 	pr7|28,*
001665  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001666  aa     000006000000
001667  aa     000000000000
001670  aa  6 00032 3735 20	epp7 	pr6|26,*
001671  aa  7 00006 3715 20	epp5 	pr7|6,*
001672  aa  6 00140 6515 00	spri5	pr6|96
						STATEMENT 1 ON LINE 344
	unspec (rcow) = ""b;

001673  aa   776141 2370 04	ldaq 	-927,ic		000034 = 000000000000 000000000000
001674  aa  6 00044 3701 20	epp4 	pr6|36,*
001675  la  4 00026 3735 20	epp7 	pr4|22,*
001676  aa  7 00000 7551 00	sta  	pr7|0
001677  aa  7 00001 7561 00	stq  	pr7|1
						STATEMENT 1 ON LINE 345
	do i = 0 to 7;

001700  aa  6 00102 4501 00	stz  	pr6|66		i
001701  aa   000000 0110 03	nop  	0,du
001702  aa  6 00102 2361 00	ldq  	pr6|66		i
001703  aa   000007 1160 07	cmpq 	7,dl
001704  aa   000040 6054 04	tpnz 	32,ic		001744
						STATEMENT 1 ON LINE 346
	     pdp = addr (scs$processor_data (i));

001705  aa  6 00044 3701 20	epp4 	pr6|36,*
001706  la  4 00024 3735 66	epp7 	pr4|20,*ql	scs$processor_data
001707  aa  6 00130 6535 00	spri7	pr6|88		pdp
						STATEMENT 1 ON LINE 347
	     if pdata.expanded_port & pdata.controller_port = port
		then if pdata.expander_port = subport
		     then substr (rcow.sub_mask, pdata.expander_port + 1, 1) = enable_sw;

001710  aa  7 00000 2351 00	lda  	pr7|0		pdata.expanded_port
001711  aa   000040 3150 07	cana 	32,dl
001712  aa   000030 6000 04	tze  	24,ic		001742
001713  aa  7 00000 2361 00	ldq  	pr7|0		pdata.controller_port
001714  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001715  aa  6 00032 3715 20	epp5 	pr6|26,*
001716  aa  5 00002 1161 20	cmpq 	pr5|2,*		port
001717  aa   000023 6010 04	tnz  	19,ic		001742
001720  aa  7 00000 2351 00	lda  	pr7|0		pdata.expander_port
001721  aa   000037 7350 00	als  	31
001722  aa   000106 7730 00	lrl  	70
001723  aa  6 00205 7561 00	stq  	pr6|133		pdata.expander_port
001724  aa  5 00004 1161 20	cmpq 	pr5|4,*		subport
001725  aa   000010 6010 04	tnz  	8,ic		001735
001726  aa   000000 6270 06	eax7 	0,ql
001727  la  4 00026 3535 20	epp3 	pr4|22,*
001730  aa  6 00140 3515 20	epp1 	pr6|96,*
001731  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001732  aa  1 00000 00 0001	descb	pr1|0,1		enable_sw
001733  aa  3 00001 00 0001	descb	pr3|1,1		rcow.sub_mask
001734  aa   000006 7100 04	tra  	6,ic		001742
						STATEMENT 1 ON LINE 350
		     else substr (rcow.sub_mask, pdata.expander_port + 1, 1) = pdata.online;

001735  aa   000000 6270 06	eax7 	0,ql
001736  la  4 00026 3535 20	epp3 	pr4|22,*
001737  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001740  aa  7 00000 00 0001	descb	pr7|0,1		pdata.online
001741  aa  3 00001 00 0001	descb	pr3|1,1		rcow.sub_mask
						STATEMENT 1 ON LINE 351
         end;

001742  aa  6 00102 0541 00	aos  	pr6|66		i
001743  aa   777737 7100 04	tra  	-33,ic		001702
						STATEMENT 1 ON LINE 352
	substr (rcow.sub_mask, 5, 1) = "1"b;

001744  aa   020000 2350 03	lda  	8192,du
001745  aa  6 00044 3701 20	epp4 	pr6|36,*
001746  la  4 00026 3735 20	epp7 	pr4|22,*
001747  aa  7 00001 2551 00	orsa 	pr7|1		rcow.sub_mask
						STATEMENT 1 ON LINE 353
         rcow.expander_command = "1"b3;

001750  aa   010000 2350 07	lda  	4096,dl
001751  aa  7 00001 6751 00	era  	pr7|1		rcow.expander_command
001752  aa   070000 3750 07	ana  	28672,dl
001753  aa  7 00001 6551 00	ersa 	pr7|1		rcow.expander_command
						STATEMENT 1 ON LINE 354
         rcow.controller_port = port;

001754  aa  6 00032 3715 20	epp5 	pr6|26,*
001755  aa  5 00002 2361 20	ldq  	pr5|2,*		port
001756  aa  7 00001 6761 00	erq  	pr7|1		rcow.controller_port
001757  aa   000007 3760 07	anq  	7,dl
001760  aa  7 00001 6561 00	ersq 	pr7|1		rcow.controller_port
						STATEMENT 1 ON LINE 355
         call privileged_mode_ut$cioc (addr (rcow.cow));

001761  aa  7 00001 3535 00	epp3 	pr7|1		rcow.cow
001762  aa  6 00206 2535 00	spri3	pr6|134
001763  aa  6 00206 3521 00	epp2 	pr6|134
001764  aa  6 00176 2521 00	spri2	pr6|126
001765  aa  6 00174 6211 00	eax1 	pr6|124
001766  aa   004000 4310 07	fld  	2048,dl
001767  la  4 00010 3521 20	epp2 	pr4|8,*		privileged_mode_ut$cioc
001770  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 357
         return;

001771  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_cfg                                            STATEMENT 1 ON LINE 361
set_cfg:	entry (port);

001772  ta     000322000000
001773  da     000341300000
001774  aa   000420 6270 00	eax7 	272
001775  aa  7 00034 3521 20	epp2 	pr7|28,*
001776  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001777  aa     000002000000
002000  aa     000000000000
						STATEMENT 1 ON LINE 364
	if scs$controller_data (port).type >= "0010"b then do;

002001  aa  6 00032 3735 20	epp7 	pr6|26,*
002002  aa  7 00002 2361 20	ldq  	pr7|2,*		port
002003  aa   000002 7360 00	qls  	2
002004  aa  6 00044 3701 20	epp4 	pr6|36,*
002005  la  4 00022 3715 20	epp5 	pr4|18,*
002006  aa  5 00002 2351 06	lda  	pr5|2,ql		scs$controller_data.type
002007  aa   000021 7350 00	als  	17
002010  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
002011  aa   100000 1150 03	cmpa 	32768,du
002012  aa   000701 6020 04	tnc  	449,ic		002713
						STATEMENT 1 ON LINE 365
	     if scs$set_cycle_switches then
		string (addr (scs$cfg_data (port)) -> scr_cfg2.cyclic_prior) = scs$cycle_priority_template;

002013  la  4 00052 2351 20	lda  	pr4|42,*		scs$set_cycle_switches
002014  aa   000011 6000 04	tze  	9,ic		002025
002015  aa  7 00002 2361 20	ldq  	pr7|2,*		port
002016  aa   000001 7360 00	qls  	1
002017  la  4 00050 2351 20	lda  	pr4|40,*		scs$cycle_priority_template
002020  aa   000025 7710 00	arl  	21
002021  la  4 00044 3535 66	epp3 	pr4|36,*ql	scs$cfg_data
002022  aa  3 00001 6751 00	era  	pr3|1		scr_cfg2.cyclic_prior
002023  aa   077400 3750 07	ana  	32512,dl
002024  aa  3 00001 6551 00	ersa 	pr3|1		scr_cfg2.cyclic_prior
002025  aa  6 00205 7561 00	stq  	pr6|133
						STATEMENT 1 ON LINE 367
try_to_set_cfg:
	     scrp = addr (scs$cfg_data (port));

002026  aa  6 00032 3735 20	epp7 	pr6|26,*
002027  aa  7 00002 2361 20	ldq  	pr7|2,*		port
002030  aa   000001 7360 00	qls  	1
002031  aa  6 00044 3701 20	epp4 	pr6|36,*
002032  la  4 00044 3715 66	epp5 	pr4|36,*ql	scs$cfg_data
002033  aa  6 00134 6515 00	spri5	pr6|92		scrp
						STATEMENT 1 ON LINE 369
	     unspec (port_enable_bits) = scr_cfg2.port_mask_0_3 || scr_cfg2.port_mask_4_7;

002034  aa  5 00000 2351 00	lda  	pr5|0		scr_cfg2.port_mask_0_3
002035  aa   000040 7350 00	als  	32
002036  aa  6 00204 7551 00	sta  	pr6|132		scr_cfg2.port_mask_0_3
002037  aa  5 00001 2351 00	lda  	pr5|1		scr_cfg2.port_mask_4_7
002040  aa   000040 7350 00	als  	32
002041  aa   000004 7710 00	arl  	4
002042  aa  6 00204 2751 00	ora  	pr6|132		scr_cfg2.port_mask_0_3
002043  aa  6 00123 6751 00	era  	pr6|83
002044  aa  0 00020 3751 00	ana  	pr0|16		= 776000000000
002045  aa  6 00123 6551 00	ersa 	pr6|83
						STATEMENT 1 ON LINE 370
	     set_cfg_ok = "0"b;

002046  aa  6 00117 4501 00	stz  	pr6|79		set_cfg_ok
						STATEMENT 1 ON LINE 371
	     do set_cfg_try_count = 1 repeat set_cfg_try_count + 1
		while (set_cfg_try_count <= SET_CFG_TRY_LIMIT & ^set_cfg_ok);

002047  aa   000001 2360 07	ldq  	1,dl
002050  aa  6 00116 7561 00	stq  	pr6|78		set_cfg_try_count
002051  aa   000000 0110 03	nop  	0,du
002052  aa  6 00117 2351 00	lda  	pr6|79		set_cfg_ok
002053  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
002054  aa  6 00204 7551 00	sta  	pr6|132
002055  aa   000065 6000 04	tze  	53,ic		002142
002056  aa  6 00116 2361 00	ldq  	pr6|78		set_cfg_try_count
002057  aa   000012 1160 07	cmpq 	10,dl
002060  aa   000062 6054 04	tpnz 	50,ic		002142
						STATEMENT 1 ON LINE 373
		call privileged_mode_ut$sscr (port, SC_CFG, scs$cfg_data (port));

002061  aa  6 00032 3735 20	epp7 	pr6|26,*
002062  aa  7 00002 2361 20	ldq  	pr7|2,*		port
002063  aa   000001 7360 00	qls  	1
002064  aa  7 00002 3521 20	epp2 	pr7|2,*		port
002065  aa  6 00176 2521 00	spri2	pr6|126
002066  aa   775742 3520 04	epp2 	-1054,ic		000030 = 000000000001
002067  aa  6 00200 2521 00	spri2	pr6|128
002070  aa  6 00044 3701 20	epp4 	pr6|36,*
002071  la  4 00044 3521 66	epp2 	pr4|36,*ql	scs$cfg_data
002072  aa  6 00202 2521 00	spri2	pr6|130
002073  aa  6 00174 6211 00	eax1 	pr6|124
002074  aa   014000 4310 07	fld  	6144,dl
002075  la  4 00014 3521 20	epp2 	pr4|12,*		privileged_mode_ut$sscr
002076  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 374
		if unspec (port_enable_bits) = "0"b then set_cfg_ok = "1"b;

002077  aa  6 00123 2351 00	lda  	pr6|83
002100  aa   776000 3150 03	cana 	261120,du
002101  aa   000004 6010 04	tnz  	4,ic		002105
002102  aa   400000 2350 03	lda  	131072,du
002103  aa  6 00117 7551 00	sta  	pr6|79		set_cfg_ok
002104  aa   000034 7100 04	tra  	28,ic		002140
						STATEMENT 1 ON LINE 375
		else do;

						STATEMENT 1 ON LINE 376
		     call privileged_mode_ut$rscr (port, SC_CFG, scr_cfg2_temp);

002105  aa  6 00032 3735 20	epp7 	pr6|26,*
002106  aa  7 00002 3521 20	epp2 	pr7|2,*		port
002107  aa  6 00176 2521 00	spri2	pr6|126
002110  aa   775720 3520 04	epp2 	-1072,ic		000030 = 000000000001
002111  aa  6 00200 2521 00	spri2	pr6|128
002112  aa  6 00114 3521 00	epp2 	pr6|76		scr_cfg2_temp
002113  aa  6 00202 2521 00	spri2	pr6|130
002114  aa  6 00174 6211 00	eax1 	pr6|124
002115  aa   014000 4310 07	fld  	6144,dl
002116  aa  6 00044 3701 20	epp4 	pr6|36,*
002117  la  4 00012 3521 20	epp2 	pr4|10,*		privileged_mode_ut$rscr
002120  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 377
		     if (unspec (scr_cfg2_temp) & SCR_CFG2_PROGRAM_MASK)
			= (unspec (scs$cfg_data (port)) & SCR_CFG2_PROGRAM_MASK)    /* check all program-settable bits*/
			then set_cfg_ok = "1"b;

002121  aa  6 00032 3735 20	epp7 	pr6|26,*
002122  aa  7 00002 2361 20	ldq  	pr7|2,*		port
002123  aa   000001 7360 00	qls  	1
002124  aa  6 00044 3701 20	epp4 	pr6|36,*
002125  la  4 00044 3715 66	epp5 	pr4|36,*ql
002126  aa  5 00000 2351 00	lda  	pr5|0
002127  aa  5 00001 2361 00	ldq  	pr5|1
002130  aa   775652 3770 04	anaq 	-1110,ic		000002 = 777774037777 777000077417
002131  aa  6 00206 7571 00	staq 	pr6|134
002132  aa  6 00114 2371 00	ldaq 	pr6|76
002133  aa   775647 3770 04	anaq 	-1113,ic		000002 = 777774037777 777000077417
002134  aa  6 00206 1171 00	cmpaq	pr6|134
002135  aa   000003 6010 04	tnz  	3,ic		002140
002136  aa   400000 2350 03	lda  	131072,du
002137  aa  6 00117 7551 00	sta  	pr6|79		set_cfg_ok
						STATEMENT 1 ON LINE 380
		end;

						STATEMENT 1 ON LINE 381
	     end;

002140  aa  6 00116 0541 00	aos  	pr6|78		set_cfg_try_count
002141  aa   777711 7100 04	tra  	-55,ic		002052
						STATEMENT 1 ON LINE 389
	     if ^set_cfg_ok then do;

002142  aa   400000 3150 03	cana 	131072,du
002143  aa   000550 6000 04	tze  	360,ic		002713
						STATEMENT 1 ON LINE 390
		call syserr (3, "scr_util: error setting configuration register. SCU ^a must be set manually",
		     substr (LETTERS, port+1, 1));

002144  aa   000003 2360 07	ldq  	3,dl
002145  aa  6 00204 7561 00	stq  	pr6|132
002146  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002147  aa   775734 00 0114	desc9a	-1060,76		000102 = 163143162137
002150  aa  6 00210 00 0114	desc9a	pr6|136,76
002151  aa  6 00173 4501 00	stz  	pr6|123
002152  aa  6 00032 3735 20	epp7 	pr6|26,*
002153  aa  7 00002 7271 20	lxl7 	pr7|2,*		port
002154  aa  040 100 100 417	mlr  	(x7),(pr),fill(040)
002155  ta   000000 00 0001	desc9a	0,1
002156  aa  6 00173 00 0001	desc9a	pr6|123,1
002157  aa  6 00204 3521 00	epp2 	pr6|132
002160  aa  6 00236 2521 00	spri2	pr6|158
002161  aa  6 00210 3521 00	epp2 	pr6|136
002162  aa  6 00240 2521 00	spri2	pr6|160
002163  aa  6 00173 3521 00	epp2 	pr6|123
002164  aa  6 00242 2521 00	spri2	pr6|162
002165  aa   775635 3520 04	epp2 	-1123,ic		000022 = 404000000005
002166  aa  6 00244 2521 00	spri2	pr6|164
002167  aa   775632 3520 04	epp2 	-1126,ic		000021 = 524000000113
002170  aa  6 00246 2521 00	spri2	pr6|166
002171  aa   775627 3520 04	epp2 	-1129,ic		000020 = 524000000001
002172  aa  6 00250 2521 00	spri2	pr6|168
002173  aa  6 00234 6211 00	eax1 	pr6|156
002174  aa   014000 4310 07	fld  	6144,dl
002175  aa  6 00044 3701 20	epp4 	pr6|36,*
002176  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002177  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 392
		call syserr (0, "Set the following switches on SCU ^a",
		     substr (LETTERS, port+1,1));

002200  aa  6 00173 4501 00	stz  	pr6|123
002201  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002202  aa   775645 00 0044	desc9a	-1115,36		000046 = 123145164040
002203  aa  6 00234 00 0044	desc9a	pr6|156,36
002204  aa  6 00204 4501 00	stz  	pr6|132
002205  aa  6 00032 3735 20	epp7 	pr6|26,*
002206  aa  7 00002 7271 20	lxl7 	pr7|2,*		port
002207  aa  040 100 100 417	mlr  	(x7),(pr),fill(040)
002210  ta   000000 00 0001	desc9a	0,1
002211  aa  6 00204 00 0001	desc9a	pr6|132,1
002212  aa  6 00173 3521 00	epp2 	pr6|123
002213  aa  6 00212 2521 00	spri2	pr6|138
002214  aa  6 00234 3521 00	epp2 	pr6|156
002215  aa  6 00214 2521 00	spri2	pr6|140
002216  aa  6 00204 3521 00	epp2 	pr6|132
002217  aa  6 00216 2521 00	spri2	pr6|142
002220  aa   775602 3520 04	epp2 	-1150,ic		000022 = 404000000005
002221  aa  6 00220 2521 00	spri2	pr6|144
002222  aa   775575 3520 04	epp2 	-1155,ic		000017 = 524000000044
002223  aa  6 00222 2521 00	spri2	pr6|146
002224  aa   775574 3520 04	epp2 	-1156,ic		000020 = 524000000001
002225  aa  6 00224 2521 00	spri2	pr6|148
002226  aa  6 00210 6211 00	eax1 	pr6|136
002227  aa   014000 4310 07	fld  	6144,dl
002230  aa  6 00044 3701 20	epp4 	pr6|36,*
002231  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002232  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 395
		unspec (cycle_priority_bits) = scr_cfg2.cyclic_prior;

002233  aa  6 00134 3735 20	epp7 	pr6|92,*		scrp
002234  aa  7 00001 2351 00	lda  	pr7|1		scr_cfg2.cyclic_prior
002235  aa   000025 7350 00	als  	21
002236  aa  6 00122 6751 00	era  	pr6|82
002237  aa  0 00016 3751 00	ana  	pr0|14		= 774000000000
002240  aa  6 00122 6551 00	ersa 	pr6|82
						STATEMENT 1 ON LINE 396
		unspec (nea_bits) = scr_cfg2.nea;

002241  aa  7 00000 2351 00	lda  	pr7|0		scr_cfg2.nea
002242  aa   000027 7350 00	als  	23
002243  aa  6 00124 6751 00	era  	pr6|84
002244  aa  0 00016 3751 00	ana  	pr0|14		= 774000000000
002245  aa  6 00124 6551 00	ersa 	pr6|84
						STATEMENT 1 ON LINE 397
		mask_a_val = convert_to_mask_val (substr (scr_cfg2.mask_a_assign, 1, 8));

002246  aa  7 00000 2351 00	lda  	pr7|0		scr_cfg2.mask_a_assign
002247  aa  0 00020 3771 00	anaq 	pr0|16		= 776000000000 000000000000
002250  aa  6 00204 7551 00	sta  	pr6|132
002251  aa  6 00204 3521 00	epp2 	pr6|132
002252  aa  6 00236 2521 00	spri2	pr6|158
002253  aa  6 00206 3521 00	epp2 	pr6|134
002254  aa  6 00240 2521 00	spri2	pr6|160
002255  aa   775541 3520 04	epp2 	-1183,ic		000016 = 514000000010
002256  aa  6 00244 2521 00	spri2	pr6|164
002257  aa  6 00173 3521 00	epp2 	pr6|123
002260  aa  6 00246 2521 00	spri2	pr6|166
002261  aa  6 00234 6211 00	eax1 	pr6|156
002262  aa   010000 4310 07	fld  	4096,dl
002263  aa   001145 3520 04	epp2 	613,ic		003430 = 000120627000
002264  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
002265  aa  6 00173 2361 00	ldq  	pr6|123
002266  aa   000002 6040 04	tmi  	2,ic		002270
002267  aa   777777 3760 07	anq  	262143,dl
002270  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002271  aa  6 00120 4501 00	stz  	pr6|80		mask_a_val
002272  aa  6 00206 3735 20	epp7 	pr6|134,*
002273  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002274  aa  7 00000 00 0006	desc9a	pr7|0,ql
002275  aa  6 00120 00 0003	desc9a	pr6|80,3		mask_a_val
						STATEMENT 1 ON LINE 398
		mask_b_val = convert_to_mask_val (substr (scr_cfg2.mask_b_assign, 1, 8));

002276  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002277  aa  6 00134 3715 20	epp5 	pr6|92,*		scrp
002300  aa  5 00001 2351 00	lda  	pr5|1		scr_cfg2.mask_b_assign
002301  aa  0 00020 3771 00	anaq 	pr0|16		= 776000000000 000000000000
002302  aa  6 00173 7551 00	sta  	pr6|123
002303  aa  6 00173 3521 00	epp2 	pr6|123
002304  aa  6 00236 2521 00	spri2	pr6|158
002305  aa  6 00206 3521 00	epp2 	pr6|134
002306  aa  6 00240 2521 00	spri2	pr6|160
002307  aa   775507 3520 04	epp2 	-1209,ic		000016 = 514000000010
002310  aa  6 00244 2521 00	spri2	pr6|164
002311  aa  6 00204 3521 00	epp2 	pr6|132
002312  aa  6 00246 2521 00	spri2	pr6|166
002313  aa  6 00234 6211 00	eax1 	pr6|156
002314  aa   010000 4310 07	fld  	4096,dl
002315  aa   001113 3520 04	epp2 	587,ic		003430 = 000120627000
002316  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
002317  aa  6 00204 2361 00	ldq  	pr6|132
002320  aa   000002 6040 04	tmi  	2,ic		002322
002321  aa   777777 3760 07	anq  	262143,dl
002322  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002323  aa  6 00121 4501 00	stz  	pr6|81		mask_b_val
002324  aa  6 00206 3735 20	epp7 	pr6|134,*
002325  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002326  aa  7 00000 00 0006	desc9a	pr7|0,ql
002327  aa  6 00121 00 0003	desc9a	pr6|81,3		mask_b_val
						STATEMENT 1 ON LINE 400
		call syserr (0, "^/^12x--PORT ENABLE--  --CYCLIC PRIORITY---^/^12x0 1 2 3 4 5 6 7  0/1 1/2 2/3 3/4 4/5 5/6 6/7^/^8xON  ^8(^[X^; ^] ^) ^7( ^[X^; ^]  ^)^/^8xOFF ^8(^[ ^;X^] ^) ^7( ^[ ^;X^]  ^)",
		     port_enable_bits, cycle_priority_bits, 
		     port_enable_bits, cycle_priority_bits);

002330  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002331  aa  6 00204 4501 00	stz  	pr6|132
002332  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002333  aa   775714 00 0260	desc9a	-1076,176		000246 = 136057136061
002334  aa  6 00252 00 0260	desc9a	pr6|170,176
002335  aa  6 00204 3521 00	epp2 	pr6|132
002336  aa  6 00330 2521 00	spri2	pr6|216
002337  aa  6 00252 3521 00	epp2 	pr6|170
002340  aa  6 00332 2521 00	spri2	pr6|218
002341  aa  6 00123 3521 00	epp2 	pr6|83		port_enable_bits
002342  aa  6 00334 2521 00	spri2	pr6|220
002343  aa  6 00122 3521 00	epp2 	pr6|82		cycle_priority_bits
002344  aa  6 00336 2521 00	spri2	pr6|222
002345  aa  6 00123 3521 00	epp2 	pr6|83		port_enable_bits
002346  aa  6 00340 2521 00	spri2	pr6|224
002347  aa  6 00122 3521 00	epp2 	pr6|82		cycle_priority_bits
002350  aa  6 00342 2521 00	spri2	pr6|226
002351  aa   775451 3520 04	epp2 	-1239,ic		000022 = 404000000005
002352  aa  6 00344 2521 00	spri2	pr6|228
002353  aa   775442 3520 04	epp2 	-1246,ic		000015 = 524000000255
002354  aa  6 00346 2521 00	spri2	pr6|230
002355  aa   775465 3520 04	epp2 	-1227,ic		000042 = 516100000001
002356  aa  6 00350 2521 00	spri2	pr6|232
002357  aa  6 00354 2521 00	spri2	pr6|236
002360  aa   775456 3520 04	epp2 	-1234,ic		000036 = 516100000001
002361  aa  6 00352 2521 00	spri2	pr6|234
002362  aa  6 00356 2521 00	spri2	pr6|238
002363  aa  6 00326 6211 00	eax1 	pr6|214
002364  aa   030000 4310 07	fld  	12288,dl
002365  aa  6 00044 3701 20	epp4 	pr6|36,*
002366  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002367  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 403
		call syserr (0, "^/^8xNON-EXISTENT ADDRESS^/^17x2 3 4 5 6 7 8^/^8xON  ^[X^; ^]  1 ^7(^[X^; ^] ^)^/^8xOFF ^[ ^;X^]  0 ^7(^[ ^;X^] ^)",
		     scr_cfg2.nea_enabled, nea_bits,
		     scr_cfg2.nea_enabled, nea_bits);

002370  aa  6 00204 4501 00	stz  	pr6|132
002371  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002372  aa   775620 00 0164	desc9a	-1136,116		000211 = 136057136070
002373  aa  6 00252 00 0164	desc9a	pr6|170,116
002374  aa  6 00204 3521 00	epp2 	pr6|132
002375  aa  6 00330 2521 00	spri2	pr6|216
002376  aa  6 00252 3521 00	epp2 	pr6|170
002377  aa  6 00332 2521 00	spri2	pr6|218
002400  aa   000026 7270 07	lxl7 	22,dl
002401  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.nea_enabled
002402  aa  2 00000 5035 17	abd  	pr2|0,7
002403  aa  6 00334 2521 00	spri2	pr6|220
002404  aa  6 00124 3521 00	epp2 	pr6|84		nea_bits
002405  aa  6 00336 2521 00	spri2	pr6|222
002406  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.nea_enabled
002407  aa  2 00000 5035 17	abd  	pr2|0,7
002410  aa  6 00340 2521 00	spri2	pr6|224
002411  aa  6 00124 3521 00	epp2 	pr6|84		nea_bits
002412  aa  6 00342 2521 00	spri2	pr6|226
002413  aa   775407 3520 04	epp2 	-1273,ic		000022 = 404000000005
002414  aa  6 00344 2521 00	spri2	pr6|228
002415  aa   775377 3520 04	epp2 	-1281,ic		000014 = 524000000162
002416  aa  6 00346 2521 00	spri2	pr6|230
002417  aa   775410 3520 04	epp2 	-1272,ic		000027 = 516000000001
002420  aa  6 00350 2521 00	spri2	pr6|232
002421  aa  6 00354 2521 00	spri2	pr6|236
002422  aa   775414 3520 04	epp2 	-1268,ic		000036 = 516100000001
002423  aa  6 00352 2521 00	spri2	pr6|234
002424  aa  6 00356 2521 00	spri2	pr6|238
002425  aa  6 00326 6211 00	eax1 	pr6|214
002426  aa   030000 4310 07	fld  	12288,dl
002427  aa  6 00044 3701 20	epp4 	pr6|36,*
002430  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002431  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 406
		call syserr (0, "^/^8xSTORE A  A1 B  B1^/^8xON    ^4(^[X^; ^]  ^)^/^8xOFF   ^4(^[ ^;X^]  ^)",
		     scr_cfg2.a_online, scr_cfg2.a1_online, scr_cfg2.b_online, scr_cfg2.b1_online,
		     scr_cfg2.a_online, scr_cfg2.a1_online, scr_cfg2.b_online, scr_cfg2.b1_online);

002432  aa  6 00204 4501 00	stz  	pr6|132
002433  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002434  aa   775424 00 0114	desc9a	-1260,76		000057 = 136057136070
002435  aa  6 00210 00 0114	desc9a	pr6|136,76
002436  aa  6 00204 3521 00	epp2 	pr6|132
002437  aa  6 00254 2521 00	spri2	pr6|172
002440  aa  6 00210 3521 00	epp2 	pr6|136
002441  aa  6 00256 2521 00	spri2	pr6|174
002442  aa   000014 7270 07	lxl7 	12,dl
002443  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.a_online
002444  aa  2 00000 5035 17	abd  	pr2|0,7
002445  aa  6 00260 2521 00	spri2	pr6|176
002446  aa   000015 7260 07	lxl6 	13,dl
002447  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.a1_online
002450  aa  2 00000 5035 16	abd  	pr2|0,6
002451  aa  6 00262 2521 00	spri2	pr6|178
002452  aa   000016 7250 07	lxl5 	14,dl
002453  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.b_online
002454  aa  2 00000 5035 15	abd  	pr2|0,5
002455  aa  6 00264 2521 00	spri2	pr6|180
002456  aa   000017 7240 07	lxl4 	15,dl
002457  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.b1_online
002460  aa  2 00000 5035 14	abd  	pr2|0,4
002461  aa  6 00266 2521 00	spri2	pr6|182
002462  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.a_online
002463  aa  2 00000 5035 17	abd  	pr2|0,7
002464  aa  6 00270 2521 00	spri2	pr6|184
002465  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.a1_online
002466  aa  2 00000 5035 16	abd  	pr2|0,6
002467  aa  6 00272 2521 00	spri2	pr6|186
002470  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.b_online
002471  aa  2 00000 5035 15	abd  	pr2|0,5
002472  aa  6 00274 2521 00	spri2	pr6|188
002473  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.b1_online
002474  aa  2 00000 5035 14	abd  	pr2|0,4
002475  aa  6 00276 2521 00	spri2	pr6|190
002476  aa   775324 3520 04	epp2 	-1324,ic		000022 = 404000000005
002477  aa  6 00300 2521 00	spri2	pr6|192
002500  aa   775313 3520 04	epp2 	-1333,ic		000013 = 524000000112
002501  aa  6 00302 2521 00	spri2	pr6|194
002502  aa   775325 3520 04	epp2 	-1323,ic		000027 = 516000000001
002503  aa  6 00304 2521 00	spri2	pr6|196
002504  aa  6 00306 2521 00	spri2	pr6|198
002505  aa  6 00310 2521 00	spri2	pr6|200
002506  aa  6 00312 2521 00	spri2	pr6|202
002507  aa  6 00314 2521 00	spri2	pr6|204
002510  aa  6 00316 2521 00	spri2	pr6|206
002511  aa  6 00320 2521 00	spri2	pr6|208
002512  aa  6 00322 2521 00	spri2	pr6|210
002513  aa  6 00252 6211 00	eax1 	pr6|170
002514  aa   050000 4310 07	fld  	20480,dl
002515  aa  6 00044 3701 20	epp4 	pr6|36,*
002516  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002517  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 409
		call syserr (0, "^/^8xLWR STORE SIZE - ^d^/^8xINTERLACE - ^[ON^;OFF^]^/^8xLWR STORE - ^[B^;A^]^/^8xMASK A - ^a^/^8xMASK B - ^a",
		     bin (scr_cfg2.size), scr_cfg2.int, scr_cfg2.lwr,
		     mask_a_val, mask_b_val);

002520  aa  6 00204 4501 00	stz  	pr6|132
002521  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002522  aa   775434 00 0160	desc9a	-1252,112		000155 = 136057136070
002523  aa  6 00252 00 0160	desc9a	pr6|170,112
002524  aa  6 00134 2351 20	lda  	pr6|92,*		scr_cfg2.size
002525  aa   000011 7350 00	als  	9
002526  aa   000105 7730 00	lrl  	69
002527  aa  6 00206 7571 00	staq 	pr6|134
002530  aa  6 00204 3521 00	epp2 	pr6|132
002531  aa  6 00362 2521 00	spri2	pr6|242
002532  aa  6 00252 3521 00	epp2 	pr6|170
002533  aa  6 00364 2521 00	spri2	pr6|244
002534  aa  6 00206 3521 00	epp2 	pr6|134
002535  aa  6 00366 2521 00	spri2	pr6|246
002536  aa   000036 7270 07	lxl7 	30,dl
002537  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.int
002540  aa  2 00000 5035 17	abd  	pr2|0,7
002541  aa  6 00370 2521 00	spri2	pr6|248
002542  aa   000037 7260 07	lxl6 	31,dl
002543  aa  6 00134 3521 20	epp2 	pr6|92,*		scr_cfg2.lwr
002544  aa  2 00000 5035 16	abd  	pr2|0,6
002545  aa  6 00372 2521 00	spri2	pr6|250
002546  aa  6 00120 3521 00	epp2 	pr6|80		mask_a_val
002547  aa  6 00374 2521 00	spri2	pr6|252
002550  aa  6 00121 3521 00	epp2 	pr6|81		mask_b_val
002551  aa  6 00376 2521 00	spri2	pr6|254
002552  aa   775250 3520 04	epp2 	-1368,ic		000022 = 404000000005
002553  aa  6 00400 2521 00	spri2	pr6|256
002554  aa   775236 3520 04	epp2 	-1378,ic		000012 = 524000000155
002555  aa  6 00402 2521 00	spri2	pr6|258
002556  aa   775250 3520 04	epp2 	-1368,ic		000026 = 410000000107
002557  aa  6 00404 2521 00	spri2	pr6|260
002560  aa   775247 3520 04	epp2 	-1369,ic		000027 = 516000000001
002561  aa  6 00406 2521 00	spri2	pr6|262
002562  aa  6 00410 2521 00	spri2	pr6|264
002563  aa   775226 3520 04	epp2 	-1386,ic		000011 = 526000000003
002564  aa  6 00412 2521 00	spri2	pr6|266
002565  aa  6 00414 2521 00	spri2	pr6|268
002566  aa  6 00360 6211 00	eax1 	pr6|240
002567  aa   034000 4310 07	fld  	14336,dl
002570  aa  6 00044 3701 20	epp4 	pr6|36,*
002571  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002572  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 413
		call syserr (0, "After setting the switches for SCU ^a place SCU ^a into Manual Mode and then into Program Mode",
		     substr (LETTERS, port+1, 1), substr (LETTERS, port+1, 1));

002573  aa  6 00204 4501 00	stz  	pr6|132
002574  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002575  aa   775331 00 0140	desc9a	-1319,96		000125 = 101146164145
002576  aa  6 00326 00 0140	desc9a	pr6|214,96
002577  aa  6 00173 4501 00	stz  	pr6|123
002600  aa  6 00032 3735 20	epp7 	pr6|26,*
002601  aa  7 00002 7271 20	lxl7 	pr7|2,*		port
002602  aa  040 100 100 417	mlr  	(x7),(pr),fill(040)
002603  ta   000000 00 0001	desc9a	0,1
002604  aa  6 00173 00 0001	desc9a	pr6|123,1
002605  aa  6 00233 4501 00	stz  	pr6|155
002606  aa  040 100 100 417	mlr  	(x7),(pr),fill(040)
002607  ta   000000 00 0001	desc9a	0,1
002610  aa  6 00233 00 0001	desc9a	pr6|155,1
002611  aa  6 00204 3521 00	epp2 	pr6|132
002612  aa  6 00212 2521 00	spri2	pr6|138
002613  aa  6 00326 3521 00	epp2 	pr6|214
002614  aa  6 00214 2521 00	spri2	pr6|140
002615  aa  6 00173 3521 00	epp2 	pr6|123
002616  aa  6 00216 2521 00	spri2	pr6|142
002617  aa  6 00233 3521 00	epp2 	pr6|155
002620  aa  6 00220 2521 00	spri2	pr6|144
002621  aa   775201 3520 04	epp2 	-1407,ic		000022 = 404000000005
002622  aa  6 00222 2521 00	spri2	pr6|146
002623  aa   775165 3520 04	epp2 	-1419,ic		000010 = 524000000136
002624  aa  6 00224 2521 00	spri2	pr6|148
002625  aa   775173 3520 04	epp2 	-1413,ic		000020 = 524000000001
002626  aa  6 00226 2521 00	spri2	pr6|150
002627  aa  6 00230 2521 00	spri2	pr6|152
002630  aa  6 00210 6211 00	eax1 	pr6|136
002631  aa   020000 4310 07	fld  	8192,dl
002632  aa  6 00044 3701 20	epp4 	pr6|36,*
002633  la  4 00020 3521 20	epp2 	pr4|16,*		syserr
002634  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 418
		do while (addr (scr_cfg2_temp) -> scr_cfg2.mode);

002635  aa   000000 0110 03	nop  	0,du
002636  aa  6 00114 2351 00	lda  	pr6|76		scr_cfg2.mode
002637  aa   040000 3150 07	cana 	16384,dl
002640  aa   000016 6000 04	tze  	14,ic		002656
						STATEMENT 1 ON LINE 419
		     call privileged_mode_ut$rscr (port, SC_CFG, scr_cfg2_temp);

002641  aa  6 00032 3735 20	epp7 	pr6|26,*
002642  aa  7 00002 3521 20	epp2 	pr7|2,*		port
002643  aa  6 00176 2521 00	spri2	pr6|126
002644  aa   775164 3520 04	epp2 	-1420,ic		000030 = 000000000001
002645  aa  6 00200 2521 00	spri2	pr6|128
002646  aa  6 00114 3521 00	epp2 	pr6|76		scr_cfg2_temp
002647  aa  6 00202 2521 00	spri2	pr6|130
002650  aa  6 00174 6211 00	eax1 	pr6|124
002651  aa   014000 4310 07	fld  	6144,dl
002652  aa  6 00044 3701 20	epp4 	pr6|36,*
002653  la  4 00012 3521 20	epp2 	pr4|10,*		privileged_mode_ut$rscr
002654  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 420
		end;

002655  aa   777761 7100 04	tra  	-15,ic		002636
						STATEMENT 1 ON LINE 424
		do while (^addr (scr_cfg2_temp) -> scr_cfg2.mode);

002656  aa  6 00114 2351 00	lda  	pr6|76		scr_cfg2.mode
002657  aa   040000 3150 07	cana 	16384,dl
002660  aa   000016 6010 04	tnz  	14,ic		002676
						STATEMENT 1 ON LINE 425
		     call privileged_mode_ut$rscr (port, SC_CFG, scr_cfg2_temp);

002661  aa  6 00032 3735 20	epp7 	pr6|26,*
002662  aa  7 00002 3521 20	epp2 	pr7|2,*		port
002663  aa  6 00176 2521 00	spri2	pr6|126
002664  aa   775144 3520 04	epp2 	-1436,ic		000030 = 000000000001
002665  aa  6 00200 2521 00	spri2	pr6|128
002666  aa  6 00114 3521 00	epp2 	pr6|76		scr_cfg2_temp
002667  aa  6 00202 2521 00	spri2	pr6|130
002670  aa  6 00174 6211 00	eax1 	pr6|124
002671  aa   014000 4310 07	fld  	6144,dl
002672  aa  6 00044 3701 20	epp4 	pr6|36,*
002673  la  4 00012 3521 20	epp2 	pr4|10,*		privileged_mode_ut$rscr
002674  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 426
		end;

002675  aa   777761 7100 04	tra  	-15,ic		002656
						STATEMENT 1 ON LINE 431
		if (unspec (scr_cfg2_temp) & SCR_CFG2_PROGRAM_MASK)
		     ^= (unspec (scs$cfg_data (port)) & SCR_CFG2_PROGRAM_MASK)
		     then goto try_to_set_cfg;

002676  aa  6 00032 3735 20	epp7 	pr6|26,*
002677  aa  7 00002 2361 20	ldq  	pr7|2,*		port
002700  aa   000001 7360 00	qls  	1
002701  aa  6 00044 3701 20	epp4 	pr6|36,*
002702  la  4 00044 3715 66	epp5 	pr4|36,*ql
002703  aa  5 00000 2351 00	lda  	pr5|0
002704  aa  5 00001 2361 00	ldq  	pr5|1
002705  aa   775075 3770 04	anaq 	-1475,ic		000002 = 777774037777 777000077417
002706  aa  6 00206 7571 00	staq 	pr6|134
002707  aa  6 00114 2371 00	ldaq 	pr6|76
002710  aa   775072 3770 04	anaq 	-1478,ic		000002 = 777774037777 777000077417
002711  aa  6 00206 1171 00	cmpaq	pr6|134
002712  aa   777114 6010 04	tnz  	-436,ic		002026
						STATEMENT 1 ON LINE 434
	     end;

						STATEMENT 1 ON LINE 440
	end;

						STATEMENT 1 ON LINE 442
	return;

002713  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_mask                                           STATEMENT 1 ON LINE 446
set_mask:	entry (port, target, mask);

002714  at     000003000031
002715  tt     000031000026
002716  ta     002714000000
002717  da     000347300000
002720  aa   000420 6270 00	eax7 	272
002721  aa  7 00034 3521 20	epp2 	pr7|28,*
002722  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002723  aa     000006000000
002724  aa     000000000000
						STATEMENT 1 ON LINE 451
	call privileged_mode_ut$sscr (port, SC_MSK + 8 * target, mask);

002725  aa  6 00032 3735 20	epp7 	pr6|26,*
002726  aa  7 00004 2361 20	ldq  	pr7|4,*		target
002727  aa   000003 7360 00	qls  	3
002730  aa   000002 0760 07	adq  	2,dl
002731  aa  6 00233 7561 00	stq  	pr6|155
002732  aa  7 00002 3521 20	epp2 	pr7|2,*		port
002733  aa  6 00176 2521 00	spri2	pr6|126
002734  aa  6 00233 3521 00	epp2 	pr6|155
002735  aa  6 00200 2521 00	spri2	pr6|128
002736  aa  7 00006 3521 20	epp2 	pr7|6,*		mask
002737  aa  6 00202 2521 00	spri2	pr6|130
002740  aa  6 00174 6211 00	eax1 	pr6|124
002741  aa   014000 4310 07	fld  	6144,dl
002742  aa  6 00044 3701 20	epp4 	pr6|36,*
002743  la  4 00014 3521 20	epp2 	pr4|12,*		privileged_mode_ut$sscr
002744  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 454
	return;

002745  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO isolts_scu_p1                                      STATEMENT 1 ON LINE 538
isolts_scu_p1: entry;

002746  da     000356200000
002747  aa   000420 6270 00	eax7 	272
002750  aa  7 00034 3521 20	epp2 	pr7|28,*
002751  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002752  aa     000000000000
002753  aa     000000000000
						STATEMENT 1 ON LINE 540
	iscu = scs$processor_test_data.scu_tag;

002754  aa  6 00044 3701 20	epp4 	pr6|36,*
002755  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.scu_tag
002756  aa   000030 7350 00	als  	24
002757  aa   000102 7330 00	lrs  	66
002760  aa  6 00104 7561 00	stq  	pr6|68		iscu
						STATEMENT 1 ON LINE 541
	icpu = scs$processor_test_data.cpu_tag;

002761  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.cpu_tag
002762  aa   000022 7350 00	als  	18
002763  aa   000102 7330 00	lrs  	66
002764  aa  6 00105 7561 00	stq  	pr6|69		icpu
						STATEMENT 1 ON LINE 542
	mcpu = scs$processor_test_data.mask_cpu;

002765  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.mask_cpu
002766  aa   000036 7350 00	als  	30
002767  aa   000102 7330 00	lrs  	66
002770  aa  6 00106 7561 00	stq  	pr6|70		mcpu
						STATEMENT 1 ON LINE 543
	cdp = addr (scs$controller_data (iscu));

002771  aa  6 00104 2361 00	ldq  	pr6|68		iscu
002772  aa   000002 7360 00	qls  	2
002773  la  4 00022 3735 66	epp7 	pr4|18,*ql	scs$controller_data
002774  aa  6 00126 6535 00	spri7	pr6|86		cdp
						STATEMENT 1 ON LINE 544
	scrp = addr (scs$cfg_data (iscu));

002775  aa  6 00104 2361 00	ldq  	pr6|68		iscu
002776  aa   000001 7360 00	qls  	1
002777  la  4 00044 3715 66	epp5 	pr4|36,*ql	scs$cfg_data
003000  aa  6 00134 6515 00	spri5	pr6|92		scrp
						STATEMENT 1 ON LINE 545
	pdp = addr (scs$processor_data (icpu));

003001  aa  6 00105 7271 00	lxl7 	pr6|69		icpu
003002  la  4 00024 3535 77	epp3 	pr4|20,*7		scs$processor_data
003003  aa  6 00130 2535 00	spri3	pr6|88		pdp
						STATEMENT 1 ON LINE 546
	mkp = addr (scs$cpu_test_mask);

003004  la  4 00034 3515 20	epp1 	pr4|28,*		scs$cpu_test_mask
003005  aa  6 00132 2515 00	spri1	pr6|90		mkp
						STATEMENT 1 ON LINE 550
	maska = set_mask_assignment (scs$processor_data (mcpu).controller_port + 1);

003006  aa  6 00106 7261 00	lxl6 	pr6|70		mcpu
003007  la  4 00024 2361 76	ldq  	pr4|20,*6		scs$processor_data.controller_port
003010  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
003011  aa   000001 0760 07	adq  	1,dl
003012  aa  6 00233 7561 00	stq  	pr6|155
003013  aa   000575 3520 04	epp2 	381,ic		003610 = 000004000000
003014  aa   000527 6700 04	tsp4 	343,ic		003543
						STATEMENT 1 ON LINE 551
	maskb = set_mask_assignment (pdata.controller_port + 1);

003015  aa  6 00130 2361 20	ldq  	pr6|88,*		pdata.controller_port
003016  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
003017  aa   000001 0760 07	adq  	1,dl
003020  aa  6 00233 7561 00	stq  	pr6|155
003021  aa   000561 3520 04	epp2 	369,ic		003602 = 000004000000
003022  aa   000521 6700 04	tsp4 	337,ic		003543
						STATEMENT 1 ON LINE 555
	scs$cpu_test_mask = "0"b;

003023  aa   775011 2370 04	ldaq 	-1527,ic		000034 = 000000000000 000000000000
003024  aa  6 00044 3701 20	epp4 	pr6|36,*
003025  la  4 00034 3735 20	epp7 	pr4|28,*		scs$cpu_test_mask
003026  aa  7 00000 7551 00	sta  	pr7|0		scs$cpu_test_mask
003027  aa  7 00001 7561 00	stq  	pr7|1		scs$cpu_test_mask
						STATEMENT 1 ON LINE 556
	mkp -> scr_msk.port_mask_1 = substr ((maska | maskb), 1, 4);

003030  aa  6 00110 2351 00	lda  	pr6|72		maskb
003031  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003032  aa  6 00233 7551 00	sta  	pr6|155		maskb
003033  aa  6 00107 2351 00	lda  	pr6|71		maska
003034  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003035  aa  6 00233 2751 00	ora  	pr6|155		maskb
003036  aa  6 00233 7551 00	sta  	pr6|155
003037  aa   000040 7710 00	arl  	32
003040  aa  6 00132 6751 20	era  	pr6|90,*		scr_msk.port_mask_1
003041  aa   000017 3750 07	ana  	15,dl
003042  aa  6 00132 6551 20	ersa 	pr6|90,*		scr_msk.port_mask_1
						STATEMENT 1 ON LINE 557
	mkp -> scr_msk.port_mask_2 = substr ((maska | maskb), 5, 4);

003043  aa  6 00233 2351 00	lda  	pr6|155
003044  aa   000034 7710 00	arl  	28
003045  aa  6 00132 3715 20	epp5 	pr6|90,*		mkp
003046  aa  5 00001 6751 00	era  	pr5|1		scr_msk.port_mask_2
003047  aa   000017 3750 07	ana  	15,dl
003050  aa  5 00001 6551 00	ersa 	pr5|1		scr_msk.port_mask_2
						STATEMENT 1 ON LINE 559
	if cdata.type >= "0010"b then do;

003051  aa  6 00126 3535 20	epp3 	pr6|86,*		cdp
003052  aa  3 00002 2351 00	lda  	pr3|2		cdata.type
003053  aa   000021 7350 00	als  	17
003054  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
003055  aa   100000 1150 03	cmpa 	32768,du
003056  aa   000030 6020 04	tnc  	24,ic		003106
						STATEMENT 1 ON LINE 561
	     scr_cfg2.mask_a_assign = maska;

003057  aa  6 00107 2351 00	lda  	pr6|71		maska
003060  aa  6 00134 3515 20	epp1 	pr6|92,*		scr_cfg2.mask_a_assign
003061  aa  1 00000 5511 40	stba 	pr1|0,40		scr_cfg2.mask_a_assign
						STATEMENT 1 ON LINE 562
	     scr_cfg2.mask_b_assign = maskb;

003062  aa  6 00110 2351 00	lda  	pr6|72		maskb
003063  aa  6 00134 3515 20	epp1 	pr6|92,*		scrp
003064  aa  1 00001 5511 40	stba 	pr1|1,40		scr_cfg2.mask_b_assign
						STATEMENT 1 ON LINE 563
	     scr_cfg2.port_mask_0_3 = mkp -> scr_msk.port_mask_1;

003065  aa  5 00000 2351 00	lda  	pr5|0		scr_msk.port_mask_1
003066  aa  1 00000 6751 00	era  	pr1|0		scr_cfg2.port_mask_0_3
003067  aa   000017 3750 07	ana  	15,dl
003070  aa  1 00000 6551 00	ersa 	pr1|0		scr_cfg2.port_mask_0_3
						STATEMENT 1 ON LINE 564
	     scr_cfg2.port_mask_4_7 = mkp -> scr_msk.port_mask_2;

003071  aa  5 00001 2351 00	lda  	pr5|1		scr_msk.port_mask_2
003072  aa  1 00001 6751 00	era  	pr1|1		scr_cfg2.port_mask_4_7
003073  aa   000017 3750 07	ana  	15,dl
003074  aa  1 00001 6551 00	ersa 	pr1|1		scr_cfg2.port_mask_4_7
						STATEMENT 1 ON LINE 566
	     call set_cfg ((iscu));

003075  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003076  aa  6 00233 7561 00	stq  	pr6|155
003077  aa  6 00233 3521 00	epp2 	pr6|155
003100  aa  6 00176 2521 00	spri2	pr6|126
003101  aa  6 00174 6211 00	eax1 	pr6|124
003102  aa   004000 4310 07	fld  	2048,dl
003103  aa   776671 3520 04	epp2 	-583,ic		001774 = 000420627000
003104  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 568
	end;

003105  aa   000012 7100 04	tra  	10,ic		003117
						STATEMENT 1 ON LINE 570
	else call privileged_mode_ut$smcm ((iscu), scs$cpu_test_mask);

003106  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003107  aa  6 00233 7561 00	stq  	pr6|155
003110  aa  6 00233 3521 00	epp2 	pr6|155
003111  aa  6 00176 2521 00	spri2	pr6|126
003112  aa  6 00200 6535 00	spri7	pr6|128
003113  aa  6 00174 6211 00	eax1 	pr6|124
003114  aa   010000 4310 07	fld  	4096,dl
003115  la  4 00016 3521 20	epp2 	pr4|14,*		privileged_mode_ut$smcm
003116  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 571
	call set_mask ((iscu), (scs$processor_data (mcpu).controller_port), /* mask off interrupts */
	     fixed (scs$cpu_test_mask, 71));

003117  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003120  aa  6 00233 7561 00	stq  	pr6|155
003121  aa  6 00106 7271 00	lxl7 	pr6|70		mcpu
003122  aa  6 00044 3701 20	epp4 	pr6|36,*
003123  la  4 00024 2361 77	ldq  	pr4|20,*7		scs$processor_data.controller_port
003124  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
003125  aa  6 00173 7561 00	stq  	pr6|123
003126  la  4 00034 3735 20	epp7 	pr4|28,*		scs$cpu_test_mask
003127  aa  7 00000 2351 00	lda  	pr7|0		scs$cpu_test_mask
003130  aa  7 00001 2361 00	ldq  	pr7|1		scs$cpu_test_mask
003131  aa  6 00206 7571 00	staq 	pr6|134
003132  aa  6 00233 3521 00	epp2 	pr6|155
003133  aa  6 00176 2521 00	spri2	pr6|126
003134  aa  6 00173 3521 00	epp2 	pr6|123
003135  aa  6 00200 2521 00	spri2	pr6|128
003136  aa  6 00206 3521 00	epp2 	pr6|134
003137  aa  6 00202 2521 00	spri2	pr6|130
003140  aa  6 00174 6211 00	eax1 	pr6|124
003141  aa   014000 4310 07	fld  	6144,dl
003142  aa   777556 3520 04	epp2 	-146,ic		002720 = 000420627000
003143  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 573
	mkp -> scr_msk.interrupt_mask_1 = "1001000000001000"b;

003144  aa   440040 2350 03	lda  	147488,du
003145  aa  6 00132 6751 20	era  	pr6|90,*		scr_msk.interrupt_mask_1
003146  aa  0 00040 3751 00	ana  	pr0|32		= 777774000000
003147  aa  6 00132 6551 20	ersa 	pr6|90,*		scr_msk.interrupt_mask_1
						STATEMENT 1 ON LINE 575
	scs$processor_test_data.scu_state = "10"b;

003150  aa   200000 2350 03	lda  	65536,du
003151  aa  6 00044 3701 20	epp4 	pr6|36,*
003152  la  4 00040 6751 20	era  	pr4|32,*		scs$processor_test_data.scu_state
003153  aa   300000 3750 03	ana  	98304,du
003154  la  4 00040 6551 20	ersa 	pr4|32,*		scs$processor_test_data.scu_state
						STATEMENT 1 ON LINE 577
	return;

003155  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO isolts_scu_p2                                      STATEMENT 1 ON LINE 583
isolts_scu_p2: entry;

003156  da     000365200000
003157  aa   000420 6270 00	eax7 	272
003160  aa  7 00034 3521 20	epp2 	pr7|28,*
003161  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003162  aa     000000000000
003163  aa     000000000000
						STATEMENT 1 ON LINE 585
	iscu = scs$processor_test_data.scu_tag;

003164  aa  6 00044 3701 20	epp4 	pr6|36,*
003165  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.scu_tag
003166  aa   000030 7350 00	als  	24
003167  aa   000102 7330 00	lrs  	66
003170  aa  6 00104 7561 00	stq  	pr6|68		iscu
						STATEMENT 1 ON LINE 586
	icpu = scs$processor_test_data.cpu_tag;

003171  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.cpu_tag
003172  aa   000022 7350 00	als  	18
003173  aa   000102 7330 00	lrs  	66
003174  aa  6 00105 7561 00	stq  	pr6|69		icpu
						STATEMENT 1 ON LINE 587
	mcpu = scs$processor_test_data.mask_cpu;

003175  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.mask_cpu
003176  aa   000036 7350 00	als  	30
003177  aa   000102 7330 00	lrs  	66
003200  aa  6 00106 7561 00	stq  	pr6|70		mcpu
						STATEMENT 1 ON LINE 588
	cdp = addr (scs$controller_data (iscu));

003201  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003202  aa   000002 7360 00	qls  	2
003203  la  4 00022 3735 66	epp7 	pr4|18,*ql	scs$controller_data
003204  aa  6 00126 6535 00	spri7	pr6|86		cdp
						STATEMENT 1 ON LINE 589
	scrp = addr (scs$cfg_data (iscu));

003205  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003206  aa   000001 7360 00	qls  	1
003207  la  4 00044 3715 66	epp5 	pr4|36,*ql	scs$cfg_data
003210  aa  6 00134 6515 00	spri5	pr6|92		scrp
						STATEMENT 1 ON LINE 590
	pdp = addr (scs$processor_data (icpu));

003211  aa  6 00105 7271 00	lxl7 	pr6|69		icpu
003212  la  4 00024 3535 77	epp3 	pr4|20,*7		scs$processor_data
003213  aa  6 00130 2535 00	spri3	pr6|88		pdp
						STATEMENT 1 ON LINE 591
	mkp = addr (scs$cpu_test_mask);

003214  la  4 00034 3515 20	epp1 	pr4|28,*		scs$cpu_test_mask
003215  aa  6 00132 2515 00	spri1	pr6|90		mkp
						STATEMENT 1 ON LINE 595
	maska = set_mask_assignment (pdata.controller_port + 1);

003216  aa  3 00000 2361 00	ldq  	pr3|0		pdata.controller_port
003217  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
003220  aa   000001 0760 07	adq  	1,dl
003221  aa  6 00173 7561 00	stq  	pr6|123
003222  aa   000352 3520 04	epp2 	234,ic		003574 = 000004000000
003223  aa   000320 6700 04	tsp4 	208,ic		003543
						STATEMENT 1 ON LINE 596
	pdp = addr (scs$sys_level);

003224  aa  6 00044 3701 20	epp4 	pr6|36,*
003225  la  4 00030 3735 20	epp7 	pr4|24,*		scs$sys_level
003226  aa  6 00130 6535 00	spri7	pr6|88		pdp
						STATEMENT 1 ON LINE 597
	mkp -> scr_msk.port_mask_1 = pdp -> scr_msk.port_mask_1 | substr (maska, 1, 4);

003227  aa  6 00107 2351 00	lda  	pr6|71		maska
003230  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
003231  aa  6 00173 7551 00	sta  	pr6|123		maska
003232  aa  7 00000 2351 00	lda  	pr7|0		scr_msk.port_mask_1
003233  aa   000040 7350 00	als  	32
003234  aa  6 00173 2751 00	ora  	pr6|123		maska
003235  aa   000040 7710 00	arl  	32
003236  aa  6 00132 6751 20	era  	pr6|90,*		scr_msk.port_mask_1
003237  aa   000017 3750 07	ana  	15,dl
003240  aa  6 00132 6551 20	ersa 	pr6|90,*		scr_msk.port_mask_1
						STATEMENT 1 ON LINE 598
	mkp -> scr_msk.port_mask_2 = pdp -> scr_msk.port_mask_2 | substr (maska, 5, 4);

003241  aa  6 00107 2351 00	lda  	pr6|71		maska
003242  aa   000004 7350 00	als  	4
003243  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
003244  aa  6 00173 7551 00	sta  	pr6|123		maska
003245  aa  7 00001 2351 00	lda  	pr7|1		scr_msk.port_mask_2
003246  aa   000040 7350 00	als  	32
003247  aa  6 00173 2751 00	ora  	pr6|123		maska
003250  aa   000040 7710 00	arl  	32
003251  aa  6 00132 3715 20	epp5 	pr6|90,*		mkp
003252  aa  5 00001 6751 00	era  	pr5|1		scr_msk.port_mask_2
003253  aa   000017 3750 07	ana  	15,dl
003254  aa  5 00001 6551 00	ersa 	pr5|1		scr_msk.port_mask_2
						STATEMENT 1 ON LINE 600
	if cdata.type >= "0010"b then do;

003255  aa  6 00126 3535 20	epp3 	pr6|86,*		cdp
003256  aa  3 00002 2351 00	lda  	pr3|2		cdata.type
003257  aa   000021 7350 00	als  	17
003260  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
003261  aa   100000 1150 03	cmpa 	32768,du
003262  aa   000023 6020 04	tnc  	19,ic		003305
						STATEMENT 1 ON LINE 602
	     scr_cfg2.port_mask_0_3 = mkp -> scr_msk.port_mask_1;

003263  aa  5 00000 2351 00	lda  	pr5|0		scr_msk.port_mask_1
003264  aa  6 00134 6751 20	era  	pr6|92,*		scr_cfg2.port_mask_0_3
003265  aa   000017 3750 07	ana  	15,dl
003266  aa  6 00134 6551 20	ersa 	pr6|92,*		scr_cfg2.port_mask_0_3
						STATEMENT 1 ON LINE 603
	     scr_cfg2.port_mask_4_7 = mkp -> scr_msk.port_mask_2;

003267  aa  5 00001 2351 00	lda  	pr5|1		scr_msk.port_mask_2
003270  aa  6 00134 3515 20	epp1 	pr6|92,*		scrp
003271  aa  1 00001 6751 00	era  	pr1|1		scr_cfg2.port_mask_4_7
003272  aa   000017 3750 07	ana  	15,dl
003273  aa  1 00001 6551 00	ersa 	pr1|1		scr_cfg2.port_mask_4_7
						STATEMENT 1 ON LINE 605
	     call set_cfg ((iscu));

003274  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003275  aa  6 00173 7561 00	stq  	pr6|123
003276  aa  6 00173 3521 00	epp2 	pr6|123
003277  aa  6 00176 2521 00	spri2	pr6|126
003300  aa  6 00174 6211 00	eax1 	pr6|124
003301  aa   004000 4310 07	fld  	2048,dl
003302  aa   776472 3520 04	epp2 	-710,ic		001774 = 000420627000
003303  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 607
	end;

003304  aa   000020 7100 04	tra  	16,ic		003324
						STATEMENT 1 ON LINE 609
	else call privileged_mode_ut$smcm ((iscu),
	     "000000000017000000000017"b3 & scs$cpu_test_mask);

003305  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003306  aa  6 00173 7561 00	stq  	pr6|123
003307  aa   774523 2370 04	ldaq 	-1709,ic		000032 = 000000000017 000000000017
003310  la  4 00034 3515 20	epp1 	pr4|28,*		scs$cpu_test_mask
003311  aa  1 00000 3751 00	ana  	pr1|0		scs$cpu_test_mask
003312  aa  1 00001 3761 00	anq  	pr1|1		scs$cpu_test_mask
003313  aa  6 00206 7571 00	staq 	pr6|134
003314  aa  6 00173 3521 00	epp2 	pr6|123
003315  aa  6 00176 2521 00	spri2	pr6|126
003316  aa  6 00206 3521 00	epp2 	pr6|134
003317  aa  6 00200 2521 00	spri2	pr6|128
003320  aa  6 00174 6211 00	eax1 	pr6|124
003321  aa   010000 4310 07	fld  	4096,dl
003322  la  4 00016 3521 20	epp2 	pr4|14,*		privileged_mode_ut$smcm
003323  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 611
	call set_mask ((iscu), (scs$processor_data (mcpu).controller_port), /* mask off interrupts */
	     fixed ("000000000017000000000017"b3 & scs$cpu_test_mask, 71));

003324  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003325  aa  6 00173 7561 00	stq  	pr6|123
003326  aa  6 00106 7271 00	lxl7 	pr6|70		mcpu
003327  aa  6 00044 3701 20	epp4 	pr6|36,*
003330  la  4 00024 2361 77	ldq  	pr4|20,*7		scs$processor_data.controller_port
003331  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
003332  aa  6 00233 7561 00	stq  	pr6|155
003333  aa   774477 2370 04	ldaq 	-1729,ic		000032 = 000000000017 000000000017
003334  la  4 00034 3735 20	epp7 	pr4|28,*		scs$cpu_test_mask
003335  aa  7 00000 3751 00	ana  	pr7|0		scs$cpu_test_mask
003336  aa  7 00001 3761 00	anq  	pr7|1		scs$cpu_test_mask
003337  aa  6 00206 7571 00	staq 	pr6|134
003340  aa  6 00173 3521 00	epp2 	pr6|123
003341  aa  6 00176 2521 00	spri2	pr6|126
003342  aa  6 00233 3521 00	epp2 	pr6|155
003343  aa  6 00200 2521 00	spri2	pr6|128
003344  aa  6 00206 3521 00	epp2 	pr6|134
003345  aa  6 00202 2521 00	spri2	pr6|130
003346  aa  6 00174 6211 00	eax1 	pr6|124
003347  aa   014000 4310 07	fld  	6144,dl
003350  aa   777350 3520 04	epp2 	-280,ic		002720 = 000420627000
003351  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 614
	return;

003352  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO isolts_scu_p3                                      STATEMENT 1 ON LINE 621
isolts_scu_p3: entry;

003353  da     000374200000
003354  aa   000420 6270 00	eax7 	272
003355  aa  7 00034 3521 20	epp2 	pr7|28,*
003356  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003357  aa     000000000000
003360  aa     000000000000
						STATEMENT 1 ON LINE 623
	iscu = scs$processor_test_data.scu_tag;

003361  aa  6 00044 3701 20	epp4 	pr6|36,*
003362  la  4 00040 2351 20	lda  	pr4|32,*		scs$processor_test_data.scu_tag
003363  aa   000030 7350 00	als  	24
003364  aa   000102 7330 00	lrs  	66
003365  aa  6 00104 7561 00	stq  	pr6|68		iscu
						STATEMENT 1 ON LINE 624
	cdp = addr (scs$controller_data (iscu));

003366  aa   000002 7360 00	qls  	2
003367  la  4 00022 3735 66	epp7 	pr4|18,*ql	scs$controller_data
003370  aa  6 00126 6535 00	spri7	pr6|86		cdp
						STATEMENT 1 ON LINE 626
	scs$cfg_data (iscu) = scs$cfg_data_save;

003371  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003372  aa   000001 7360 00	qls  	1
003373  aa   000000 6270 06	eax7 	0,ql
003374  la  4 00046 2371 20	ldaq 	pr4|38,*		scs$cfg_data_save
003375  la  4 00044 7571 77	staq 	pr4|36,*7		scs$cfg_data
						STATEMENT 1 ON LINE 628
	if cdata.type >= "0010"b then			/* if 4MW SCU */
	     call set_cfg ((iscu));

003376  aa  7 00002 2351 00	lda  	pr7|2		cdata.type
003377  aa   000021 7350 00	als  	17
003400  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
003401  aa   100000 1150 03	cmpa 	32768,du
003402  aa   000012 6020 04	tnc  	10,ic		003414
003403  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003404  aa  6 00233 7561 00	stq  	pr6|155
003405  aa  6 00233 3521 00	epp2 	pr6|155
003406  aa  6 00176 2521 00	spri2	pr6|126
003407  aa  6 00174 6211 00	eax1 	pr6|124
003410  aa   004000 4310 07	fld  	2048,dl
003411  aa   776363 3520 04	epp2 	-781,ic		001774 = 000420627000
003412  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
003413  aa   000013 7100 04	tra  	11,ic		003426
						STATEMENT 1 ON LINE 630
	else call privileged_mode_ut$smcm ((iscu), scs$sys_level);

003414  aa  6 00104 2361 00	ldq  	pr6|68		iscu
003415  aa  6 00233 7561 00	stq  	pr6|155
003416  aa  6 00233 3521 00	epp2 	pr6|155
003417  aa  6 00176 2521 00	spri2	pr6|126
003420  la  4 00030 3521 20	epp2 	pr4|24,*		scs$sys_level
003421  aa  6 00200 2521 00	spri2	pr6|128
003422  aa  6 00174 6211 00	eax1 	pr6|124
003423  aa   010000 4310 07	fld  	4096,dl
003424  la  4 00016 3521 20	epp2 	pr4|14,*		privileged_mode_ut$smcm
003425  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 632
	return;

003426  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 664
     end scr_util$read_cfg;

BEGIN PROCEDURE convert_to_mask_val
ENTRY TO convert_to_mask_val                                STATEMENT 1 ON LINE 459
convert_to_mask_val:
	proc (scu_mask_bits) returns (char (*));

003427  da     000404220000
003430  aa   000120 6270 00	eax7 	80
003431  aa  7 00034 3521 20	epp2 	pr7|28,*
003432  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
003433  aa     000004000000
003434  aa     000000000000
003435  aa  6 00042 3735 20	epp7 	pr6|34,*
003436  aa  7 00000 2361 20	ldq  	pr7|0,*
003437  aa   000002 6040 04	tmi  	2,ic		003441
003440  aa   777777 3760 07	anq  	262143,dl
003441  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003442  aa  6 00101 7561 00	stq  	pr6|65
						STATEMENT 1 ON LINE 466
	if index (scu_mask_bits, "1"b) >0 then do;

003443  aa   400000 2350 03	lda  	131072,du
003444  aa  6 00032 3715 20	epp5 	pr6|26,*
003445  aa  5 00002 3521 20	epp2 	pr5|2,*		scu_mask_bits
003446  aa  0 01234 7001 00	tsx0 	pr0|668		index_bs_1_eis
003447  aa  6 00102 7561 00	stq  	pr6|66
003450  aa   000022 6044 04	tmoz 	18,ic		003472
						STATEMENT 1 ON LINE 467
	     mask_val = index (scu_mask_bits, "1"b) - 1;

003451  aa   000001 1760 07	sbq  	1,dl
003452  aa  6 00102 7561 00	stq  	pr6|66
003453  aa  000 100 301 500	btd  	(pr),(pr)
003454  aa  6 00102 00 0004	desc9a	pr6|66,4
003455  aa  6 00103 01 0002	desc9ls	pr6|67,2,0
003456  aa  6 00100 4501 00	stz  	pr6|64		mask_val
003457  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
003460  aa  6 00103 01 0002	desc9ls	pr6|67,2,0
003461  aa   000113 00 0002	desc9a	75,2		003572 = 070321000000
003462  aa  6 00100 00 0001	desc9a	pr6|64,1		mask_val
						STATEMENT 1 ON LINE 468
	     return (mask_val);

003463  aa   000001 2360 07	ldq  	1,dl
003464  aa   526000 2760 03	orq  	175104,du
003465  aa  7 00002 7561 20	stq  	pr7|2,*
003466  aa   000001 2360 07	ldq  	1,dl
003467  aa   000000 7200 07	lxl0 	0,dl
003470  aa  6 00100 3521 00	epp2 	pr6|64		mask_val
003471  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 469
	end;

						STATEMENT 1 ON LINE 470
	else return ("Off");

003472  aa   000003 2360 07	ldq  	3,dl
003473  aa   526000 2760 03	orq  	175104,du
003474  aa  7 00002 7561 20	stq  	pr7|2,*
003475  aa   000003 2360 07	ldq  	3,dl
003476  aa   000000 7200 07	lxl0 	0,dl
003477  aa   774305 3520 04	epp2 	-1851,ic		000004 = 117146146000
003500  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 473
end convert_to_mask_val;

  END PROCEDURE convert_to_mask_val
BEGIN PROCEDURE interpret_eima
ENTRY TO interpret_eima                                     STATEMENT 1 ON LINE 479
interpret_eima: proc (n, eima);

003501  aa  6 00144 6501 00	spri4	pr6|100
003502  aa  6 00146 2521 00	spri2	pr6|102
						STATEMENT 1 ON LINE 487
	     x = index (eima, "1"b);

003503  aa   400000 2350 03	lda  	131072,du
003504  aa   000011 2360 07	ldq  	9,dl
003505  aa  2 00004 3521 20	epp2 	pr2|4,*		eima
003506  aa  0 01234 7001 00	tsx0 	pr0|668		index_bs_1_eis
003507  aa  6 00152 7561 00	stq  	pr6|106		x
						STATEMENT 1 ON LINE 488
	     if (x = 0) | (x = 9) then		/* If no bits ON, or last bit ON ... */
		cdata.eima_data (n).mask_assigned = "0"b;

003510  aa   000003 6000 04	tze  	3,ic		003513
003511  aa   000011 1160 07	cmpq 	9,dl
003512  aa   000011 6010 04	tnz  	9,ic		003523
003513  aa  6 00146 3735 20	epp7 	pr6|102,*
003514  aa  7 00002 2361 20	ldq  	pr7|2,*		n
003515  aa   000011 4020 07	mpy  	9,dl
003516  aa  6 00126 3715 20	epp5 	pr6|86,*		cdp
003517  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
003520  aa   000000 00 0000	descb	0,0
003521  aa  5 00000 61 0001	descb	pr5|0(28),1	cdata.mask_assigned
003522  aa   000020 7100 04	tra  	16,ic		003542
						STATEMENT 1 ON LINE 490
	     else do;

						STATEMENT 1 ON LINE 491
		cdata.eima_data (n).mask_assigned = "1"b;

003523  aa  6 00146 3735 20	epp7 	pr6|102,*
003524  aa  7 00002 2361 20	ldq  	pr7|2,*		n
003525  aa   000011 4020 07	mpy  	9,dl
003526  aa  6 00126 3715 20	epp5 	pr6|86,*		cdp
003527  aa  403 106 060 400	csl  	(),(pr,ql),fill(1),bool(move)
003530  aa   000000 00 0000	descb	0,0
003531  aa  5 00000 61 0001	descb	pr5|0(28),1	cdata.mask_assigned
						STATEMENT 1 ON LINE 492
		cdata.eima_data (n).mask_assignment = x - 1;

003532  aa   000000 6270 06	eax7 	0,ql
003533  aa  6 00152 2361 00	ldq  	pr6|106		x
003534  aa   000001 1760 07	sbq  	1,dl
003535  aa   000104 7370 00	lls  	68
003536  aa  6 00056 7551 00	sta  	pr6|46
003537  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
003540  aa  6 00056 00 0004	descb	pr6|46,4
003541  aa  5 00000 65 0004	descb	pr5|0(32),4	cdata.mask_assignment
						STATEMENT 1 ON LINE 493
	     end;

						STATEMENT 1 ON LINE 495
	     return;

003542  aa  6 00144 6101 00	rtcd 	pr6|100
						STATEMENT 1 ON LINE 497
	end interpret_eima;

  END PROCEDURE interpret_eima
BEGIN PROCEDURE set_mask_assignment
ENTRY TO set_mask_assignment                                STATEMENT 1 ON LINE 501
set_mask_assignment: proc (n) returns (bit (9) unal);

003543  aa  6 00154 6501 00	spri4	pr6|108
003544  aa  6 00156 2521 00	spri2	pr6|110
						STATEMENT 1 ON LINE 508
	     m = "0"b;

003545  aa  6 00162 4501 00	stz  	pr6|114		m
						STATEMENT 1 ON LINE 509
	     substr (m, n, 1) = "1"b;

003546  aa  2 00002 7271 20	lxl7 	pr2|2,*		n
003547  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
003550  aa   000000 00 0000	descb	0,0
003551  aa  6 00161 70 0001	descb	pr6|113(35),1	m
						STATEMENT 1 ON LINE 511
	     return (m);

003552  aa  2 00004 3735 20	epp7 	pr2|4,*
003553  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003554  aa  6 00162 00 0011	descb	pr6|114,9		m
003555  aa  7 00000 00 0011	descb	pr7|0,9
003556  aa  6 00154 6101 00	rtcd 	pr6|108
						STATEMENT 1 ON LINE 514
	end set_mask_assignment;

  END PROCEDURE set_mask_assignment
BEGIN PROCEDURE power_of_two
ENTRY TO power_of_two                                       STATEMENT 1 ON LINE 519
power_of_two: proc (e) returns (fixed bin);

003557  aa  6 00164 6501 00	spri4	pr6|116
003560  aa  6 00166 2521 00	spri2	pr6|118
						STATEMENT 1 ON LINE 526
	     p = 0;

003561  aa  6 00172 4501 00	stz  	pr6|122		p
						STATEMENT 1 ON LINE 527
	     substr (unspec (p), 36 - e, 1) = "1"b;

003562  aa   000044 2360 07	ldq  	36,dl
003563  aa  2 00002 1761 20	sbq  	pr2|2,*		e
003564  aa  403 106 060 400	csl  	(),(pr,ql),fill(1),bool(move)
003565  aa   000000 00 0000	descb	0,0
003566  aa  6 00171 70 0001	descb	pr6|121(35),1
						STATEMENT 1 ON LINE 529
	     return (p);

003567  aa  6 00172 2361 00	ldq  	pr6|122		p
003570  aa  2 00004 7561 20	stq  	pr2|4,*
003571  aa  6 00164 6101 00	rtcd 	pr6|116
						STATEMENT 1 ON LINE 532
	end power_of_two;

  END PROCEDURE power_of_two
  END PROCEDURE scr_util$read_cfg


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
