	COMPILATION LISTING OF SEGMENT scavenger
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1116.95_Tue_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /* format: style3 */
       12 scavenger:
       13      proc (Pvtx, Pvid, Scavenger_Optionsp, Sc_metersp, Code);
       14 
       15 /*  This is the driver program for the scavenger. It validates the PVTE
       16*    and sets up all data structures needed for scavenging. The scavenge
       17*    itself is done elsewhere.
       18*
       19*    scavenger$shutdown is called by normal shutdown to reset any
       20*    scavenge in progress. It must be called after traffic control
       21*    is shutdown to avoid races.
       22*
       23*    Written July 1982 by J. Bongiovanni
       24*    Modified October 1982 by J. Bongiovanni for fm_damaged and associated meters
       25*    Modified 83-12-13 BIM to call verify_lock on faults.
       26*    Modified 85-02-21, EJ Sharpe: use syserr_fault_msg.incl.pl1, correct logging of history registers.
       27**/
       28 
       29 /****^  HISTORY COMMENTS:
       30*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       31*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       32*     Correct error message documentation.
       33*  2) change(86-06-02,Fawcett), approve(86-04-11,MCR7383),
       34*     audit(86-06-18,Beattie), install(86-07-17,MR12.0-1097):
       35*     Add support for subvolumes.
       36*                                                   END HISTORY COMMENTS */
       37 
       38 /*  Parameter  */
       39 
       40 dcl	Pvtx		fixed bin;		/* PVTE index */
       41 dcl	Pvid		bit (36) aligned;		/* Physical Volume ID */
       42 dcl	Scavenger_Optionsp	ptr;			/* -> scavenger_options */
       43 dcl	Sc_metersp	ptr;			/* -> returned meters, or null */
       44 dcl	Code		fixed bin (35);		/* Error code */
       45 
       46 /*  Automatic  */
       47 
       48 dcl	begin_clock	fixed bin (71);
       49 dcl	begin_pf		fixed bin;
       50 dcl	begin_vcpu	fixed bin (71);
       51 dcl	code		fixed bin (35);
       52 dcl	end_pf		fixed bin;
       53 dcl	end_vcpu		fixed bin (71);
       54 dcl	i_am_wired	bit (1) aligned;
       55 dcl	1 local_sc_meters	aligned like sc_meters;
       56 dcl	1 local_scavenger_options
       57 			aligned like scavenger_options;
       58 dcl	p99		pic "99";
       59 dcl	old_mask		fixed bin (71);
       60 dcl	process_tablex	fixed bin;
       61 dcl	ptwp		ptr;
       62 dcl	scavenger_data_astep
       63 			ptr;
       64 dcl	started		bit (1) aligned;
       65 
       66 /*  Static  */
       67 
       68 dcl	N_OVFL		fixed bin int static options (constant) init (1023);
       69 						/* Limited by field size */
       70 
       71 /*  Based  */
       72 
       73 dcl	1 Sc_meters	aligned like sc_meters based (Sc_metersp);
       74 dcl	1 Scavenger_Options aligned like scavenger_options based (Scavenger_Optionsp);
       75 
       76 /*  External  */
       77 
       78 dcl	error_table_$pvid_not_found
       79 			fixed bin (35) external;
       80 dcl	error_table_$unexpected_condition
       81 			fixed bin (35) external;
       82 dcl	error_table_$scavenge_process_limit
       83 			fixed bin (35) external;
       84 dcl	error_table_$pv_no_scavenge
       85 			fixed bin (35) external;
       86 dcl	pds$process_group_id
       87 			char (32) aligned external;
       88 dcl	pds$processid	bit (36) aligned external;
       89 dcl	sst$astl		bit (36) aligned external;
       90 
       91 /*  Entry  */
       92 
       93 dcl	condition_	entry (char (*), entry);
       94 dcl	get_ptrs_$given_segno
       95 			entry (fixed bin) returns (ptr);
       96 dcl	lock$lock_ast	entry;
       97 dcl	lock$lock_fast	entry (ptr);
       98 dcl	lock$unlock_ast	entry;
       99 dcl	lock$unlock_fast	entry (ptr);
      100 dcl	pc_wired$wire_wait	entry (ptr, fixed bin, fixed bin);
      101 dcl	pc_wired$unwire	entry (ptr, fixed bin, fixed bin);
      102 dcl	pmut$lock_ptl	entry (fixed bin (71), ptr);
      103 dcl	pmut$unlock_ptl	entry (fixed bin (71), ptr);
      104 dcl	scavenge_volume	entry (ptr, ptr, ptr, ptr, fixed bin (35));
      105 dcl	syserr		entry options (variable);
      106 dcl	syserr$binary	entry options (variable);
      107 dcl	syserr$error_code	entry options (variable);
      108 dcl	usage_values	entry (fixed bin, fixed bin (71));
      109 dcl	verify_lock$condition_nolog
      110 			entry (character (*), pointer);
      111 dcl	wire_proc$wire_me	entry;
      112 dcl	wire_proc$unwire_me entry;
      113 
      114 /*  Builtin  */
      115 
      116 dcl	addr		builtin;
      117 dcl	addrel		builtin;
      118 dcl	baseno		builtin;
      119 dcl	bin		builtin;
      120 dcl	clock		builtin;
      121 dcl	convert		builtin;
      122 dcl	divide		builtin;
      123 dcl	float		builtin;
      124 dcl	null		builtin;
      125 dcl	rel		builtin;
      126 dcl	size		builtin;
      127 dcl	unspec		builtin;
      128 
      129 	started = "0"b;
      130 	i_am_wired = "0"b;
      131 
      132 	unspec (local_sc_meters) = ""b;
      133 	unspec (local_scavenger_options) = unspec (Scavenger_Options);
      134 
      135 	call SETUP_LOCK (Code);
      136 	if Code ^= 0
      137 	then return;
      138 
      139 	call SETUP_PROCESS_TABLE (process_tablex, code);
      140 	if code ^= 0
      141 	then goto CLEANUP_RETURN;
      142 
      143 	call SETUP_BLOCK (process_tablex);
      144 
      145 	pvte.scavenger_block_rel = rel (scavenger_blockp);
      146 	call lock$unlock_fast (addr (scavenger_data.lock));
      147 
      148 	call usage_values (begin_pf, begin_vcpu);
      149 	begin_clock = clock ();
      150 
      151 	call condition_ ("any_other", PRINT_ERROR);
      152 
      153 	call syserr (ANNOUNCE, "scavenger: Begin scavenge of ^a_^a^[^a^;^1s^] by ^a", pvte.devname,
      154 	     convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);
      155 	started = "1"b;
      156 	call wire_proc$wire_me;
      157 	i_am_wired = "1"b;
      158 	call scavenge_volume (pvtep, scavenger_blockp, addr (local_scavenger_options), addr (local_sc_meters), code);
      159 
      160 LOCK_CLEANUP_RETURN:
      161 	call lock$lock_fast (addr (scavenger_data.lock));
      162 
      163 CLEANUP_RETURN:
      164 	if i_am_wired
      165 	then call wire_proc$unwire_me;
      166 
      167 	if started & (code = 0)
      168 	then do;
      169 		call usage_values (end_pf, end_vcpu);
      170 		local_sc_meters.n_scavenge = 1;
      171 		local_sc_meters.pf = end_pf - begin_pf;
      172 		local_sc_meters.vcpu = end_vcpu - begin_vcpu;
      173 		local_sc_meters.clock_time = clock () - begin_clock;
      174 		if local_scavenger_options.print_meters
      175 		then call PRINT_METERS;
      176 		scavenger_data.meters = scavenger_data.meters + local_sc_meters;
      177 	     end;
      178 
      179 	call lock$lock_ast;				/* Protect against asynchronous SC/PC */
      180 	call pmut$lock_ptl (old_mask, ptwp);
      181 	pvte.scavenger_block_rel = ""b;
      182 	pvte.scav_check_address = "0"b;
      183 	pvte.deposit_to_volmap = "0"b;
      184 	call pmut$unlock_ptl (old_mask, ptwp);
      185 	call lock$unlock_ast;
      186 
      187 	if scavenger_blockp ^= null ()
      188 	then call RETURN_BLOCK (process_tablex);
      189 	if sc_process_tablep ^= null ()
      190 	then call RETURN_PROCESS_TABLE (process_tablex);
      191 
      192 	call lock$unlock_fast (addr (scavenger_data.lock));
      193 
      194 	if started
      195 	then do;
      196 		if code = 0
      197 		then call syserr (ANNOUNCE, "scavenger: Scavenge of ^a_^a^[^a^;^1s^] by ^a completed.", pvte.devname,
      198 			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);
      199 		else call syserr$error_code (ANNOUNCE, code,
      200 			"scavenger: Scavenge of ^a_^a^[^a^;^1s^] by ^a completed with error.", pvte.devname,
      201 			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);
      202 	     end;
      203 
      204 	if Sc_metersp ^= null ()
      205 	then unspec (Sc_meters) = unspec (local_sc_meters);
      206 
      207 	Code = code;
      208 	return;
      209 
      210 /*  Entry to shutdown scavenges in progress  */
      211 
      212 shutdown:
      213      entry;
      214 
      215 	scavenger_datap = addr (scavenger_data$);
      216 	sc_process_tablep = scavenger_data.process_table_ptr;
      217 
      218 	do process_tablex = 1 to sc_process_table.max_n_processes;
      219 	     if sc_process_table.process (process_tablex).processid ^= ""b
      220 						/* Live entry */
      221 	     then do;
      222 		     pvtep = sc_process_table.process (process_tablex).pvtep;
      223 		     pvte.deposit_to_volmap = "0"b;
      224 		     pvte.scav_check_address = "0"b;
      225 		     pvte.scavenger_block_rel = ""b;
      226 		     call syserr (ANNOUNCE, "scavenger: Scavenge of ^a_^a^[^a^] stopped.", pvte.devname,
      227 			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);
      228 		end;
      229 	end;
      230 
      231 	return;
      232 
      233 
      234 
      235 /*  Internal Procedure to lock the scavenger data base and set up pointers */
      236 
      237 SETUP_LOCK:
      238      proc (Code);
      239 
      240 dcl	Code		fixed bin (35);
      241 
      242 	scavenger_datap = addr (scavenger_data$);
      243 	sc_process_tablep = null ();
      244 	scavenger_blockp = null ();
      245 	pvt_arrayp = addr (pvt$array);
      246 	pvtep = addr (pvt_array (Pvtx));
      247 	scavenger_data_astep = get_ptrs_$given_segno (bin (baseno (scavenger_datap)));
      248 	Code = 0;
      249 
      250 	if pvte.pvid ^= Pvid
      251 	then do;
      252 		Code = error_table_$pvid_not_found;
      253 		return;
      254 	     end;
      255 	if ^pvte.used | ^pvte.storage_system | (pvte.scavenger_block_rel ^= ""b)
      256 	then do;
      257 		Code = error_table_$pv_no_scavenge;
      258 		return;
      259 	     end;
      260 
      261 	call lock$lock_fast (addr (scavenger_data.lock));
      262 
      263      end SETUP_LOCK;
      264 
      265 /*  Internal Procedure to get a process table entry and fill it in */
      266 
      267 SETUP_PROCESS_TABLE:
      268      proc (Process_Index, Code);
      269 
      270 dcl	Process_Index	fixed bin;
      271 dcl	Code		fixed bin (35);
      272 
      273 dcl	n_header_pages	fixed bin;
      274 dcl	procx		fixed bin;
      275 
      276 	Process_Index = -1;
      277 	Code = 0;
      278 
      279 	sc_process_tablep = scavenger_data.process_table_ptr;
      280 	if sc_process_table.n_processes >= sc_process_table.max_n_processes
      281 	then do;
      282 RETURN_ERROR:
      283 		sc_process_tablep = null ();
      284 		Code = error_table_$scavenge_process_limit;
      285 		return;
      286 	     end;
      287 
      288 	do procx = 1 repeat procx + 1 while (procx <= sc_process_table.max_n_processes);
      289 	     if sc_process_table.process (procx).processid = ""b
      290 	     then goto FOUND_EMPTY;
      291 	end;
      292 	goto RETURN_ERROR;
      293 
      294 FOUND_EMPTY:
      295 	Process_Index = procx;
      296 	sc_process_table.process (procx).processid = pds$processid;
      297 	sc_process_table.process (procx).pvtep = pvtep;
      298 
      299 	sc_process_table.n_processes = sc_process_table.n_processes + 1;
      300 	if sc_process_table.n_processes = 1
      301 	then do;
      302 		n_header_pages = divide (size (scavenger_data) + 1023, 1024, 17);
      303 		call pc_wired$wire_wait (scavenger_data_astep, 0, n_header_pages);
      304 	     end;
      305 
      306 
      307      end SETUP_PROCESS_TABLE;
      308 
      309 /*  Internal Procedure to Allocate and Setup the Scavenge Block  */
      310 
      311 SETUP_BLOCK:
      312      proc (Process_Index);
      313 
      314 dcl	Process_Index	fixed bin;
      315 
      316 dcl	first_page	fixed bin;
      317 dcl	n_pages		fixed bin;
      318 
      319 
      320 	scavenger_n_records = pvte.totrec;
      321 	scavenger_n_ovfl = N_OVFL;
      322 
      323 	first_page = sc_process_table.process (Process_Index).first_block_page;
      324 	n_pages = divide (size (scavenger_block) + 1023, 1024, 17);
      325 
      326 	scavenger_blockp = sc_process_table.process (process_tablex).blockp;
      327 
      328 	scavenger_block.n_records = scavenger_n_records;
      329 	scavenger_block.n_ovfl = scavenger_n_ovfl;
      330 	scavenger_block.ovfl_free_ix = 1;
      331 
      332 	unspec (scavenger_block.records) = ""b;
      333 	unspec (scavenger_block.overflow) = ""b;
      334 
      335 
      336 	call pc_wired$wire_wait (scavenger_data_astep, first_page, n_pages);
      337 
      338 	sc_process_table.process (Process_Index).n_block_pages = n_pages;
      339 
      340      end SETUP_BLOCK;
      341 
      342 /*  Internal Procedure to Revert a Scavenge Block  */
      343 
      344 RETURN_BLOCK:
      345      proc (Process_Index);
      346 
      347 dcl	Process_Index	fixed bin;
      348 
      349 dcl	first_page	fixed bin;
      350 dcl	n_pages		fixed bin;
      351 
      352 
      353 	if sc_process_table.process (Process_Index).processid ^= pds$processid
      354 	then call syserr (CRASH, "scavenger: Invalid block reset");
      355 
      356 	first_page = sc_process_table.process (Process_Index).first_block_page;
      357 	n_pages = sc_process_table.process (Process_Index).n_block_pages;
      358 	call pc_wired$unwire (scavenger_data_astep, first_page, n_pages);
      359 
      360 
      361 
      362      end RETURN_BLOCK;
      363 
      364 /*  Internal Procedure to release a process table entry  */
      365 
      366 RETURN_PROCESS_TABLE:
      367      proc (Process_Index);
      368 
      369 dcl	Process_Index	fixed bin;
      370 dcl	n_header_pages	fixed bin;
      371 
      372 	if sc_process_table.process (Process_Index).processid ^= pds$processid
      373 	then call syserr (CRASH, "scavenger: Process table entry not owned by this process.");
      374 
      375 	sc_process_table.process (Process_Index).processid = ""b;
      376 	sc_process_table.process (Process_Index).pvtep = null ();
      377 	sc_process_table.process (Process_Index).n_block_pages = 0;
      378 
      379 	sc_process_table.n_processes = sc_process_table.n_processes - 1;
      380 	if sc_process_table.n_processes = 0
      381 	then do;
      382 		n_header_pages = divide (size (scavenger_data) + 1023, 1024, 17);
      383 		call pc_wired$unwire (scavenger_data_astep, 0, n_header_pages);
      384 	     end;
      385 
      386 
      387      end RETURN_PROCESS_TABLE;
      388 
      389 /*  Internal Procedure to print an error message and cleanup. Called
      390*    when any conditon is signalled through this frame */
      391 
      392 PRINT_ERROR:
      393      proc (Mcptr, Condition, Coptr, Infoptr, Continue) options (non_quick);
      394 
      395 dcl	Mcptr		ptr;
      396 dcl	Condition		char (*);
      397 dcl	Coptr		ptr;
      398 dcl	Infoptr		ptr;
      399 dcl	Continue		bit (1) aligned;
      400 
      401 dcl	1 auto_fault_msg	aligned like fault_msg;	/* Machine conds and hist regs for logging */
      402 dcl	ssptr		ptr;			/* pointer to signaller stack frame */
      403 
      404 
      405 	if Mcptr ^= null ()
      406 	then do;
      407 		ssptr = addrel (Mcptr, -8);		/* signaller_stack.pad is 8 words long! */
      408 
      409 /* Construct contiguous machine conditions and history registers */
      410 		unspec (auto_fault_msg.mach_cond) = unspec (ssptr -> signaller_stack.mach_cond);
      411 		auto_fault_msg.hist_reg = ssptr -> signaller_stack.history_registers;
      412 
      413 		call syserr$binary (scavenger_data.error_severity, Mcptr, SB_hw_fault, SBL_hw_fault,
      414 		     "scavenger: ^a condition signalled during scavenge of ^a_^a^[^a^;^1s^] by ^a", Condition,
      415 		     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name,
      416 		     pds$process_group_id);
      417 	     end;
      418 	else do;
      419 		call syserr (scavenger_data.error_severity,
      420 		     "scavenger: ^a condition signalled during scavenge of ^a_^a^[^a^;^1s^] by ^a", Condition,
      421 		     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name,
      422 		     pds$process_group_id);
      423 	     end;
      424 
      425 	if sst$astl = pds$processid
      426 	then call lock$unlock_ast;			/* Read-only, safe */
      427 	call verify_lock$condition_nolog (Condition, Mcptr);
      428 						/* Fix other locks */
      429 
      430 	code = error_table_$unexpected_condition;
      431 
      432 	goto LOCK_CLEANUP_RETURN;
      433 
      434      end PRINT_ERROR;
      435 
      436 /*  Internal Procedure to print metering data into the syserr log  */
      437 
      438 PRINT_METERS:
      439      proc;
      440 
      441 dcl	clock_sec		float;
      442 dcl	vcpu_sec		float;
      443 
      444 	vcpu_sec = float (local_sc_meters.vcpu) / 1.0e6;
      445 	clock_sec = float (local_sc_meters.clock_time) / 1.0e6;
      446 
      447 	call syserr (LOG,
      448 	     "scavenger: Meters from scavenge of ^a_^a^[^a^;^1s^]. Clock=^6.1f vcpu=^6.1f pf=^d^/VTOCES: Total=^d Damaged=^d Per-Proc=^d Per-Boot=^d FMDamaged=^d Freed=^d^/Records: Total=^d Pot conflict=^d FMD Conflict = ^d Conflict=^d Lost=^d",
      449 	     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, clock_sec, vcpu_sec,
      450 	     local_sc_meters.pf, local_sc_meters.n_vtoces, local_sc_meters.n_vtoces_damaged,
      451 	     local_sc_meters.n_vtoces_per_proc, local_sc_meters.n_vtoces_per_boot, local_sc_meters.n_vtoces_fmd,
      452 	     local_sc_meters.n_vtoces_freed, local_sc_meters.n_records, local_sc_meters.n_conflicts,
      453 	     local_sc_meters.n_fmd_conflicts, local_sc_meters.n_real_conflicts, local_sc_meters.n_lost_records);
      454 
      455      end PRINT_METERS;
      456 
      457 
  1     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  1     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1     8*     Add the support for subvolumes
  1     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  1    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  1    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  1    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  1    14*     Added inconsistent_dbm bit for determining the status of volume
  1    15*     dumper bit maps.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18      dcl	   pvt$array	      aligned external;
  1    19      dcl	   pvt$max_n_entries      fixed bin external;
  1    20 
  1    21      dcl	   pvt_arrayp	      ptr;
  1    22      dcl	   pvtep		      ptr;
  1    23 
  1    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  1    25 
  1    26      dcl	   1 pvte		      based (pvtep) aligned,
  1    27 
  1    28 	     2 pvid	      bit (36),		/* physical volume ID */
  1    29 
  1    30 	     2 lvid	      bit (36),		/* logical volume ID */
  1    31 
  1    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  1    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  1    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  1    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  1    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  1    37 	     2 pad3	      bit (2) unaligned,
  1    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  1    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  1    40 
  1    41 
  1    42 
  1    43 	     2 devname	      char (4),		/* device name */
  1    44 
  1    45 	     (2 device_type	      fixed bin (8),	/* device type */
  1    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  1    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  1    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  1    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  1    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  1    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  1    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  1    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  1    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  1    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  1    56 	     2 scav_check_address
  1    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  1    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  1    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  1    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  1    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  1    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  1    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  1    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  1    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  1    66 
  1    67 
  1    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  1    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  1    70 
  1    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  1    72 
  1    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  1    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  1    75 
  1    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  1    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  1    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  1    79 	     2 records_per_cyl    fixed bin,
  1    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  1    81 	     2 sv_name            char (2) aligned,
  1    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  1    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  1    84 
  1    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  1    86 	     2 pad2	      bit (18) unaligned,
  1    87 
  1    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  1    89 
  1    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  1    91 
  1    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  1    93 
  1    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  1    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  1    96 
  1    97 
  1    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  1    99 
  1   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  1   101 
  1   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  1   103 
  1   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  1   105 
  1   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  1   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  1   108 
  1   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  1   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  1   111 
  1   112 
  1   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  1   114 	   VOLMAP_ASYNC_READ      init (1),
  1   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  1   116 
  1   117 
  1   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      458 
      459 
  2     1 /*  START OF:	scavenger_data.incl.pl1   November 1982       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* format: style3 */
  2     4 dcl	scavenger_data$	external;
  2     5 
  2     6 dcl	scavenger_datap	ptr;
  2     7 dcl	sc_metersp	ptr;
  2     8 dcl	sc_process_tablep	ptr;
  2     9 dcl	scavenger_blockp	ptr;
  2    10 dcl	record_blockp	ptr;
  2    11 dcl	scavenger_optionsp	ptr;
  2    12 
  2    13 dcl	sc_n_processes	fixed bin;
  2    14 dcl	scavenger_n_records fixed bin;
  2    15 dcl	scavenger_n_ovfl	fixed bin;
  2    16 
  2    17 
  2    18 dcl	1 scavenger_data	aligned based (scavenger_datap),
  2    19 	  2 lock		aligned,			/* Lock on scavenger_data */
  2    20 	    3 lock_word	bit (36) aligned,
  2    21 	    3 wait_event	bit (36) aligned,
  2    22 	    3 notify_sw	bit (1) aligned,
  2    23 	  2 process_table_ptr
  2    24 			ptr,			/* Pointer to scavenger process table */
  2    25 	  2 error_severity	fixed bin,		/* Severity of unexpected error condition */
  2    26 	  2 meters	aligned like sc_meters,
  2    27 	  2 free		bit (1) aligned;		/* Available region */
  2    28 
  2    29 
  2    30 dcl	1 sc_meters	aligned based (sc_metersp),	/* Meters */
  2    31 	  2 n_scavenge	fixed bin (35),		/* Number of volume scavenges */
  2    32 	  2 pf		fixed bin (35),		/* Total page faults */
  2    33 	  2 vcpu		fixed bin (71),		/* Total virtual CPU time */
  2    34 	  2 clock_time	fixed bin (71),		/* Total clock time */
  2    35 	  2 n_vtoces	fixed bin (35),		/* Number VTOCEs examined */
  2    36 	  2 n_vtoces_damaged
  2    37 			fixed bin (35),		/* Number VTOCEs damaged by scavenge */
  2    38 	  2 n_vtoces_per_proc
  2    39 			fixed bin (35),		/* Number per-process VTOCEs freed */
  2    40 	  2 n_vtoces_per_boot
  2    41 			fixed bin (35),		/* Number per-bootload VTOCEs freed */
  2    42 	  2 n_vtoces_freed	fixed bin (35),		/* Total number VTOCEs freed */
  2    43 	  2 n_vtoces_fmd	fixed bin (35),		/* Number VTOCEs with fm_damaged reset */
  2    44 	  2 n_records	fixed bin (35),		/* Number non-null filemap entries examined */
  2    45 	  2 n_conflicts	fixed bin (35),		/* Number potential conflicts detected */
  2    46 	  2 n_fmd_conflicts fixed bin (35),		/* Number potential conflicts due to fm_damaged */
  2    47 	  2 n_real_conflicts
  2    48 			fixed bin (35),		/* Number real conflicts */
  2    49 	  2 n_lost_records	fixed bin (35);		/* Number lost records freed */
  2    50 
  2    51 
  2    52 dcl	1 sc_process_table	aligned based (sc_process_tablep),
  2    53 	  2 max_n_processes fixed bin,		/* Number of table entries */
  2    54 	  2 n_processes	fixed bin,		/* Number active entries */
  2    55 	  2 process	(sc_n_processes refer (sc_process_table.max_n_processes)) aligned,
  2    56 	    3 processid	bit (36) aligned,		/* Owner. 0=>empty */
  2    57 	    3 pvtep	ptr unal,			/* PVTE of volume being scavenged */
  2    58 	    3 blockp	ptr unal,			/* Block w/i scavenger_data */
  2    59 	    3 first_block_page
  2    60 			fixed bin,		/* Index of first page of block */
  2    61 	    3 n_block_pages fixed bin;		/* Number of pages in block */
  2    62 
  2    63 
  2    64 dcl	1 scavenger_block	aligned based (scavenger_blockp),
  2    65 	  2 n_records	fixed bin,		/* Number of record addresses */
  2    66 	  2 n_ovfl	fixed bin,		/* Number of overflow blocks */
  2    67 	  2 ovfl_free_ix	fixed bin,		/* Index of first free overflow block */
  2    68 	  2 records	(scavenger_n_records refer (scavenger_block.n_records)) aligned like record_block,
  2    69 	  2 overflow	(scavenger_n_ovfl refer (scavenger_block.n_ovfl)) aligned like record_block;
  2    70 
  2    71 
  2    72 dcl	1 record_block	aligned based (record_blockp),/* One per record address */
  2    73 	  2 vtocx		fixed bin (15) uns unal,	/* Owning VTOCE index */
  2    74 	  2 pageno	fixed bin (8) uns unal,	/* Owning page number */
  2    75 	  2 state		fixed bin (2) uns unal,	/* State */
  2    76 	  2 lock		bit (1) unal,		/* Lock bit on this block */
  2    77 	  2 ovflx		fixed bin (10) uns unal;	/* Index of first overflow block on chain */
  2    78 
  2    79 dcl	1 scavenger_data_pages
  2    80 			aligned based (scavenger_datap),
  2    81 	  2 page		(0:255) aligned,
  2    82 	    3 word	(1024) bit (36) aligned;
  2    83 
  2    84 dcl	1 scavenger_options aligned based (scavenger_optionsp),
  2    85 	  2 print_meters	bit (1) unaligned,		/* ON => meter each scavenge into the log */
  2    86 	  2 debug		bit (1) unaligned,		/* ON => do special debugging things */
  2    87 	  2 dump		bit (1) unaligned,		/* ON => dump bad VTOCEs into syserr log */
  2    88 	  2 trap		bit (1) unaligned,		/* ON => trap to BOS for debug */
  2    89 	  2 no_optimize	bit (1) unaligned,		/* ON => no VTOCE read-ahead */
  2    90 	  2 fault_under_ast bit (1) unaligned,		/* ON => fault under AST lock, benign */
  2    91 	  2 fault_under_volmap bit (1) unaligned,	/* ON => fault under volmap lock, benign */
  2    92 	  2 fault_under_pt bit (1) unaligned;		/* ON => fault inder PTL, NOT BENIGN */
  2    93 
  2    94 dcl	(
  2    95 	STATE_UNSEEN	init (0),
  2    96 	STATE_FREE	init (1),
  2    97 	STATE_IN_USE	init (2),
  2    98 	STATE_CONFLICT	init (3)
  2    99 	)		fixed bin int static options (constant);
  2   100 
  2   101 
  2   102 
  2   103 
  2   104 /*  END OF:	scavenger_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      460 
      461 
  3     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  3     2 
  3     3 /* This include file has an ALM version, keep 'em in sync. */
  3     4 
  3     5 /* format: off */
  3     6 
  3     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  3     8*   to be examined by display_cpu_error. */
  3     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  3    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  3    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  3    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  3    13*		also changed some codes to "SB_unused_NN" - see line comments */
  3    14 
  3    15 /* In the future, these will be the only constants needed in this include
  3    16*file.  They are the binary data class strings for messages in the new format
  3    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  3    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  3    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  3    20 
  3    21 dcl (						/* include file name */
  3    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  3    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  3    24 SB_mos_data_class		init ("mos"),		/* scr */
  3    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  3    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  3    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  3    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  3    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  3    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  3    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  3    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  3    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  3    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  3    35 ) static internal char (16) varying options (constant);
  3    36 
  3    37 
  3    38 /************************
  3    39*Once the syserr$binary is replaced with something that takes real data classes
  3    40*and all system modules and tools are upgraded to use the new interface, the
  3    41*rest of this include file may be discarded.
  3    42*************************/
  3    43 
  3    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  3    45*   extended at any time. */
  3    46 
  3    47 dcl (
  3    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  3    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  3    50 SB_io_err		init (3),		SBL_io_err	init (5),
  3    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  3    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  3    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  3    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  3    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  3    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  3    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  3    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  3    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  3    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  3    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  3    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  3    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  3    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  3    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  3    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  3    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  3    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  3    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  3    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  3    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  3    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  3    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  3    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  3    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  3    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  3    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  3    78   ) internal static options (constant) fixed bin;
  3    79 
  3    80 
  3    81 /* The following array is a mapping of the old syserr$binary codes into the
  3    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  3    83*the binary data codes stored in the wired syserr log (see above) into the data
  3    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  3    85*is also used by syserr_log_util_ to translate the data classes back into the
  3    86*corresponding binary code (for tools not yet upgraded to deal with the new
  3    87*format log messages). */
  3    88 
  3    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  3    90 	init (	"io_status",		/* 1 */
  3    91 		"hwfault",		/* 2 */
  3    92 		"io_status",		/* 3 */
  3    93 		"unused_4",		/* 4 */
  3    94 		"mos",			/* 5 */
  3    95 
  3    96 		"unused_6",		/* 6 */
  3    97 		"unused_7",		/* 7 */
  3    98 		"unused_8",		/* 8 */
  3    99 		"unused_9",		/* 9 */ 
  3   100 		"unused_10",		/* 10 */
  3   101 
  3   102 		"segdamage",		/* 11 */
  3   103 		"unused_12",		/* 12 */
  3   104 		"segdamage",		/* 13 */
  3   105 		"unused_14",		/* 14 */
  3   106 		"unused_15",		/* 15 */
  3   107 
  3   108 		"segdamage",		/* 16 */
  3   109 		"voldamage",		/* 17 */
  3   110 		"unused_18",		/* 18 */
  3   111 		"mdc_del_uidpath",		/* 19 */
  3   112 		"io_status",		/* 20 */
  3   113 
  3   114 		"mmdam",			/* 21 */
  3   115 		"hwfault",		/* 22 */
  3   116 		"io_status",		/* 23 */
  3   117 		"mpc_poll",		/* 24 */
  3   118 		"fnp_poll",		/* 25 */
  3   119 
  3   120 		"config_deck",		/* 26 */
  3   121 		"vtoce",			/* 27 */
  3   122 		"access_audit",		/* 28 */
  3   123 		"unused_29",		/* 29 */
  3   124 		"unused_30",		/* 30 */
  3   125 		"unused_31",		/* 31 */
  3   126 		"unused_32",		/* 32 */
  3   127 		"unused_33",		/* 33 */
  3   128 		"unused_34",		/* 34 */
  3   129 		"ibm3270_mde",		/* 35 */
  3   130 		"unused_36"		/* 36 */
  3   131 	);
  3   132 
  3   133 
  3   134 /* format: on */
  3   135 
  3   136 /* These constants are used by various tools which analyze syserr messages and
  3   137*still call the old interface "syserr_log_util_". */
  3   138 
  3   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  3   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  3   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  3   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  3   143 
  3   144      dcl	   display_cpu_error_binary_defs (2) init (
  3   145 			      2,			/** SB_hw_fault */
  3   146 			      22			/** SB_verify_lock */
  3   147 			      ) internal static options (constant) fixed bin;
  3   148 
  3   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      462 
      463 
  4     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      464 
      465 
  5     1 
  5     2 /* Begin include file ...... syserr_fault_msg.incl.pl1
  5     3*	Modified 1985-02-21, EJ Sharpe: changed mach_cond to be "like mc"
  5     4*	Modified 8/12/76 by Noel I. Morris	*/
  5     5 
  5     6 
  5     7 /* This include file defines the format of the syserr message
  5     8*   generated on faults handled by various modules.
  5     9*NOTE: program must also include "mc". */
  5    10 
  5    11 dcl  fmsgp ptr;					/* pointer to structure */
  5    12 
  5    13 dcl 1 fault_msg based (fmsgp) aligned,
  5    14     2 mach_cond like mc,				/* machine conditions */
  5    15     2 hist_reg (0:127) bit (36);			/* history registers */
  5    16 		/* someday the hist_reg should be increased to 256 wds to accomodate all DPS8 data */
  5    17 
  5    18 /* End of include file ...... syserr_fault_msg.incl.pl1 */
  5    19 
      466 
      467 
  6     1 /*  */
  6     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  6     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  6     4 /* Modified 07/07/76 by Morris for fault register data */
  6     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  6     6 /* Modified '82 to make values constant */
  6     7 
  6     8 /* words 0-15 pointer registers */
  6     9 
  6    10 dcl  mcp ptr;
  6    11 
  6    12 dcl 1 mc based (mcp) aligned,
  6    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  6    14    (2 regs,					/* registers */
  6    15       3 x (0:7) bit (18),				/* index registers */
  6    16       3 a bit (36),					/* accumulator */
  6    17       3 q bit (36),					/* q-register */
  6    18       3 e bit (8),					/* exponent */
  6    19       3 pad1 bit (28),
  6    20       3 t bit (27),					/* timer register */
  6    21       3 pad2 bit (6),
  6    22       3 ralr bit (3),				/* ring alarm register */
  6    23 
  6    24     2 scu (0:7) bit (36),
  6    25 
  6    26     2 mask bit (72),				/* mem controller mask at time of fault */
  6    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  6    28     2 errcode fixed bin (35),				/* fault handler's error code */
  6    29     2 fim_temp,
  6    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  6    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  6    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  6    33     2 fault_reg bit (36),				/* fault register */
  6    34     2 pad2 bit (1),
  6    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  6    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  6    37     2 fault_time bit (54),				/* time of fault */
  6    38 
  6    39     2 eis_info (0:7) bit (36)) unaligned;
  6    40 
  6    41 
  6    42 dcl (apx fixed bin init (0),
  6    43      abx fixed bin init (1),
  6    44      bpx fixed bin init (2),
  6    45      bbx fixed bin init (3),
  6    46      lpx fixed bin init (4),
  6    47      lbx fixed bin init (5),
  6    48      spx fixed bin init (6),
  6    49      sbx fixed bin init (7)) internal static options (constant);
  6    50 
  6    51 
  6    52 
  6    53 
  6    54 dcl  scup ptr;
  6    55 
  6    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  6    57 
  6    58 
  6    59 /*	WORD (0)		*/
  6    60 
  6    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  6    62       3 prr bit (3),				/* procedure ring register */
  6    63       3 psr bit (15),				/* procedure segment register */
  6    64       3 p bit (1),					/* procedure privileged bit */
  6    65 
  6    66     2 apu,					/* APPENDING UNIT STATUS */
  6    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  6    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  6    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  6    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  6    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  6    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  6    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  6    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  6    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  6    76       3 ptw bit (1),				/* Fetch of PTW */
  6    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  6    78       3 fap bit (1),				/* Fetch of final address paged */
  6    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  6    80       3 fabs bit (1),				/* Fetch of final address absolute */
  6    81 
  6    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  6    83 
  6    84 
  6    85 /*	WORD (1)		*/
  6    86 
  6    87     2 fd,						/* FAULT  DATA */
  6    88       3 iro bit (1),				/* illegal ring order */
  6    89       3 oeb bit (1),				/* out of execute bracket */
  6    90       3 e_off bit (1),				/* no execute */
  6    91       3 orb bit (1),				/* out of read bracket */
  6    92       3 r_off bit (1),				/* no read */
  6    93       3 owb bit (1),				/* out of write bracket */
  6    94       3 w_off bit (1),				/* no write */
  6    95       3 no_ga bit (1),				/* not a gate */
  6    96       3 ocb bit (1),				/* out of call bracket */
  6    97       3 ocall bit (1),				/* outward call */
  6    98       3 boc bit (1),				/* bad outward call */
  6    99       3 inret bit (1),				/* inward return */
  6   100       3 crt bit (1),				/* cross ring transfer */
  6   101       3 ralr bit (1),				/* ring alarm register */
  6   102       3 am_er bit (1),				/* associative memory fault */
  6   103       3 oosb bit (1),				/* out of segment bounds */
  6   104       3 paru bit (1),				/* processor parity upper */
  6   105       3 parl bit (1),				/* processor parity lower */
  6   106       3 onc_1 bit (1),				/* op not complete type 1 */
  6   107       3 onc_2 bit (1),				/* op not complete type 2 */
  6   108 
  6   109     2 port_stat,					/* PORT  STATUS */
  6   110       3 ial bit (4),				/* illegal action lines */
  6   111       3 iac bit (3),				/* illegal action channel */
  6   112       3 con_chan bit (3),				/* connect channel */
  6   113 
  6   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  6   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  6   116 
  6   117 
  6   118 /*	WORD (2)		*/
  6   119 
  6   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  6   121       3 trr bit (3),				/* temporary ring register */
  6   122       3 tsr bit (15),				/* temporary segment register */
  6   123 
  6   124     2 pad2 bit (9),
  6   125 
  6   126     2 cpu_no bit (3),				/* CPU number */
  6   127 
  6   128     2 delta bit (6),				/* tally modification DELTA */
  6   129 
  6   130 
  6   131 /*	WORD (3)		*/
  6   132 
  6   133     2 word3 bit (18),
  6   134 
  6   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  6   136       3 tsna,					/* Word 1 status */
  6   137         4 prn bit (3),				/* Word 1  PR  number */
  6   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  6   139       3 tsnb,					/* Word 2  status */
  6   140         4 prn bit (3),				/* Word 2  PR  number */
  6   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  6   142       3 tsnc,					/* Word 3  status */
  6   143         4 prn bit (3),				/* Word 3  PR  number */
  6   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  6   145 
  6   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  6   147 
  6   148 
  6   149 /* 	WORD (4)		*/
  6   150 
  6   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  6   152 
  6   153     2 ir,						/* INDICATOR  REGISTERS */
  6   154       3 zero bit (1),				/* zero indicator */
  6   155       3 neg bit (1),				/* negative indicator */
  6   156       3 carry bit (1),				/* carryry indicator */
  6   157       3 ovfl bit (1),				/* overflow indicator */
  6   158       3 eovf bit (1),				/* eponent overflow */
  6   159       3 eufl bit (1),				/* exponent underflow */
  6   160       3 oflm bit (1),				/* overflow mask */
  6   161       3 tro bit (1),				/* tally runout */
  6   162       3 par bit (1),				/* parity error */
  6   163       3 parm bit (1),				/* parity mask */
  6   164       3 bm bit (1),					/* ^bar mode */
  6   165       3 tru bit (1),				/* truncation mode */
  6   166       3 mif bit (1),				/* multi-word instruction mode */
  6   167       3 abs bit (1),				/* absolute mode */
  6   168       3 hex bit (1),				/* hexadecimal exponent mode */
  6   169       3 pad bit (3),
  6   170 
  6   171 
  6   172 /*	WORD (5)		*/
  6   173 
  6   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  6   175 
  6   176     2 cu,						/* CONTROL UNIT STATUS */
  6   177       3 rf bit (1),					/* on first cycle of repeat instr */
  6   178       3 rpt bit (1),				/* repeat instruction */
  6   179       3 rd bit (1),					/* repeat double instruction */
  6   180       3 rl bit (1),					/* repeat link instruciton */
  6   181       3 pot bit (1),				/* IT  modification */
  6   182       3 pon bit (1),				/* return type instruction */
  6   183       3 xde bit (1),				/* XDE from Even location */
  6   184       3 xdo bit (1),				/* XDE from Odd  location */
  6   185       3 poa bit (1),				/* operation preparation */
  6   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  6   187       3 its bit (1),				/* ITS modification */
  6   188       3 if bit (1),					/* fault occured during instruction fetch */
  6   189 
  6   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  6   191 
  6   192 
  6   193 /*	WORDS (6,7)	*/
  6   194 
  6   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  6   196 
  6   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  6   198 
  6   199 
  6   200 
  6   201 
  6   202 
  6   203 
  6   204 /*	ALTERNATE   SCU  DECLARATION		*/
  6   205 
  6   206 
  6   207 dcl 1 scux based (scup) aligned,
  6   208 
  6   209    (2 pad0 bit (36),
  6   210 
  6   211     2 fd,						/* GROUP II  FAULT DATA */
  6   212       3 isn bit (1),				/* illegal segment number */
  6   213       3 ioc bit (1),				/* illegal op  code  */
  6   214       3 ia_am bit (1),				/* illegal address - modifier */
  6   215       3 isp bit (1),				/* illegal slave  procedure */
  6   216       3 ipr bit (1),				/* illegal procedure */
  6   217       3 nea bit (1),				/* non existent address */
  6   218       3 oobb bit (1),				/* out of bounds */
  6   219       3 pad bit (29),
  6   220 
  6   221     2 pad2 bit (36),
  6   222 
  6   223     2 pad3a bit (18),
  6   224 
  6   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  6   226       3 prn bit (3),				/* PR  number */
  6   227       3 prv bit (1),				/* PR  valid bit */
  6   228 
  6   229     2 pad3b bit (6)) unaligned,
  6   230 
  6   231     2 pad45 (0:1) bit (36),
  6   232 
  6   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  6   234 
  6   235 
  6   236 
  6   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      468 
      469 
  7     1 /*	BEGIN INCLUDE FILE ... signaller_stack.incl.pl1 ... Created Feb 79 by D.Spector */
  7     2 
  7     3 /*	This file matches signaller_stack.incl.alm and is currently used only by verify_lock */
  7     4 
  7     5 declare	1 signaller_stack based unaligned,
  7     6 	  2 pad (8) bit (36),		/* Make machine conditions 0 mod 16 */
  7     7 	  2 mach_cond (48) bit (36),		/* Machine conditions */
  7     8 	  2 mc_ptr ptr aligned,		/* Pointer to machine conditions */
  7     9 	  2 null_ptr ptr aligned,		/* Null pointer */
  7    10 	  2 string_descriptor bit (36),	/* Condition name descriptor */
  7    11 	  2 ptr_descriptor bit (36),		/* M.C. ptr descriptor */
  7    12 	  2 arglist (18) bit (36),		/* Arg list for call to signal */
  7    13 	  2 signal_string char (32),		/* Condition name */
  7    14 	  2 on_unit (16) bit (36),		/* Must be at 128 in stack frame */
  7    15 	  2 history_registers (128) bit (36);
  7    16 
  7    17 /* on_unit must start at 128 because trap_caller_caller_ sets up a stack frame
  7    18*   assuming this to be so.  Similarly mach_cond must start at 48. */
  7    19 
  7    20 /*	END INCLUDE FILE ... signaller_stack.incl.pl1 ... */
      470 
      471 
      472 /* BEGIN MESSAGE DOCUMENTATION
      473*
      474*
      475*Message:
      476*scavenger: Begin scavenge of dskX_NN{s} by PERSON.PROJECT.TAG
      477*
      478*S:        $info
      479*
      480*T:        When a physical volume is being scavenged
      481*
      482*M:        This is an informational message at the beginning of a volume
      483*scavenge.
      484*
      485*A:        $ignore
      486*
      487*
      488*Message:
      489*scavenger: Scavenge of dskX_NN{s} by PERSON.PROJECT.TAG completed. 
      490*
      491*S:        $info
      492*
      493*T:        When a physical volume is being scavenged.
      494*
      495*M:        This is an informational message to indicate successful completion
      496*of a scavenge.
      497*
      498*A:        $ignore
      499*
      500*
      501*Message:
      502*scavenger: Scavenge of dskX_NN{s} by PERSON.PROJECT.TAG completed with error. ERRORMESSAGE.
      503*
      504*S:        $info
      505*
      506*T:	When a physical volume is being scavenged.
      507*
      508*M:        Scavenging could not be completed because of the error indicated.
      509*
      510*A:        $inform
      511*
      512*
      513*Message:
      514*scavenger: Invalid block reset.
      515*
      516*S:        $crash
      517*
      518*T:        When a physical volume is being scavenged.
      519*
      520*M:        A process attempted to clean up a scavenger block which was not
      521*assigned to it. This indicates a software malfunction.
      522*
      523*A:        $recover
      524*
      525*
      526*Message:
      527*scavenger: Process table entry not owned by this process.
      528*
      529*S:        $crash
      530*
      531*T:        When a physical volume is being scavenged.
      532*
      533*M:        The scavenger attempted to release a process table entry which did not
      534*belong to this process. This indicates a software malfunction.
      535*
      536*A:        $recover
      537*
      538*
      539*Message:
      540*scavenger: XXXXXX condition signalled during scavenge of dskX_NN{s} by PERSON.PROJECT.TAG
      541*
      542*S:        $info
      543*
      544*T:        When a physical volume is being scavenged.
      545*
      546*M:        An unexpected XXXXXX condition was signalled during a volume
      547*scavenge, causing abnormal termination of the scavenge.
      548*
      549*A:        $inform
      550*
      551*
      552*Message:
      553*scavenger: Meters from scavenge of dskX_NN{s}. METERINGDATA.
      554*
      555*S:        $log
      556*
      557*T:        When a physical volume is being scavenged.
      558*
      559*M:        Various peformance measurements of the scavenge are recorded if
      560*the appropriate scavenger control flag is set. 
      561*
      562*A:        $ignore
      563*
      564*Message:
      565*scavenger: Scavenge of dskX_NN{s} stopped.
      566*
      567*S:	$info
      568*
      569*T:	During system shutdown.
      570*
      571*M:	The system is being shutdown, and a scavenge of dskX_NN{s} is
      572*in progress. The scavenge is terminated and likely had no effect. 
      573*
      574*A:        Rerun the scavenge.
      575*
      576*
      577*END MESSAGE DOCUMENTATION */
      578 
      579      end scavenger;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1116.9  scavenger.pl1                     >udd>sm>ds>w>ml>scavenger.pl1
458          1    07/21/88  2136.0  pvte.incl.pl1                     >ldd>incl>pvte.incl.pl1
460          2    02/27/84  1241.4  scavenger_data.incl.pl1           >ldd>incl>scavenger_data.incl.pl1
462          3    03/15/85  1053.1  syserr_binary_def.incl.pl1        >ldd>incl>syserr_binary_def.incl.pl1
464          4    05/17/85  0715.7  syserr_constants.incl.pl1         >ldd>incl>syserr_constants.incl.pl1
466          5    03/15/85  1053.1  syserr_fault_msg.incl.pl1         >ldd>incl>syserr_fault_msg.incl.pl1
468          6    12/15/83  1200.4  mc.incl.pl1                       >ldd>incl>mc.incl.pl1
470          7    03/08/79  1815.0  signaller_stack.incl.pl1          >ldd>incl>signaller_stack.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000023 constant        fixed bin(17,0)          initial dcl 4-7 set ref 153* 196* 199* 226*
CRASH                           000031 constant        fixed bin(17,0)          initial dcl 4-7 set ref 353* 372*
Code                                   parameter       fixed bin(35,0)          dcl 271 in procedure "SETUP_PROCESS_TABLE" set ref
                                                                                  267 277* 284*
Code                                   parameter       fixed bin(35,0)          dcl 44 in procedure "scavenger" set ref 12 135* 136
                                                                                  207*
Code                                   parameter       fixed bin(35,0)          dcl 240 in procedure "SETUP_LOCK" set ref 237 248*
                                                                                  252* 257*
Condition                              parameter       char                     packed unaligned dcl 396 set ref 392 413* 419* 427*
Continue                               parameter       bit(1)                   dcl 399 ref 392
Coptr                                  parameter       pointer                  dcl 397 ref 392
Infoptr                                parameter       pointer                  dcl 398 ref 392
LOG                             000025 constant        fixed bin(17,0)          initial dcl 4-7 set ref 447*
Mcptr                                  parameter       pointer                  dcl 395 set ref 392 405 407 413* 427*
N_OVFL                                 constant        fixed bin(17,0)          initial dcl 68 ref 321
Process_Index                          parameter       fixed bin(17,0)          dcl 270 in procedure "SETUP_PROCESS_TABLE" set ref
                                                                                  267 276* 294*
Process_Index                          parameter       fixed bin(17,0)          dcl 314 in procedure "SETUP_BLOCK" ref 311 323 338
Process_Index                          parameter       fixed bin(17,0)          dcl 369 in procedure "RETURN_PROCESS_TABLE" ref 366
                                                                                  372 375 376 377
Process_Index                          parameter       fixed bin(17,0)          dcl 347 in procedure "RETURN_BLOCK" ref 344 353 356
                                                                                  357
Pvid                                   parameter       bit(36)                  dcl 41 ref 12 250
Pvtx                                   parameter       fixed bin(17,0)          dcl 40 ref 12 246
SBL_hw_fault                    000000 constant        fixed bin(17,0)          initial dcl 3-47 set ref 413*
SB_hw_fault                     000027 constant        fixed bin(17,0)          initial dcl 3-47 set ref 413*
Sc_meters                              based           structure                level 1 dcl 73 set ref 204*
Sc_metersp                             parameter       pointer                  dcl 43 ref 12 204 204
Scavenger_Options                      based           structure                level 1 dcl 74 ref 133
Scavenger_Optionsp                     parameter       pointer                  dcl 42 ref 12 133
addr                                                   builtin function         dcl 116 ref 146 146 158 158 158 158 160 160 192 192
                                                                                  215 242 245 246 261 261
addrel                                                 builtin function         dcl 117 ref 407
auto_fault_msg                  000100 automatic       structure                level 1 dcl 401
baseno                                                 builtin function         dcl 118 ref 247 247
begin_clock                     000100 automatic       fixed bin(71,0)          dcl 48 set ref 149* 173
begin_pf                        000102 automatic       fixed bin(17,0)          dcl 49 set ref 148* 171
begin_vcpu                      000104 automatic       fixed bin(71,0)          dcl 50 set ref 148* 172
bin                                                    builtin function         dcl 119 ref 247 247
blockp                    4            based           pointer                  array level 3 packed packed unaligned dcl 2-52 ref
                                                                                  326
clock                                                  builtin function         dcl 120 ref 149 173
clock_sec                       000242 automatic       float bin(27)            dcl 441 set ref 445* 447*
clock_time                4     000114 automatic       fixed bin(71,0)          level 2 dcl 55 set ref 173* 445
code                            000106 automatic       fixed bin(35,0)          dcl 51 set ref 139* 140 158* 167 196 199* 207 430*
condition_                      000026 constant        entry                    external dcl 93 ref 151
convert                                                builtin function         dcl 121 ref 153 153 196 196 199 199 226 226 413 413
                                                                                  419 419 447 447
deposit_to_volmap         4(28)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  183* 223*
devname                   3            based           char(4)                  level 2 dcl 1-26 set ref 153* 196* 199* 226* 413*
                                                                                  419* 447*
divide                                                 builtin function         dcl 122 ref 302 324 382
end_pf                          000107 automatic       fixed bin(17,0)          dcl 52 set ref 169* 171
end_vcpu                        000110 automatic       fixed bin(71,0)          dcl 53 set ref 169* 172
error_severity            6            based           fixed bin(17,0)          level 2 dcl 2-18 set ref 413* 419*
error_table_$pv_no_scavenge     000016 external static fixed bin(35,0)          dcl 84 ref 257
error_table_$pvid_not_found     000010 external static fixed bin(35,0)          dcl 78 ref 252
error_table_$scavenge_process_limit
                                000014 external static fixed bin(35,0)          dcl 82 ref 284
error_table_$unexpected_condition
                                000012 external static fixed bin(35,0)          dcl 80 ref 430
fault_msg                              based           structure                level 1 dcl 5-13
first_block_page          5            based           fixed bin(17,0)          array level 3 dcl 2-52 ref 323 356
first_page                      000222 automatic       fixed bin(17,0)          dcl 349 in procedure "RETURN_BLOCK" set ref 356*
                                                                                  358*
first_page                      000212 automatic       fixed bin(17,0)          dcl 316 in procedure "SETUP_BLOCK" set ref 323* 336*
float                                                  builtin function         dcl 123 ref 444 445
get_ptrs_$given_segno           000030 constant        entry                    external dcl 94 ref 247
hist_reg                 60     000100 automatic       bit(36)                  array level 2 dcl 401 set ref 411*
history_registers       150            based           bit(36)                  array level 2 packed packed unaligned dcl 7-5 ref
                                                                                  411
i_am_wired                      000112 automatic       bit(1)                   dcl 54 set ref 130* 157* 163
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  153* 196* 199* 226* 413* 419* 447*
local_sc_meters                 000114 automatic       structure                level 1 dcl 55 set ref 132* 158 158 176 204
local_scavenger_options         000135 automatic       structure                level 1 dcl 56 set ref 133* 158 158
lock                                   based           structure                level 2 dcl 2-18 set ref 146 146 160 160 192 192 261
                                                                                  261
lock$lock_ast                   000032 constant        entry                    external dcl 96 ref 179
lock$lock_fast                  000034 constant        entry                    external dcl 97 ref 160 261
lock$unlock_ast                 000036 constant        entry                    external dcl 98 ref 185 425
lock$unlock_fast                000040 constant        entry                    external dcl 99 ref 146 192
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1-26 ref 153 153
                                                                                  196 196 199 199 226 226 413 413 419 419 447 447
mach_cond                       000100 automatic       structure                level 2 in structure "auto_fault_msg" dcl 401
                                                                                  in procedure "PRINT_ERROR" set ref 410*
mach_cond                10            based           bit(36)                  array level 2 in structure "signaller_stack" packed
                                                                                  packed unaligned dcl 7-5 in procedure "scavenger"
                                                                                  ref 410
max_n_processes                        based           fixed bin(17,0)          level 2 dcl 2-52 ref 218 280 288
mc                                     based           structure                level 1 dcl 6-12
meters                   10            based           structure                level 2 dcl 2-18 set ref 176* 176
n_block_pages             6            based           fixed bin(17,0)          array level 3 dcl 2-52 set ref 338* 357 377*
n_conflicts              15     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_fmd_conflicts          16     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_header_pages                  000232 automatic       fixed bin(17,0)          dcl 370 in procedure "RETURN_PROCESS_TABLE" set ref
                                                                                  382* 383*
n_header_pages                  000202 automatic       fixed bin(17,0)          dcl 273 in procedure "SETUP_PROCESS_TABLE" set ref
                                                                                  302* 303*
n_lost_records           20     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_ovfl                    1            based           fixed bin(17,0)          level 2 dcl 2-64 set ref 329* 333
n_pages                         000223 automatic       fixed bin(17,0)          dcl 350 in procedure "RETURN_BLOCK" set ref 357*
                                                                                  358*
n_pages                         000213 automatic       fixed bin(17,0)          dcl 317 in procedure "SETUP_BLOCK" set ref 324* 336*
                                                                                  338
n_processes               1            based           fixed bin(17,0)          level 2 dcl 2-52 set ref 280 299* 299 300 379* 379
                                                                                  380
n_real_conflicts         17     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_records                              based           fixed bin(17,0)          level 2 in structure "scavenger_block" dcl 2-64
                                                                                  in procedure "scavenger" set ref 328* 332 333
n_records                14     000114 automatic       fixed bin(35,0)          level 2 in structure "local_sc_meters" dcl 55
                                                                                  in procedure "scavenger" set ref 447*
n_scavenge                      000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 170*
n_vtoces                  6     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_vtoces_damaged          7     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_vtoces_fmd             13     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_vtoces_freed           12     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_vtoces_per_boot        11     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
n_vtoces_per_proc        10     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 447*
null                                                   builtin function         dcl 124 ref 187 189 204 243 244 282 376 405
old_mask                        000136 automatic       fixed bin(71,0)          dcl 59 set ref 180* 184*
overflow                               based           structure                array level 2 dcl 2-64 set ref 333*
ovfl_free_ix              2            based           fixed bin(17,0)          level 2 dcl 2-64 set ref 330*
p99                                    automatic       picture(2)               packed unaligned dcl 58 ref 153 153 196 196 199 199
                                                                                  226 226 413 413 419 419 447 447
pc_wired$unwire                 000044 constant        entry                    external dcl 101 ref 358 383
pc_wired$wire_wait              000042 constant        entry                    external dcl 100 ref 303 336
pds$process_group_id            000020 external static char(32)                 dcl 86 set ref 153* 196* 199* 413* 419*
pds$processid                   000022 external static bit(36)                  dcl 88 ref 296 353 372 425
pf                        1     000114 automatic       fixed bin(35,0)          level 2 dcl 55 set ref 171* 447*
pmut$lock_ptl                   000046 constant        entry                    external dcl 102 ref 180
pmut$unlock_ptl                 000050 constant        entry                    external dcl 103 ref 184
print_meters                    000135 automatic       bit(1)                   level 2 packed packed unaligned dcl 56 set ref 174
process                   2            based           structure                array level 2 dcl 2-52
process_table_ptr         4            based           pointer                  level 2 dcl 2-18 ref 216 279
process_tablex                  000140 automatic       fixed bin(17,0)          dcl 60 set ref 139* 143* 187* 189* 218* 219 222* 326
processid                 2            based           bit(36)                  array level 3 dcl 2-52 set ref 219 289 296* 353 372
                                                                                  375*
procx                           000203 automatic       fixed bin(17,0)          dcl 274 set ref 288* 288* 289* 291 294 296 297
ptwp                            000142 automatic       pointer                  dcl 61 set ref 180* 184*
pvid                                   based           bit(36)                  level 2 dcl 1-26 ref 250
pvt$array                       000072 external static fixed bin(17,0)          dcl 1-18 set ref 245
pvt_array                              based           structure                array level 1 dcl 1-24 set ref 246
pvt_arrayp                      000150 automatic       pointer                  dcl 1-21 set ref 245* 246
pvte                                   based           structure                level 1 dcl 1-26
pvtep                     3            based           pointer                  array level 3 in structure "sc_process_table" packed
                                                                                  packed unaligned dcl 2-52 in procedure "scavenger"
                                                                                  set ref 222 297* 376*
pvtep                           000152 automatic       pointer                  dcl 1-22 in procedure "scavenger" set ref 145 153
                                                                                  153 153 153 153 158* 181 182 183 196 196 196 196
                                                                                  196 199 199 199 199 199 222* 223 224 225 226 226
                                                                                  226 226 226 246* 250 255 255 255 297 320 413 413
                                                                                  413 413 413 419 419 419 419 419 447 447 447 447
                                                                                  447
record_block                           based           structure                level 1 dcl 2-72
records                   3            based           structure                array level 2 dcl 2-64 set ref 332*
rel                                                    builtin function         dcl 125 ref 145
sc_meters                              based           structure                level 1 dcl 2-30
sc_process_table                       based           structure                level 1 dcl 2-52
sc_process_tablep               000156 automatic       pointer                  dcl 2-8 set ref 189 216* 218 219 222 243* 279* 280
                                                                                  280 282* 288 289 296 297 299 299 300 323 326 338
                                                                                  353 356 357 372 375 376 377 379 379 380
scav_check_address        4(27)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  182* 224*
scavenge_volume                 000052 constant        entry                    external dcl 104 ref 158
scavenger_block                        based           structure                level 1 dcl 2-64 set ref 324
scavenger_block_rel      33(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  145* 181* 225* 255
scavenger_blockp                000160 automatic       pointer                  dcl 2-9 set ref 145 158* 187 244* 324 326* 328 329
                                                                                  330 332 333
scavenger_data                         based           structure                level 1 dcl 2-18 set ref 302 382
scavenger_data$                 000074 external static fixed bin(17,0)          dcl 2-4 set ref 215 242
scavenger_data_astep            000144 automatic       pointer                  dcl 62 set ref 247* 303* 336* 358* 383*
scavenger_datap                 000154 automatic       pointer                  dcl 2-6 set ref 146 146 160 160 176 176 192 192 215*
                                                                                  216 242* 247 247 261 261 279 302 382 413 419
scavenger_n_ovfl                000163 automatic       fixed bin(17,0)          dcl 2-15 set ref 321* 324 329
scavenger_n_records             000162 automatic       fixed bin(17,0)          dcl 2-14 set ref 320* 324 328
scavenger_options                      based           structure                level 1 dcl 2-84
signaller_stack                        based           structure                level 1 unaligned dcl 7-5
size                                                   builtin function         dcl 126 ref 302 324 382
ssptr                           000360 automatic       pointer                  dcl 402 set ref 407* 410 411
sst$astl                        000024 external static bit(36)                  dcl 89 ref 425
started                         000146 automatic       bit(1)                   dcl 64 set ref 129* 155* 167 194
storage_system            4(19)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 ref 255
sv_name                  15            based           char(2)                  level 2 dcl 1-26 set ref 153* 196* 199* 226* 413*
                                                                                  419* 447*
syserr                          000054 constant        entry                    external dcl 105 ref 153 196 226 353 372 419 447
syserr$binary                   000056 constant        entry                    external dcl 106 ref 413
syserr$error_code               000060 constant        entry                    external dcl 107 ref 199
totrec                    7(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-26 ref 320
unspec                                                 builtin function         dcl 127 set ref 132* 133* 133 204* 204 332* 333*
                                                                                  410* 410
usage_values                    000062 constant        entry                    external dcl 108 ref 148 169
used                      4(18)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 ref 255
vcpu                      2     000114 automatic       fixed bin(71,0)          level 2 dcl 55 set ref 172* 444
vcpu_sec                        000243 automatic       float bin(27)            dcl 442 set ref 444* 447*
verify_lock$condition_nolog     000064 constant        entry                    external dcl 109 ref 427
wire_proc$unwire_me             000070 constant        entry                    external dcl 112 ref 163
wire_proc$wire_me               000066 constant        entry                    external dcl 111 ref 156

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 4-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 3-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 3-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 3-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 3-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 3-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 3-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 3-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 3-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 3-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 3-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 3-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 3-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 3-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 3-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 3-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 3-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 3-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 3-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 3-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 3-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 3-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 3-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 3-21
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 3-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 3-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 3-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 3-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 3-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 3-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 3-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 3-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 3-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 3-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 3-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 3-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 3-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 3-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 3-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 3-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 3-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 3-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 3-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 3-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 3-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 3-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 3-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 3-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 3-47
STATE_CONFLICT                         internal static fixed bin(17,0)          initial dcl 2-94
STATE_FREE                             internal static fixed bin(17,0)          initial dcl 2-94
STATE_IN_USE                           internal static fixed bin(17,0)          initial dcl 2-94
STATE_UNSEEN                           internal static fixed bin(17,0)          initial dcl 2-94
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 1-113
abx                                    internal static fixed bin(17,0)          initial dcl 6-42
apx                                    internal static fixed bin(17,0)          initial dcl 6-42
bbx                                    internal static fixed bin(17,0)          initial dcl 6-42
bpx                                    internal static fixed bin(17,0)          initial dcl 6-42
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 3-144
fmsgp                                  automatic       pointer                  dcl 5-11
lbx                                    internal static fixed bin(17,0)          initial dcl 6-42
lpx                                    internal static fixed bin(17,0)          initial dcl 6-42
mcp                                    automatic       pointer                  dcl 6-10
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 1-19
record_blockp                          automatic       pointer                  dcl 2-10
sbx                                    internal static fixed bin(17,0)          initial dcl 6-42
sc_metersp                             automatic       pointer                  dcl 2-7
sc_n_processes                         automatic       fixed bin(17,0)          dcl 2-13
scavenger_data_pages                   based           structure                level 1 dcl 2-79
scavenger_optionsp                     automatic       pointer                  dcl 2-11
scu                                    based           structure                level 1 dcl 6-56
scup                                   automatic       pointer                  dcl 6-54
scux                                   based           structure                level 1 dcl 6-207
spx                                    internal static fixed bin(17,0)          initial dcl 6-42
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 3-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 3-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 3-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 3-141

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP_RETURN                  000542 constant        label                    dcl 163 ref 140
FOUND_EMPTY                     001433 constant        label                    dcl 294 ref 289
LOCK_CLEANUP_RETURN             000531 constant        label                    dcl 160 ref 432
PRINT_ERROR                     001733 constant        entry                    internal dcl 392 ref 151 151
PRINT_METERS                    002227 constant        entry                    internal dcl 438 ref 174
RETURN_BLOCK                    001570 constant        entry                    internal dcl 344 ref 187
RETURN_ERROR                    001407 constant        label                    dcl 282 ref 292
RETURN_PROCESS_TABLE            001645 constant        entry                    internal dcl 366 ref 189
SETUP_BLOCK                     001467 constant        entry                    internal dcl 311 ref 143
SETUP_LOCK                      001301 constant        entry                    internal dcl 237 ref 135
SETUP_PROCESS_TABLE             001374 constant        entry                    internal dcl 267 ref 139
scavenger                       000301 constant        entry                    external dcl 12
shutdown                        001163 constant        entry                    external dcl 212

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2762        3060    2420        2772
Length      3436    2420        76         342     341           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
scavenger                           518 external procedure  is an external procedure.  
SETUP_LOCK                              internal procedure  shares stack frame of external procedure scavenger.  
SETUP_PROCESS_TABLE                     internal procedure  shares stack frame of external procedure scavenger.  
SETUP_BLOCK                             internal procedure  shares stack frame of external procedure scavenger.  
RETURN_BLOCK                            internal procedure  shares stack frame of external procedure scavenger.  
RETURN_PROCESS_TABLE                    internal procedure  shares stack frame of external procedure scavenger.  
PRINT_ERROR                         312 internal procedure  is assigned to an entry variable, and is declared options(non_quick).  
PRINT_METERS                            internal procedure  shares stack frame of external procedure scavenger.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
PRINT_ERROR              000100 auto_fault_msg              PRINT_ERROR
                         000360 ssptr                       PRINT_ERROR
scavenger                000100 begin_clock                 scavenger
                         000102 begin_pf                    scavenger
                         000104 begin_vcpu                  scavenger
                         000106 code                        scavenger
                         000107 end_pf                      scavenger
                         000110 end_vcpu                    scavenger
                         000112 i_am_wired                  scavenger
                         000114 local_sc_meters             scavenger
                         000135 local_scavenger_options     scavenger
                         000136 old_mask                    scavenger
                         000140 process_tablex              scavenger
                         000142 ptwp                        scavenger
                         000144 scavenger_data_astep        scavenger
                         000146 started                     scavenger
                         000150 pvt_arrayp                  scavenger
                         000152 pvtep                       scavenger
                         000154 scavenger_datap             scavenger
                         000156 sc_process_tablep           scavenger
                         000160 scavenger_blockp            scavenger
                         000162 scavenger_n_records         scavenger
                         000163 scavenger_n_ovfl            scavenger
                         000202 n_header_pages              SETUP_PROCESS_TABLE
                         000203 procx                       SETUP_PROCESS_TABLE
                         000212 first_page                  SETUP_BLOCK
                         000213 n_pages                     SETUP_BLOCK
                         000222 first_page                  RETURN_BLOCK
                         000223 n_pages                     RETURN_BLOCK
                         000232 n_header_pages              RETURN_PROCESS_TABLE
                         000242 clock_sec                   PRINT_METERS
                         000243 vcpu_sec                    PRINT_METERS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           ext_entry           int_entry_desc
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_                    get_ptrs_$given_segno         lock$lock_ast                 lock$lock_fast
lock$unlock_ast               lock$unlock_fast              pc_wired$unwire               pc_wired$wire_wait
pmut$lock_ptl                 pmut$unlock_ptl               scavenge_volume               syserr
syserr$binary                 syserr$error_code             usage_values                  verify_lock$condition_nolog
wire_proc$unwire_me           wire_proc$wire_me

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$pv_no_scavenge   error_table_$pvid_not_found   error_table_$scavenge_process_limit
error_table_$unexpected_condition                           pds$process_group_id          pds$processid
pvt$array                     scavenger_data$               sst$astl


CONSTANTS
002401  aa     007777000001

002402  aa     777777777577

002403  aa     777777777377

002404  aa  070 322 000 000	8

002406  aa     000002000000
002407  aa     000000000000
002410  aa     600000000041
002411  aa     000140000000

002412  aa     000004000000
002413  aa     000000000000
002414  aa     600000000041
002415  aa     000140000000
002416  aa     600000000041
002417  aa     000106000000

000000  aa     000000000260

000001  aa     414000000033

000002  aa     524000000345

000003  aa     050750220000

000004  aa     524000000113

000005  aa     514000000001

000006  aa     526077777777

000007  aa     524000000071

000010  aa     524000000036

000011  aa     524000000053

000012  aa     524000000103

000013  aa     524000000070

000014  aa     524000000040

000015  aa     516000000001

000016  aa     524000000002

000017  aa     524000000004

000020  aa     524000000063

000021  aa     500000000000

000022  aa     524000000011

000023  aa     000000000000

000024  aa     404000000043

000025  aa     000000000004

000026  aa     464000000000

000027  aa     000000000002

000030  aa     514000000044

000031  aa     000000000001

000032  aa     404000000021

000034  aa     077777000043
000035  aa     000001000000

000036  aa  141 156 171 137	any_
000037  aa  157 164 150 145	othe
000040  aa  162 000 000 000	r

000041  aa  163 143 141 166	scav
000042  aa  145 156 147 145	enge
000043  aa  162 072 040 111	r: I
000044  aa  156 166 141 154	nval
000045  aa  151 144 040 142	id b
000046  aa  154 157 143 153	lock
000047  aa  040 162 145 163	 res
000050  aa  145 164 000 000	et

000051  aa  163 143 141 166	scav
000052  aa  145 156 147 145	enge
000053  aa  162 072 040 123	r: S
000054  aa  143 141 166 145	cave
000055  aa  156 147 145 040	nge 
000056  aa  157 146 040 136	of ^
000057  aa  141 137 136 141	a_^a
000060  aa  136 133 136 141	^[^a
000061  aa  136 135 040 163	^] s
000062  aa  164 157 160 160	topp
000063  aa  145 144 056 000	ed.

000064  aa  163 143 141 166	scav
000065  aa  145 156 147 145	enge
000066  aa  162 072 040 102	r: B
000067  aa  145 147 151 156	egin
000070  aa  040 163 143 141	 sca
000071  aa  166 145 156 147	veng
000072  aa  145 040 157 146	e of
000073  aa  040 136 141 137	 ^a_
000074  aa  136 141 136 133	^a^[
000075  aa  136 141 136 073	^a^;
000076  aa  136 061 163 136	^1s^
000077  aa  135 040 142 171	] by
000100  aa  040 136 141 000	 ^a

000101  aa  163 143 141 166	scav
000102  aa  145 156 147 145	enge
000103  aa  162 072 040 123	r: S
000104  aa  143 141 166 145	cave
000105  aa  156 147 145 040	nge 
000106  aa  157 146 040 136	of ^
000107  aa  141 137 136 141	a_^a
000110  aa  136 133 136 141	^[^a
000111  aa  136 073 136 061	^;^1
000112  aa  163 136 135 040	s^] 
000113  aa  142 171 040 136	by ^
000114  aa  141 040 143 157	a co
000115  aa  155 160 154 145	mple
000116  aa  164 145 144 056	ted.

000117  aa  163 143 141 166	scav
000120  aa  145 156 147 145	enge
000121  aa  162 072 040 120	r: P
000122  aa  162 157 143 145	roce
000123  aa  163 163 040 164	ss t
000124  aa  141 142 154 145	able
000125  aa  040 145 156 164	 ent
000126  aa  162 171 040 156	ry n
000127  aa  157 164 040 157	ot o
000130  aa  167 156 145 144	wned
000131  aa  040 142 171 040	 by 
000132  aa  164 150 151 163	this
000133  aa  040 160 162 157	 pro
000134  aa  143 145 163 163	cess
000135  aa  056 000 000 000	.

000136  aa  163 143 141 166	scav
000137  aa  145 156 147 145	enge
000140  aa  162 072 040 123	r: S
000141  aa  143 141 166 145	cave
000142  aa  156 147 145 040	nge 
000143  aa  157 146 040 136	of ^
000144  aa  141 137 136 141	a_^a
000145  aa  136 133 136 141	^[^a
000146  aa  136 073 136 061	^;^1
000147  aa  163 136 135 040	s^] 
000150  aa  142 171 040 136	by ^
000151  aa  141 040 143 157	a co
000152  aa  155 160 154 145	mple
000153  aa  164 145 144 040	ted 
000154  aa  167 151 164 150	with
000155  aa  040 145 162 162	 err
000156  aa  157 162 056 000	or.

000157  aa  163 143 141 166	scav
000160  aa  145 156 147 145	enge
000161  aa  162 072 040 136	r: ^
000162  aa  141 040 143 157	a co
000163  aa  156 144 151 164	ndit
000164  aa  151 157 156 040	ion 
000165  aa  163 151 147 156	sign
000166  aa  141 154 154 145	alle
000167  aa  144 040 144 165	d du
000170  aa  162 151 156 147	ring
000171  aa  040 163 143 141	 sca
000172  aa  166 145 156 147	veng
000173  aa  145 040 157 146	e of
000174  aa  040 136 141 137	 ^a_
000175  aa  136 141 136 133	^a^[
000176  aa  136 141 136 073	^a^;
000177  aa  136 061 163 136	^1s^
000200  aa  135 040 142 171	] by
000201  aa  040 136 141 000	 ^a

000202  aa  163 143 141 166	scav
000203  aa  145 156 147 145	enge
000204  aa  162 072 040 115	r: M
000205  aa  145 164 145 162	eter
000206  aa  163 040 146 162	s fr
000207  aa  157 155 040 163	om s
000210  aa  143 141 166 145	cave
000211  aa  156 147 145 040	nge 
000212  aa  157 146 040 136	of ^
000213  aa  141 137 136 141	a_^a
000214  aa  136 133 136 141	^[^a
000215  aa  136 073 136 061	^;^1
000216  aa  163 136 135 056	s^].
000217  aa  040 103 154 157	 Clo
000220  aa  143 153 075 136	ck=^
000221  aa  066 056 061 146	6.1f
000222  aa  040 166 143 160	 vcp
000223  aa  165 075 136 066	u=^6
000224  aa  056 061 146 040	.1f 
000225  aa  160 146 075 136	pf=^
000226  aa  144 136 057 126	d^/V
000227  aa  124 117 103 105	TOCE
000230  aa  123 072 040 124	S: T
000231  aa  157 164 141 154	otal
000232  aa  075 136 144 040	=^d 
000233  aa  104 141 155 141	Dama
000234  aa  147 145 144 075	ged=
000235  aa  136 144 040 120	^d P
000236  aa  145 162 055 120	er-P
000237  aa  162 157 143 075	roc=
000240  aa  136 144 040 120	^d P
000241  aa  145 162 055 102	er-B
000242  aa  157 157 164 075	oot=
000243  aa  136 144 040 106	^d F
000244  aa  115 104 141 155	MDam
000245  aa  141 147 145 144	aged
000246  aa  075 136 144 040	=^d 
000247  aa  106 162 145 145	Free
000250  aa  144 075 136 144	d=^d
000251  aa  136 057 122 145	^/Re
000252  aa  143 157 162 144	cord
000253  aa  163 072 040 124	s: T
000254  aa  157 164 141 154	otal
000255  aa  075 136 144 040	=^d 
000256  aa  120 157 164 040	Pot 
000257  aa  143 157 156 146	conf
000260  aa  154 151 143 164	lict
000261  aa  075 136 144 040	=^d 
000262  aa  106 115 104 040	FMD 
000263  aa  103 157 156 146	Conf
000264  aa  154 151 143 164	lict
000265  aa  040 075 040 136	 = ^
000266  aa  144 040 103 157	d Co
000267  aa  156 146 154 151	nfli
000270  aa  143 164 075 136	ct=^
000271  aa  144 040 114 157	d Lo
000272  aa  163 164 075 136	st=^
000273  aa  144 000 000 000	d

BEGIN PROCEDURE scavenger
ENTRY TO scavenger                                          STATEMENT 1 ON LINE 12
scavenger:
     proc (Pvtx, Pvid, Scavenger_Optionsp, Sc_metersp, Code);

000274  at     000005000032
000275  tt     000030000026
000276  tt     000026000024
000277  ta     000274000000
000300  da     000321300000
000301  aa   001020 6270 00	eax7 	528
000302  aa  7 00034 3521 20	epp2 	pr7|28,*
000303  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000304  aa     000012000000
000305  aa     000000000000
						STATEMENT 1 ON LINE 129
	started = "0"b;

000306  aa  6 00146 4501 00	stz  	pr6|102		started
						STATEMENT 1 ON LINE 130
	i_am_wired = "0"b;

000307  aa  6 00112 4501 00	stz  	pr6|74		i_am_wired
						STATEMENT 1 ON LINE 132
	unspec (local_sc_meters) = ""b;

000310  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000311  aa   000000 00 0000	desc9a	0,0
000312  aa  6 00114 00 0104	desc9a	pr6|76,68
						STATEMENT 1 ON LINE 133
	unspec (local_scavenger_options) = unspec (Scavenger_Options);

000313  aa  6 00032 3735 20	epp7 	pr6|26,*
000314  aa  7 00006 3715 20	epp5 	pr7|6,*		Scavenger_Optionsp
000315  aa  5 00000 2351 20	lda  	pr5|0,*
000316  aa  0 00020 3771 00	anaq 	pr0|16		= 776000000000 000000000000
000317  aa  6 00135 7551 00	sta  	pr6|93
						STATEMENT 1 ON LINE 135
	call SETUP_LOCK (Code);

000320  aa  7 00012 3521 20	epp2 	pr7|10,*		Code
000321  aa  6 00246 2521 00	spri2	pr6|166
000322  aa  6 00244 3521 00	epp2 	pr6|164
000323  aa   004000 4310 07	fld  	2048,dl
000324  aa  2 00000 7571 00	staq 	pr2|0
000325  aa   000754 6700 04	tsp4 	492,ic		001301
						STATEMENT 1 ON LINE 136
	if Code ^= 0
	then return;

000326  aa  6 00032 3735 20	epp7 	pr6|26,*
000327  aa  7 00012 2361 20	ldq  	pr7|10,*		Code
000330  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 139
	call SETUP_PROCESS_TABLE (process_tablex, code);

000331  aa   002061 3520 04	epp2 	1073,ic		002412 = 000004000000
000332  aa   001042 6700 04	tsp4 	546,ic		001374
						STATEMENT 1 ON LINE 140
	if code ^= 0
	then goto CLEANUP_RETURN;

000333  aa  6 00106 2361 00	ldq  	pr6|70		code
000334  aa   000206 6010 04	tnz  	134,ic		000542
						STATEMENT 1 ON LINE 143
	call SETUP_BLOCK (process_tablex);

000335  aa   002051 3520 04	epp2 	1065,ic		002406 = 000002000000
000336  aa   001131 6700 04	tsp4 	601,ic		001467
						STATEMENT 1 ON LINE 145
	pvte.scavenger_block_rel = rel (scavenger_blockp);

000337  aa  6 00160 6351 20	eaa  	pr6|112,*		scavenger_blockp
000340  aa   000022 7710 00	arl  	18
000341  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
000342  aa  7 00033 5511 14	stba 	pr7|27,14		pvte.scavenger_block_rel
						STATEMENT 1 ON LINE 146
	call lock$unlock_fast (addr (scavenger_data.lock));

000343  aa  6 00154 3715 20	epp5 	pr6|108,*		scavenger_data.lock
000344  aa  6 00252 6515 00	spri5	pr6|170
000345  aa  6 00252 3521 00	epp2 	pr6|170
000346  aa  6 00246 2521 00	spri2	pr6|166
000347  aa  6 00244 6211 00	eax1 	pr6|164
000350  aa   004000 4310 07	fld  	2048,dl
000351  aa  6 00044 3701 20	epp4 	pr6|36,*
000352  la  4 00040 3521 20	epp2 	pr4|32,*		lock$unlock_fast
000353  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 148
	call usage_values (begin_pf, begin_vcpu);

000354  aa  6 00102 3521 00	epp2 	pr6|66		begin_pf
000355  aa  6 00246 2521 00	spri2	pr6|166
000356  aa  6 00104 3521 00	epp2 	pr6|68		begin_vcpu
000357  aa  6 00250 2521 00	spri2	pr6|168
000360  aa  6 00244 6211 00	eax1 	pr6|164
000361  aa   010000 4310 07	fld  	4096,dl
000362  aa  6 00044 3701 20	epp4 	pr6|36,*
000363  la  4 00062 3521 20	epp2 	pr4|50,*		usage_values
000364  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 149
	begin_clock = clock ();

000365  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
000366  aa  6 00100 7571 00	staq 	pr6|64		begin_clock
						STATEMENT 1 ON LINE 151
	call condition_ ("any_other", PRINT_ERROR);

000367  aa   777447 2370 04	ldaq 	-217,ic		000036 = 141156171137 157164150145
000370  aa  6 00244 7571 00	staq 	pr6|164
000371  aa   162000 2350 03	lda  	58368,du
000372  aa  6 00246 7551 00	sta  	pr6|166
000373  aa   001340 3520 04	epp2 	736,ic		001733 = 000500627000
000374  aa  6 00254 2521 00	spri2	pr6|172		cp.268
000375  aa  6 00256 6521 00	spri6	pr6|174		cp.268
000376  aa  6 00244 3521 00	epp2 	pr6|164
000377  aa  6 00262 2521 00	spri2	pr6|178
000400  aa  6 00254 3521 00	epp2 	pr6|172		cp.268
000401  aa  6 00264 2521 00	spri2	pr6|180
000402  aa   777420 3520 04	epp2 	-240,ic		000022 = 524000000011
000403  aa  6 00266 2521 00	spri2	pr6|182
000404  aa   777415 3520 04	epp2 	-243,ic		000021 = 500000000000
000405  aa  6 00270 2521 00	spri2	pr6|184
000406  aa  6 00260 6211 00	eax1 	pr6|176
000407  aa   010000 4310 07	fld  	4096,dl
000410  aa  6 00044 3701 20	epp4 	pr6|36,*
000411  la  4 00026 3521 20	epp2 	pr4|22,*		condition_
000412  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 153
	call syserr (ANNOUNCE, "scavenger: Begin scavenge of ^a_^a^[^a^;^1s^] by ^a", pvte.devname,
	     convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);

000413  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000414  aa   777451 00 0064	desc9a	-215,52		000064 = 163143141166
000415  aa  6 00272 00 0064	desc9a	pr6|186,52
000416  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
000417  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
000420  aa   000011 7350 00	als  	9
000421  aa   000077 7330 00	lrs  	63
000422  aa  6 00311 7561 00	stq  	pr6|201		pvte.logical_area_number
000423  aa  000 100 301 500	btd  	(pr),(pr)
000424  aa  6 00311 00 0004	desc9a	pr6|201,4		pvte.logical_area_number
000425  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
000426  aa  6 00307 4501 00	stz  	pr6|199
000427  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
000430  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
000431  aa   001755 00 0002	desc9a	1005,2		002404 = 070322000000
000432  aa  6 00307 00 0002	desc9a	pr6|199,2
000433  aa   777370 3520 04	epp2 	-264,ic		000023 = 000000000000
000434  aa  6 00314 2521 00	spri2	pr6|204
000435  aa  6 00272 3521 00	epp2 	pr6|186
000436  aa  6 00316 2521 00	spri2	pr6|206
000437  aa  7 00003 3521 00	epp2 	pr7|3		pvte.devname
000440  aa  6 00320 2521 00	spri2	pr6|208
000441  aa  6 00307 3521 00	epp2 	pr6|199
000442  aa  6 00322 2521 00	spri2	pr6|210
000443  aa   000003 7270 07	lxl7 	3,dl
000444  aa  7 00002 3521 00	epp2 	pr7|2		pvte.is_sv
000445  aa  2 00000 5035 17	abd  	pr2|0,7
000446  aa  6 00324 2521 00	spri2	pr6|212
000447  aa  7 00015 3521 00	epp2 	pr7|13		pvte.sv_name
000450  aa  6 00326 2521 00	spri2	pr6|214
000451  aa  6 00044 3701 20	epp4 	pr6|36,*
000452  la  4 00020 3521 20	epp2 	pr4|16,*		pds$process_group_id
000453  aa  6 00330 2521 00	spri2	pr6|216
000454  aa   777356 3520 04	epp2 	-274,ic		000032 = 404000000021
000455  aa  6 00332 2521 00	spri2	pr6|218
000456  aa   777342 3520 04	epp2 	-286,ic		000020 = 524000000063
000457  aa  6 00334 2521 00	spri2	pr6|220
000460  aa   777337 3520 04	epp2 	-289,ic		000017 = 524000000004
000461  aa  6 00336 2521 00	spri2	pr6|222
000462  aa   777334 3520 04	epp2 	-292,ic		000016 = 524000000002
000463  aa  6 00340 2521 00	spri2	pr6|224
000464  aa  6 00344 2521 00	spri2	pr6|228
000465  aa   777330 3520 04	epp2 	-296,ic		000015 = 516000000001
000466  aa  6 00342 2521 00	spri2	pr6|226
000467  aa   777325 3520 04	epp2 	-299,ic		000014 = 524000000040
000470  aa  6 00346 2521 00	spri2	pr6|230
000471  aa  6 00312 6211 00	eax1 	pr6|202
000472  aa   034000 4310 07	fld  	14336,dl
000473  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
000474  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 155
	started = "1"b;

000475  aa   400000 2350 03	lda  	131072,du
000476  aa  6 00146 7551 00	sta  	pr6|102		started
						STATEMENT 1 ON LINE 156
	call wire_proc$wire_me;

000477  aa  6 00056 6211 00	eax1 	pr6|46
000500  aa   000000 4310 07	fld  	0,dl
000501  aa  6 00044 3701 20	epp4 	pr6|36,*
000502  la  4 00066 3521 20	epp2 	pr4|54,*		wire_proc$wire_me
000503  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 157
	i_am_wired = "1"b;

000504  aa   400000 2350 03	lda  	131072,du
000505  aa  6 00112 7551 00	sta  	pr6|74		i_am_wired
						STATEMENT 1 ON LINE 158
	call scavenge_volume (pvtep, scavenger_blockp, addr (local_scavenger_options), addr (local_sc_meters), code);

000506  aa  6 00135 3735 00	epp7 	pr6|93		local_scavenger_options
000507  aa  6 00252 6535 00	spri7	pr6|170
000510  aa  6 00114 3715 00	epp5 	pr6|76		local_sc_meters
000511  aa  6 00350 6515 00	spri5	pr6|232
000512  aa  6 00152 3521 00	epp2 	pr6|106		pvtep
000513  aa  6 00274 2521 00	spri2	pr6|188
000514  aa  6 00160 3521 00	epp2 	pr6|112		scavenger_blockp
000515  aa  6 00276 2521 00	spri2	pr6|190
000516  aa  6 00252 3521 00	epp2 	pr6|170
000517  aa  6 00300 2521 00	spri2	pr6|192
000520  aa  6 00350 3521 00	epp2 	pr6|232
000521  aa  6 00302 2521 00	spri2	pr6|194
000522  aa  6 00106 3521 00	epp2 	pr6|70		code
000523  aa  6 00304 2521 00	spri2	pr6|196
000524  aa  6 00272 6211 00	eax1 	pr6|186
000525  aa   024000 4310 07	fld  	10240,dl
000526  aa  6 00044 3701 20	epp4 	pr6|36,*
000527  la  4 00052 3521 20	epp2 	pr4|42,*		scavenge_volume
000530  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 160
LOCK_CLEANUP_RETURN:
	call lock$lock_fast (addr (scavenger_data.lock));

000531  aa  6 00154 3735 20	epp7 	pr6|108,*		scavenger_data.lock
000532  aa  6 00350 6535 00	spri7	pr6|232
000533  aa  6 00350 3521 00	epp2 	pr6|232
000534  aa  6 00256 2521 00	spri2	pr6|174
000535  aa  6 00254 6211 00	eax1 	pr6|172
000536  aa   004000 4310 07	fld  	2048,dl
000537  aa  6 00044 3701 20	epp4 	pr6|36,*
000540  la  4 00034 3521 20	epp2 	pr4|28,*		lock$lock_fast
000541  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 163
CLEANUP_RETURN:
	if i_am_wired
	then call wire_proc$unwire_me;

000542  aa  6 00112 2351 00	lda  	pr6|74		i_am_wired
000543  aa   000006 6000 04	tze  	6,ic		000551
000544  aa  6 00056 6211 00	eax1 	pr6|46
000545  aa   000000 4310 07	fld  	0,dl
000546  aa  6 00044 3701 20	epp4 	pr6|36,*
000547  la  4 00070 3521 20	epp2 	pr4|56,*		wire_proc$unwire_me
000550  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 167
	if started & (code = 0)
	then do;

000551  aa  6 00146 2351 00	lda  	pr6|102		started
000552  aa   000126 6000 04	tze  	86,ic		000700
000553  aa  6 00106 2361 00	ldq  	pr6|70		code
000554  aa   000124 6010 04	tnz  	84,ic		000700
						STATEMENT 1 ON LINE 169
		call usage_values (end_pf, end_vcpu);

000555  aa  6 00107 3521 00	epp2 	pr6|71		end_pf
000556  aa  6 00246 2521 00	spri2	pr6|166
000557  aa  6 00110 3521 00	epp2 	pr6|72		end_vcpu
000560  aa  6 00250 2521 00	spri2	pr6|168
000561  aa  6 00244 6211 00	eax1 	pr6|164
000562  aa   010000 4310 07	fld  	4096,dl
000563  aa  6 00044 3701 20	epp4 	pr6|36,*
000564  la  4 00062 3521 20	epp2 	pr4|50,*		usage_values
000565  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 170
		local_sc_meters.n_scavenge = 1;

000566  aa   000001 2360 07	ldq  	1,dl
000567  aa  6 00114 7561 00	stq  	pr6|76		local_sc_meters.n_scavenge
						STATEMENT 1 ON LINE 171
		local_sc_meters.pf = end_pf - begin_pf;

000570  aa  6 00107 2361 00	ldq  	pr6|71		end_pf
000571  aa  6 00102 1761 00	sbq  	pr6|66		begin_pf
000572  aa  6 00115 7561 00	stq  	pr6|77		local_sc_meters.pf
						STATEMENT 1 ON LINE 172
		local_sc_meters.vcpu = end_vcpu - begin_vcpu;

000573  aa  6 00110 2371 00	ldaq 	pr6|72		end_vcpu
000574  aa  6 00104 1771 00	sbaq 	pr6|68		begin_vcpu
000575  aa  6 00116 7571 00	staq 	pr6|78		local_sc_meters.vcpu
						STATEMENT 1 ON LINE 173
		local_sc_meters.clock_time = clock () - begin_clock;

000576  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
000577  aa  6 00100 1771 00	sbaq 	pr6|64		begin_clock
000600  aa  6 00120 7571 00	staq 	pr6|80		local_sc_meters.clock_time
						STATEMENT 1 ON LINE 174
		if local_scavenger_options.print_meters
		then call PRINT_METERS;

000601  aa  6 00135 2351 00	lda  	pr6|93		local_scavenger_options.print_meters
000602  aa   400000 3150 03	cana 	131072,du
000603  aa   000002 6000 04	tze  	2,ic		000605
000604  aa   001423 6700 04	tsp4 	787,ic		002227
						STATEMENT 1 ON LINE 176
		scavenger_data.meters = scavenger_data.meters + local_sc_meters;

000605  aa  6 00154 3735 20	epp7 	pr6|108,*		scavenger_datap
000606  aa  7 00010 2351 00	lda  	pr7|8		scavenger_data.n_scavenge
000607  aa   000044 7330 00	lrs  	36
000610  aa  6 00114 0331 00	adl  	pr6|76		local_sc_meters.n_scavenge
000611  aa  7 00010 7561 00	stq  	pr7|8		scavenger_data.n_scavenge
000612  aa  7 00011 2351 00	lda  	pr7|9		scavenger_data.pf
000613  aa   000044 7330 00	lrs  	36
000614  aa  6 00115 0331 00	adl  	pr6|77		local_sc_meters.pf
000615  aa  7 00011 7561 00	stq  	pr7|9		scavenger_data.pf
000616  aa  7 00012 2371 00	ldaq 	pr7|10		scavenger_data.vcpu
000617  aa  6 00116 0771 00	adaq 	pr6|78		local_sc_meters.vcpu
000620  aa  7 00012 7571 00	staq 	pr7|10		scavenger_data.vcpu
000621  aa  7 00014 2371 00	ldaq 	pr7|12		scavenger_data.clock_time
000622  aa  6 00120 0771 00	adaq 	pr6|80		local_sc_meters.clock_time
000623  aa  7 00014 7571 00	staq 	pr7|12		scavenger_data.clock_time
000624  aa  7 00016 2351 00	lda  	pr7|14		scavenger_data.n_vtoces
000625  aa   000044 7330 00	lrs  	36
000626  aa  6 00122 0331 00	adl  	pr6|82		local_sc_meters.n_vtoces
000627  aa  7 00016 7561 00	stq  	pr7|14		scavenger_data.n_vtoces
000630  aa  7 00017 2351 00	lda  	pr7|15		scavenger_data.n_vtoces_damaged
000631  aa   000044 7330 00	lrs  	36
000632  aa  6 00123 0331 00	adl  	pr6|83		local_sc_meters.n_vtoces_damaged
000633  aa  7 00017 7561 00	stq  	pr7|15		scavenger_data.n_vtoces_damaged
000634  aa  7 00020 2351 00	lda  	pr7|16		scavenger_data.n_vtoces_per_proc
000635  aa   000044 7330 00	lrs  	36
000636  aa  6 00124 0331 00	adl  	pr6|84		local_sc_meters.n_vtoces_per_proc
000637  aa  7 00020 7561 00	stq  	pr7|16		scavenger_data.n_vtoces_per_proc
000640  aa  7 00021 2351 00	lda  	pr7|17		scavenger_data.n_vtoces_per_boot
000641  aa   000044 7330 00	lrs  	36
000642  aa  6 00125 0331 00	adl  	pr6|85		local_sc_meters.n_vtoces_per_boot
000643  aa  7 00021 7561 00	stq  	pr7|17		scavenger_data.n_vtoces_per_boot
000644  aa  7 00022 2351 00	lda  	pr7|18		scavenger_data.n_vtoces_freed
000645  aa   000044 7330 00	lrs  	36
000646  aa  6 00126 0331 00	adl  	pr6|86		local_sc_meters.n_vtoces_freed
000647  aa  7 00022 7561 00	stq  	pr7|18		scavenger_data.n_vtoces_freed
000650  aa  7 00023 2351 00	lda  	pr7|19		scavenger_data.n_vtoces_fmd
000651  aa   000044 7330 00	lrs  	36
000652  aa  6 00127 0331 00	adl  	pr6|87		local_sc_meters.n_vtoces_fmd
000653  aa  7 00023 7561 00	stq  	pr7|19		scavenger_data.n_vtoces_fmd
000654  aa  7 00024 2351 00	lda  	pr7|20		scavenger_data.n_records
000655  aa   000044 7330 00	lrs  	36
000656  aa  6 00130 0331 00	adl  	pr6|88		local_sc_meters.n_records
000657  aa  7 00024 7561 00	stq  	pr7|20		scavenger_data.n_records
000660  aa  7 00025 2351 00	lda  	pr7|21		scavenger_data.n_conflicts
000661  aa   000044 7330 00	lrs  	36
000662  aa  6 00131 0331 00	adl  	pr6|89		local_sc_meters.n_conflicts
000663  aa  7 00025 7561 00	stq  	pr7|21		scavenger_data.n_conflicts
000664  aa  7 00026 2351 00	lda  	pr7|22		scavenger_data.n_fmd_conflicts
000665  aa   000044 7330 00	lrs  	36
000666  aa  6 00132 0331 00	adl  	pr6|90		local_sc_meters.n_fmd_conflicts
000667  aa  7 00026 7561 00	stq  	pr7|22		scavenger_data.n_fmd_conflicts
000670  aa  7 00027 2351 00	lda  	pr7|23		scavenger_data.n_real_conflicts
000671  aa   000044 7330 00	lrs  	36
000672  aa  6 00133 0331 00	adl  	pr6|91		local_sc_meters.n_real_conflicts
000673  aa  7 00027 7561 00	stq  	pr7|23		scavenger_data.n_real_conflicts
000674  aa  7 00030 2351 00	lda  	pr7|24		scavenger_data.n_lost_records
000675  aa   000044 7330 00	lrs  	36
000676  aa  6 00134 0331 00	adl  	pr6|92		local_sc_meters.n_lost_records
000677  aa  7 00030 7561 00	stq  	pr7|24		scavenger_data.n_lost_records
						STATEMENT 1 ON LINE 177
	     end;

						STATEMENT 1 ON LINE 179
	call lock$lock_ast;

000700  aa  6 00056 6211 00	eax1 	pr6|46
000701  aa   000000 4310 07	fld  	0,dl
000702  aa  6 00044 3701 20	epp4 	pr6|36,*
000703  la  4 00032 3521 20	epp2 	pr4|26,*		lock$lock_ast
000704  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 180
	call pmut$lock_ptl (old_mask, ptwp);

000705  aa  6 00136 3521 00	epp2 	pr6|94		old_mask
000706  aa  6 00246 2521 00	spri2	pr6|166
000707  aa  6 00142 3521 00	epp2 	pr6|98		ptwp
000710  aa  6 00250 2521 00	spri2	pr6|168
000711  aa  6 00244 6211 00	eax1 	pr6|164
000712  aa   010000 4310 07	fld  	4096,dl
000713  aa  6 00044 3701 20	epp4 	pr6|36,*
000714  la  4 00046 3521 20	epp2 	pr4|38,*		pmut$lock_ptl
000715  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 181
	pvte.scavenger_block_rel = ""b;

000716  aa   777777 2350 03	lda  	262143,du
000717  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
000720  aa  7 00033 3551 00	ansa 	pr7|27		pvte.scavenger_block_rel
						STATEMENT 1 ON LINE 182
	pvte.scav_check_address = "0"b;

000721  aa   001462 2350 04	lda  	818,ic		002403 = 777777777377
000722  aa  7 00004 3551 00	ansa 	pr7|4		pvte.scav_check_address
						STATEMENT 1 ON LINE 183
	pvte.deposit_to_volmap = "0"b;

000723  aa   001457 2350 04	lda  	815,ic		002402 = 777777777577
000724  aa  7 00004 3551 00	ansa 	pr7|4		pvte.deposit_to_volmap
						STATEMENT 1 ON LINE 184
	call pmut$unlock_ptl (old_mask, ptwp);

000725  aa  6 00136 3521 00	epp2 	pr6|94		old_mask
000726  aa  6 00246 2521 00	spri2	pr6|166
000727  aa  6 00142 3521 00	epp2 	pr6|98		ptwp
000730  aa  6 00250 2521 00	spri2	pr6|168
000731  aa  6 00244 6211 00	eax1 	pr6|164
000732  aa   010000 4310 07	fld  	4096,dl
000733  aa  6 00044 3701 20	epp4 	pr6|36,*
000734  la  4 00050 3521 20	epp2 	pr4|40,*		pmut$unlock_ptl
000735  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 185
	call lock$unlock_ast;

000736  aa  6 00056 6211 00	eax1 	pr6|46
000737  aa   000000 4310 07	fld  	0,dl
000740  aa  6 00044 3701 20	epp4 	pr6|36,*
000741  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_ast
000742  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 187
	if scavenger_blockp ^= null ()
	then call RETURN_BLOCK (process_tablex);

000743  aa  6 00160 2371 00	ldaq 	pr6|112		scavenger_blockp
000744  aa   777070 6770 04	eraq 	-456,ic		000034 = 077777000043 000001000000
000745  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000746  aa   000003 6000 04	tze  	3,ic		000751
000747  aa   001437 3520 04	epp2 	799,ic		002406 = 000002000000
000750  aa   000620 6700 04	tsp4 	400,ic		001570
						STATEMENT 1 ON LINE 189
	if sc_process_tablep ^= null ()
	then call RETURN_PROCESS_TABLE (process_tablex);

000751  aa  6 00156 2371 00	ldaq 	pr6|110		sc_process_tablep
000752  aa   777062 6770 04	eraq 	-462,ic		000034 = 077777000043 000001000000
000753  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000754  aa   000003 6000 04	tze  	3,ic		000757
000755  aa   001431 3520 04	epp2 	793,ic		002406 = 000002000000
000756  aa   000667 6700 04	tsp4 	439,ic		001645
						STATEMENT 1 ON LINE 192
	call lock$unlock_fast (addr (scavenger_data.lock));

000757  aa  6 00154 3735 20	epp7 	pr6|108,*		scavenger_data.lock
000760  aa  6 00350 6535 00	spri7	pr6|232
000761  aa  6 00350 3521 00	epp2 	pr6|232
000762  aa  6 00256 2521 00	spri2	pr6|174
000763  aa  6 00254 6211 00	eax1 	pr6|172
000764  aa   004000 4310 07	fld  	2048,dl
000765  aa  6 00044 3701 20	epp4 	pr6|36,*
000766  la  4 00040 3521 20	epp2 	pr4|32,*		lock$unlock_fast
000767  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 194
	if started
	then do;

000770  aa  6 00146 2351 00	lda  	pr6|102		started
000771  aa   000154 6000 04	tze  	108,ic		001145
						STATEMENT 1 ON LINE 196
		if code = 0
		then call syserr (ANNOUNCE, "scavenger: Scavenge of ^a_^a^[^a^;^1s^] by ^a completed.", pvte.devname,
			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);

000772  aa  6 00106 2361 00	ldq  	pr6|70		code
000773  aa   000064 6010 04	tnz  	52,ic		001057
000774  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000775  aa   777105 00 0070	desc9a	-443,56		000101 = 163143141166
000776  aa  6 00312 00 0070	desc9a	pr6|202,56
000777  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
001000  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
001001  aa   000011 7350 00	als  	9
001002  aa   000077 7330 00	lrs  	63
001003  aa  6 00311 7561 00	stq  	pr6|201		pvte.logical_area_number
001004  aa  000 100 301 500	btd  	(pr),(pr)
001005  aa  6 00311 00 0004	desc9a	pr6|201,4		pvte.logical_area_number
001006  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
001007  aa  6 00307 4501 00	stz  	pr6|199
001010  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001011  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
001012  aa   001374 00 0002	desc9a	764,2		002404 = 070322000000
001013  aa  6 00307 00 0002	desc9a	pr6|199,2
001014  aa   777007 3520 04	epp2 	-505,ic		000023 = 000000000000
001015  aa  6 00354 2521 00	spri2	pr6|236
001016  aa  6 00312 3521 00	epp2 	pr6|202
001017  aa  6 00356 2521 00	spri2	pr6|238
001020  aa  7 00003 3521 00	epp2 	pr7|3		pvte.devname
001021  aa  6 00360 2521 00	spri2	pr6|240
001022  aa  6 00307 3521 00	epp2 	pr6|199
001023  aa  6 00362 2521 00	spri2	pr6|242
001024  aa   000003 7270 07	lxl7 	3,dl
001025  aa  7 00002 3521 00	epp2 	pr7|2		pvte.is_sv
001026  aa  2 00000 5035 17	abd  	pr2|0,7
001027  aa  6 00364 2521 00	spri2	pr6|244
001030  aa  7 00015 3521 00	epp2 	pr7|13		pvte.sv_name
001031  aa  6 00366 2521 00	spri2	pr6|246
001032  aa  6 00044 3701 20	epp4 	pr6|36,*
001033  la  4 00020 3521 20	epp2 	pr4|16,*		pds$process_group_id
001034  aa  6 00370 2521 00	spri2	pr6|248
001035  aa   776775 3520 04	epp2 	-515,ic		000032 = 404000000021
001036  aa  6 00372 2521 00	spri2	pr6|250
001037  aa   776754 3520 04	epp2 	-532,ic		000013 = 524000000070
001040  aa  6 00374 2521 00	spri2	pr6|252
001041  aa   776756 3520 04	epp2 	-530,ic		000017 = 524000000004
001042  aa  6 00376 2521 00	spri2	pr6|254
001043  aa   776753 3520 04	epp2 	-533,ic		000016 = 524000000002
001044  aa  6 00400 2521 00	spri2	pr6|256
001045  aa  6 00404 2521 00	spri2	pr6|260
001046  aa   776747 3520 04	epp2 	-537,ic		000015 = 516000000001
001047  aa  6 00402 2521 00	spri2	pr6|258
001050  aa   776744 3520 04	epp2 	-540,ic		000014 = 524000000040
001051  aa  6 00406 2521 00	spri2	pr6|262
001052  aa  6 00352 6211 00	eax1 	pr6|234
001053  aa   034000 4310 07	fld  	14336,dl
001054  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
001055  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
001056  aa   000067 7100 04	tra  	55,ic		001145
						STATEMENT 1 ON LINE 199
		else call syserr$error_code (ANNOUNCE, code,
			"scavenger: Scavenge of ^a_^a^[^a^;^1s^] by ^a completed with error.", pvte.devname,
			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);

001057  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001060  aa   777057 00 0104	desc9a	-465,68		000136 = 163143141166
001061  aa  6 00352 00 0104	desc9a	pr6|234,68
001062  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
001063  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
001064  aa   000011 7350 00	als  	9
001065  aa   000077 7330 00	lrs  	63
001066  aa  6 00311 7561 00	stq  	pr6|201		pvte.logical_area_number
001067  aa  000 100 301 500	btd  	(pr),(pr)
001070  aa  6 00311 00 0004	desc9a	pr6|201,4		pvte.logical_area_number
001071  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
001072  aa  6 00307 4501 00	stz  	pr6|199
001073  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001074  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
001075  aa   001311 00 0002	desc9a	713,2		002404 = 070322000000
001076  aa  6 00307 00 0002	desc9a	pr6|199,2
001077  aa   776724 3520 04	epp2 	-556,ic		000023 = 000000000000
001100  aa  6 00412 2521 00	spri2	pr6|266
001101  aa  6 00106 3521 00	epp2 	pr6|70		code
001102  aa  6 00414 2521 00	spri2	pr6|268
001103  aa  6 00352 3521 00	epp2 	pr6|234
001104  aa  6 00416 2521 00	spri2	pr6|270
001105  aa  7 00003 3521 00	epp2 	pr7|3		pvte.devname
001106  aa  6 00420 2521 00	spri2	pr6|272
001107  aa  6 00307 3521 00	epp2 	pr6|199
001110  aa  6 00422 2521 00	spri2	pr6|274
001111  aa   000003 7270 07	lxl7 	3,dl
001112  aa  7 00002 3521 00	epp2 	pr7|2		pvte.is_sv
001113  aa  2 00000 5035 17	abd  	pr2|0,7
001114  aa  6 00424 2521 00	spri2	pr6|276
001115  aa  7 00015 3521 00	epp2 	pr7|13		pvte.sv_name
001116  aa  6 00426 2521 00	spri2	pr6|278
001117  aa  6 00044 3701 20	epp4 	pr6|36,*
001120  la  4 00020 3521 20	epp2 	pr4|16,*		pds$process_group_id
001121  aa  6 00430 2521 00	spri2	pr6|280
001122  aa   776710 3520 04	epp2 	-568,ic		000032 = 404000000021
001123  aa  6 00432 2521 00	spri2	pr6|282
001124  aa   776700 3520 04	epp2 	-576,ic		000024 = 404000000043
001125  aa  6 00434 2521 00	spri2	pr6|284
001126  aa   776664 3520 04	epp2 	-588,ic		000012 = 524000000103
001127  aa  6 00436 2521 00	spri2	pr6|286
001130  aa   776667 3520 04	epp2 	-585,ic		000017 = 524000000004
001131  aa  6 00440 2521 00	spri2	pr6|288
001132  aa   776664 3520 04	epp2 	-588,ic		000016 = 524000000002
001133  aa  6 00442 2521 00	spri2	pr6|290
001134  aa  6 00446 2521 00	spri2	pr6|294
001135  aa   776660 3520 04	epp2 	-592,ic		000015 = 516000000001
001136  aa  6 00444 2521 00	spri2	pr6|292
001137  aa   776655 3520 04	epp2 	-595,ic		000014 = 524000000040
001140  aa  6 00450 2521 00	spri2	pr6|296
001141  aa  6 00410 6211 00	eax1 	pr6|264
001142  aa   040000 4310 07	fld  	16384,dl
001143  la  4 00060 3521 20	epp2 	pr4|48,*		syserr$error_code
001144  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 202
	     end;

						STATEMENT 1 ON LINE 204
	if Sc_metersp ^= null ()
	then unspec (Sc_meters) = unspec (local_sc_meters);

001145  aa  6 00032 3735 20	epp7 	pr6|26,*
001146  aa  7 00010 2371 20	ldaq 	pr7|8,*		Sc_metersp
001147  aa   776665 6770 04	eraq 	-587,ic		000034 = 077777000043 000001000000
001150  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001151  aa   000006 6000 04	tze  	6,ic		001157
001152  aa  7 00010 3715 20	epp5 	pr7|8,*		Sc_metersp
001153  aa  5 00000 3715 20	epp5 	pr5|0,*		Sc_metersp
001154  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001155  aa  6 00114 00 0104	desc9a	pr6|76,68
001156  aa  5 00000 00 0104	desc9a	pr5|0,68
						STATEMENT 1 ON LINE 207
	Code = code;

001157  aa  6 00106 2361 00	ldq  	pr6|70		code
001160  aa  7 00012 7561 20	stq  	pr7|10,*		Code
						STATEMENT 1 ON LINE 208
	return;

001161  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO shutdown                                           STATEMENT 1 ON LINE 212
shutdown:
     entry;

001162  da     000327200000
001163  aa   001020 6270 00	eax7 	528
001164  aa  7 00034 3521 20	epp2 	pr7|28,*
001165  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001166  aa     000000000000
001167  aa     000000000000
						STATEMENT 1 ON LINE 215
	scavenger_datap = addr (scavenger_data$);

001170  aa  6 00044 3701 20	epp4 	pr6|36,*
001171  la  4 00074 3735 20	epp7 	pr4|60,*		scavenger_data$
001172  aa  6 00154 6535 00	spri7	pr6|108		scavenger_datap
						STATEMENT 1 ON LINE 216
	sc_process_tablep = scavenger_data.process_table_ptr;

001173  aa  7 00004 3715 20	epp5 	pr7|4,*		scavenger_data.process_table_ptr
001174  aa  6 00156 6515 00	spri5	pr6|110		sc_process_tablep
						STATEMENT 1 ON LINE 218
	do process_tablex = 1 to sc_process_table.max_n_processes;

001175  aa  5 00000 2361 00	ldq  	pr5|0		sc_process_table.max_n_processes
001176  aa  6 00164 7561 00	stq  	pr6|116
001177  aa   000001 2360 07	ldq  	1,dl
001200  aa  6 00140 7561 00	stq  	pr6|96		process_tablex
001201  aa   000000 0110 03	nop  	0,du
001202  aa  6 00140 2361 00	ldq  	pr6|96		process_tablex
001203  aa  6 00164 1161 00	cmpq 	pr6|116
001204  aa   000074 6054 04	tpnz 	60,ic		001300
						STATEMENT 1 ON LINE 219
	     if sc_process_table.process (process_tablex).processid ^= ""b
						/* Live entry */
	     then do;

001205  aa   000005 4020 07	mpy  	5,dl
001206  aa  6 00156 3735 20	epp7 	pr6|110,*		sc_process_tablep
001207  aa  7 77775 2351 06	lda  	pr7|-3,ql		sc_process_table.processid
001210  aa   000066 6000 04	tze  	54,ic		001276
						STATEMENT 1 ON LINE 222
		     pvtep = sc_process_table.process (process_tablex).pvtep;

001211  aa  7 77776 7651 06	lprp5	pr7|-2,ql		sc_process_table.pvtep
001212  aa  6 00152 6515 00	spri5	pr6|106		pvtep
						STATEMENT 1 ON LINE 223
		     pvte.deposit_to_volmap = "0"b;

001213  aa   001167 2350 04	lda  	631,ic		002402 = 777777777577
001214  aa  5 00004 3551 00	ansa 	pr5|4		pvte.deposit_to_volmap
						STATEMENT 1 ON LINE 224
		     pvte.scav_check_address = "0"b;

001215  aa   001166 2350 04	lda  	630,ic		002403 = 777777777377
001216  aa  5 00004 3551 00	ansa 	pr5|4		pvte.scav_check_address
						STATEMENT 1 ON LINE 225
		     pvte.scavenger_block_rel = ""b;

001217  aa   777777 2350 03	lda  	262143,du
001220  aa  5 00033 3551 00	ansa 	pr5|27		pvte.scavenger_block_rel
						STATEMENT 1 ON LINE 226
		     call syserr (ANNOUNCE, "scavenger: Scavenge of ^a_^a^[^a^] stopped.", pvte.devname,
			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);

001221  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001222  aa   776630 00 0054	desc9a	-616,44		000051 = 163143141166
001223  aa  6 00272 00 0054	desc9a	pr6|186,44
001224  aa  5 00004 2351 00	lda  	pr5|4		pvte.logical_area_number
001225  aa   000011 7350 00	als  	9
001226  aa   000077 7330 00	lrs  	63
001227  aa  6 00311 7561 00	stq  	pr6|201		pvte.logical_area_number
001230  aa  000 100 301 500	btd  	(pr),(pr)
001231  aa  6 00311 00 0004	desc9a	pr6|201,4		pvte.logical_area_number
001232  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
001233  aa  6 00307 4501 00	stz  	pr6|199
001234  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001235  aa  6 00310 01 0003	desc9ls	pr6|200,3,0
001236  aa   001150 00 0002	desc9a	616,2		002404 = 070322000000
001237  aa  6 00307 00 0002	desc9a	pr6|199,2
001240  aa   776563 3520 04	epp2 	-653,ic		000023 = 000000000000
001241  aa  6 00314 2521 00	spri2	pr6|204
001242  aa  6 00272 3521 00	epp2 	pr6|186
001243  aa  6 00316 2521 00	spri2	pr6|206
001244  aa  5 00003 3521 00	epp2 	pr5|3		pvte.devname
001245  aa  6 00320 2521 00	spri2	pr6|208
001246  aa  6 00307 3521 00	epp2 	pr6|199
001247  aa  6 00322 2521 00	spri2	pr6|210
001250  aa   000003 7270 07	lxl7 	3,dl
001251  aa  5 00002 3521 00	epp2 	pr5|2		pvte.is_sv
001252  aa  2 00000 5035 17	abd  	pr2|0,7
001253  aa  6 00324 2521 00	spri2	pr6|212
001254  aa  5 00015 3521 00	epp2 	pr5|13		pvte.sv_name
001255  aa  6 00326 2521 00	spri2	pr6|214
001256  aa   776554 3520 04	epp2 	-660,ic		000032 = 404000000021
001257  aa  6 00330 2521 00	spri2	pr6|216
001260  aa   776531 3520 04	epp2 	-679,ic		000011 = 524000000053
001261  aa  6 00332 2521 00	spri2	pr6|218
001262  aa   776535 3520 04	epp2 	-675,ic		000017 = 524000000004
001263  aa  6 00334 2521 00	spri2	pr6|220
001264  aa   776532 3520 04	epp2 	-678,ic		000016 = 524000000002
001265  aa  6 00336 2521 00	spri2	pr6|222
001266  aa  6 00342 2521 00	spri2	pr6|226
001267  aa   776526 3520 04	epp2 	-682,ic		000015 = 516000000001
001270  aa  6 00340 2521 00	spri2	pr6|224
001271  aa  6 00312 6211 00	eax1 	pr6|202
001272  aa   030000 4310 07	fld  	12288,dl
001273  aa  6 00044 3701 20	epp4 	pr6|36,*
001274  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
001275  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 228
		end;

						STATEMENT 1 ON LINE 229
	end;

001276  aa  6 00140 0541 00	aos  	pr6|96		process_tablex
001277  aa   777703 7100 04	tra  	-61,ic		001202
						STATEMENT 1 ON LINE 231
	return;

001300  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 579
     end scavenger;

BEGIN PROCEDURE SETUP_LOCK
ENTRY TO SETUP_LOCK                                         STATEMENT 1 ON LINE 237
SETUP_LOCK:
     proc (Code);

001301  aa  6 00166 6501 00	spri4	pr6|118
001302  aa  6 00170 2521 00	spri2	pr6|120
						STATEMENT 1 ON LINE 242
	scavenger_datap = addr (scavenger_data$);

001303  aa  6 00044 3701 20	epp4 	pr6|36,*
001304  la  4 00074 3735 20	epp7 	pr4|60,*		scavenger_data$
001305  aa  6 00154 6535 00	spri7	pr6|108		scavenger_datap
						STATEMENT 1 ON LINE 243
	sc_process_tablep = null ();

001306  aa   776526 2370 04	ldaq 	-682,ic		000034 = 077777000043 000001000000
001307  aa  6 00156 7571 00	staq 	pr6|110		sc_process_tablep
						STATEMENT 1 ON LINE 244
	scavenger_blockp = null ();

001310  aa  6 00160 7571 00	staq 	pr6|112		scavenger_blockp
						STATEMENT 1 ON LINE 245
	pvt_arrayp = addr (pvt$array);

001311  la  4 00072 3715 20	epp5 	pr4|58,*		pvt$array
001312  aa  6 00150 6515 00	spri5	pr6|104		pvt_arrayp
						STATEMENT 1 ON LINE 246
	pvtep = addr (pvt_array (Pvtx));

001313  aa  6 00032 3535 20	epp3 	pr6|26,*
001314  aa  3 00002 2361 20	ldq  	pr3|2,*		Pvtx
001315  aa   000034 4020 07	mpy  	28,dl
001316  aa  5 77744 3515 06	epp1 	pr5|-28,ql	pvt_array
001317  aa  6 00152 2515 00	spri1	pr6|106		pvtep
						STATEMENT 1 ON LINE 247
	scavenger_data_astep = get_ptrs_$given_segno (bin (baseno (scavenger_datap)));

001320  aa  7 00000 2131 00	epaq 	pr7|0		scavenger_datap
001321  aa   077777 3750 03	ana  	32767,du
001322  aa   000066 7730 00	lrl  	54
001323  aa  6 00452 7561 00	stq  	pr6|298
001324  aa  6 00452 3521 00	epp2 	pr6|298
001325  aa  6 00456 2521 00	spri2	pr6|302
001326  aa  6 00144 3521 00	epp2 	pr6|100		scavenger_data_astep
001327  aa  6 00460 2521 00	spri2	pr6|304
001330  aa  6 00454 6211 00	eax1 	pr6|300
001331  aa   010000 4310 07	fld  	4096,dl
001332  la  4 00030 3521 20	epp2 	pr4|24,*		get_ptrs_$given_segno
001333  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 248
	Code = 0;

001334  aa  6 00170 3735 20	epp7 	pr6|120,*
001335  aa  7 00002 4501 20	stz  	pr7|2,*		Code
						STATEMENT 1 ON LINE 250
	if pvte.pvid ^= Pvid
	then do;

001336  aa  6 00152 2351 20	lda  	pr6|106,*		pvte.pvid
001337  aa  6 00032 3715 20	epp5 	pr6|26,*
001340  aa  5 00004 1151 20	cmpa 	pr5|4,*		Pvid
001341  aa   000005 6000 04	tze  	5,ic		001346
						STATEMENT 1 ON LINE 252
		Code = error_table_$pvid_not_found;

001342  aa  6 00044 3701 20	epp4 	pr6|36,*
001343  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$pvid_not_found
001344  aa  7 00002 7561 20	stq  	pr7|2,*		Code
						STATEMENT 1 ON LINE 253
		return;

001345  aa  6 00166 6101 00	rtcd 	pr6|118
						STATEMENT 1 ON LINE 254
	     end;

						STATEMENT 1 ON LINE 255
	if ^pvte.used | ^pvte.storage_system | (pvte.scavenger_block_rel ^= ""b)
	then do;

001346  aa  6 00152 3535 20	epp3 	pr6|106,*		pvtep
001347  aa  3 00004 2351 00	lda  	pr3|4		pvte.storage_system
001350  aa   600000 3750 07	ana  	196608,dl
001351  aa   600000 1150 07	cmpa 	196608,dl
001352  aa   000004 6010 04	tnz  	4,ic		001356
001353  aa  3 00033 2351 00	lda  	pr3|27		pvte.scavenger_block_rel
001354  aa   777777 3150 07	cana 	262143,dl
001355  aa   000005 6000 04	tze  	5,ic		001362
						STATEMENT 1 ON LINE 257
		Code = error_table_$pv_no_scavenge;

001356  aa  6 00044 3701 20	epp4 	pr6|36,*
001357  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$pv_no_scavenge
001360  aa  7 00002 7561 20	stq  	pr7|2,*		Code
						STATEMENT 1 ON LINE 258
		return;

001361  aa  6 00166 6101 00	rtcd 	pr6|118
						STATEMENT 1 ON LINE 259
	     end;

						STATEMENT 1 ON LINE 261
	call lock$lock_fast (addr (scavenger_data.lock));

001362  aa  6 00154 3515 20	epp1 	pr6|108,*		scavenger_data.lock
001363  aa  6 00462 2515 00	spri1	pr6|306
001364  aa  6 00462 3521 00	epp2 	pr6|306
001365  aa  6 00456 2521 00	spri2	pr6|302
001366  aa  6 00454 6211 00	eax1 	pr6|300
001367  aa   004000 4310 07	fld  	2048,dl
001370  aa  6 00044 3701 20	epp4 	pr6|36,*
001371  la  4 00034 3521 20	epp2 	pr4|28,*		lock$lock_fast
001372  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 263
     end SETUP_LOCK;

001373  aa  6 00166 6101 00	rtcd 	pr6|118
  END PROCEDURE SETUP_LOCK
BEGIN PROCEDURE SETUP_PROCESS_TABLE
ENTRY TO SETUP_PROCESS_TABLE                                STATEMENT 1 ON LINE 267
SETUP_PROCESS_TABLE:
     proc (Process_Index, Code);

001374  aa  6 00174 6501 00	spri4	pr6|124
001375  aa  6 00176 2521 00	spri2	pr6|126
						STATEMENT 1 ON LINE 276
	Process_Index = -1;

001376  aa   000001 3360 07	lcq  	1,dl
001377  aa  2 00002 7561 20	stq  	pr2|2,*		Process_Index
						STATEMENT 1 ON LINE 277
	Code = 0;

001400  aa  2 00004 4501 20	stz  	pr2|4,*		Code
						STATEMENT 1 ON LINE 279
	sc_process_tablep = scavenger_data.process_table_ptr;

001401  aa  6 00154 3735 20	epp7 	pr6|108,*		scavenger_datap
001402  aa  7 00004 3735 20	epp7 	pr7|4,*		scavenger_data.process_table_ptr
001403  aa  6 00156 6535 00	spri7	pr6|110		sc_process_tablep
						STATEMENT 1 ON LINE 280
	if sc_process_table.n_processes >= sc_process_table.max_n_processes
	then do;

001404  aa  7 00001 2361 00	ldq  	pr7|1		sc_process_table.n_processes
001405  aa  7 00000 1161 00	cmpq 	pr7|0		sc_process_table.max_n_processes
001406  aa   000010 6040 04	tmi  	8,ic		001416
						STATEMENT 1 ON LINE 282
RETURN_ERROR:
		sc_process_tablep = null ();

001407  aa   776425 2370 04	ldaq 	-747,ic		000034 = 077777000043 000001000000
001410  aa  6 00156 7571 00	staq 	pr6|110		sc_process_tablep
						STATEMENT 1 ON LINE 284
		Code = error_table_$scavenge_process_limit;

001411  aa  6 00044 3701 20	epp4 	pr6|36,*
001412  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$scavenge_process_limit
001413  aa  6 00176 3735 20	epp7 	pr6|126,*
001414  aa  7 00004 7561 20	stq  	pr7|4,*		Code
						STATEMENT 1 ON LINE 285
		return;

001415  aa  6 00174 6101 00	rtcd 	pr6|124
						STATEMENT 1 ON LINE 286
	     end;

						STATEMENT 1 ON LINE 288
	do procx = 1 repeat procx + 1 while (procx <= sc_process_table.max_n_processes);

001416  aa   000001 2360 07	ldq  	1,dl
001417  aa  6 00203 7561 00	stq  	pr6|131		procx
001420  aa  6 00203 2361 00	ldq  	pr6|131		procx
001421  aa  6 00156 1161 20	cmpq 	pr6|110,*		sc_process_table.max_n_processes
001422  aa   777765 6054 04	tpnz 	-11,ic		001407
						STATEMENT 1 ON LINE 289
	     if sc_process_table.process (procx).processid = ""b
	     then goto FOUND_EMPTY;

001423  aa   000005 4020 07	mpy  	5,dl
001424  aa  6 00464 7561 00	stq  	pr6|308
001425  aa  6 00156 3735 20	epp7 	pr6|110,*		sc_process_tablep
001426  aa  7 77775 2351 06	lda  	pr7|-3,ql		sc_process_table.processid
001427  aa   000004 6000 04	tze  	4,ic		001433
						STATEMENT 1 ON LINE 291
	end;

001430  aa  6 00203 0541 00	aos  	pr6|131		procx
001431  aa   777767 7100 04	tra  	-9,ic		001420
						STATEMENT 1 ON LINE 292
	goto RETURN_ERROR;

001432  aa   777755 7100 04	tra  	-19,ic		001407
						STATEMENT 1 ON LINE 294
FOUND_EMPTY:
	Process_Index = procx;

001433  aa  6 00203 2361 00	ldq  	pr6|131		procx
001434  aa  6 00176 3715 20	epp5 	pr6|126,*
001435  aa  5 00002 7561 20	stq  	pr5|2,*		Process_Index
						STATEMENT 1 ON LINE 296
	sc_process_table.process (procx).processid = pds$processid;

001436  aa  6 00044 3701 20	epp4 	pr6|36,*
001437  la  4 00022 2351 20	lda  	pr4|18,*		pds$processid
001440  aa  6 00464 7271 00	lxl7 	pr6|308
001441  aa  7 77775 7551 17	sta  	pr7|-3,7		sc_process_table.processid
						STATEMENT 1 ON LINE 297
	sc_process_table.process (procx).pvtep = pvtep;

001442  aa  6 00152 3535 20	epp3 	pr6|106,*		pvtep
001443  aa  7 77776 5431 17	sprp3	pr7|-2,7		sc_process_table.pvtep
						STATEMENT 1 ON LINE 299
	sc_process_table.n_processes = sc_process_table.n_processes + 1;

001444  aa  7 00001 0541 00	aos  	pr7|1		sc_process_table.n_processes
						STATEMENT 1 ON LINE 300
	if sc_process_table.n_processes = 1
	then do;

001445  aa  7 00001 2361 00	ldq  	pr7|1		sc_process_table.n_processes
001446  aa   000001 1160 07	cmpq 	1,dl
001447  aa   000017 6010 04	tnz  	15,ic		001466
						STATEMENT 1 ON LINE 302
		n_header_pages = divide (size (scavenger_data) + 1023, 1024, 17);

001450  aa   002031 2360 07	ldq  	1049,dl
001451  aa   002000 5060 07	div  	1024,dl
001452  aa  6 00202 7561 00	stq  	pr6|130		n_header_pages
						STATEMENT 1 ON LINE 303
		call pc_wired$wire_wait (scavenger_data_astep, 0, n_header_pages);

001453  aa  6 00464 4501 00	stz  	pr6|308
001454  aa  6 00144 3521 00	epp2 	pr6|100		scavenger_data_astep
001455  aa  6 00470 2521 00	spri2	pr6|312
001456  aa  6 00464 3521 00	epp2 	pr6|308
001457  aa  6 00472 2521 00	spri2	pr6|314
001460  aa  6 00202 3521 00	epp2 	pr6|130		n_header_pages
001461  aa  6 00474 2521 00	spri2	pr6|316
001462  aa  6 00466 6211 00	eax1 	pr6|310
001463  aa   014000 4310 07	fld  	6144,dl
001464  la  4 00042 3521 20	epp2 	pr4|34,*		pc_wired$wire_wait
001465  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 304
	     end;

						STATEMENT 1 ON LINE 307
     end SETUP_PROCESS_TABLE;

001466  aa  6 00174 6101 00	rtcd 	pr6|124
  END PROCEDURE SETUP_PROCESS_TABLE
BEGIN PROCEDURE SETUP_BLOCK
ENTRY TO SETUP_BLOCK                                        STATEMENT 1 ON LINE 311
SETUP_BLOCK:
     proc (Process_Index);

001467  aa  6 00204 6501 00	spri4	pr6|132
001470  aa  6 00206 2521 00	spri2	pr6|134
						STATEMENT 1 ON LINE 320
	scavenger_n_records = pvte.totrec;

001471  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
001472  aa  7 00007 2351 00	lda  	pr7|7		pvte.totrec
001473  aa   000022 7350 00	als  	18
001474  aa   000066 7330 00	lrs  	54
001475  aa  6 00162 7561 00	stq  	pr6|114		scavenger_n_records
						STATEMENT 1 ON LINE 321
	scavenger_n_ovfl = N_OVFL;

001476  aa   001777 2360 07	ldq  	1023,dl
001477  aa  6 00163 7561 00	stq  	pr6|115		scavenger_n_ovfl
						STATEMENT 1 ON LINE 323
	first_page = sc_process_table.process (Process_Index).first_block_page;

001500  aa  2 00002 2361 20	ldq  	pr2|2,*		Process_Index
001501  aa   000005 4020 07	mpy  	5,dl
001502  aa  6 00156 2361 66	ldq  	pr6|110,*ql	sc_process_table.first_block_page
001503  aa  6 00212 7561 00	stq  	pr6|138		first_page
						STATEMENT 1 ON LINE 324
	n_pages = divide (size (scavenger_block) + 1023, 1024, 17);

001504  aa  6 00162 2361 00	ldq  	pr6|114		scavenger_n_records
001505  aa   000003 0760 07	adq  	3,dl
001506  aa  6 00163 0761 00	adq  	pr6|115		scavenger_n_ovfl
001507  aa   001777 0760 07	adq  	1023,dl
001510  aa   002000 5060 07	div  	1024,dl
001511  aa  6 00213 7561 00	stq  	pr6|139		n_pages
						STATEMENT 1 ON LINE 326
	scavenger_blockp = sc_process_table.process (process_tablex).blockp;

001512  aa  6 00140 2361 00	ldq  	pr6|96		process_tablex
001513  aa   000005 4020 07	mpy  	5,dl
001514  aa  6 00156 3715 20	epp5 	pr6|110,*		sc_process_tablep
001515  aa  5 77777 7651 06	lprp5	pr5|-1,ql		sc_process_table.blockp
001516  aa  6 00160 6515 00	spri5	pr6|112		scavenger_blockp
						STATEMENT 1 ON LINE 328
	scavenger_block.n_records = scavenger_n_records;

001517  aa  6 00162 2361 00	ldq  	pr6|114		scavenger_n_records
001520  aa  5 00000 7561 00	stq  	pr5|0		scavenger_block.n_records
						STATEMENT 1 ON LINE 329
	scavenger_block.n_ovfl = scavenger_n_ovfl;

001521  aa  6 00163 2361 00	ldq  	pr6|115		scavenger_n_ovfl
001522  aa  5 00001 7561 00	stq  	pr5|1		scavenger_block.n_ovfl
						STATEMENT 1 ON LINE 330
	scavenger_block.ovfl_free_ix = 1;

001523  aa   000001 2360 07	ldq  	1,dl
001524  aa  5 00002 7561 00	stq  	pr5|2		scavenger_block.ovfl_free_ix
						STATEMENT 1 ON LINE 332
	unspec (scavenger_block.records) = ""b;

001525  aa  5 00000 2361 00	ldq  	pr5|0		scavenger_block.n_records
001526  aa   000044 4020 07	mpy  	36,dl
001527  aa   000010 0760 07	adq  	8,dl
001530  aa   000011 5060 07	div  	9,dl
001531  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
001532  aa   000000 00 0000	desc9a	0,0
001533  aa  5 00003 00 0006	desc9a	pr5|3,ql
						STATEMENT 1 ON LINE 333
	unspec (scavenger_block.overflow) = ""b;

001534  aa  5 00001 2361 00	ldq  	pr5|1		scavenger_block.n_ovfl
001535  aa   000044 4020 07	mpy  	36,dl
001536  aa   000010 0760 07	adq  	8,dl
001537  aa   000011 5060 07	div  	9,dl
001540  aa  5 00000 7271 00	lxl7 	pr5|0		scavenger_block.n_records
001541  aa  5 00003 3735 17	epp7 	pr5|3,7
001542  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
001543  aa   000000 00 0000	desc9a	0,0
001544  aa  7 00000 00 0006	desc9a	pr7|0,ql
						STATEMENT 1 ON LINE 336
	call pc_wired$wire_wait (scavenger_data_astep, first_page, n_pages);

001545  aa  6 00144 3521 00	epp2 	pr6|100		scavenger_data_astep
001546  aa  6 00500 2521 00	spri2	pr6|320
001547  aa  6 00212 3521 00	epp2 	pr6|138		first_page
001550  aa  6 00502 2521 00	spri2	pr6|322
001551  aa  6 00213 3521 00	epp2 	pr6|139		n_pages
001552  aa  6 00504 2521 00	spri2	pr6|324
001553  aa  6 00476 6211 00	eax1 	pr6|318
001554  aa   014000 4310 07	fld  	6144,dl
001555  aa  6 00044 3701 20	epp4 	pr6|36,*
001556  la  4 00042 3521 20	epp2 	pr4|34,*		pc_wired$wire_wait
001557  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 338
	sc_process_table.process (Process_Index).n_block_pages = n_pages;

001560  aa  6 00206 3735 20	epp7 	pr6|134,*
001561  aa  7 00002 2361 20	ldq  	pr7|2,*		Process_Index
001562  aa   000005 4020 07	mpy  	5,dl
001563  aa   000000 6270 06	eax7 	0,ql
001564  aa  6 00213 2361 00	ldq  	pr6|139		n_pages
001565  aa  6 00156 3715 20	epp5 	pr6|110,*		sc_process_tablep
001566  aa  5 00001 7561 17	stq  	pr5|1,7		sc_process_table.n_block_pages
						STATEMENT 1 ON LINE 340
     end SETUP_BLOCK;

001567  aa  6 00204 6101 00	rtcd 	pr6|132
  END PROCEDURE SETUP_BLOCK
BEGIN PROCEDURE RETURN_BLOCK
ENTRY TO RETURN_BLOCK                                       STATEMENT 1 ON LINE 344
RETURN_BLOCK:
     proc (Process_Index);

001570  aa  6 00214 6501 00	spri4	pr6|140
001571  aa  6 00216 2521 00	spri2	pr6|142
						STATEMENT 1 ON LINE 353
	if sc_process_table.process (Process_Index).processid ^= pds$processid
	then call syserr (CRASH, "scavenger: Invalid block reset");

001572  aa  2 00002 2361 20	ldq  	pr2|2,*		Process_Index
001573  aa   000005 4020 07	mpy  	5,dl
001574  aa  6 00156 3735 20	epp7 	pr6|110,*		sc_process_tablep
001575  aa  7 77775 2351 06	lda  	pr7|-3,ql		sc_process_table.processid
001576  aa  6 00044 3701 20	epp4 	pr6|36,*
001577  la  4 00022 1151 20	cmpa 	pr4|18,*		pds$processid
001600  aa   000020 6000 04	tze  	16,ic		001620
001601  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001602  aa   776240 00 0040	desc9a	-864,32		000041 = 163143141166
001603  aa  6 00510 00 0040	desc9a	pr6|328,32
001604  aa   776225 3520 04	epp2 	-875,ic		000031 = 000000000001
001605  aa  6 00522 2521 00	spri2	pr6|338
001606  aa  6 00510 3521 00	epp2 	pr6|328
001607  aa  6 00524 2521 00	spri2	pr6|340
001610  aa   776222 3520 04	epp2 	-878,ic		000032 = 404000000021
001611  aa  6 00526 2521 00	spri2	pr6|342
001612  aa   776176 3520 04	epp2 	-898,ic		000010 = 524000000036
001613  aa  6 00530 2521 00	spri2	pr6|344
001614  aa  6 00520 6211 00	eax1 	pr6|336
001615  aa   010000 4310 07	fld  	4096,dl
001616  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
001617  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 356
	first_page = sc_process_table.process (Process_Index).first_block_page;

001620  aa  6 00216 3735 20	epp7 	pr6|142,*
001621  aa  7 00002 2361 20	ldq  	pr7|2,*		Process_Index
001622  aa   000005 4020 07	mpy  	5,dl
001623  aa   000000 6270 06	eax7 	0,ql
001624  aa  6 00156 2361 66	ldq  	pr6|110,*ql	sc_process_table.first_block_page
001625  aa  6 00222 7561 00	stq  	pr6|146		first_page
						STATEMENT 1 ON LINE 357
	n_pages = sc_process_table.process (Process_Index).n_block_pages;

001626  aa  6 00156 3715 20	epp5 	pr6|110,*		sc_process_tablep
001627  aa  5 00001 2361 17	ldq  	pr5|1,7		sc_process_table.n_block_pages
001630  aa  6 00223 7561 00	stq  	pr6|147		n_pages
						STATEMENT 1 ON LINE 358
	call pc_wired$unwire (scavenger_data_astep, first_page, n_pages);

001631  aa  6 00144 3521 00	epp2 	pr6|100		scavenger_data_astep
001632  aa  6 00512 2521 00	spri2	pr6|330
001633  aa  6 00222 3521 00	epp2 	pr6|146		first_page
001634  aa  6 00514 2521 00	spri2	pr6|332
001635  aa  6 00223 3521 00	epp2 	pr6|147		n_pages
001636  aa  6 00516 2521 00	spri2	pr6|334
001637  aa  6 00510 6211 00	eax1 	pr6|328
001640  aa   014000 4310 07	fld  	6144,dl
001641  aa  6 00044 3701 20	epp4 	pr6|36,*
001642  la  4 00044 3521 20	epp2 	pr4|36,*		pc_wired$unwire
001643  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 362
     end RETURN_BLOCK;

001644  aa  6 00214 6101 00	rtcd 	pr6|140
  END PROCEDURE RETURN_BLOCK
BEGIN PROCEDURE RETURN_PROCESS_TABLE
ENTRY TO RETURN_PROCESS_TABLE                               STATEMENT 1 ON LINE 366
RETURN_PROCESS_TABLE:
     proc (Process_Index);

001645  aa  6 00224 6501 00	spri4	pr6|148
001646  aa  6 00226 2521 00	spri2	pr6|150
						STATEMENT 1 ON LINE 372
	if sc_process_table.process (Process_Index).processid ^= pds$processid
	then call syserr (CRASH, "scavenger: Process table entry not owned by this process.");

001647  aa  2 00002 2361 20	ldq  	pr2|2,*		Process_Index
001650  aa   000005 4020 07	mpy  	5,dl
001651  aa  6 00156 3735 20	epp7 	pr6|110,*		sc_process_tablep
001652  aa  7 77775 2351 06	lda  	pr7|-3,ql		sc_process_table.processid
001653  aa  6 00044 3701 20	epp4 	pr6|36,*
001654  la  4 00022 1151 20	cmpa 	pr4|18,*		pds$processid
001655  aa   000020 6000 04	tze  	16,ic		001675
001656  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001657  aa   776241 00 0074	desc9a	-863,60		000117 = 163143141166
001660  aa  6 00532 00 0074	desc9a	pr6|346,60
001661  aa   776150 3520 04	epp2 	-920,ic		000031 = 000000000001
001662  aa  6 00554 2521 00	spri2	pr6|364
001663  aa  6 00532 3521 00	epp2 	pr6|346
001664  aa  6 00556 2521 00	spri2	pr6|366
001665  aa   776145 3520 04	epp2 	-923,ic		000032 = 404000000021
001666  aa  6 00560 2521 00	spri2	pr6|368
001667  aa   776120 3520 04	epp2 	-944,ic		000007 = 524000000071
001670  aa  6 00562 2521 00	spri2	pr6|370
001671  aa  6 00552 6211 00	eax1 	pr6|362
001672  aa   010000 4310 07	fld  	4096,dl
001673  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
001674  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 375
	sc_process_table.process (Process_Index).processid = ""b;

001675  aa  6 00226 3735 20	epp7 	pr6|150,*
001676  aa  7 00002 2361 20	ldq  	pr7|2,*		Process_Index
001677  aa   000005 4020 07	mpy  	5,dl
001700  aa  6 00156 3715 20	epp5 	pr6|110,*		sc_process_tablep
001701  aa  5 77775 4501 06	stz  	pr5|-3,ql		sc_process_table.processid
						STATEMENT 1 ON LINE 376
	sc_process_table.process (Process_Index).pvtep = null ();

001702  aa   000000 6270 06	eax7 	0,ql
001703  aa   000476 2360 04	ldq  	318,ic		002401 = 007777000001
001704  aa  5 77776 7561 17	stq  	pr5|-2,7		sc_process_table.pvtep
						STATEMENT 1 ON LINE 377
	sc_process_table.process (Process_Index).n_block_pages = 0;

001705  aa  5 00001 4501 17	stz  	pr5|1,7		sc_process_table.n_block_pages
						STATEMENT 1 ON LINE 379
	sc_process_table.n_processes = sc_process_table.n_processes - 1;

001706  aa   000001 3360 07	lcq  	1,dl
001707  aa  5 00001 0561 00	asq  	pr5|1		sc_process_table.n_processes
						STATEMENT 1 ON LINE 380
	if sc_process_table.n_processes = 0
	then do;

001710  aa  5 00001 2361 00	ldq  	pr5|1		sc_process_table.n_processes
001711  aa   000020 6010 04	tnz  	16,ic		001731
						STATEMENT 1 ON LINE 382
		n_header_pages = divide (size (scavenger_data) + 1023, 1024, 17);

001712  aa   002031 2360 07	ldq  	1049,dl
001713  aa   002000 5060 07	div  	1024,dl
001714  aa  6 00232 7561 00	stq  	pr6|154		n_header_pages
						STATEMENT 1 ON LINE 383
		call pc_wired$unwire (scavenger_data_astep, 0, n_header_pages);

001715  aa  6 00551 4501 00	stz  	pr6|361
001716  aa  6 00144 3521 00	epp2 	pr6|100		scavenger_data_astep
001717  aa  6 00554 2521 00	spri2	pr6|364
001720  aa  6 00551 3521 00	epp2 	pr6|361
001721  aa  6 00556 2521 00	spri2	pr6|366
001722  aa  6 00232 3521 00	epp2 	pr6|154		n_header_pages
001723  aa  6 00560 2521 00	spri2	pr6|368
001724  aa  6 00552 6211 00	eax1 	pr6|362
001725  aa   014000 4310 07	fld  	6144,dl
001726  aa  6 00044 3701 20	epp4 	pr6|36,*
001727  la  4 00044 3521 20	epp2 	pr4|36,*		pc_wired$unwire
001730  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 384
	     end;

						STATEMENT 1 ON LINE 387
     end RETURN_PROCESS_TABLE;

001731  aa  6 00224 6101 00	rtcd 	pr6|148
  END PROCEDURE RETURN_PROCESS_TABLE
BEGIN PROCEDURE PRINT_ERROR
ENTRY TO PRINT_ERROR                                        STATEMENT 1 ON LINE 392
PRINT_ERROR:
     proc (Mcptr, Condition, Coptr, Infoptr, Continue) options (non_quick);

001732  da     000335200000
001733  aa   000500 6270 00	eax7 	320
001734  aa  7 00034 3521 20	epp2 	pr7|28,*
001735  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
001736  aa     000012000000
001737  aa     000000000000
001740  aa  6 00042 3735 20	epp7 	pr6|34,*
001741  aa  7 00002 2361 20	ldq  	pr7|2,*
001742  aa   000002 6040 04	tmi  	2,ic		001744
001743  aa   777777 3760 07	anq  	262143,dl
001744  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001745  aa  6 00363 7561 00	stq  	pr6|243
						STATEMENT 1 ON LINE 405
	if Mcptr ^= null ()
	then do;

001746  aa  6 00032 3715 20	epp5 	pr6|26,*
001747  aa  5 00002 2371 20	ldaq 	pr5|2,*		Mcptr
001750  aa   776064 6770 04	eraq 	-972,ic		000034 = 077777000043 000001000000
001751  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001752  aa   000127 6000 04	tze  	87,ic		002101
						STATEMENT 1 ON LINE 407
		ssptr = addrel (Mcptr, -8);

001753  aa  5 00002 3521 20	epp2 	pr5|2,*		Mcptr
001754  aa  2 00000 3521 20	epp2 	pr2|0,*		Mcptr
001755  aa   777770 0520 03	adwp2	262136,du
001756  aa  6 00360 2521 00	spri2	pr6|240		ssptr
						STATEMENT 1 ON LINE 410
		unspec (auto_fault_msg.mach_cond) = unspec (ssptr -> signaller_stack.mach_cond);

001757  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001760  aa  2 00010 00 0300	desc9a	pr2|8,192
001761  aa  6 00100 00 0300	desc9a	pr6|64,192
						STATEMENT 1 ON LINE 411
		auto_fault_msg.hist_reg = ssptr -> signaller_stack.history_registers;

001762  aa   000001 2360 07	ldq  	1,dl
001763  aa  6 00362 7561 00	stq  	pr6|242
001764  aa  6 00362 7271 00	lxl7 	pr6|242
001765  aa  6 00360 3735 20	epp7 	pr6|240,*		ssptr
001766  aa  7 00147 2351 17	lda  	pr7|103,7		signaller_stack.history_registers
001767  aa  6 00157 7551 17	sta  	pr6|111,7		auto_fault_msg.hist_reg
001770  aa  6 00362 2361 00	ldq  	pr6|242
001771  aa  6 00362 0541 00	aos  	pr6|242
001772  aa   000200 1160 07	cmpq 	128,dl
001773  aa   777771 6040 04	tmi  	-7,ic		001764
						STATEMENT 1 ON LINE 413
		call syserr$binary (scavenger_data.error_severity, Mcptr, SB_hw_fault, SBL_hw_fault,
		     "scavenger: ^a condition signalled during scavenge of ^a_^a^[^a^;^1s^] by ^a", Condition,
		     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name,
		     pds$process_group_id);

001774  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001775  aa   776163 00 0114	desc9a	-909,76		000157 = 163143141166
001776  aa  6 00364 00 0114	desc9a	pr6|244,76
001777  aa  6 00040 3715 20	epp5 	pr6|32,*
002000  aa  5 00152 3535 20	epp3 	pr5|106,*		pvtep
002001  aa  3 00004 2351 00	lda  	pr3|4		pvte.logical_area_number
002002  aa   000011 7350 00	als  	9
002003  aa   000077 7330 00	lrs  	63
002004  aa  6 00411 7561 00	stq  	pr6|265		pvte.logical_area_number
002005  aa  000 100 301 500	btd  	(pr),(pr)
002006  aa  6 00411 00 0004	desc9a	pr6|265,4		pvte.logical_area_number
002007  aa  6 00410 01 0003	desc9ls	pr6|264,3,0
002010  aa  6 00407 4501 00	stz  	pr6|263
002011  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
002012  aa  6 00410 01 0003	desc9ls	pr6|264,3,0
002013  aa   000373 00 0002	desc9a	251,2		002404 = 070322000000
002014  aa  6 00407 00 0002	desc9a	pr6|263,2
002015  aa  5 00154 3515 20	epp1 	pr5|108,*		scavenger_datap
002016  aa  1 00006 3521 00	epp2 	pr1|6		scavenger_data.error_severity
002017  aa  6 00414 2521 00	spri2	pr6|268
002020  aa  6 00032 3735 20	epp7 	pr6|26,*
002021  aa  7 00002 3521 20	epp2 	pr7|2,*		Mcptr
002022  aa  6 00416 2521 00	spri2	pr6|270
002023  aa   776004 3520 04	epp2 	-1020,ic		000027 = 000000000002
002024  aa  6 00420 2521 00	spri2	pr6|272
002025  aa   775753 3520 04	epp2 	-1045,ic		000000 = 000000000260
002026  aa  6 00422 2521 00	spri2	pr6|274
002027  aa  6 00364 3521 00	epp2 	pr6|244
002030  aa  6 00424 2521 00	spri2	pr6|276
002031  aa  7 00004 3521 20	epp2 	pr7|4,*		Condition
002032  aa  6 00426 2521 00	spri2	pr6|278
002033  aa  3 00003 3521 00	epp2 	pr3|3		pvte.devname
002034  aa  6 00430 2521 00	spri2	pr6|280
002035  aa  6 00407 3521 00	epp2 	pr6|263
002036  aa  6 00432 2521 00	spri2	pr6|282
002037  aa   000003 7260 07	lxl6 	3,dl
002040  aa  3 00002 3521 00	epp2 	pr3|2		pvte.is_sv
002041  aa  2 00000 5035 16	abd  	pr2|0,6
002042  aa  6 00434 2521 00	spri2	pr6|284
002043  aa  3 00015 3521 00	epp2 	pr3|13		pvte.sv_name
002044  aa  6 00436 2521 00	spri2	pr6|286
002045  aa  6 00044 3701 20	epp4 	pr6|36,*
002046  la  4 00020 3521 20	epp2 	pr4|16,*		pds$process_group_id
002047  aa  6 00440 2521 00	spri2	pr6|288
002050  aa   775762 3520 04	epp2 	-1038,ic		000032 = 404000000021
002051  aa  6 00442 2521 00	spri2	pr6|290
002052  aa  6 00446 2521 00	spri2	pr6|294
002053  aa  6 00450 2521 00	spri2	pr6|296
002054  aa   775752 3520 04	epp2 	-1046,ic		000026 = 464000000000
002055  aa  6 00444 2521 00	spri2	pr6|292
002056  aa   775726 3520 04	epp2 	-1066,ic		000004 = 524000000113
002057  aa  6 00452 2521 00	spri2	pr6|298
002060  aa  6 00042 3515 20	epp1 	pr6|34,*
002061  aa  1 00002 3521 20	epp2 	pr1|2,*
002062  aa  6 00454 2521 00	spri2	pr6|300
002063  aa   775734 3520 04	epp2 	-1060,ic		000017 = 524000000004
002064  aa  6 00456 2521 00	spri2	pr6|302
002065  aa   775731 3520 04	epp2 	-1063,ic		000016 = 524000000002
002066  aa  6 00460 2521 00	spri2	pr6|304
002067  aa  6 00464 2521 00	spri2	pr6|308
002070  aa   775725 3520 04	epp2 	-1067,ic		000015 = 516000000001
002071  aa  6 00462 2521 00	spri2	pr6|306
002072  aa   775722 3520 04	epp2 	-1070,ic		000014 = 524000000040
002073  aa  6 00466 2521 00	spri2	pr6|310
002074  aa  6 00412 6211 00	eax1 	pr6|266
002075  aa   054000 4310 07	fld  	22528,dl
002076  la  4 00056 3521 20	epp2 	pr4|46,*		syserr$binary
002077  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 417
	     end;

002100  aa   000071 7100 04	tra  	57,ic		002171
						STATEMENT 1 ON LINE 418
	else do;

						STATEMENT 1 ON LINE 419
		call syserr (scavenger_data.error_severity,
		     "scavenger: ^a condition signalled during scavenge of ^a_^a^[^a^;^1s^] by ^a", Condition,
		     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name,
		     pds$process_group_id);

002101  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002102  aa   776056 00 0114	desc9a	-978,76		000157 = 163143141166
002103  aa  6 00364 00 0114	desc9a	pr6|244,76
002104  aa  6 00040 3535 20	epp3 	pr6|32,*
002105  aa  3 00152 3515 20	epp1 	pr3|106,*		pvtep
002106  aa  1 00004 2351 00	lda  	pr1|4		pvte.logical_area_number
002107  aa   000011 7350 00	als  	9
002110  aa   000077 7330 00	lrs  	63
002111  aa  6 00411 7561 00	stq  	pr6|265		pvte.logical_area_number
002112  aa  000 100 301 500	btd  	(pr),(pr)
002113  aa  6 00411 00 0004	desc9a	pr6|265,4		pvte.logical_area_number
002114  aa  6 00410 01 0003	desc9ls	pr6|264,3,0
002115  aa  6 00407 4501 00	stz  	pr6|263
002116  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
002117  aa  6 00410 01 0003	desc9ls	pr6|264,3,0
002120  aa   000266 00 0002	desc9a	182,2		002404 = 070322000000
002121  aa  6 00407 00 0002	desc9a	pr6|263,2
002122  aa  3 00154 3735 20	epp7 	pr3|108,*		scavenger_datap
002123  aa  7 00006 3521 00	epp2 	pr7|6		scavenger_data.error_severity
002124  aa  6 00414 2521 00	spri2	pr6|268
002125  aa  6 00364 3521 00	epp2 	pr6|244
002126  aa  6 00416 2521 00	spri2	pr6|270
002127  aa  5 00004 3521 20	epp2 	pr5|4,*		Condition
002130  aa  6 00420 2521 00	spri2	pr6|272
002131  aa  1 00003 3521 00	epp2 	pr1|3		pvte.devname
002132  aa  6 00422 2521 00	spri2	pr6|274
002133  aa  6 00407 3521 00	epp2 	pr6|263
002134  aa  6 00424 2521 00	spri2	pr6|276
002135  aa   000003 7270 07	lxl7 	3,dl
002136  aa  1 00002 3521 00	epp2 	pr1|2		pvte.is_sv
002137  aa  2 00000 5035 17	abd  	pr2|0,7
002140  aa  6 00426 2521 00	spri2	pr6|278
002141  aa  1 00015 3521 00	epp2 	pr1|13		pvte.sv_name
002142  aa  6 00430 2521 00	spri2	pr6|280
002143  la  4 00020 3521 20	epp2 	pr4|16,*		pds$process_group_id
002144  aa  6 00432 2521 00	spri2	pr6|282
002145  aa   775665 3520 04	epp2 	-1099,ic		000032 = 404000000021
002146  aa  6 00434 2521 00	spri2	pr6|284
002147  aa   775635 3520 04	epp2 	-1123,ic		000004 = 524000000113
002150  aa  6 00436 2521 00	spri2	pr6|286
002151  aa  6 00042 3735 20	epp7 	pr6|34,*
002152  aa  7 00002 3521 20	epp2 	pr7|2,*
002153  aa  6 00440 2521 00	spri2	pr6|288
002154  aa   775643 3520 04	epp2 	-1117,ic		000017 = 524000000004
002155  aa  6 00442 2521 00	spri2	pr6|290
002156  aa   775640 3520 04	epp2 	-1120,ic		000016 = 524000000002
002157  aa  6 00444 2521 00	spri2	pr6|292
002160  aa  6 00450 2521 00	spri2	pr6|296
002161  aa   775634 3520 04	epp2 	-1124,ic		000015 = 516000000001
002162  aa  6 00446 2521 00	spri2	pr6|294
002163  aa   775631 3520 04	epp2 	-1127,ic		000014 = 524000000040
002164  aa  6 00452 2521 00	spri2	pr6|298
002165  aa  6 00412 6211 00	eax1 	pr6|266
002166  aa   040000 4310 07	fld  	16384,dl
002167  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
002170  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 423
	     end;

						STATEMENT 1 ON LINE 425
	if sst$astl = pds$processid
	then call lock$unlock_ast;

002171  aa  6 00044 3701 20	epp4 	pr6|36,*
002172  la  4 00024 2351 20	lda  	pr4|20,*		sst$astl
002173  la  4 00022 1151 20	cmpa 	pr4|18,*		pds$processid
002174  aa   000005 6010 04	tnz  	5,ic		002201
002175  aa  6 00056 6211 00	eax1 	pr6|46
002176  aa   000000 4310 07	fld  	0,dl
002177  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_ast
002200  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 427
	call verify_lock$condition_nolog (Condition, Mcptr);

002201  aa  6 00032 3735 20	epp7 	pr6|26,*
002202  aa  7 00004 3521 20	epp2 	pr7|4,*		Condition
002203  aa  6 00366 2521 00	spri2	pr6|246
002204  aa  7 00002 3521 20	epp2 	pr7|2,*		Mcptr
002205  aa  6 00370 2521 00	spri2	pr6|248
002206  aa  6 00042 3715 20	epp5 	pr6|34,*
002207  aa  5 00002 3521 20	epp2 	pr5|2,*
002210  aa  6 00372 2521 00	spri2	pr6|250
002211  aa   775615 3520 04	epp2 	-1139,ic		000026 = 464000000000
002212  aa  6 00374 2521 00	spri2	pr6|252
002213  aa  6 00364 6211 00	eax1 	pr6|244
002214  aa   010000 4310 07	fld  	4096,dl
002215  aa  6 00044 3701 20	epp4 	pr6|36,*
002216  la  4 00064 3521 20	epp2 	pr4|52,*		verify_lock$condition_nolog
002217  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 430
	code = error_table_$unexpected_condition;

002220  aa  6 00044 3701 20	epp4 	pr6|36,*
002221  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$unexpected_condition
002222  aa  6 00040 3735 20	epp7 	pr6|32,*
002223  aa  7 00106 7561 00	stq  	pr7|70		code
						STATEMENT 1 ON LINE 432
	goto LOCK_CLEANUP_RETURN;

002224  aa   776305 3520 04	epp2 	-827,ic		000531 = 600154373520
002225  aa   000001 7270 07	lxl7 	1,dl
002226  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 434
     end PRINT_ERROR;

  END PROCEDURE PRINT_ERROR
BEGIN PROCEDURE PRINT_METERS
ENTRY TO PRINT_METERS                                       STATEMENT 1 ON LINE 438
PRINT_METERS:
     proc;

002227  aa  6 00234 6501 00	spri4	pr6|156
						STATEMENT 1 ON LINE 444
	vcpu_sec = float (local_sc_meters.vcpu) / 1.0e6;

002230  aa   775553 4310 04	fld  	-1173,ic		000003 = 050750220000
002231  aa  6 00564 4571 00	dfst 	pr6|372
002232  aa  6 00116 2371 00	ldaq 	pr6|78		local_sc_meters.vcpu
002233  aa   216000 4110 03	lde  	72704,du
002234  aa   400000 4750 03	fad  	131072,du
002235  aa  6 00564 5671 00	dfdv 	pr6|372
002236  aa  6 00243 4551 00	fst  	pr6|163		vcpu_sec
						STATEMENT 1 ON LINE 445
	clock_sec = float (local_sc_meters.clock_time) / 1.0e6;

002237  aa   775544 4310 04	fld  	-1180,ic		000003 = 050750220000
002240  aa  6 00564 4571 00	dfst 	pr6|372
002241  aa  6 00120 2371 00	ldaq 	pr6|80		local_sc_meters.clock_time
002242  aa   216000 4110 03	lde  	72704,du
002243  aa   400000 4750 03	fad  	131072,du
002244  aa  6 00564 5671 00	dfdv 	pr6|372
002245  aa  6 00242 4551 00	fst  	pr6|162		clock_sec
						STATEMENT 1 ON LINE 447
	call syserr (LOG,
	     "scavenger: Meters from scavenge of ^a_^a^[^a^;^1s^]. Clock=^6.1f vcpu=^6.1f pf=^d^/VTOCES: Total=^d Damaged=^d Per-Proc=^d Per-Boot=^d FMDamaged=^d Freed=^d^/Records: Total=^d Pot conflict=^d FMD Conflict = ^d Conflict=^d Lost=^d",
	     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, clock_sec, vcpu_sec,
	     local_sc_meters.pf, local_sc_meters.n_vtoces, local_sc_meters.n_vtoces_damaged,
	     local_sc_meters.n_vtoces_per_proc, local_sc_meters.n_vtoces_per_boot, local_sc_meters.n_vtoces_fmd,
	     local_sc_meters.n_vtoces_freed, local_sc_meters.n_records, local_sc_meters.n_conflicts,
	     local_sc_meters.n_fmd_conflicts, local_sc_meters.n_real_conflicts, local_sc_meters.n_lost_records);

002246  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002247  aa   775734 00 0350	desc9a	-1060,232		000202 = 163143141166
002250  aa  6 00566 00 0350	desc9a	pr6|374,232
002251  aa  6 00152 3735 20	epp7 	pr6|106,*		pvtep
002252  aa  7 00004 2351 00	lda  	pr7|4		pvte.logical_area_number
002253  aa   000011 7350 00	als  	9
002254  aa   000077 7330 00	lrs  	63
002255  aa  6 00662 7561 00	stq  	pr6|434		pvte.logical_area_number
002256  aa  000 100 301 500	btd  	(pr),(pr)
002257  aa  6 00662 00 0004	desc9a	pr6|434,4		pvte.logical_area_number
002260  aa  6 00661 01 0003	desc9ls	pr6|433,3,0
002261  aa  6 00660 4501 00	stz  	pr6|432
002262  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
002263  aa  6 00661 01 0003	desc9ls	pr6|433,3,0
002264  aa   000122 00 0002	desc9a	82,2		002404 = 070322000000
002265  aa  6 00660 00 0002	desc9a	pr6|432,2
002266  aa   775537 3520 04	epp2 	-1185,ic		000025 = 000000000004
002267  aa  6 00666 2521 00	spri2	pr6|438
002270  aa  6 00566 3521 00	epp2 	pr6|374
002271  aa  6 00670 2521 00	spri2	pr6|440
002272  aa  7 00003 3521 00	epp2 	pr7|3		pvte.devname
002273  aa  6 00672 2521 00	spri2	pr6|442
002274  aa  6 00660 3521 00	epp2 	pr6|432
002275  aa  6 00674 2521 00	spri2	pr6|444
002276  aa   000003 7270 07	lxl7 	3,dl
002277  aa  7 00002 3521 00	epp2 	pr7|2		pvte.is_sv
002300  aa  2 00000 5035 17	abd  	pr2|0,7
002301  aa  6 00676 2521 00	spri2	pr6|446
002302  aa  7 00015 3521 00	epp2 	pr7|13		pvte.sv_name
002303  aa  6 00700 2521 00	spri2	pr6|448
002304  aa  6 00242 3521 00	epp2 	pr6|162		clock_sec
002305  aa  6 00702 2521 00	spri2	pr6|450
002306  aa  6 00243 3521 00	epp2 	pr6|163		vcpu_sec
002307  aa  6 00704 2521 00	spri2	pr6|452
002310  aa  6 00115 3521 00	epp2 	pr6|77		local_sc_meters.pf
002311  aa  6 00706 2521 00	spri2	pr6|454
002312  aa  6 00122 3521 00	epp2 	pr6|82		local_sc_meters.n_vtoces
002313  aa  6 00710 2521 00	spri2	pr6|456
002314  aa  6 00123 3521 00	epp2 	pr6|83		local_sc_meters.n_vtoces_damaged
002315  aa  6 00712 2521 00	spri2	pr6|458
002316  aa  6 00124 3521 00	epp2 	pr6|84		local_sc_meters.n_vtoces_per_proc
002317  aa  6 00714 2521 00	spri2	pr6|460
002320  aa  6 00125 3521 00	epp2 	pr6|85		local_sc_meters.n_vtoces_per_boot
002321  aa  6 00716 2521 00	spri2	pr6|462
002322  aa  6 00127 3521 00	epp2 	pr6|87		local_sc_meters.n_vtoces_fmd
002323  aa  6 00720 2521 00	spri2	pr6|464
002324  aa  6 00126 3521 00	epp2 	pr6|86		local_sc_meters.n_vtoces_freed
002325  aa  6 00722 2521 00	spri2	pr6|466
002326  aa  6 00130 3521 00	epp2 	pr6|88		local_sc_meters.n_records
002327  aa  6 00724 2521 00	spri2	pr6|468
002330  aa  6 00131 3521 00	epp2 	pr6|89		local_sc_meters.n_conflicts
002331  aa  6 00726 2521 00	spri2	pr6|470
002332  aa  6 00132 3521 00	epp2 	pr6|90		local_sc_meters.n_fmd_conflicts
002333  aa  6 00730 2521 00	spri2	pr6|472
002334  aa  6 00133 3521 00	epp2 	pr6|91		local_sc_meters.n_real_conflicts
002335  aa  6 00732 2521 00	spri2	pr6|474
002336  aa  6 00134 3521 00	epp2 	pr6|92		local_sc_meters.n_lost_records
002337  aa  6 00734 2521 00	spri2	pr6|476
002340  aa   775472 3520 04	epp2 	-1222,ic		000032 = 404000000021
002341  aa  6 00736 2521 00	spri2	pr6|478
002342  aa   775440 3520 04	epp2 	-1248,ic		000002 = 524000000345
002343  aa  6 00740 2521 00	spri2	pr6|480
002344  aa   775453 3520 04	epp2 	-1237,ic		000017 = 524000000004
002345  aa  6 00742 2521 00	spri2	pr6|482
002346  aa   775450 3520 04	epp2 	-1240,ic		000016 = 524000000002
002347  aa  6 00744 2521 00	spri2	pr6|484
002350  aa  6 00750 2521 00	spri2	pr6|488
002351  aa   775444 3520 04	epp2 	-1244,ic		000015 = 516000000001
002352  aa  6 00746 2521 00	spri2	pr6|486
002353  aa   775426 3520 04	epp2 	-1258,ic		000001 = 414000000033
002354  aa  6 00752 2521 00	spri2	pr6|490
002355  aa  6 00754 2521 00	spri2	pr6|492
002356  aa   775446 3520 04	epp2 	-1242,ic		000024 = 404000000043
002357  aa  6 00756 2521 00	spri2	pr6|494
002360  aa  6 00760 2521 00	spri2	pr6|496
002361  aa  6 00762 2521 00	spri2	pr6|498
002362  aa  6 00764 2521 00	spri2	pr6|500
002363  aa  6 00766 2521 00	spri2	pr6|502
002364  aa  6 00770 2521 00	spri2	pr6|504
002365  aa  6 00772 2521 00	spri2	pr6|506
002366  aa  6 00774 2521 00	spri2	pr6|508
002367  aa  6 00776 2521 00	spri2	pr6|510
002370  aa  6 01000 2521 00	spri2	pr6|512
002371  aa  6 01002 2521 00	spri2	pr6|514
002372  aa  6 01004 2521 00	spri2	pr6|516
002373  aa  6 00664 6211 00	eax1 	pr6|436
002374  aa   120000 4310 07	fld  	40960,dl
002375  aa  6 00044 3701 20	epp4 	pr6|36,*
002376  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
002377  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 455
     end PRINT_METERS;

002400  aa  6 00234 6101 00	rtcd 	pr6|156
  END PROCEDURE PRINT_METERS
  END PROCEDURE scavenger


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
