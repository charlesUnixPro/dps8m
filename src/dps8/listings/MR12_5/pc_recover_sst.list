	COMPILATION LISTING OF SEGMENT pc_recover_sst
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0944.1 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* pc_recover_sst.pl1. The smarts of this program live in
        9*   pc_check_tables_.pl1, which see. */
       10 
       11 /* format: style2,indcomtxt */
       12 
       13 pc_recover_sst:
       14      procedure;
       15 
       16 /* BIM 84-01-11 */
       17 
  1     1 /* Begin include file pc_check_tables_info.incl.pl1 */
  1     2 /* format: style3,indcomtxt,idind25 */
  1     3 
  1     4 /**** This include file is the driver for pv_check_tables_.
  1     5*      It is used by pc_recover_sst and various user ring
  1     6*      analysis tools to
  1     7*
  1     8*      1) report on the state of an SST/CoreMap.
  1     9*      2) Make repairs for emergency shutdown.
  1    10*
  1    11*      BIM 84-01-10 */
  1    12 
  1    13 declare	check_tables_info_ptr    pointer;
  1    14 declare	1 check_tables_info	     aligned based (check_tables_info_ptr),
  1    15 	  2 version	     char (8) aligned,
  1    16 	  2 system_type	     fixed bin,
  1    17 	  2 flags		     aligned,
  1    18 	    3 report_error_counts
  1    19 			     bit (1) unaligned,	/* total errors found */
  1    20 	    3 report_errors	     bit (1) unaligned,	/* report each error */
  1    21 	    3 report_statistics  bit (1) unaligned,	/* totals of CME's, PTW's, and ASTE's in interesting states */
  1    22 	    3 report_state       bit (1) unaligned,       /* things interrupted */
  1    23 	    3 recover_errors     bit (1) unaligned,	/* you are pc_recover_sst,
  1    24*						   and you should fix things,
  1    25*						   calling page control etc. */
  1    26 	    3 errors_found	     bit (1) unaligned,	/* OUTPUT */
  1    27 	    3 pad		     bit (32) unaligned,	/* someday, maybe show whole works */
  1    28 	  2 sst_ptr	     pointer,
  1    29 	  2 core_map_ptr	     pointer,
  1    30 	  2 pvt_ptr	     pointer,
  1    31 	  2 pad_ptr	     (7) pointer,		/* future expansion */
  1    32 	  2 report	     entry options (variable),/* ioa */
  1    33 	  2 display_cme	     entry (pointer),/* (cmep) show a CME */
  1    34 	  2 display_ptw	     entry (pointer),/* (ptwp) show a PTW */
  1    35 	  2 display_aste	     entry (pointer),/* (astep) show ASTE (not page table) */
  1    36 	  2 display_pvname       entry (fixed bin) returns (char (32)), /* pvname = (pxtx) */
  1    37 	  2 display_ptr	     entry (pointer) returns (char (*)), /* ptrname = (ctip, ptr); */
  1    38 	  2 pad_entries	     (5) entry;
  1    39 
  1    40 declare	PC_CHECK_TABLES_INFO_VERSION_1
  1    41 			     char (8) aligned init ("pcct0001") int static options (constant);
  1    42 
  1    43 /* End include file pc_check_tables_info.incl.pl1 */
       18 
       19 
       20 	declare arg_list_ptr_	 entry returns (pointer);
       21 	declare syserr		 entry options (variable);
       22 	declare syserr$error_code	 entry options (variable);
       23 	declare ioa_$general_rs	 entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21),
       24 				 bit (1) aligned, bit (1) aligned);
       25 	declare ioa_$rsnnl		 entry () options (variable);
       26 	declare pc_check_tables_	 entry (pointer, fixed bin (35));
       27 	declare debug_check		 entry (char (4) aligned) returns (bit (1) aligned);
       28 
       29 	declare 1 CTI		 aligned like check_tables_info;
       30 
       31 	declare sst_seg$		 external;
       32 	declare core_map$		 external;
       33 	declare slt$		 external;
       34 	declare pvt$		 external;
       35 	declare sys_info$system_type	 fixed bin (35) external static;
       36 
       37 	declare code		 fixed bin (35);
       38 
       39 	declare (addr, setwordno, segno)
       40 				 builtin;
       41 
       42 
       43 	CTI.version = PC_CHECK_TABLES_INFO_VERSION_1;
       44 	CTI.flags = "0"b;
       45 	CTI.flags.recover_errors = "1"b;
       46 	CTI.flags.report_errors, CTI.report_state = debug_check ("esdt");
       47 	CTI.flags.report_error_counts = CTI.flags.report_errors | debug_check ("esds");
       48 	CTI.report = report_;
       49 	CTI.display_ptw = display_ptw_;
       50 	CTI.display_cme = display_cme_;
       51 	CTI.display_aste = display_aste_;
       52 	CTI.display_ptr = display_ptr_;
       53 	CTI.display_pvname = display_pvname_;
       54 
       55 	CTI.sst_ptr = addr (sst_seg$);
       56 	CTI.core_map_ptr = addr (core_map$);		/* NOT sst.cmp */
       57 	CTI.pvt_ptr = addr (pvt$);
       58 	CTI.system_type = sys_info$system_type;
       59 
       60 	call pc_check_tables_ (addr (CTI), code);
       61 	if code ^= 0
       62 	then call syserr$error_code (CRASH, code, "pc_recover_sst: could not recover sst/core_map. Reboot and salvage.")
       63 		;
       64 	return;
       65 
       66 report_:
       67      procedure options (variable);
       68 
       69 	declare long_string		 char (200);
       70 	declare lsl		 fixed bin (21);
       71 
       72 	call ioa_$general_rs (arg_list_ptr_ (), 1, 2, long_string, lsl, "0"b, "0"b);
       73 	call syserr (ANNOUNCE, "^a", substr (long_string, 1, lsl));
       74 	return;
       75      end report_;
       76 
       77 display_ptw_:
       78      procedure (ptwp);
       79 
       80 	declare ptwp		 pointer;
       81 
       82 	call report_ (" --> PTW at ^6o", wordno (ptwp));
       83 	return;
       84      end display_ptw_;
       85 
       86 display_cme_:
       87      procedure (cmep);
       88 
       89 	declare cmep		 pointer;
       90 
       91 	call report_ (" --> CME at ^6o", wordno (cmep));
       92 	return;
       93      end display_cme_;
       94 
       95 display_aste_:
       96      procedure (astep);
       97 
       98 	declare astep		 pointer;
       99 
      100 	call report_ (" --> aste at ^6o", wordno (astep));
      101 	return;
      102      end display_aste_;
      103 
      104 display_ptr_:
      105      procedure (ap) returns (char (*));
      106 
      107 	declare ap		 pointer;
      108 	declare offset		 char (12);
      109 
      110 	offset = "";
      111 	call ioa_$rsnnl ("^o", offset, (0), wordno (ap));
      112 	sltp = addr (slt$);
      113 	names_ptr = slt.name_seg_ptr;
      114 	sltep = addr (slt.seg (segno (ap)));
      115 	namep = setwordno (names_ptr, bin (slte_uns.names_ptr, 18));
      116 	return (rtrim (segnam.names (1).name) || rtrim (offset));
      117      end display_ptr_;
      118 
      119 display_pvname_:
      120      procedure (pvtx) returns (char (32));
      121 
      122 	declare pvtx		 fixed bin;
      123 
      124 	declare 1 dname		 unaligned,
      125 		2 devname		 char (4),
      126 		2 u		 char (1) init ("_"),
      127 		2 nn		 picture "99";
      128 
      129 	pvt_arrayp = addr (pvt$array);
      130 	pvtep = addr (pvt_array (pvtx));
      131 	dname.devname = pvte.devname;
      132 	dname.nn = pvte.logical_area_number;
      133 	return (string (dname));
      134      end display_pvname_;
      135 
      136 
      137 /* format: off */
      138 
      139  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  2     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  2     8*     Add the support for subvolumes
  2     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  2    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  2    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  2    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  2    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  2    14*     Added inconsistent_dbm bit for determining the status of volume
  2    15*     dumper bit maps.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18      dcl	   pvt$array	      aligned external;
  2    19      dcl	   pvt$max_n_entries      fixed bin external;
  2    20 
  2    21      dcl	   pvt_arrayp	      ptr;
  2    22      dcl	   pvtep		      ptr;
  2    23 
  2    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  2    25 
  2    26      dcl	   1 pvte		      based (pvtep) aligned,
  2    27 
  2    28 	     2 pvid	      bit (36),		/* physical volume ID */
  2    29 
  2    30 	     2 lvid	      bit (36),		/* logical volume ID */
  2    31 
  2    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  2    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  2    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  2    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  2    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  2    37 	     2 pad3	      bit (2) unaligned,
  2    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  2    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  2    40 
  2    41 
  2    42 
  2    43 	     2 devname	      char (4),		/* device name */
  2    44 
  2    45 	     (2 device_type	      fixed bin (8),	/* device type */
  2    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  2    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  2    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  2    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  2    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  2    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  2    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  2    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  2    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  2    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  2    56 	     2 scav_check_address
  2    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  2    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  2    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  2    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  2    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  2    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  2    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  2    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  2    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  2    66 
  2    67 
  2    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  2    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  2    70 
  2    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  2    72 
  2    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  2    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  2    75 
  2    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  2    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  2    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  2    79 	     2 records_per_cyl    fixed bin,
  2    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  2    81 	     2 sv_name            char (2) aligned,
  2    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  2    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  2    84 
  2    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  2    86 	     2 pad2	      bit (18) unaligned,
  2    87 
  2    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  2    89 
  2    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  2    91 
  2    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  2    93 
  2    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  2    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  2    96 
  2    97 
  2    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  2    99 
  2   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  2   101 
  2   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  2   103 
  2   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  2   105 
  2   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  2   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  2   108 
  2   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  2   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  2   111 
  2   112 
  2   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  2   114 	   VOLMAP_ASYNC_READ      init (1),
  2   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  2   116 
  2   117 
  2   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      139 
      140  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  3     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  3     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  3     4 
  3     5 /* This include file has an ALM version.  Keep 'em in sync! */
  3     6 
  3     7 dcl (
  3     8 
  3     9 /* The following constants define the message action codes.  This indicates
  3    10*how a message is to be handled.  */
  3    11 
  3    12      SYSERR_CRASH_SYSTEM	init (1),			
  3    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  3    14 
  3    15      SYSERR_TERMINATE_PROCESS	init (2),
  3    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  3    17 
  3    18      SYSERR_PRINT_WITH_ALARM	init (3),
  3    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  3    20 
  3    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  3    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  3    23 
  3    24      SYSERR_LOG_OR_PRINT	init (4),
  3    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  3    26 
  3    27      SYSERR_LOG_OR_DISCARD	init (5),
  3    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  3    29 
  3    30 
  3    31 /* The following constants are added to the normal severities to indicate
  3    32*different sorting classes of messages.  */
  3    33 
  3    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  3    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  3    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  3    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  3    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  3    39 	) fixed bin internal static options (constant);
  3    40 
  3    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      140 
      141  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  4     2 
  4     3 /* Declarations for Segment Loading Table header and array.
  4     4*
  4     5*   Used by Initialization and MST Checker subroutines */
  4     6 
  4     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  4     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  4     9     namep ptr,					/* pointer to segment name list block */
  4    10     pathp ptr,					/* pointer to segment's directory path name */
  4    11     aclp ptr;					/* pointer to acl structure */
  4    12 
  4    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  4    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  4    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  4    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  4    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  4    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  4    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  4    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  4    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  4    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  4    23 
  4    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  4    25 
  4    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  4    27 	2 pad bit (18) unal,
  4    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  4    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  4    30 
  4    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  4    32 	2 count fixed bin (17),			/* number of segment names in this block */
  4    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  4    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  4    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  4    36 	  3 pad bit (5) unal,
  4    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  4    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  4    39 
  4    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  4    41 	2 size fixed bin (17),			/* length of pathname */
  4    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  4    43 	2 acls fixed bin;				/* ACL list starts here */
  4    44 
  4    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  4    46 	2 count fixed bin,				/* number of entries in acl list */
  4    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  4    48 	  3 userid char (32),			/* user specification */
  4    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  4    50 	  3 pad bit (36) aligned,
  4    51 	  3 code fixed bin;
  4    52 
  4    53 
  4    54 /* END INCLUDE FILE slt.incl.pl1 */
      141 
      142  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  5     2 /* Declaration for Segment Loading Table Entry structure.
  5     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  5     4 /* modified 5/4/76 by Noel I. Morris	*/
  5     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  5     6 /* format: style3 */
  5     7 
  5     8 dcl	sltep		ptr;
  5     9 
  5    10 dcl	1 slte_uns	based (sltep) aligned,
  5    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  5    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  5    13 /**** End of word 1 */
  5    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  5    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  5    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  5    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  5    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  5    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  5    20 	  2 pad1		bit (3),			/* unused */
  5    21 	  2 wired		bit (1),			/* segment is wired if ON */
  5    22 	  2 paged		bit (1),			/* segment is paged if ON */
  5    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  5    24 	  2 pad3		bit (2),
  5    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  5    26 /**** End of 1st half of word 2 */
  5    27 	  2 pad4		bit (3),
  5    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  5    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  5    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  5    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  5    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  5    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  5    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  5    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  5    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  5    37 /***** End of word 2 */
  5    38 	  2 pad5		bit (6),
  5    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  5    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  5    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  5    42 /***** End of word 3 */
  5    43 	  2 pad7		bit (3),
  5    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  5    45 	  2 bit_count	fixed bin (24) uns
  5    46 	  )		unaligned;		/* bitcount of segment */
  5    47 
  5    48 dcl	1 slte		based (sltep) aligned,
  5    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  5    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  5    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  5    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  5    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  5    54 	  2 firmware_seg    bit (1),
  5    55 	  2 layout_seg      bit (1),
  5    56 	  2 breakpointable  bit (1),
  5    57 	  2 pad2		bit (3),
  5    58 	  2 wired		bit (1),			/* segment is wired if ON */
  5    59 	  2 paged		bit (1),			/* segment is paged if ON */
  5    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  5    61 	  2 pad3		bit (2),
  5    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  5    63 	  2 pad4		bit (3),
  5    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  5    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  5    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  5    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  5    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  5    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  5    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  5    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  5    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  5    73 	  2 pad5		bit (6),
  5    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  5    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  5    76 	  2 segno		bit (18),			/* text/link segment number */
  5    77 	  2 pad6		bit (3),
  5    78 	  2 max_length	bit (9),			/* maximum length for segment */
  5    79 	  2 bit_count	bit (24)
  5    80 	  )		unaligned;		/* bitcount of segment */
  5    81 
  5    82 /* END INCLUDE FILE slte.incl.pl1 */
      142 
      143 
      144        end pc_recover_sst;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0853.8  pc_recover_sst.pl1                >spec>install>1115>pc_recover_sst.pl1
18           1    07/11/84  0937.3  pc_check_tables_info.incl.pl1     >ldd>include>pc_check_tables_info.incl.pl1
139          2    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
140          3    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
141          4    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
142          5    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000022 constant        fixed bin(17,0)          initial dcl 3-7 set ref 73*
CRASH                           000023 constant        fixed bin(17,0)          initial dcl 3-7 set ref 61*
CTI                             000100 automatic       structure                level 1 dcl 29 set ref 60 60
PC_CHECK_TABLES_INFO_VERSION_1  000000 constant        char(8)                  initial dcl 1-40 ref 43
addr                                                   builtin function         dcl 39 ref 55 56 57 60 60 112 114 129 130
ap                                     parameter       pointer                  dcl 107 ref 104 111 111 114
arg_list_ptr_                   000010 constant        entry                    external dcl 20 ref 72 72
astep                                  parameter       pointer                  dcl 98 ref 95 100 100
check_tables_info                      based           structure                level 1 dcl 1-14
cmep                                   parameter       pointer                  dcl 89 ref 86 91 91
code                            000206 automatic       fixed bin(35,0)          dcl 37 set ref 60* 61 61*
core_map$                       000030 external static fixed bin(17,0)          dcl 32 set ref 56
core_map_ptr             10     000100 automatic       pointer                  level 2 dcl 29 set ref 56*
debug_check                     000024 constant        entry                    external dcl 27 ref 46 47
devname                   3            based           char(4)                  level 2 in structure "pvte" dcl 2-26 in procedure
                                                                                  "pc_recover_sst" ref 131
devname                         000100 automatic       char(4)                  level 2 in structure "dname" packed packed unaligned
                                                                                  dcl 124 in procedure "display_pvname_" set ref
                                                                                  131*
display_aste             46     000100 automatic       entry variable           level 2 dcl 29 set ref 51*
display_cme              36     000100 automatic       entry variable           level 2 dcl 29 set ref 50*
display_ptr              56     000100 automatic       entry variable           level 2 dcl 29 set ref 52*
display_ptw              42     000100 automatic       entry variable           level 2 dcl 29 set ref 49*
display_pvname           52     000100 automatic       entry variable           level 2 dcl 29 set ref 53*
dname                           000100 automatic       structure                level 1 packed packed unaligned dcl 124 set ref 133
flags                     3     000100 automatic       structure                level 2 dcl 29 set ref 44*
ioa_$general_rs                 000016 constant        entry                    external dcl 23 ref 72
ioa_$rsnnl                      000020 constant        entry                    external dcl 25 ref 111
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 2-26 ref 132
long_string                     000100 automatic       char(200)                packed unaligned dcl 69 set ref 72* 73 73
lsl                             000162 automatic       fixed bin(21,0)          dcl 70 set ref 72* 73 73
name                      2            based           char(32)                 array level 3 packed packed unaligned dcl 4-31 ref
                                                                                  116
name_seg_ptr                           based           pointer                  level 2 dcl 4-13 ref 113
namep                           000220 automatic       pointer                  dcl 4-7 set ref 115* 116
names                     1            based           structure                array level 2 dcl 4-31
names_ptr                       000216 automatic       pointer                  dcl 4-7 in procedure "pc_recover_sst" set ref 113*
                                                                                  115
names_ptr                              based           bit(18)                  level 2 in structure "slte_uns" packed packed
                                                                                  unaligned dcl 5-10 in procedure "pc_recover_sst"
                                                                                  ref 115
nn                        1(09) 000100 automatic       picture(2)               level 2 packed packed unaligned dcl 124 set ref 132*
offset                          000100 automatic       char(12)                 packed unaligned dcl 108 set ref 110* 111* 116
pc_check_tables_                000022 constant        entry                    external dcl 26 ref 60
ptwp                                   parameter       pointer                  dcl 80 ref 77 82 82
pvt$                            000034 external static fixed bin(17,0)          dcl 34 set ref 57
pvt$array                       000040 external static fixed bin(17,0)          dcl 2-18 set ref 129
pvt_array                              based           structure                array level 1 dcl 2-24 set ref 130
pvt_arrayp                      000210 automatic       pointer                  dcl 2-21 set ref 129* 130
pvt_ptr                  12     000100 automatic       pointer                  level 2 dcl 29 set ref 57*
pvte                                   based           structure                level 1 dcl 2-26
pvtep                           000212 automatic       pointer                  dcl 2-22 set ref 130* 131 132
pvtx                                   parameter       fixed bin(17,0)          dcl 122 ref 119 130
recover_errors            3(04) 000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 29 set ref 45*
report                   32     000100 automatic       entry variable           level 2 dcl 29 set ref 48*
report_error_counts       3     000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 29 set ref 47*
report_errors             3(01) 000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 29 set ref 46*
                                                                                  47
report_state              3(03) 000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 29 set ref 46*
seg                      10            based           structure                array level 2 dcl 4-13 set ref 114
segnam                                 based           structure                level 1 dcl 4-31
segno                                                  builtin function         dcl 39 ref 114
setwordno                                              builtin function         dcl 39 ref 115
slt                                    based           structure                level 1 dcl 4-13
slt$                            000032 external static fixed bin(17,0)          dcl 33 set ref 112
slte_uns                               based           structure                level 1 dcl 5-10
sltep                           000222 automatic       pointer                  dcl 5-8 set ref 114* 115
sltp                            000214 automatic       pointer                  dcl 4-7 set ref 112* 113 114
sst_ptr                   6     000100 automatic       pointer                  level 2 dcl 29 set ref 55*
sst_seg$                        000026 external static fixed bin(17,0)          dcl 31 set ref 55
sys_info$system_type            000036 external static fixed bin(35,0)          dcl 35 ref 58
syserr                          000012 constant        entry                    external dcl 21 ref 73
syserr$error_code               000014 constant        entry                    external dcl 22 ref 61
system_type               2     000100 automatic       fixed bin(17,0)          level 2 dcl 29 set ref 58*
u                         1     000100 automatic       char(1)                  initial level 2 packed packed unaligned dcl 124 set
                                                                                  ref 124*
version                         000100 automatic       char(8)                  level 2 dcl 29 set ref 43*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 3-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 3-7
LOG                                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 3-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 3-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 2-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 2-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 2-113
aclp                                   automatic       pointer                  dcl 4-7
acls                                   based           structure                level 1 dcl 4-45
check_tables_info_ptr                  automatic       pointer                  dcl 1-13
name_seg                               based           structure                level 1 dcl 4-26
path                                   based           structure                level 1 dcl 4-40
pathp                                  automatic       pointer                  dcl 4-7
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 2-19
slte                                   based           structure                level 1 dcl 5-48

NAMES DECLARED BY EXPLICIT CONTEXT.
display_aste_                   000503 constant        entry                    internal dcl 95 ref 51
display_cme_                    000443 constant        entry                    internal dcl 86 ref 50
display_ptr_                    000543 constant        entry                    internal dcl 104 ref 52
display_ptw_                    000403 constant        entry                    internal dcl 77 ref 49
display_pvname_                 000705 constant        entry                    internal dcl 119 ref 53
pc_recover_sst                  000065 constant        entry                    external dcl 13
report_                         000265 constant        entry                    internal dcl 66 ref 48 82 91 100

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 115
rtrim                                                  builtin function         ref 116 116
string                                                 builtin function         ref 133
substr                                                 builtin function         ref 73 73
wordno                                                 builtin function         ref 82 82 91 91 100 100 111 111

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1174        1236     760        1204
Length      1534     760        42         261     213           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pc_recover_sst                      190 external procedure  is an external procedure.  
report_                             156 internal procedure  is assigned to an entry variable, and is declared options(variable).  
display_ptw_                         82 internal procedure  is assigned to an entry variable.  
display_cme_                         82 internal procedure  is assigned to an entry variable.  
display_aste_                        82 internal procedure  is assigned to an entry variable.  
display_ptr_                         88 internal procedure  uses returns(char(*)) or returns(bit(*)), and   
                                                            is assigned to an entry variable.  
display_pvname_                      68 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
display_ptr_             000100 offset                      display_ptr_
display_pvname_          000100 dname                       display_pvname_
pc_recover_sst           000100 CTI                         pc_recover_sst
                         000206 code                        pc_recover_sst
                         000210 pvt_arrayp                  pc_recover_sst
                         000212 pvtep                       pc_recover_sst
                         000214 sltp                        pc_recover_sst
                         000216 names_ptr                   pc_recover_sst
                         000220 namep                       pc_recover_sst
                         000222 sltep                       pc_recover_sst
report_                  000100 long_string                 report_
                         000162 lsl                         report_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_other_desc return_mac          shorten_stack
ext_entry           int_entry           int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
arg_list_ptr_                 debug_check                   ioa_$general_rs               ioa_$rsnnl
pc_check_tables_              syserr                        syserr$error_code

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
core_map$                     pvt$                          pvt$array                     slt$
sst_seg$                      sys_info$system_type


CONSTANTS
000746  aa  070 322 000 000	8Ò

000750  aa     770000000000
000751  aa     177777777777

000752  aa     767777777777

000753  aa     757777777777

000754  aa     737777777777

000755  aa     677777777777

000756  aa     577777777777

000757  aa     377777777777

000000  aa  160 143 143 164	pcct
000001  aa  060 060 060 061	0001

000002  aa     526000000000

000003  aa     404000000005

000004  aa     526000000014

000005  aa     526077777777

000006  aa     524000000020

000007  aa     404000000022

000010  aa     524000000017

000011  aa     524000000000

000012  aa     524000000002

000013  aa     404000000025

000014  aa     526000000310

000015  aa     524000000103

000016  aa     404000000043

000017  aa     404000000021

000020  aa  145 163 144 163	esds

000021  aa  145 163 144 164	esdt

000022  aa     000000000000

000023  aa     000000000001

000024  aa     514000000001

000025  aa     464000000000

000026  aa     526000000040

000027  aa  040 055 055 076	 -->
000030  aa  040 141 163 164	 ast
000031  aa  145 040 141 164	e at
000032  aa  040 136 066 157	 ^6o

000033  aa  040 055 055 076	 -->
000034  aa  040 103 115 105	 CME
000035  aa  040 141 164 040	 at 
000036  aa  136 066 157 000	^6o

000037  aa  040 055 055 076	 -->
000040  aa  040 120 124 127	 PTW
000041  aa  040 141 164 040	 at 
000042  aa  136 066 157 000	^6o

000043  aa  160 143 137 162	pc_r
000044  aa  145 143 157 166	ecov
000045  aa  145 162 137 163	er_s
000046  aa  163 164 072 040	st: 
000047  aa  143 157 165 154	coul
000050  aa  144 040 156 157	d no
000051  aa  164 040 162 145	t re
000052  aa  143 157 166 145	cove
000053  aa  162 040 163 163	r ss
000054  aa  164 057 143 157	t/co
000055  aa  162 145 137 155	re_m
000056  aa  141 160 056 040	ap. 
000057  aa  122 145 142 157	Rebo
000060  aa  157 164 040 141	ot a
000061  aa  156 144 040 163	nd s
000062  aa  141 154 166 141	alva
000063  aa  147 145 056 000	ge.

BEGIN PROCEDURE pc_recover_sst
ENTRY TO pc_recover_sst                                     STATEMENT 1 ON LINE 13
pc_recover_sst:
     procedure;

000064  da     000137200000
000065  aa   000300 6270 00	eax7 	192
000066  aa  7 00034 3521 20	epp2 	pr7|28,*
000067  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000070  aa     000000000000
000071  aa     000000000000
						STATEMENT 1 ON LINE 43
	CTI.version = PC_CHECK_TABLES_INFO_VERSION_1;

000072  aa   777706 2370 04	ldaq 	-58,ic		000000 = 160143143164 060060060061
000073  aa  6 00100 7571 00	staq 	pr6|64		CTI.version
						STATEMENT 1 ON LINE 44
	CTI.flags = "0"b;

000074  aa   000663 2350 04	lda  	435,ic		000757 = 377777777777
000075  aa  6 00103 3551 00	ansa 	pr6|67		CTI.report_error_counts
000076  aa   000660 2350 04	lda  	432,ic		000756 = 577777777777
000077  aa  6 00103 3551 00	ansa 	pr6|67		CTI.report_errors
000100  aa   000655 2350 04	lda  	429,ic		000755 = 677777777777
000101  aa  6 00103 3551 00	ansa 	pr6|67		CTI.report_statistics
000102  aa   000652 2350 04	lda  	426,ic		000754 = 737777777777
000103  aa  6 00103 3551 00	ansa 	pr6|67		CTI.report_state
000104  aa   000647 2350 04	lda  	423,ic		000753 = 757777777777
000105  aa  6 00103 3551 00	ansa 	pr6|67		CTI.recover_errors
000106  aa   000644 2350 04	lda  	420,ic		000752 = 767777777777
000107  aa  6 00103 3551 00	ansa 	pr6|67		CTI.errors_found
000110  aa   000640 2370 04	ldaq 	416,ic		000750 = 770000000000 177777777777
000111  aa  6 00103 3551 00	ansa 	pr6|67		CTI.pad
000112  aa  6 00104 3561 00	ansq 	pr6|68		CTI.pad
						STATEMENT 1 ON LINE 45
	CTI.flags.recover_errors = "1"b;

000113  aa   020000 2350 03	lda  	8192,du
000114  aa  6 00103 2551 00	orsa 	pr6|67		CTI.recover_errors
						STATEMENT 1 ON LINE 46
	CTI.flags.report_errors, CTI.report_state = debug_check ("esdt");

000115  aa   777704 2350 04	lda  	-60,ic		000021 = 145163144164
000116  aa  6 00224 7551 00	sta  	pr6|148
000117  aa  6 00224 3521 00	epp2 	pr6|148
000120  aa  6 00230 2521 00	spri2	pr6|152
000121  aa  6 00225 3521 00	epp2 	pr6|149
000122  aa  6 00232 2521 00	spri2	pr6|154
000123  aa  6 00226 6211 00	eax1 	pr6|150
000124  aa   010000 4310 07	fld  	4096,dl
000125  la  4 00024 3521 20	epp2 	pr4|20,*		debug_check
000126  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000127  aa  6 00225 2351 00	lda  	pr6|149
000130  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000131  aa   000001 7730 00	lrl  	1
000132  aa  6 00225 7551 00	sta  	pr6|149
000133  aa  6 00103 6751 00	era  	pr6|67		CTI.report_errors
000134  aa   200000 3750 03	ana  	65536,du
000135  aa  6 00103 6551 00	ersa 	pr6|67		CTI.report_errors
000136  aa  6 00225 2351 00	lda  	pr6|149
000137  aa   000002 7710 00	arl  	2
000140  aa  6 00103 6751 00	era  	pr6|67		CTI.report_state
000141  aa   040000 3750 03	ana  	16384,du
000142  aa  6 00103 6551 00	ersa 	pr6|67		CTI.report_state
						STATEMENT 1 ON LINE 47
	CTI.flags.report_error_counts = CTI.flags.report_errors | debug_check ("esds");

000143  aa   777655 2350 04	lda  	-83,ic		000020 = 145163144163
000144  aa  6 00225 7551 00	sta  	pr6|149
000145  aa  6 00225 3521 00	epp2 	pr6|149
000146  aa  6 00230 2521 00	spri2	pr6|152
000147  aa  6 00224 3521 00	epp2 	pr6|148
000150  aa  6 00232 2521 00	spri2	pr6|154
000151  aa  6 00226 6211 00	eax1 	pr6|150
000152  aa   010000 4310 07	fld  	4096,dl
000153  aa  6 00044 3701 20	epp4 	pr6|36,*
000154  la  4 00024 3521 20	epp2 	pr4|20,*		debug_check
000155  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000156  aa  6 00224 2351 00	lda  	pr6|148
000157  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000160  aa  6 00224 7551 00	sta  	pr6|148
000161  aa  6 00103 2351 00	lda  	pr6|67		CTI.report_errors
000162  aa   000001 7350 00	als  	1
000163  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000164  aa  6 00224 2751 00	ora  	pr6|148
000165  aa  6 00103 6751 00	era  	pr6|67		CTI.report_error_counts
000166  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
000167  aa  6 00103 6551 00	ersa 	pr6|67		CTI.report_error_counts
						STATEMENT 1 ON LINE 48
	CTI.report = report_;

000170  aa   000075 3520 04	epp2 	61,ic		000265 = 000240627000
000171  aa  6 00132 2521 00	spri2	pr6|90		CTI.report
000172  aa  6 00134 6521 00	spri6	pr6|92		CTI.report
						STATEMENT 1 ON LINE 49
	CTI.display_ptw = display_ptw_;

000173  aa   000210 3520 04	epp2 	136,ic		000403 = 000140627000
000174  aa  6 00142 2521 00	spri2	pr6|98		CTI.display_ptw
000175  aa  6 00144 6521 00	spri6	pr6|100		CTI.display_ptw
						STATEMENT 1 ON LINE 50
	CTI.display_cme = display_cme_;

000176  aa   000245 3520 04	epp2 	165,ic		000443 = 000140627000
000177  aa  6 00136 2521 00	spri2	pr6|94		CTI.display_cme
000200  aa  6 00140 6521 00	spri6	pr6|96		CTI.display_cme
						STATEMENT 1 ON LINE 51
	CTI.display_aste = display_aste_;

000201  aa   000302 3520 04	epp2 	194,ic		000503 = 000140627000
000202  aa  6 00146 2521 00	spri2	pr6|102		CTI.display_aste
000203  aa  6 00150 6521 00	spri6	pr6|104		CTI.display_aste
						STATEMENT 1 ON LINE 52
	CTI.display_ptr = display_ptr_;

000204  aa   000337 3520 04	epp2 	223,ic		000543 = 000140627000
000205  aa  6 00156 2521 00	spri2	pr6|110		CTI.display_ptr
000206  aa  6 00160 6521 00	spri6	pr6|112		CTI.display_ptr
						STATEMENT 1 ON LINE 53
	CTI.display_pvname = display_pvname_;

000207  aa   000476 3520 04	epp2 	318,ic		000705 = 000120627000
000210  aa  6 00152 2521 00	spri2	pr6|106		CTI.display_pvname
000211  aa  6 00154 6521 00	spri6	pr6|108		CTI.display_pvname
						STATEMENT 1 ON LINE 55
	CTI.sst_ptr = addr (sst_seg$);

000212  aa  6 00044 3701 20	epp4 	pr6|36,*
000213  la  4 00026 3735 20	epp7 	pr4|22,*		sst_seg$
000214  aa  6 00106 6535 00	spri7	pr6|70		CTI.sst_ptr
						STATEMENT 1 ON LINE 56
	CTI.core_map_ptr = addr (core_map$);

000215  la  4 00030 3715 20	epp5 	pr4|24,*		core_map$
000216  aa  6 00110 6515 00	spri5	pr6|72		CTI.core_map_ptr
						STATEMENT 1 ON LINE 57
	CTI.pvt_ptr = addr (pvt$);

000217  la  4 00034 3735 20	epp7 	pr4|28,*		pvt$
000220  aa  6 00112 6535 00	spri7	pr6|74		CTI.pvt_ptr
						STATEMENT 1 ON LINE 58
	CTI.system_type = sys_info$system_type;

000221  la  4 00036 2361 20	ldq  	pr4|30,*		sys_info$system_type
000222  aa  6 00102 7561 00	stq  	pr6|66		CTI.system_type
						STATEMENT 1 ON LINE 60
	call pc_check_tables_ (addr (CTI), code);

000223  aa  6 00100 3715 00	epp5 	pr6|64		CTI
000224  aa  6 00234 6515 00	spri5	pr6|156
000225  aa  6 00234 3521 00	epp2 	pr6|156
000226  aa  6 00230 2521 00	spri2	pr6|152
000227  aa  6 00206 3521 00	epp2 	pr6|134		code
000230  aa  6 00232 2521 00	spri2	pr6|154
000231  aa  6 00226 6211 00	eax1 	pr6|150
000232  aa   010000 4310 07	fld  	4096,dl
000233  la  4 00022 3521 20	epp2 	pr4|18,*		pc_check_tables_
000234  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 61
	if code ^= 0
	then call syserr$error_code (CRASH, code, "pc_recover_sst: could not recover sst/core_map. Reboot and salvage.")
		;

000235  aa  6 00206 2361 00	ldq  	pr6|134		code
000236  aa   000025 6000 04	tze  	21,ic		000263
000237  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000240  aa   777604 00 0104	desc9a	-124,68		000043 = 160143137162
000241  aa  6 00236 00 0104	desc9a	pr6|158,68
000242  aa   777561 3520 04	epp2 	-143,ic		000023 = 000000000001
000243  aa  6 00262 2521 00	spri2	pr6|178
000244  aa  6 00206 3521 00	epp2 	pr6|134		code
000245  aa  6 00264 2521 00	spri2	pr6|180
000246  aa  6 00236 3521 00	epp2 	pr6|158
000247  aa  6 00266 2521 00	spri2	pr6|182
000250  aa   777547 3520 04	epp2 	-153,ic		000017 = 404000000021
000251  aa  6 00270 2521 00	spri2	pr6|184
000252  aa   777544 3520 04	epp2 	-156,ic		000016 = 404000000043
000253  aa  6 00272 2521 00	spri2	pr6|186
000254  aa   777541 3520 04	epp2 	-159,ic		000015 = 524000000103
000255  aa  6 00274 2521 00	spri2	pr6|188
000256  aa  6 00260 6211 00	eax1 	pr6|176
000257  aa   014000 4310 07	fld  	6144,dl
000260  aa  6 00044 3701 20	epp4 	pr6|36,*
000261  la  4 00014 3521 20	epp2 	pr4|12,*		syserr$error_code
000262  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 64
	return;

000263  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 144
       end pc_recover_sst;

BEGIN PROCEDURE report_
ENTRY TO report_                                            STATEMENT 1 ON LINE 66
report_:
     procedure options (variable);

000264  da     000144240000
000265  aa   000240 6270 00	eax7 	160
000266  aa  7 00034 3521 20	epp2 	pr7|28,*
000267  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000270  aa     000000000000
000271  aa     000000000000
						STATEMENT 1 ON LINE 72
	call ioa_$general_rs (arg_list_ptr_ (), 1, 2, long_string, lsl, "0"b, "0"b);

000272  aa  6 00164 3521 00	epp2 	pr6|116
000273  aa  6 00170 2521 00	spri2	pr6|120
000274  aa  6 00166 6211 00	eax1 	pr6|118
000275  aa   004000 4310 07	fld  	2048,dl
000276  la  4 00010 3521 20	epp2 	pr4|8,*		arg_list_ptr_
000277  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000300  aa   000001 2360 07	ldq  	1,dl
000301  aa  6 00163 7561 00	stq  	pr6|115
000302  aa   000002 2360 07	ldq  	2,dl
000303  aa  6 00172 7561 00	stq  	pr6|122
000304  aa   000000 2350 07	lda  	0,dl
000305  aa  6 00173 7551 00	sta  	pr6|123
000306  aa  6 00174 7551 00	sta  	pr6|124
000307  aa  6 00164 3521 00	epp2 	pr6|116
000310  aa  6 00200 2521 00	spri2	pr6|128
000311  aa  6 00163 3521 00	epp2 	pr6|115
000312  aa  6 00202 2521 00	spri2	pr6|130
000313  aa  6 00172 3521 00	epp2 	pr6|122
000314  aa  6 00204 2521 00	spri2	pr6|132
000315  aa  6 00100 3521 00	epp2 	pr6|64		long_string
000316  aa  6 00206 2521 00	spri2	pr6|134
000317  aa  6 00162 3521 00	epp2 	pr6|114		lsl
000320  aa  6 00210 2521 00	spri2	pr6|136
000321  aa  6 00173 3521 00	epp2 	pr6|123
000322  aa  6 00212 2521 00	spri2	pr6|138
000323  aa  6 00174 3521 00	epp2 	pr6|124
000324  aa  6 00214 2521 00	spri2	pr6|140
000325  aa   777500 3520 04	epp2 	-192,ic		000025 = 464000000000
000326  aa  6 00216 2521 00	spri2	pr6|142
000327  aa   777470 3520 04	epp2 	-200,ic		000017 = 404000000021
000330  aa  6 00220 2521 00	spri2	pr6|144
000331  aa  6 00222 2521 00	spri2	pr6|146
000332  aa   777462 3520 04	epp2 	-206,ic		000014 = 526000000310
000333  aa  6 00224 2521 00	spri2	pr6|148
000334  aa   777457 3520 04	epp2 	-209,ic		000013 = 404000000025
000335  aa  6 00226 2521 00	spri2	pr6|150
000336  aa   777466 3520 04	epp2 	-202,ic		000024 = 514000000001
000337  aa  6 00230 2521 00	spri2	pr6|152
000340  aa  6 00232 2521 00	spri2	pr6|154
000341  aa  6 00176 6211 00	eax1 	pr6|126
000342  aa   034000 4310 07	fld  	14336,dl
000343  aa  6 00044 3701 20	epp4 	pr6|36,*
000344  la  4 00016 3521 20	epp2 	pr4|14,*		ioa_$general_rs
000345  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 73
	call syserr (ANNOUNCE, "^a", substr (long_string, 1, lsl));

000346  aa  6 00162 2361 00	ldq  	pr6|114		lsl
000347  aa   524000 2760 03	orq  	174080,du
000350  aa  6 00174 7561 00	stq  	pr6|124
000351  aa   136141 2350 03	lda  	48225,du
000352  aa  6 00173 7551 00	sta  	pr6|123
000353  aa  6 00162 2361 00	ldq  	pr6|114		lsl
000354  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000355  aa  6 00204 2521 00	spri2	pr6|132
000356  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000357  aa  6 00100 00 0006	desc9a	pr6|64,ql		long_string
000360  aa  2 00000 00 0006	desc9a	pr2|0,ql
000361  aa   777441 3520 04	epp2 	-223,ic		000022 = 000000000000
000362  aa  6 00200 2521 00	spri2	pr6|128
000363  aa  6 00173 3521 00	epp2 	pr6|123
000364  aa  6 00202 2521 00	spri2	pr6|130
000365  aa   777432 3520 04	epp2 	-230,ic		000017 = 404000000021
000366  aa  6 00206 2521 00	spri2	pr6|134
000367  aa   777423 3520 04	epp2 	-237,ic		000012 = 524000000002
000370  aa  6 00210 2521 00	spri2	pr6|136
000371  aa  6 00174 3521 00	epp2 	pr6|124
000372  aa  6 00212 2521 00	spri2	pr6|138
000373  aa  6 00176 6211 00	eax1 	pr6|126
000374  aa   014000 4310 07	fld  	6144,dl
000375  aa  6 00044 3701 20	epp4 	pr6|36,*
000376  la  4 00012 3521 20	epp2 	pr4|10,*		syserr
000377  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 74
	return;

000400  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000401  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 75
     end report_;

  END PROCEDURE report_
BEGIN PROCEDURE display_ptw_
ENTRY TO display_ptw_                                       STATEMENT 1 ON LINE 77
display_ptw_:
     procedure (ptwp);

000402  da     000153200000
000403  aa   000140 6270 00	eax7 	96
000404  aa  7 00034 3521 20	epp2 	pr7|28,*
000405  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000406  aa     000002000000
000407  aa     000000000000
						STATEMENT 1 ON LINE 82
	call report_ (" --> PTW at ^6o", wordno (ptwp));

000410  aa   777427 2350 04	lda  	-233,ic		000037 = 040055055076
000411  aa   777427 2360 04	ldq  	-233,ic		000040 = 040120124127
000412  aa  6 00100 7571 00	staq 	pr6|64
000413  aa   777426 2350 04	lda  	-234,ic		000041 = 040141164040
000414  aa   777426 2360 04	ldq  	-234,ic		000042 = 136066157000
000415  aa  6 00102 7571 00	staq 	pr6|66
000416  aa  6 00032 3735 20	epp7 	pr6|26,*
000417  aa  7 00002 3715 20	epp5 	pr7|2,*		ptwp
000420  aa  5 00000 3715 20	epp5 	pr5|0,*		ptwp
000421  aa  5 00000 6361 00	eaq  	pr5|0		ptwp
000422  aa   000022 7720 00	qrl  	18
000423  aa  6 00104 7561 00	stq  	pr6|68
000424  aa  6 00100 3521 00	epp2 	pr6|64
000425  aa  6 00110 2521 00	spri2	pr6|72
000426  aa  6 00104 3521 00	epp2 	pr6|68
000427  aa  6 00112 2521 00	spri2	pr6|74
000430  aa   777360 3520 04	epp2 	-272,ic		000010 = 524000000017
000431  aa  6 00116 2521 00	spri2	pr6|78
000432  aa   777355 3520 04	epp2 	-275,ic		000007 = 404000000022
000433  aa  6 00120 2521 00	spri2	pr6|80
000434  aa   000001 7270 07	lxl7 	1,dl
000435  aa  6 00106 6211 00	eax1 	pr6|70
000436  aa   010000 4310 07	fld  	4096,dl
000437  aa   777626 3520 04	epp2 	-106,ic		000265 = 000240627000
000440  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 83
	return;

000441  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 84
     end display_ptw_;

  END PROCEDURE display_ptw_
BEGIN PROCEDURE display_cme_
ENTRY TO display_cme_                                       STATEMENT 1 ON LINE 86
display_cme_:
     procedure (cmep);

000442  da     000162200000
000443  aa   000140 6270 00	eax7 	96
000444  aa  7 00034 3521 20	epp2 	pr7|28,*
000445  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000446  aa     000002000000
000447  aa     000000000000
						STATEMENT 1 ON LINE 91
	call report_ (" --> CME at ^6o", wordno (cmep));

000450  aa   777363 2350 04	lda  	-269,ic		000033 = 040055055076
000451  aa   777363 2360 04	ldq  	-269,ic		000034 = 040103115105
000452  aa  6 00100 7571 00	staq 	pr6|64
000453  aa   777362 2350 04	lda  	-270,ic		000035 = 040141164040
000454  aa   777362 2360 04	ldq  	-270,ic		000036 = 136066157000
000455  aa  6 00102 7571 00	staq 	pr6|66
000456  aa  6 00032 3735 20	epp7 	pr6|26,*
000457  aa  7 00002 3715 20	epp5 	pr7|2,*		cmep
000460  aa  5 00000 3715 20	epp5 	pr5|0,*		cmep
000461  aa  5 00000 6361 00	eaq  	pr5|0		cmep
000462  aa   000022 7720 00	qrl  	18
000463  aa  6 00104 7561 00	stq  	pr6|68
000464  aa  6 00100 3521 00	epp2 	pr6|64
000465  aa  6 00110 2521 00	spri2	pr6|72
000466  aa  6 00104 3521 00	epp2 	pr6|68
000467  aa  6 00112 2521 00	spri2	pr6|74
000470  aa   777320 3520 04	epp2 	-304,ic		000010 = 524000000017
000471  aa  6 00116 2521 00	spri2	pr6|78
000472  aa   777315 3520 04	epp2 	-307,ic		000007 = 404000000022
000473  aa  6 00120 2521 00	spri2	pr6|80
000474  aa   000001 7270 07	lxl7 	1,dl
000475  aa  6 00106 6211 00	eax1 	pr6|70
000476  aa   010000 4310 07	fld  	4096,dl
000477  aa   777566 3520 04	epp2 	-138,ic		000265 = 000240627000
000500  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 92
	return;

000501  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 93
     end display_cme_;

  END PROCEDURE display_cme_
BEGIN PROCEDURE display_aste_
ENTRY TO display_aste_                                      STATEMENT 1 ON LINE 95
display_aste_:
     procedure (astep);

000502  da     000171200000
000503  aa   000140 6270 00	eax7 	96
000504  aa  7 00034 3521 20	epp2 	pr7|28,*
000505  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000506  aa     000002000000
000507  aa     000000000000
						STATEMENT 1 ON LINE 100
	call report_ (" --> aste at ^6o", wordno (astep));

000510  aa   777317 2350 04	lda  	-305,ic		000027 = 040055055076
000511  aa   777317 2360 04	ldq  	-305,ic		000030 = 040141163164
000512  aa  6 00100 7571 00	staq 	pr6|64
000513  aa   777316 2350 04	lda  	-306,ic		000031 = 145040141164
000514  aa   777316 2360 04	ldq  	-306,ic		000032 = 040136066157
000515  aa  6 00102 7571 00	staq 	pr6|66
000516  aa  6 00032 3735 20	epp7 	pr6|26,*
000517  aa  7 00002 3715 20	epp5 	pr7|2,*		astep
000520  aa  5 00000 3715 20	epp5 	pr5|0,*		astep
000521  aa  5 00000 6361 00	eaq  	pr5|0		astep
000522  aa   000022 7720 00	qrl  	18
000523  aa  6 00104 7561 00	stq  	pr6|68
000524  aa  6 00100 3521 00	epp2 	pr6|64
000525  aa  6 00110 2521 00	spri2	pr6|72
000526  aa  6 00104 3521 00	epp2 	pr6|68
000527  aa  6 00112 2521 00	spri2	pr6|74
000530  aa   777256 3520 04	epp2 	-338,ic		000006 = 524000000020
000531  aa  6 00116 2521 00	spri2	pr6|78
000532  aa   777255 3520 04	epp2 	-339,ic		000007 = 404000000022
000533  aa  6 00120 2521 00	spri2	pr6|80
000534  aa   000001 7270 07	lxl7 	1,dl
000535  aa  6 00106 6211 00	eax1 	pr6|70
000536  aa   010000 4310 07	fld  	4096,dl
000537  aa   777526 3520 04	epp2 	-170,ic		000265 = 000240627000
000540  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
						STATEMENT 1 ON LINE 101
	return;

000541  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 102
     end display_aste_;

  END PROCEDURE display_aste_
BEGIN PROCEDURE display_ptr_
ENTRY TO display_ptr_                                       STATEMENT 1 ON LINE 104
display_ptr_:
     procedure (ap) returns (char (*));

000542  da     000200220000
000543  aa   000140 6270 00	eax7 	96
000544  aa  7 00034 3521 20	epp2 	pr7|28,*
000545  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
000546  aa     000004000000
000547  aa     000000000000
						STATEMENT 1 ON LINE 110
	offset = "";

000550  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000551  aa   000000 00 0000	desc9a	0,0
000552  aa  6 00100 00 0014	desc9a	pr6|64,12		offset
						STATEMENT 1 ON LINE 111
	call ioa_$rsnnl ("^o", offset, (0), wordno (ap));

000553  aa   136157 2350 03	lda  	48239,du
000554  aa  6 00103 7551 00	sta  	pr6|67
000555  aa  6 00104 4501 00	stz  	pr6|68
000556  aa  6 00032 3735 20	epp7 	pr6|26,*
000557  aa  7 00002 3715 20	epp5 	pr7|2,*		ap
000560  aa  5 00000 3715 20	epp5 	pr5|0,*		ap
000561  aa  5 00000 6361 00	eaq  	pr5|0		ap
000562  aa   000022 7720 00	qrl  	18
000563  aa  6 00105 7561 00	stq  	pr6|69
000564  aa  6 00103 3521 00	epp2 	pr6|67
000565  aa  6 00110 2521 00	spri2	pr6|72
000566  aa  6 00100 3521 00	epp2 	pr6|64		offset
000567  aa  6 00112 2521 00	spri2	pr6|74
000570  aa  6 00104 3521 00	epp2 	pr6|68
000571  aa  6 00114 2521 00	spri2	pr6|76
000572  aa  6 00105 3521 00	epp2 	pr6|69
000573  aa  6 00116 2521 00	spri2	pr6|78
000574  aa   777216 3520 04	epp2 	-370,ic		000012 = 524000000002
000575  aa  6 00120 2521 00	spri2	pr6|80
000576  aa   777206 3520 04	epp2 	-378,ic		000004 = 526000000014
000577  aa  6 00122 2521 00	spri2	pr6|82
000600  aa   777203 3520 04	epp2 	-381,ic		000003 = 404000000005
000601  aa  6 00124 2521 00	spri2	pr6|84
000602  aa   777205 3520 04	epp2 	-379,ic		000007 = 404000000022
000603  aa  6 00126 2521 00	spri2	pr6|86
000604  aa  6 00106 6211 00	eax1 	pr6|70
000605  aa   020000 4310 07	fld  	8192,dl
000606  la  4 00020 3521 20	epp2 	pr4|16,*		ioa_$rsnnl
000607  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 112
	sltp = addr (slt$);

000610  aa  6 00044 3701 20	epp4 	pr6|36,*
000611  la  4 00032 3735 20	epp7 	pr4|26,*		slt$
000612  aa  6 00040 3715 20	epp5 	pr6|32,*
000613  aa  5 00214 6535 00	spri7	pr5|140		sltp
						STATEMENT 1 ON LINE 113
	names_ptr = slt.name_seg_ptr;

000614  aa  7 00000 3535 20	epp3 	pr7|0,*		slt.name_seg_ptr
000615  aa  5 00216 2535 00	spri3	pr5|142		names_ptr
						STATEMENT 1 ON LINE 114
	sltep = addr (slt.seg (segno (ap)));

000616  aa  6 00032 3515 20	epp1 	pr6|26,*
000617  aa  1 00002 3735 20	epp7 	pr1|2,*		ap
000620  aa  7 00000 3735 20	epp7 	pr7|0,*		ap
000621  aa  7 00000 2131 00	epaq 	pr7|0		ap
000622  aa   000022 7770 00	llr  	18
000623  aa   077777 3760 07	anq  	32767,dl
000624  aa   000002 7360 00	qls  	2
000625  aa  5 00214 3735 20	epp7 	pr5|140,*		sltp
000626  aa  7 00010 3735 06	epp7 	pr7|8,ql		slt.seg
000627  aa  5 00222 6535 00	spri7	pr5|146		sltep
						STATEMENT 1 ON LINE 115
	namep = setwordno (names_ptr, bin (slte_uns.names_ptr, 18));

000630  aa  7 00000 2351 00	lda  	pr7|0		slte_uns.names_ptr
000631  aa   000066 7730 00	lrl  	54
000632  aa  3 00000 3521 00	epp2 	pr3|0
000633  aa   000000 3120 06	eawp2	0,ql
000634  aa  5 00220 2521 00	spri2	pr5|144		namep
						STATEMENT 1 ON LINE 116
	return (rtrim (segnam.names (1).name) || rtrim (offset));

000635  aa  000 000 165 500	tctr 	(pr)
000636  aa  6 00100 00 0014	desc9a	pr6|64,12		offset
000637  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000640  aa  6 00056 0001 00	arg  	pr6|46
000641  aa  6 00056 2361 00	ldq  	pr6|46
000642  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000643  aa  6 00105 7561 00	stq  	pr6|69
000644  aa   000014 2360 07	ldq  	12,dl
000645  aa  6 00105 1761 00	sbq  	pr6|69
000646  aa  6 00105 7561 00	stq  	pr6|69
000647  aa  000 000 165 500	tctr 	(pr)
000650  aa  2 00002 00 0040	desc9a	pr2|2,32		segnam.name
000651  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000652  aa  6 00056 0001 00	arg  	pr6|46
000653  aa  6 00056 2361 00	ldq  	pr6|46
000654  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000655  aa  6 00104 7561 00	stq  	pr6|68
000656  aa   000040 2360 07	ldq  	32,dl
000657  aa  6 00104 1761 00	sbq  	pr6|68
000660  aa  6 00104 7561 00	stq  	pr6|68
000661  aa  6 00105 0761 00	adq  	pr6|69
000662  aa  6 00042 3535 20	epp3 	pr6|34,*
000663  aa  6 00103 7561 00	stq  	pr6|67
000664  aa   526000 2760 03	orq  	175104,du
000665  aa  3 00002 7561 20	stq  	pr3|2,*
000666  aa  6 00103 2361 00	ldq  	pr6|67
000667  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000670  aa  5 00220 3735 20	epp7 	pr5|144,*		namep
000671  aa  6 00104 2351 00	lda  	pr6|68
000672  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000673  aa  7 00002 00 0005	desc9a	pr7|2,al		segnam.name
000674  aa  2 00000 00 0005	desc9a	pr2|0,al
000675  aa  6 00105 2361 00	ldq  	pr6|69
000676  aa  040 145 100 540	mlr  	(pr,rl),(pr,rl,al),fill(040)
000677  aa  6 00100 00 0006	desc9a	pr6|64,ql		offset
000700  aa  2 00000 00 0006	desc9a	pr2|0,ql
000701  aa  6 00103 2361 00	ldq  	pr6|67
000702  aa   000000 7200 07	lxl0 	0,dl
000703  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 117
     end display_ptr_;

  END PROCEDURE display_ptr_
BEGIN PROCEDURE display_pvname_
ENTRY TO display_pvname_                                    STATEMENT 1 ON LINE 119
display_pvname_:
     procedure (pvtx) returns (char (32));

000704  da     000207220000
000705  aa   000120 6270 00	eax7 	80
000706  aa  7 00034 3521 20	epp2 	pr7|28,*
000707  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000710  aa     000004000000
000711  aa     000000000000
						STATEMENT 1 ON LINE 124
000712  aa   137000 2350 03	lda  	48640,du
000713  aa  6 00101 5511 40	stba 	pr6|65,40		dname.u
						STATEMENT 1 ON LINE 129
	pvt_arrayp = addr (pvt$array);

000714  la  4 00040 3735 20	epp7 	pr4|32,*		pvt$array
000715  aa  6 00040 3715 20	epp5 	pr6|32,*
000716  aa  5 00210 6535 00	spri7	pr5|136		pvt_arrayp
						STATEMENT 1 ON LINE 130
	pvtep = addr (pvt_array (pvtx));

000717  aa  6 00032 3535 20	epp3 	pr6|26,*
000720  aa  3 00002 2361 20	ldq  	pr3|2,*		pvtx
000721  aa   000034 4020 07	mpy  	28,dl
000722  aa  7 77744 3515 06	epp1 	pr7|-28,ql	pvt_array
000723  aa  5 00212 2515 00	spri1	pr5|138		pvtep
						STATEMENT 1 ON LINE 131
	dname.devname = pvte.devname;

000724  aa  1 00003 2351 00	lda  	pr1|3		pvte.devname
000725  aa  6 00100 7551 00	sta  	pr6|64		dname.devname
						STATEMENT 1 ON LINE 132
	dname.nn = pvte.logical_area_number;

000726  aa  1 00004 2351 00	lda  	pr1|4		pvte.logical_area_number
000727  aa   000011 7350 00	als  	9
000730  aa   000077 7330 00	lrs  	63
000731  aa  6 00103 7561 00	stq  	pr6|67		pvte.logical_area_number
000732  aa  000 100 301 500	btd  	(pr),(pr)
000733  aa  6 00103 00 0004	desc9a	pr6|67,4		pvte.logical_area_number
000734  aa  6 00102 01 0003	desc9ls	pr6|66,3,0
000735  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
000736  aa  6 00102 01 0003	desc9ls	pr6|66,3,0
000737  aa   000011 00 0002	desc9a	9,2		000746 = 070322000000
000740  aa  6 00101 20 0002	desc9a	pr6|65(1),2	dname.nn
						STATEMENT 1 ON LINE 133
	return (string (dname));

000741  aa  3 00004 3735 20	epp7 	pr3|4,*
000742  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000743  aa  6 00100 00 0007	desc9a	pr6|64,7
000744  aa  7 00000 00 0040	desc9a	pr7|0,32
000745  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 134
     end display_pvname_;

  END PROCEDURE display_pvname_
  END PROCEDURE pc_recover_sst


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
