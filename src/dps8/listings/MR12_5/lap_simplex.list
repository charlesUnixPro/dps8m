	COMPILATION LISTING OF SEGMENT lap_simplex
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0943.0 mst Sat
	    Options: optimize list

        1 /****^  **************************************************************
        2*        *                                                            *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                   *
        4*        *                                                            *
        5*        * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        6*        *                                                            *
        7*        ************************************************************** */
        8 
        9 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       10 
       11 lap_simplex:
       12      procedure;
       13 
       14 /*
       15*   This procedure is the trivial multiplexer which is used to gain direct access to the
       16*   FNP LAP implementation for use by the ARPAnet HDH interface. It contains both the
       17*   wired and nonwired entrypoints, since it's so small.
       18**/
       19 
       20 /*
       21*   Coded December 1978 by J. Stern
       22*   Modified 7/31/79 by B.Westcott to support lap instead.
       23*   Modified November 1979 by C. Hornig for installation.
       24*   Modified August 1981 by C. Hornig to add metering.
       25*   Modified May 1982 by D. W. Cousins for deletion of HOST level2 mpx.
       26*   Modified January 1983 by W. Olin Sibert to create lap_simplex (again!)
       27*   Modified 6/23/83 by Jis to wire itself down when first invoked
       28*   Modified Nov 1986 by T. Beecher to correctly adjust buffer.tally for
       29*   insertion of L2_HEADER_PAD, to handle "frame-size" error @ line-status
       30*   interrupt, and to remove local copies of error_table codes.
       31*   Note:  the lap_cmdr_status structure was copied from x25_mpx.pl1.
       32**/
       33 
       34 /****^  HISTORY COMMENTS:
       35*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
       36*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
       37*     Prepared for installation.
       38*                                                   END HISTORY COMMENTS */
       39 
       40 /* * * * * * * * * * * INTERRUPT * * * * * * * * * * */
       41 
       42 lap_simplex$interrupt:
       43      entry (P_lap_data_ptr, P_int_type, P_int_data);
       44 
       45 	lap_data_ptr = P_lap_data_ptr;
       46 	int_type = P_int_type;
       47 	int_data = P_int_data;
       48 
       49 	if (int_type < lbound (INTERRUPT, 1)) | (int_type > hbound (INTERRUPT, 1)) then do;
       50 BAD_INTERRUPT:
       51 	     call syserr (Log_message, "lap_simplex(^a): Unexpected interrupt ^d ^.3b received.", lap_data.name,
       52 		int_type, int_data);
       53 	     return;
       54 	     end;
       55 	else goto INTERRUPT (int_type);
       56 
       57 
       58 INTERRUPT (1):					/* DIALUP - major channel has dialed up */
       59 	if (lap_data.state ^= LAP_LISTENING) then goto BAD_INTERRUPT;
       60 	unspec (lap_data.dialup_info) = int_data;	/* Remember it, and send it on */
       61 	lap_data.sc_dialup_info = lap_data.dialup_info;	/* Construct new version */
       62 	lap_data.sc_dialup_info.buffer_pad = L2_HEADER_PAD;
       63 	lap_data.sc_dialup_info.line_type = LINE_ASCII;
       64 
       65 	call pxss$ring_0_wakeup (lap_data.load_process_id, lap_data.load_event_channel, MPX_UP, ignore_code);
       66 	lap_data.state = LAP_ACTIVE;			/* Tell the Initializer we're here */
       67 	return;
       68 
       69 
       70 INTERRUPT (2):					/* HANGUP - major channel has hung up */
       71 	call crash (int_type);
       72 	return;
       73 
       74 
       75 INTERRUPT (3):					/* CRASH - parent multiplexer has died */
       76 	call crash (int_type);
       77 	return;
       78 
       79 
       80 INTERRUPT (4):					/* SEND_OUTPUT - it's safe to write next output frame now */
       81 	lap_data.flags.send_output = "1"b;
       82 	call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, (""b));
       83 	return;
       84 
       85 
       86 INTERRUPT (5):					/* INPUT_AVAILABLE */
       87 	goto BAD_INTERRUPT;
       88 
       89 
       90 INTERRUPT (6):					/* ACCEPT INPUT - process an input frame */
       91 	unspec (rtx_info) = int_data;
       92 	blockp = pointer (lap_data_ptr, rtx_info.chain_head);
       93 	real_buffer_lth = buffer.tally - L2_HEADER_PAD;
       94 
       95 	if ((lap_data.state < LAP_ACTIVE) | (real_buffer_lth <= 0)) then do;
       96 	     call tty_space_man$free_chain (lap_data.devx, INPUT, blockp);
       97 	     goto BAD_INTERRUPT;			/* Packet either too small or arrived at a bad time */
       98 	     end;
       99 
      100 	call tty_space_man$switch_chain (lap_data.devx, lap_data.subchannel, INPUT, INPUT, blockp);
      101 						/* Be sure to switch BEFORE shrinking.... */
      102 	begin;					/* Shift the characters over to eliminate the LAP */
      103 dcl  old_string char (real_buffer_lth) automatic;		/* header bytes */
      104 dcl  new_string char (real_buffer_lth) defined (buffer.chars);
      105 	     old_string = substr (string (buffer.chars), L2_HEADER_PAD + 1, real_buffer_lth);
      106 	     new_string = old_string;
      107 	end;
      108 
      109 	buffer.tally = buffer.tally - L2_HEADER_PAD;
      110 	rtx_info.input_count = rtx_info.input_count - L2_HEADER_PAD;
      111 
      112 	blockp = pointer (blockp, rtx_info.chain_tail);	/* Set the sentinel bit in the last char (just like */
      113 	begin;					/* the one we get when writing) */
      114 dcl  last_char char (1) unaligned defined (buffer.chars (buffer.tally - 1));
      115 	     unspec (last_char) = unspec (last_char) | "400"b3;
      116 	end;
      117 
      118 	call channel_manager$interrupt (lap_data.subchannel, ACCEPT_INPUT, unspec (rtx_info));
      119 	return;					/* Otherwise, just send it on */
      120 
      121 
      122 INTERRUPT (7):					/* INPUT REJECTED - ignore */
      123 INTERRUPT (8):					/* QUIT - ignore */
      124 	return;
      125 
      126 
      127 INTERRUPT (9):					/* LINE_STATUS - LAP link has gone down */
      128 	unspec (lap_down_status) = int_data;
      129 
      130 	if lap_down_status.status_type = 1
      131 	then call syserr (Log_message,
      132 		"lap_simplex(^a): Failure, Link state: ^a, Current action: ^a, in ^a, Primary state: ^a, Secondary state: ^a",
      133 		lap_data.name, FRAME_STATE_ARRAY (lap_down_status.main_state),
      134 		FRAME_FUNCTION_CODE (lap_down_status.last_function_process),
      135 		FRAME_SUB_STATE_ARRAY (lap_down_status.which_state_process),
      136 		FRAME_SUB_STATE_ARRAY (lap_down_status.primary_sub_state),
      137 		FRAME_SUB_STATE_ARRAY (lap_down_status.secondary_sub_state));
      138 
      139 	else if lap_cmdr_status.cmdr_status = 3
      140 	then call syserr (Log_message,
      141 		"lap_simplex(^a): Link disconnected due to mis-matched frame sizes. CMDR/FRMR frame: ^( ^.4b^).",
      142 		lap_data.name, lap_cmdr_status.cmdr_bytes.byte (*));
      143 
      144 	else goto BAD_INTERRUPT;			/* We don't know this status. */
      145 
      146 	return;					/* FNP will send hangup itself. */
      147 
      148 
      149 INTERRUPT (10):					/* DIAL STATUS - ignore */
      150 INTERRUPT (11):					/* WRU TIMEOUT - ignore */
      151 	goto BAD_INTERRUPT;
      152 
      153 
      154 INTERRUPT (12):					/* SPACE AVAILABLE - some buffer space was freed that we need */
      155 	call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, ""b);
      156 	return;					/* If we didn't ask, ignore it */
      157 
      158 
      159 INTERRUPT (13):					/* ACKNOWLEDGE_ECHNEGO_INIT */
      160 INTERRUPT (14):					/* ACKNOWLEDGE_ECHNEGO_STOP */
      161 	return;					/* Ignore both of these */
      162 
      163 
      164 INTERRUPT (15):					/* TIMER */
      165 INTERRUPT (16):					/* USER_INTERRUPT */
      166 	goto BAD_INTERRUPT;
      167 
      168 
      169 INTERRUPT (17):					/* MASKED - treat like HANGUP but use different wakeup message */
      170 	call pxss$ring_0_wakeup (lap_data.load_process_id, lap_data.load_event_channel, MPX_MASKED, code);
      171 	call crash (MASKED);
      172 	lap_data.state = LAP_HUNGUP;
      173 	return;
      174 
      175 /* * * * * * * * * * * WRITE * * * * * * * * * * */
      176 
      177 lap_simplex$write:
      178      entry (P_lap_data_ptr, P_subchan_idx, P_chain_ptr, P_code);
      179 
      180 	call setup ();
      181 
      182 	code = 0;
      183 	chain_ptr = P_chain_ptr;
      184 	next_block = binary (rel (chain_ptr), 18);
      185 
      186 	do while ((next_block ^= 0) & lap_data.send_output);
      187 	     blockp = pointer (chain_ptr, next_block);
      188 
      189 /*
      190*   The following statement generates miserable code, in that it invokes the pessimal search operator.
      191*   Clearly, it could be optimized, and, indeed, it turns out that search (XXX, collate) is thusly
      192*   optimized, so it's probably not even that hard to fix.
      193**/
      194 
      195 	     frame_end = search (substr (string (buffer.chars), 1, buffer.tally), substr (collate9 (), 257, 256));
      196 
      197 	     if frame_end = 0 then do;		/* Buffer contains the middle of a frame */
      198 		next_block = buffer.next;		/* Just add it on and try the next buffer */
      199 		call add_buffer_to_frame ();		/* in the chain */
      200 		end;
      201 
      202 	     else if frame_end = buffer.tally then do;	/* Buffer ends a frame. Add it on, try to write */
      203 		next_block = buffer.next;		/* it out, and go on to the next buffer */
      204 		lap_data.frame_ready = "1"b;
      205 		call add_buffer_to_frame ();
      206 		end;
      207 
      208 	     else do;				/* Frame ends in the middle of a buffer. */
      209 		call split_buffer ();
      210 		lap_data.frame_ready = "1"b;		/* Guaranteed to be ready after splitting */
      211 		call add_buffer_to_frame ();		/* This adds on only the old half */
      212 		end;
      213 
      214 	     if lap_data.frame_ready then call write_frame ();
      215 	end;
      216 
      217 WRITE_FINISHES:
      218 	if (next_block = 0)
      219 	then P_chain_ptr = null ();
      220 	else P_chain_ptr = pointer (chain_ptr, next_block);
      221 
      222 	if lap_data.send_output then call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, ""b);
      223 
      224 	P_code = code;
      225 	return;
      226 
      227 /* * * * * * * * * * * ADD_BUFFER_TO_FRAME * * * * * * * * * * */
      228 
      229 add_buffer_to_frame:
      230      procedure ();
      231 
      232 	if (buffer.tally + lap_data.frame_size) > lap_data.max_frame_size then do;
      233 	     call syserr (Log_message, "lap_simplex(^a): Attempt to write overlength frame.", lap_data.name);
      234 	     call crash (HANGUP);
      235 	     call free_pending_frame ();
      236 	     end;
      237 
      238 	lap_data.frame_size = lap_data.frame_size + buffer.tally;
      239 	buffer.next = 0;				/* Break the chain before adding on */
      240 	string (buffer.flags) = ""b;
      241 
      242 	if (lap_data.frame_start ^= null ())
      243 	then					/* Add it to the end if there's something there */
      244 	     lap_data.frame_end -> buffer.next = binary (rel (blockp), 18);
      245 	else lap_data.frame_start = blockp;		/* Otherwise, remember the first */
      246 
      247 	lap_data.frame_end = blockp;			/* And always remember the end */
      248 
      249 	return;
      250      end add_buffer_to_frame;
      251 
      252 /* * * * * * * * * * SPLIT_BUFFER * * * * * * * * * * */
      253 
      254 split_buffer:
      255      procedure ();
      256 
      257 dcl  leftover_chars fixed bin;
      258 dcl  new_buf_size fixed bin;
      259 dcl  new_bufp pointer;
      260 
      261 /*
      262*   This procedure is invoked when a frame terminator is found in the middle of a buffer. It splits
      263*   the buffer in two, copies the extra characters into the new one, shrinks the old one, and
      264*   adjusts next_block so that the new one will be the next one considered.
      265**/
      266 
      267 	leftover_chars = buffer.tally - frame_end;
      268 
      269 	new_buf_size = 16 * (1 + divide ((leftover_chars + 7), 64, 17, 0));
      270 	call tty_space_man$get_buffer (lap_data.subchannel, new_buf_size, OUTPUT, new_bufp);
      271 	if (new_bufp = null ()) then do;		/* If this fails, it means we return the buffer we split */
      272 	     call tty_space_man$needs_space (lap_data.devx);
      273 						/* to our caller, and let him ship it back to us some */
      274 	     lap_data.send_output = "0"b;		/* other time. It gets shipped back because, at this */
      275 	     goto WRITE_FINISHES;			/* point, next_block still indicates the buffer being */
      276 	     end;					/* considered for splitting. */
      277 
      278 	substr (string (new_bufp -> buffer.chars), 1, leftover_chars) =
      279 	     substr (string (buffer.chars), frame_end + 1, leftover_chars);
      280 	new_bufp -> buffer.next = buffer.next;
      281 	new_bufp -> buffer.tally = leftover_chars;
      282 	string (new_bufp -> buffer.flags) = ""b;
      283 
      284 	next_block = binary (rel (new_bufp), 18);	/* Now, the new buffer will be the one we look at next */
      285 
      286 	buffer.tally = buffer.tally - leftover_chars;	/* Shrink the old one, and return */
      287 
      288 	return;
      289      end split_buffer;
      290 
      291 /* * * * * * * * * * WRITE_FRAME * * * * * * * * * * */
      292 
      293 write_frame:
      294      procedure ();
      295 
      296 dcl  bufp pointer;
      297 dcl  bufl fixed bin;
      298 
      299 
      300 	lap_data.frame_end -> buffer.break = "1"b;	/* Since this IS the end */
      301 
      302 	bufp = lap_data.frame_start;			/* Shift first buffer right to make room for the */
      303 	bufl = bufp -> buffer.tally;			/* LAP header */
      304 
      305 	begin;					/* copy the characters over, avoiding overlap */
      306 dcl  old_string char (bufl) automatic;
      307 dcl  new_string char (bufl) defined (bufp -> buffer.chars (L2_HEADER_PAD));
      308 	     old_string = substr (string (bufp -> buffer.chars), 1, bufl);
      309 	     new_string = old_string;
      310 	end;
      311 
      312 	bufp -> buffer.tally = bufp -> buffer.tally + L2_HEADER_PAD;
      313 						/* Update the tally to say that the  */
      314 						/* header is there */
      315 
      316 	call tty_space_man$switch_chain (lap_data.subchannel, lap_data.devx, OUTPUT, OUTPUT, lap_data.frame_start);
      317 
      318 	call channel_manager$write (lap_data.devx, lap_data.frame_start, code);
      319 	if (code ^= 0) then do;
      320 	     call syserr$error_code (Log_message, code, "lap_simplex(^a): Error from write of ^d chars.", lap_data.name,
      321 		lap_data.frame_size);
      322 	     call free_pending_frame ();
      323 	     call channel_manager$control (lap_data.devx, "hangup", null (), ignore_code);
      324 	     return;
      325 	     end;
      326 
      327 	if (lap_data.frame_start ^= null ()) & (lap_data.frame_start ^= bufp) then do;
      328 	     call syserr (Log_message, "lap_simplex(^a): Write failed to take whole frame, discarding rest.",
      329 		lap_data.name);
      330 	     call free_pending_frame ();
      331 	     return;
      332 	     end;
      333 
      334 	if (lap_data.frame_start = null ()) then do;
      335 	     lap_data.frame_end = null ();
      336 	     lap_data.frame_size = 0;
      337 	     lap_data.frame_ready = "0"b;
      338 	     lap_data.send_output = "1"b;		/* Try it over again */
      339 	     end;
      340 	else lap_data.send_output = "0"b;		/* Didn't take the frame, so wait */
      341 
      342 	return;
      343      end write_frame;
      344 
      345 /* * * * * * * * * * * CONTROL * * * * * * * * * * */
      346 
      347 lap_simplex$control:
      348      entry (P_lap_data_ptr, P_subchan_idx, P_order, P_info_ptr, P_code);
      349 
      350 	call setup ();
      351 
      352 	order = P_order;
      353 	info_ptr = P_info_ptr;
      354 	code = 0;
      355 
      356 	if (order = "hangup") then do;
      357 	     if (lap_data.state = LAP_HUNGUP)
      358 	     then code = error_table_$invalid_state;
      359 	     else call channel_manager$control (lap_data.devx, "hangup", null (), code);
      360 	     end;
      361 
      362 	else if (order = "listen") then do;
      363 	     if (lap_data.state ^= LAP_ACTIVE)
      364 	     then code = error_table_$invalid_state;
      365 	     else do;
      366 		call channel_manager$interrupt (lap_data.subchannel, DIALUP, unspec (lap_data.sc_dialup_info));
      367 		call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, ""b);
      368 		end;
      369 	     end;
      370 
      371 	else if (order = "abort") then do;
      372 	     if (info_ptr = null ())
      373 	     then code = error_table_$null_info_ptr;
      374 	     else call free_pending_frame ();
      375 	     end;
      376 
      377 	else if (order = "write_status") then do;
      378 	     if (info_ptr = null ())
      379 	     then code = error_table_$null_info_ptr;
      380 	     else do;
      381 		if (lap_data.frame_size ^= 0)
      382 		then info_ptr -> tty_write_status_info.output_pending = "1"b;
      383 		else call channel_manager$control (lap_data.devx, "write_status", info_ptr, code);
      384 		end;
      385 	     end;
      386 
      387 	else if (order = "wru") then do;
      388 	     if (lap_data.state ^= LAP_ACTIVE)
      389 	     then code = error_table_$invalid_state;
      390 	     else call channel_manager$interrupt (lap_data.subchannel, WRU_TIMEOUT, ""b);
      391 	     end;
      392 
      393 	else code = error_table_$undefined_order_request;
      394 
      395 	P_code = code;
      396 	return;
      397 
      398 /* * * * * * * * * * * CHECK_MODES * * * * * * * * * */
      399 
      400 lap_simplex$check_modes:
      401      entry (P_lap_data_ptr, P_subchan_idx, P_mcl_info_ptr, P_code);
      402 
      403 	call do_modes ("0"b);
      404 	return;
      405 
      406 /* * * * * * * * * * SET_MODES * * * * * * * * * */
      407 
      408 lap_simplex$set_modes:
      409      entry (P_lap_data_ptr, P_subchan_idx, P_mcl_info_ptr, P_code);
      410 
      411 	call do_modes ("1"b);
      412 	return;
      413 
      414 /* * * * * * * * * * * GET_MODES * * * * * * * * * * */
      415 
      416 lap_simplex$get_modes:
      417      entry (P_lap_data_ptr, P_subchan_idx, P_modes, P_code);
      418 
      419 	call setup ();
      420 	P_code = 0;
      421 	P_modes = "";
      422 	return;
      423 
      424 /* * * * * * * * * * * DO_MODES * * * * * * * * * * */
      425 
      426 do_modes:
      427      procedure (P_set_sw);
      428 
      429 dcl  P_set_sw bit (1) aligned parameter;
      430 dcl  mode_error fixed bin (35);
      431 
      432 
      433 	call setup ();
      434 	mclp = P_mcl_info_ptr;
      435 
      436 	if mcl.version ^= mcl_version_2 then do;
      437 	     P_code = error_table_$unimplemented_version;
      438 	     return;
      439 	     end;
      440 
      441 	mode_error = 0;				/* The only modes we implement are rawo and rawi, and they */
      442 						/* must always be turned on */
      443 	do mode_idx = 1 to mcl.n_entries;
      444 	     mclep = addr (mcl.entries (mode_idx));
      445 	     if (mcle.mode_name = "rawo") | (mcle.mode_name = "rawi") then do;
      446 		if ^P_set_sw then mcle.mpx_mode = "1"b;
      447 		else if (mcle.mode_switch = "0"b) then do;
      448 						/* They can only be turned on */
      449 		     mode_error = error_table_$bad_mode;
      450 		     mcle.error = "1"b;
      451 		     end;
      452 		end;
      453 
      454 	     else if P_set_sw
      455 	     then if (mcle.mpx_mode & ^mcle.force) then do;
      456 		     mode_error = error_table_$bad_mode;
      457 		     mcle.error = "1"b;
      458 		     end;
      459 
      460 		else mcle.mpx_mode = "0"b;
      461 	end;
      462 
      463 	P_code = mode_error;
      464 	return;
      465      end do_modes;
      466 
      467 /* * * * * * * * * * SETUP_SUBCHAN * * * * * * * * * */
      468 
      469 setup:
      470      procedure ();
      471 
      472 	lap_data_ptr = P_lap_data_ptr;
      473 	if (P_subchan_idx ^= 1) then do;
      474 	     call syserr (Write_with_alarm, "lap_simplex(^a): Invalid subchannel index ^d", lap_data.name, P_subchan_idx);
      475 	     P_code = error_table_$bad_arg;
      476 	     goto SETUP_RETURNS_FOR_ERROR;
      477 	     end;
      478 
      479 	return;
      480      end setup;
      481 
      482 SETUP_RETURNS_FOR_ERROR:
      483 	return;					/* from lap_simplex */
      484 
      485 
      486 /* * * * * * * * * * CRASH * * * * * * * * * */
      487 
      488 crash:
      489      procedure (P_type);
      490 
      491 dcl  P_type fixed bin parameter;
      492 
      493 
      494 	call free_pending_frame ();
      495 
      496 	call channel_manager$interrupt (lap_data.subchannel, P_type, ""b);
      497 
      498 	if (P_type ^= CRASH)
      499 	then					/* Unless he's already obviously aware, */
      500 	     call pxss$ring_0_wakeup (lap_data.load_process_id, lap_data.load_event_channel, MPX_DOWN, code);
      501 						/* we'd better let daddy know we've been bad */
      502 	lap_data.state = LAP_HUNGUP;
      503 
      504 	return;
      505      end crash;
      506 
      507 /* * * * * * * * * * FREE_PENDING_FRAME * * * * * * * * * */
      508 
      509 free_pending_frame:
      510      procedure ();
      511 
      512 	if (lap_data.frame_start = null ()) then return;
      513 
      514 	call tty_space_man$free_chain (lap_data.devx, OUTPUT, lap_data.frame_start);
      515 
      516 	lap_data.frame_start = null ();
      517 	lap_data.frame_end = null ();
      518 	lap_data.frame_size = 0;
      519 	lap_data.frame_ready = "0"b;
      520 
      521 	return;
      522      end free_pending_frame;
      523 
      524 /*
      525*   All the "unwired" entries are below; they share no important code with the operational
      526*   parts of the multiplexer, only declarations, and are here for packaging reasons only.
      527**/
      528 
      529 /* * * * * * * * * * INIT_MULTIPLEXER * * * * * * * * * */
      530 
      531 /* Entry to allocate and initialize the multiplexer data base for a given major channel */
      532 
      533 lap_simplex$init_multiplexer:
      534      entry (P_devx, P_miip, P_lap_data_ptr, P_code);
      535 
      536 	devx = P_devx;
      537 	miip = P_miip;
      538 	P_lap_data_ptr = null ();
      539 
      540 	if ^init_sw then do;
      541 	     call wire_proc$wire_me;			/* Chomp on the memories */
      542 	     init_sw = "1"b;
      543 	     end;
      544 
      545 	lap_data_ptr = null ();
      546 	on cleanup
      547 	     begin;
      548 	     if lap_data_ptr ^= null () then call tty_space_man$free_space (size (lap_data), lap_data_ptr);
      549 	end;
      550 
      551 	call tty_space_man$get_space (size (lap_data), lap_data_ptr);
      552 	if lap_data_ptr = null () then do;		/* allocate space for multiplexer data base */
      553 	     P_code = error_table_$noalloc;
      554 	     return;
      555 	     end;
      556 
      557 	lap_data.name = reverse (after (reverse (mux_init_info.channels (1).name), "."));
      558 	lap_data.devx = devx;
      559 	lap_data.subchannel = mux_init_info.channels (1).devx;
      560 	lap_data.state = LAP_HUNGUP;
      561 	lap_data.frame_start = null ();
      562 	lap_data.frame_end = null ();
      563 
      564 	lctp = tty_buf$lct_ptr;
      565 	lctep = addr (lct.lcte_array (lap_data.subchannel));
      566 	lcte.subchannel = 1;
      567 
      568 	P_lap_data_ptr = lap_data_ptr;
      569 	P_code = 0;
      570 	return;
      571 
      572 /* * * * * * * * * * TERMINATE_MULTIPLEXER * * * * * * * * * */
      573 
      574 /* Entry to discard the multiplexer data base for a given major channel */
      575 
      576 lap_simplex$terminate_multiplexer:
      577      entry (P_lap_data_ptr, P_code);
      578 
      579 	lap_data_ptr = P_lap_data_ptr;
      580 	call tty_space_man$free_space (currentsize (lap_data), lap_data_ptr);
      581 
      582 	P_lap_data_ptr = null ();
      583 	P_code = 0;
      584 	return;
      585 
      586 /* * * * * * * * * START * * * * * * * * * */
      587 
      588 /* Entry to allow dialups on multiplexer subchannels */
      589 
      590 lap_simplex$start:
      591      entry (P_lap_data_ptr, P_code);
      592 
      593 	lap_data_ptr = P_lap_data_ptr;
      594 	lap_data.simplex_started = "1"b;
      595 	P_code = 0;
      596 	return;
      597 
      598 /* * * * * * * * * * STOP * * * * * * * * * */
      599 
      600 /* Entry to forbid dialups on multiplexer subchannels */
      601 
      602 lap_simplex$stop:
      603      entry (P_lap_data_ptr, P_code);
      604 
      605 	lap_data_ptr = P_lap_data_ptr;
      606 	lap_data.simplex_started = "0"b;
      607 	P_code = 0;
      608 	return;
      609 
      610 /* * * * * * * * * * SHUTDOWN * * * * * * * * * */
      611 
      612 /*
      613*   Entry to shut down the multiplexer (equivalent to a crash)
      614*   instead of just hangup. It should be a disconnect order and
      615*   then a deactivate order for any state greater than listening
      616**/
      617 
      618 lap_simplex$shutdown:
      619      entry (P_lap_data_ptr, P_code);
      620 
      621 	lap_data_ptr = P_lap_data_ptr;
      622 	if (lap_data.state > LAP_HUNGUP) then call channel_manager$control (lap_data.devx, "hangup", null (), code);
      623 	return;
      624 
      625 /* * * * * * * * * PRIV_CONTROL * * * * * * * * * * */
      626 
      627 /* Entry to perform privileged control orders */
      628 
      629 lap_simplex$priv_control:
      630      entry (P_lap_data_ptr, P_order, P_info_ptr, P_code);
      631 
      632 	lap_data_ptr = P_lap_data_ptr;
      633 	order = P_order;
      634 	P_code = 0;
      635 
      636 	if /* case */ order = "copy_meters" then do;
      637 	     call channel_manager$control (lap_data.devx, order, P_info_ptr, P_code);
      638 	     end;
      639 
      640 	else if order = "get_meters" then do;
      641 	     call channel_manager$control (lap_data.devx, order, P_info_ptr, P_code);
      642 	     end;
      643 
      644 	else P_code = error_table_$undefined_order_request;
      645 
      646 	return;
      647 
      648 /* * * * * * * * * * HPRIV_CONTROL * * * * * * * * * */
      649 
      650 /* Entry to perform highly privileged control orders */
      651 
      652 lap_simplex$hpriv_control:
      653      entry (P_lap_data_ptr, P_order, P_info_ptr, P_code);
      654 
      655 	lap_data_ptr = P_lap_data_ptr;
      656 	order = P_order;
      657 	code = 0;
      658 
      659 	if /* case */ order = "load_mpx" then do;	/* bootload the multiplexed device */
      660 	     lap_load_info_ptr = P_info_ptr;		/* save load info */
      661 
      662 	     if lap_load_info.version ^= LAP_LOAD_INFO_VERSION_1 then do;
      663 		P_code = error_table_$unimplemented_version;
      664 		return;
      665 		end;
      666 
      667 	     if lap_data.state > LAP_HUNGUP then do;	/* one at a time please */
      668 		P_code = error_table_$action_not_performed;
      669 		return;
      670 		end;
      671 
      672 	     string (lap_data.flags) = ""b;
      673 	     lap_data.load_process_id = lap_load_info.process_id;
      674 	     lap_data.load_event_channel = lap_load_info.event_channel;
      675 	     lap_data.activate_order = lap_load_info.activate_order;
      676 
      677 	     lap_data.activate_order.pad = ""b;		/* Just in case */
      678 	     lap_data.activate_order.command = ACTIVATE_COMMAND;
      679 
      680 	     lap_data.max_frame_size = divide (lap_data.activate_order.frame_size + 7, 8, 17, 0);
      681 
      682 	     call channel_manager$control (lap_data.devx, "line_control", addr (lap_data.activate_order), code);
      683 	     if code ^= 0 then do;
      684 		P_code = code;
      685 		return;
      686 		end;
      687 
      688 	     call channel_manager$control (lap_data.devx, "listen", null (), code);
      689 	     if code ^= 0 then do;
      690 		P_code = code;
      691 		return;
      692 		end;
      693 
      694 	     lap_data.state = LAP_LISTENING;
      695 	     end;
      696 
      697 	else code = error_table_$undefined_order_request;
      698 
      699 	P_code = code;
      700 	return;
      701 
      702 dcl  P_devx fixed bin parameter;			/* device (LCT) index */
      703 dcl  P_info_ptr pointer parameter;			/* ptr to control order info structure */
      704 dcl  P_miip pointer parameter;			/* ptr to mux_init_info structure */
      705 dcl  P_order char (*) parameter;			/* control order name */
      706 dcl  P_lap_data_ptr pointer parameter;			/* ptr to lap_data (lap multiplexer data base) */
      707 dcl  P_subchan_idx fixed bin parameter;			/* Subchannel index (should always be 1) */
      708 dcl  P_int_type fixed bin parameter;
      709 dcl  P_int_data bit (72) aligned parameter;
      710 dcl  P_chain_ptr pointer parameter;
      711 dcl  P_mcl_info_ptr pointer parameter;			/* Mode change list and modes */
      712 dcl  P_modes char (*) parameter;
      713 dcl  P_code fixed bin (35) parameter;			/* error code */
      714 
      715 dcl  code fixed bin (35);
      716 dcl  ignore_code fixed bin (35);
      717 dcl  devx fixed bin;
      718 dcl  info_ptr pointer;
      719 dcl  order char (32);
      720 dcl  int_type fixed bin;
      721 dcl  int_data bit (72) aligned;
      722 dcl  chain_ptr pointer;
      723 dcl  next_block fixed bin (18);
      724 dcl  frame_end fixed bin;
      725 dcl  real_buffer_lth fixed bin;
      726 dcl  mode_idx fixed bin;
      727 
      728 dcl  1 lap_down_status aligned like lap_line_status_info automatic;
      729 
      730 dcl  1 lap_cmdr_status aligned based (addr (int_data)),
      731        2 cmdr_status uns fixed bin (18) unaligned,	/* constant 3 */
      732        2 cmdr_bytes (3) unaligned,			/* I-frame at fault */
      733          3 pad bit (1) unaligned,			/* N(s) & N(r) */
      734          3 byte bit (8) unaligned,			/* flags w,x,y,z */
      735        2 pad bit (27) unaligned;
      736 
      737 dcl  init_sw bit (1) aligned static init ("0"b);		/* Whether proc has been wired */
      738 
      739 dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      740 dcl  syserr entry options (variable);
      741 dcl  syserr$error_code entry options (variable);
      742 dcl  wire_proc$wire_me entry;
      743 
      744 dcl  error_table_$action_not_performed fixed bin (35) external static;
      745 dcl  error_table_$bad_arg fixed bin (35) external static;
      746 dcl  error_table_$bad_mode fixed bin (35) external static;
      747 dcl  error_table_$invalid_state fixed bin (35) external static;
      748 dcl  error_table_$noalloc fixed bin (35) external static;
      749 dcl  error_table_$null_info_ptr fixed bin (35) external static;
      750 dcl  error_table_$undefined_order_request fixed bin (35) external static;
      751 dcl  error_table_$unimplemented_version fixed bin (35) external static;
      752 
      753 dcl  tty_buf$lct_ptr pointer external static;
      754 
      755 dcl  MPX_UP fixed bin (71) static options (constant) init (1);
      756 dcl  MPX_DOWN fixed bin (71) static options (constant) init (2);
      757 dcl  MPX_MASKED fixed bin (71) static options (constant) init (3);
      758 
      759 dcl  cleanup condition;
      760 
      761 dcl  (addr, after, binary, collate9, currentsize, divide, hbound, lbound, pointer, null, rel, reverse, search, size,
      762      string, substr, unspec) builtin;
      763 
  1     1 /* BEGIN INCLUDE FILE ... lap_simplex_data.incl.pl1 */
  1     2 
  1     3 /*
  1     4*   Created 2/1/83 by Olin Sibert to add support for LAP mulitiplexers.
  1     5**/
  1     6 
  1     7 /****^  HISTORY COMMENTS:
  1     8*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
  1     9*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
  1    10*     Prepared for installation.
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 dcl  lap_load_info_ptr pointer;
  1    14 dcl  lap_data_ptr pointer;
  1    15 
  1    16 dcl 1 lap_data aligned based (lap_data_ptr),
  1    17     2 name char (32) unaligned,
  1    18     2 devx fixed bin,
  1    19     2 subchannel fixed bin,
  1    20     2 state fixed bin,                                      /* One of the state values below */
  1    21     2 flags aligned,
  1    22       3 send_output bit (1) unaligned,
  1    23       3 simplex_started bit (1) unaligned,                      /* Whether to accept dialups */
  1    24       3 pad bit (34) unaligned,
  1    25     2 load_process_id bit (36) aligned,                     /* For notifications */
  1    26     2 load_event_channel fixed bin (71),
  1    27     2 activate_order aligned like lap_line_control_info,    /* Order used to activate the LAP tables */
  1    28     2 dialup_info aligned like dialup_info,                 /* Dialup info received from FNP */
  1    29     2 sc_dialup_info aligned like dialup_info,              /* and info sent on to our subchannel */
  1    30     2 max_frame_size fixed bin,                             /* Max number of characters stuffable into a frame */
  1    31     2 frame_ready bit (1) aligned,                          /* Frame (collected below) is complete and should be sent */
  1    32     2 frame_size fixed bin,                                 /* Number of characters */
  1    33     2 frame_start pointer,                                  /* Beginning and end of buffer chain */
  1    34     2 frame_end pointer;
  1    35 
  1    36 dcl  LAP_HUNGUP init (0) fixed bin internal static options (constant);
  1    37 dcl  LAP_LISTENING init (1) fixed bin internal static options (constant);
  1    38 dcl  LAP_ACTIVE init (2) fixed bin internal static options (constant);
  1    39 
  1    40 dcl 1 lap_load_info aligned based (lap_load_info_ptr),
  1    41     2 version char (8) aligned,
  1    42     2 event_channel fixed bin (71),                         /* For notifying loading process */
  1    43     2 process_id bit (36) aligned,
  1    44     2 activate_order aligned like lap_line_control_info;    /* Only "real" parameter */
  1    45 
  1    46 dcl  LAP_LOAD_INFO_VERSION_1 char (8) internal static options (constant) init ("lapload1");
  1    47 
  1    48 /* END INCLUDE FILE ... lap_simplex_data.incl.pl1 */
      764 
      765 
  2     1 /* BEGIN INCLUDE FILE ... lap_line_info.incl.pl1 */
  2     2 
  2     3 /*
  2     4*   Line status and control information for LAP -- extracted from x25_mpx
  2     5*
  2     6*   Created January 10, 1983 by Olin Sibert to support LAP multiplexers.
  2     7**/
  2     8 
  2     9 /****^  HISTORY COMMENTS:
  2    10*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
  2    11*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
  2    12*     Prepared for installation.
  2    13*                                                   END HISTORY COMMENTS */
  2    14 
  2    15 dcl  L2_HEADER_PAD fixed bin internal static options (constant) init (2);
  2    16 
  2    17 dcl  lap_line_control_info_ptr pointer;
  2    18 
  2    19 dcl 1 lap_line_control_info aligned based (lap_line_control_info_ptr),
  2    20     2 dce_or_dte bit (1) unaligned,                         /* ON = DCE */
  2    21     2 lap_or_lapb bit (1) unaligned,                        /* ON = lapb */
  2    22     2 disc_first bit (1) unaligned,                         /* ON = send disc upon physical connect */
  2    23     2 trace_off bit (1) unaligned,                          /* ON = turn off trace upon line crash */
  2    24     2 pad bit (5) unaligned,                                /* padding */
  2    25     2 command bit (9) unaligned,                            /* One of the values below */
  2    26     2 frame_size fixed bin (18) unsigned unaligned,         /* max size of I-frame */
  2    27 
  2    28     2 K fixed bin (9) unsigned unaligned,                   /* max un-acked frames allowed */
  2    29     2 N2 fixed bin (9) unsigned unaligned,                  /* number of retries */
  2    30     2 T1 fixed bin (9) unsigned unaligned,                  /* frame ack wait timer in tenths of seconds */
  2    31     2 T3 fixed bin (9) unsigned unaligned;                  /* init timer */
  2    32 
  2    33 dcl  ACTIVATE_COMMAND init ("001"b3) bit (9) internal static options (constant);
  2    34 dcl  DEACTIVATE_COMMAND init ("002"b3) bit (9) internal static options (constant);
  2    35 dcl  DISCONNECT_COMMAND init ("003"b3) bit (9) internal static options (constant);
  2    36 
  2    37 dcl  lap_line_status_info_ptr pointer;
  2    38 
  2    39 dcl 1 lap_line_status_info aligned based (lap_line_status_info_ptr),
  2    40     2 status_type fixed bin (18) unsigned unaligned,        /* One of the values below */
  2    41     2 last_function_process fixed bin (17) unaligned,       /* coded function */
  2    42 
  2    43     2 which_state_process fixed bin (9) unsigned unaligned, /* process state */
  2    44     2 main_state fixed bin (9) unsigned unaligned,          /* current frame level state */
  2    45     2 primary_sub_state fixed bin (9) unsigned unaligned,   /* sub link up state */
  2    46     2 secondary_sub_state fixed bin (9) unsigned unaligned;
  2    47 
  2    48 dcl  LINE_DOWN_STATUS init (1) fixed bin (18) unsigned internal static options (constant);
  2    49 
  2    50 dcl  FRAME_STATE_ARRAY (5) char (32) static options (constant) init
  2    51     ("Down", "T3", "SABM Sent", "Set Up", "Up");
  2    52 
  2    53 dcl  FRAME_SUB_STATE_ARRAY (0:14) char (32) static options (constant) init
  2    54     ("Link down: see frame", "Link down: down", "Link down: T3",                                    /* 0, 1, 2 */
  2    55      "Link down: SABM sent", "Link down: set up", "Primary normal",                                 /* 3, 4, 5 */
  2    56      "Primary remote busy", "Primary T1 expired", "Primary SARM reset",                             /* 6, 7, 8 */
  2    57      "Secondary normal", "Secondary local busy", "Secondary reject",                                /* 9, 10, 11 */
  2    58      "Secondary CMDR send", "Link up FRMR send", "Link up reset started (lapb)");                   /* 12, 13, 14 */
  2    59 
  2    60 dcl  FRAME_FUNCTION_CODE (0:19) char (32) static options (constant) init
  2    61     ("Recieved invalid command or data", "Recieved DISC", "Recieved DM (lapb)",                     /* 0, 1, 2 */
  2    62      "Recieved SARM (lap)", "Recieved SABM (lapb)", "Recieved UA",                                  /* 3, 4, 5 */
  2    63      "Recieved CMDR/FRMR", "Recieved RR", "Recieved RNR",                                           /* 6, 7, 8 */
  2    64      "Recieved REJ", "Recieved bad command or response", "Timer (T1) expired with rc<N2",           /* 9, 10, 11 */
  2    65      "Timer (T1) expired with rc=N2", "Recieved bad final bit", "Recieved bad I-frame (N(R))",      /* 12, 13, 14 */
  2    66      "Recieved bad I-frame (N(S))", "Recieved I-frame", "Recieved poll RR command (lapb)",          /* 15, 16, 17 */
  2    67      "Recieved poll RNR command (lapb)", "Recieved poll REJ command (lapb)");                       /* 18, 19 */
  2    68 
  2    69 /* END INCLUDE FILE ... lap_line_info.incl.pl1 */
      766 
      767 
  3     1 /* BEGIN INCLUDE FILE ... mux_init_info.incl.pl1 */
  3     2 
  3     3 /* Created 8/2/78 by J. Stern */
  3     4 
  3     5 
  3     6 dcl  miip ptr;					/* ptr to mux_init_info structure */
  3     7 dcl  mii_chan_count fixed bin;			/* channel count when allocating mux_init_info */
  3     8 
  3     9 
  3    10 dcl 1 mux_init_info aligned based (miip),		/* multiplexer initialization info */
  3    11       2 no_channels fixed bin,			/* number of multiplexed channels */
  3    12       2 channels (mii_chan_count refer (mux_init_info.no_channels)), /* one entry per channel */
  3    13         3 name char (32) unal,			/* channel name */
  3    14         3 devx fixed bin;				/* device index for channel */
  3    15 
  3    16 
  3    17 /* END INCLUDE FILE ... mux_init_info.incl.pl1 */
      768 
      769 
  4     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      770 
      771 
  5     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
  5     2 
  5     3 /* Created 8/25/78 by J. Stern */
  5     4 
  5     5 
  5     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
  5     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
  5     8 
  5     9 /* call channel_manager$write (devx, output_ptr, code) */
  5    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
  5    11 
  5    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
  5    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
  5    14 
  5    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
  5    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
  5    17 
  5    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
  5    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
  5    20 
  5    21 /* call channel_manager$get_modes (devx, modes, code) */
  5    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
  5    23 
  5    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
  5    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  5    26 
  5    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
  5    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
  5    29 
  5    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
  5    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  5    32 
  5    33 
  5    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      772 
      773 
  6     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  6     2 
  6     3 /* This include file declares all the entries in tty_space_man and defines the constants
  6     4**  to be used for the flags argument
  6     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  6     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  6     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  6     8**/
  6     9 
  6    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  6    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  6    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  6    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  6    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  6    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  6    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  6    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  6    18 dcl  tty_space_man$needs_space entry (fixed bin);
  6    19 
  6    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  6    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  6    22 
  6    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      774 
      775 
  7     1 /* BEGIN INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
  7     2 
  7     3 /* Created 4/9/79 by J. Stern */
  7     4 /* Modified: 10 November 1980 by G. Palter to add can_type */
  7     5 
  7     6 
  7     7 dcl  mclp ptr;
  7     8 dcl  mcl_version_2 fixed bin int static options (constant) init (2);
  7     9 
  7    10 dcl 1 mcl aligned based (mclp),			/* modes change list */
  7    11       2 version fixed bin,				/* version number of this structure (Input) */
  7    12       2 n_entries fixed bin,				/* number of mode change entries (Input) */
  7    13       2 line_len fixed bin,				/* new line length (-1 => no change) (Input) */
  7    14       2 page_len fixed bin,				/* new page length (-1 => no change) (Input) */
  7    15       2 can_type fixed binary,			/* new canonicalization type (-1 => no change) (Input) */
  7    16       2 flags,
  7    17         3 init bit (1) unal,				/* ON if all modes to be reinitialized (Input) */
  7    18         3 ll_error bit (1) unal,			/* ON if line length error detected (Output) */
  7    19         3 pl_error bit (1) unal,			/* ON if page length error detected (Output) */
  7    20         3 can_type_error bit (1) unaligned,		/* ON if can_type error detected (Output) */
  7    21         3 mbz bit (32) unal,
  7    22       2 entries (36) like mcle;			 /* one entry per mode change */
  7    23 
  7    24 dcl  mclep ptr;
  7    25 
  7    26 dcl 1 mcle aligned based (mclep),			/* mode change list entry */
  7    27       2 mode_name char (16) unal,			/* name of mode to change (Input) */
  7    28       2 flags,
  7    29         3 mode_switch bit (1) unal,			/* ON to turn mode on, else OFF (Input) */
  7    30         3 force bit (1) unal,				/* ON to ignore errors for this mode change (Input) */
  7    31         3 mpx_mode bit (1) unal,			/* ON if mode recognized by multiplexer (Output) */
  7    32         3 error bit (1) unal,				/* ON if mode change is in error (Output) */
  7    33         3 mbz bit (32) unal;
  7    34 
  7    35 
  7    36 /* END INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
      776 
      777 
  8     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  8     2 
  8     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  8     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  8     5 
  8     6 declare	mode_value_ptr		ptr,
  8     7 	number_of_modes		fixed bin;
  8     8 
  8     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  8    10 	  2 version		fixed bin,
  8    11 	  2 number		fixed bin,
  8    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  8    13 
  8    14 declare	mode_string_info_ptr	ptr;
  8    15 
  8    16 declare	1 mode_value		aligned based (mode_value_ptr),
  8    17 	  2 version		fixed bin,
  8    18 	  2 mode_name		char (32) unaligned,
  8    19 	  2 flags,
  8    20 	    3 boolean_valuep	bit (1) unaligned,
  8    21 	    3 numeric_valuep	bit (1) unaligned,
  8    22 	    3 char_valuep		bit (1) unaligned,
  8    23 	    3 boolean_value		bit (1) unaligned,
  8    24 	    3 pad1		bit (32) unaligned,
  8    25 	  2 numeric_value		fixed bin (35),
  8    26 	  2 char_value		char (32) varying,
  8    27 	  2 code			fixed bin (35),
  8    28 	  2 pad2			bit (36);
  8    29 
  8    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  8    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  8    32 
  8    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
      778 
      779 
  9     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  9     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  9     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  9     9*     implementation.
  9    10*                                                   END HISTORY COMMENTS */
  9    11 
  9    12 
  9    13 /*
  9    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  9    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  9    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  9    17**/
  9    18 
  9    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  9    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  9    21 
  9    22 
  9    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  9    24     2 next bit (18),				/* foward pointer to next free block */
  9    25     2 size fixed bin;				/* number of words in this block */
  9    26 
  9    27 
  9    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  9    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  9    30     2 flags unaligned,
  9    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  9    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  9    33       3 break bit (1) unaligned,			/* buffer contains break character */
  9    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  9    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  9    36       3 pad bit (1) unaligned,
  9    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  9    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  9    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  9    40 
  9    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  9    42 
  9    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  9    44 
  9    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      780 
      781 
 10     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
 10     2 
 10     3 /* Defines constants and structures  used by MCS interrupt handlers */
 10     4 
 10     5 /* Created 08/21/78 by Robert Coren */
 10     6 /* Echo negotiation types added sometime by Bernie Greenberg */
 10     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
 10     8 /* MASKED type added June 23, 1982, by Robert Coren */
 10     9 
 10    10 dcl  DIALUP fixed bin int static options (constant) init (1);
 10    11 dcl  HANGUP fixed bin int static options (constant) init (2);
 10    12 dcl  CRASH fixed bin int static options (constant) init (3);
 10    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
 10    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
 10    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
 10    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
 10    17 dcl  QUIT fixed bin int static options (constant) init (8);
 10    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
 10    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
 10    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
 10    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
 10    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
 10    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
 10    24 dcl  TIMER fixed bin int static options (constant) init (15);
 10    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
 10    26 dcl  MASKED fixed bin int static options (constant) init (17);
 10    27 
 10    28 dcl  interrupt_info bit (72) aligned;
 10    29 
 10    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
 10    31     2 line_type fixed bin (9) unal uns,
 10    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
 10    33     2 baud_rate fixed bin (18) unal uns,
 10    34     2 max_buf_size fixed bin (9) unal uns,
 10    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
 10    36     2 pad bit (26) unal;
 10    37 
 10    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
 10    39     2 input_chain unaligned,
 10    40       3 chain_head bit (18) unaligned,
 10    41       3 chain_tail bit (18) unaligned,
 10    42     2 input_count fixed bin (18) unal uns,
 10    43     2 flags unaligned,
 10    44       3 break_char bit (1),				/* data contains a break character */
 10    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
 10    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
 10    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
 10    48       3 pad bit (14);
 10    49 
 10    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
 10    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
 10    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
 10    53 
 10    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
      782 
      783 
 11     1 /* BEGIN INCLUDE FILE ... line_types.incl.pl1  */
 11     2 
 11     3 /* Written  November 10 1975 by Paul Green */
 11     4 /* Modified October 1978 by Larry Johnson to include line_type_names */
 11     5 /* Modified 12/19/78 by J. Stern to add POLLED_VIP line type */
 11     6 /* Modified 9/27/79 by J. Stern to add X25LAP line type */
 11     7 /* Modified Spring 1981 by Charles Hornig to add HDLC line type */
 11     8 /* Modified May 1981 by Robert Coren to add COLTS line type */
 11     9 /* Modified September 1984 by Robert Coren to correctly count VIP as a synchronous line type */
 11    10 
 11    11 
 11    12 /****^  HISTORY COMMENTS:
 11    13*  1) change(86-02-25,Negaret), approve(87-07-13,MCR7679),
 11    14*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    15*     Add a DSA line type.
 11    16*  2) change(87-03-17,Beattie), approve(87-07-13,MCR7656),
 11    17*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    18*     Add HASP_OPR to identify HASP workstation consoles with login service.
 11    19*                                                   END HISTORY COMMENTS */
 11    20 
 11    21 
 11    22 declare   (LINE_MC            initial (-2),
 11    23        	 LINE_TELNET	initial (-1),
 11    24            LINE_UNKNOWN       initial (0),
 11    25 	 LINE_ASCII	initial (1),
 11    26 	 LINE_1050	initial (2),
 11    27 	 LINE_2741	initial (3),
 11    28 	 LINE_ARDS	initial (4),
 11    29 	 LINE_SYNCH	initial (5),
 11    30 	 LINE_G115	initial (6),
 11    31 	 LINE_BSC		initial (7),
 11    32 	 LINE_ETX		initial (8),
 11    33 	 LINE_VIP		initial (9),
 11    34 	 LINE_ASYNC1	initial (10),
 11    35 	 LINE_ASYNC2	initial (11),
 11    36 	 LINE_ASYNC3	initial (12),
 11    37 	 LINE_SYNC1	initial (13),
 11    38 	 LINE_SYNC2	initial (14),
 11    39 	 LINE_SYNC3	initial (15),
 11    40 	 LINE_POLLED_VIP	initial (16),
 11    41 	 LINE_X25LAP	initial (17),
 11    42 	 LINE_HDLC	initial (18),
 11    43 	 LINE_COLTS	initial (19),
 11    44 	 LINE_DSA           initial (20),
 11    45 	 LINE_HASP_OPR	initial (21)
 11    46 	) fixed bin internal static options (constant);
 11    47 
 11    48 dcl  max_line_type fixed bin int static options (constant) init (21);
 11    49 
 11    50 declare  n_sync_line_types fixed bin int static options (constant) init (10);
 11    51 
 11    52 declare  sync_line_type (10) fixed bin int static options (constant) init (5, 6, 7, 9, 13, 14, 15, 16, 17, 18);
 11    53 
 11    54 dcl  line_types (-2:21) char (16) int static options (constant) init (
 11    55      "MC",                                                  /* -2 */
 11    56      "TELNET",					/* -1 */
 11    57      "none",					/* 0 */
 11    58      "ASCII",					/* 1 */
 11    59      "1050",					/* 2 */
 11    60      "2741",					/* 3 */
 11    61      "ARDS",					/* 4 */
 11    62      "Sync",					/* 5 */
 11    63      "G115",					/* 6 */
 11    64      "BSC",					/* 7 */
 11    65      "202ETX",					/* 8 */
 11    66      "VIP",					/* 9 */
 11    67      "ASYNC1",					/* 10 */
 11    68      "ASYNC2",					/* 11 */
 11    69      "ASYNC3",					/* 12 */
 11    70      "SYNC1",					/* 13 */
 11    71      "SYNC2",					/* 14 */
 11    72      "SYNC3",					/* 15 */
 11    73      "POLLED_VIP",					/* 16 */
 11    74      "X25LAP",					/* 17 */
 11    75      "HDLC",					/* 18 */
 11    76      "COLTS",					/* 19 */
 11    77      "DSA",					/* 20 */
 11    78      "HASP_OPR");					/* 21 */
 11    79 
 11    80 /* END INCLUDE FILE ... line_types.incl.pl1  */
      784 
      785 
 12     1 /* BEGIN INCLUDE FILE ... tty_read_status_info.incl.pl1
 12     2*
 12     3*   control structure for the read_status and write_status orders to tty_
 12     4*
 12     5*   Modified 2/1/83 by Olin Sibert to add tty_write_status_info structure in
 12     6*     support of lap_simplex_ MPX.
 12     7**/
 12     8 
 12     9 
 12    10 /****^  HISTORY COMMENTS:
 12    11*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
 12    12*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
 12    13*     Prepared for installation.
 12    14*                                                   END HISTORY COMMENTS */
 12    15 
 12    16 
 12    17      dcl	   1 tty_read_status_info aligned based (tty_read_status_info_ptr),
 12    18 	     2 event_channel      fixed bin (71),
 12    19 	     2 input_pending      bit (1);
 12    20 
 12    21      dcl	   tty_read_status_info_ptr ptr;
 12    22 
 12    23      dcl	   1 tty_write_status_info aligned based (tty_write_status_info_ptr),
 12    24 	     2 event_channel      fixed bin (71),
 12    25 	     2 output_pending     bit (1);
 12    26 
 12    27      dcl	   tty_write_status_info_ptr ptr;
 12    28 
 12    29 /* END INCLUDE FILE ... tty_read_status_info.incl.pl1 */
      786 
      787 
 13     1 /* --------------- BEGIN include file syserr_codes.incl.pl1 --------------- */
 13     2 
 13     3 /* THIS INCLUDE FILE IS OBSOLETE.  USE syserr_constants include files instead.
 13     4*This include file is surrently used only by x25_mpx.pl1.  There is a conflict
 13     5*in names between syserr_constants.incl.pl1 and one of the communications
 13     6*include files (i.e. CRASH for a mpx rather than the system).  That include
 13     7*file and syserr_constants should be changed to use more meaningful names. */
 13     8 
 13     9 /* This include file contains action codes for calling syserr,
 13    10*   admin_gate_$syserr, and friends.
 13    11*   Written 01/09/79 by C. D. Tavares after pulling out the source for
 13    12*   syserr_real for the seventh time. */
 13    13 
 13    14 dcl (Write_on_console initial (0),
 13    15      Write_and_crash_system initial (1),
 13    16      Write_with_alarm_and_terminate initial (2),
 13    17      Write_with_alarm initial (3),
 13    18      Log_message initial (4),
 13    19      Log_message_or_discard initial (5)) fixed bin static options (constant);
 13    20 
 13    21 /* ---------------- END include file syserr_codes.incl.pl1 ---------------- */
 13    22 
      788 
      789 
      790 /* BEGIN MESSAGE DOCUMENTATION
      791*
      792*   Message:
      793*   lap_simplex(CHN): Unexpected interrupt TYPE DATA received.
      794*
      795*   S: $log
      796*
      797*   T: $run
      798*
      799*   M: An unexpected MCM interrupt was processed.
      800*
      801*   A: $notify
      802*
      803*   Message:
      804*   lap_simplex(CHN): Failure, Link state: STATE, Current Action: FUNCTION, in ESTATE, Primary state: PSTATE, Secondary state: SSTATE.
      805*
      806*   S: $log
      807*
      808*   T: $run
      809*
      810*   M: Normal request to crash the line when the link has been disconnected by
      811*   the FNP.  STATE is the main state of the link. FUNCTION is the last
      812*   function the link processed. The ESTATE is the execution state of the
      813*   last function. PSTATE and SSTATE are the link up substate.
      814*
      815*   A: $notify
      816*
      817*   Message:
      818*   lap_simplex(CHN): Link disconnected due to mis-matched frame sizes. CMDR/FRMR frame: FRAME.
      819*
      820*   S: $log
      821*
      822*   T: $run
      823*
      824*   M: The FNP has received a command reject (LAPB) or frame reject (LAP) which
      825*   specified a reason of "wide frame" on channel CHN.  The actual level 2
      826*   command is FRAME.  This means the frame received by the other end was too
      827*   long.  Instead of looping continuously trying to send this frame, the link
      828*   will be disconnected.  The maximum frame size in the Multics TTF for this
      829*   link should be checked against the size expected by the other end of the
      830*   link, and corrected.
      831*
      832*   A: $notify
      833*
      834*   Message:
      835*   lap_simplex(CHN): Attempt to write overlength frame.
      836*
      837*   S: $log
      838*
      839*   T: $run
      840*
      841*   M: An attempt was made to add a buffer to a frame which didn't have room
      842*   for it.  The connection will be crashed.
      843*
      844*   A: $notify
      845*
      846*   Message:
      847*   x25_mpx(CHN): Error from write of XXX chars. ERROR
      848*
      849*   S: $log
      850*
      851*   T: $run
      852*
      853*   M: The ERROR occurred writing XXX characters to the LAP channel.
      854*   The LAP channel will be disconnected.
      855*
      856*   A: $notify
      857*
      858*   Message:
      859*   lap_simplex(CHN): Write failed to take whole frame, discarding rest.
      860*
      861*   S: $log
      862*
      863*   T: $run
      864*
      865*   M: A attempt to write a whole frame failed, only a part of it was taken.
      866*   An attempt will be made to continue.
      867*
      868*   A: $notify
      869*
      870*   Message:
      871*   lap_simplex(CHN): Invalid subchannel index XXX
      872*
      873*   S: $alarm
      874*
      875*   T: $run
      876*
      877*   M: Some call which attempted to write, process a control order or process
      878*   a modes operation specified a subchannel other than 1.
      879*
      880*   A: $notify
      881*
      882*   END MESSAGE DOCUMENTATION */
      883 
      884      end lap_simplex;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0857.2  lap_simplex.pl1                   >spec>install>1115>lap_simplex.pl1
764          1    08/11/88  2015.0  lap_simplex_data.incl.pl1         >ldd>include>lap_simplex_data.incl.pl1
766          2    08/11/88  2015.0  lap_line_info.incl.pl1            >ldd>include>lap_line_info.incl.pl1
768          3    02/23/79  1434.9  mux_init_info.incl.pl1            >ldd>include>mux_init_info.incl.pl1
770          4    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
772          5    05/06/80  0958.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
774          6    06/18/81  0900.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
776          7    03/19/81  1131.8  mcs_modes_change_list.incl.pl1    >ldd>include>mcs_modes_change_list.incl.pl1
778          8    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
780          9    07/21/88  2036.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
782         10    10/20/82  0938.6  mcs_interrupt_info.incl.pl1       >ldd>include>mcs_interrupt_info.incl.pl1
784         11    08/06/87  0913.4  line_types.incl.pl1               >ldd>include>line_types.incl.pl1
786         12    08/11/88  2015.0  tty_read_status_info.incl.pl1     >ldd>include>tty_read_status_info.incl.pl1
788         13    03/15/85  0953.1  syserr_codes.incl.pl1             >ldd>include>syserr_codes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACCEPT_INPUT                    000022 constant        fixed bin(17,0)          initial dcl 10-15 set ref 118*
ACTIVATE_COMMAND                       constant        bit(9)                   initial packed unaligned dcl 2-33 ref 678
CRASH                                  constant        fixed bin(17,0)          initial dcl 10-12 ref 498
DIALUP                          000563 constant        fixed bin(17,0)          initial dcl 10-10 set ref 366*
FRAME_FUNCTION_CODE             000023 constant        char(32)                 initial array packed unaligned dcl 2-60 set ref 130*
FRAME_STATE_ARRAY               000453 constant        char(32)                 initial array packed unaligned dcl 2-50 set ref 130*
FRAME_SUB_STATE_ARRAY           000263 constant        char(32)                 initial array packed unaligned dcl 2-53 set ref 130*
                                                                                  130* 130*
HANGUP                                 constant        fixed bin(17,0)          initial dcl 10-11 set ref 234*
INPUT                           000526 constant        bit(1)                   initial packed unaligned dcl 6-20 set ref 96* 100*
                                                                                  100*
L2_HEADER_PAD                          constant        fixed bin(17,0)          initial dcl 2-15 ref 62 93 105 109 110 309 312
LAP_ACTIVE                             constant        fixed bin(17,0)          initial dcl 1-38 ref 66 95 363 388
LAP_HUNGUP                             constant        fixed bin(17,0)          initial dcl 1-36 ref 172 357 502 560 622 667
LAP_LISTENING                          constant        fixed bin(17,0)          initial dcl 1-37 ref 58 694
LAP_LOAD_INFO_VERSION_1         000524 constant        char(8)                  initial packed unaligned dcl 1-46 ref 662
LINE_ASCII                             constant        fixed bin(17,0)          initial dcl 11-22 ref 63
Log_message                     000554 constant        fixed bin(17,0)          initial dcl 13-14 set ref 50* 130* 139* 233* 320*
                                                                                  328*
MASKED                                 constant        fixed bin(17,0)          initial dcl 10-26 set ref 171*
MPX_DOWN                        000530 constant        fixed bin(71,0)          initial dcl 756 set ref 498*
MPX_MASKED                      000526 constant        fixed bin(71,0)          initial dcl 757 set ref 169*
MPX_UP                          000532 constant        fixed bin(71,0)          initial dcl 755 set ref 65*
OUTPUT                          000550 constant        bit(1)                   initial packed unaligned dcl 6-21 set ref 270* 316*
                                                                                  316* 514*
P_chain_ptr                            parameter       pointer                  dcl 710 set ref 177 183 217* 220*
P_code                                 parameter       fixed bin(35,0)          dcl 713 set ref 177 224* 347 395* 400 408 416 420*
                                                                                  437* 463* 475* 533 553* 569* 576 583* 590 595* 602
                                                                                  607* 618 629 634* 637* 641* 644* 652 663* 668*
                                                                                  684* 690* 699*
P_devx                                 parameter       fixed bin(17,0)          dcl 702 ref 533 536
P_info_ptr                             parameter       pointer                  dcl 703 set ref 347 353 629 637* 641* 652 660
P_int_data                             parameter       bit(72)                  dcl 709 ref 42 47
P_int_type                             parameter       fixed bin(17,0)          dcl 708 ref 42 46
P_lap_data_ptr                         parameter       pointer                  dcl 706 set ref 42 45 177 347 400 408 416 472 533
                                                                                  538* 568* 576 579 582* 590 593 602 605 618 621 629
                                                                                  632 652 655
P_mcl_info_ptr                         parameter       pointer                  dcl 711 ref 400 408 434
P_miip                                 parameter       pointer                  dcl 704 ref 533 537
P_modes                                parameter       char                     packed unaligned dcl 712 set ref 416 421*
P_order                                parameter       char                     packed unaligned dcl 705 ref 347 352 629 633 652 656
P_set_sw                               parameter       bit(1)                   dcl 429 ref 426 446 454
P_subchan_idx                          parameter       fixed bin(17,0)          dcl 707 set ref 177 347 400 408 416 473 474*
P_type                                 parameter       fixed bin(17,0)          dcl 491 set ref 488 496* 498
SEND_OUTPUT                     000554 constant        fixed bin(17,0)          initial dcl 10-13 set ref 82* 154* 222* 367*
WRU_TIMEOUT                     000021 constant        fixed bin(17,0)          initial dcl 10-20 set ref 390*
Write_with_alarm                000556 constant        fixed bin(17,0)          initial dcl 13-14 set ref 474*
activate_order           20            based           structure                level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 675* 682 682
activate_order            5            based           structure                level 2 in structure "lap_load_info" dcl 1-40
                                                                                  in procedure "lap_simplex" ref 675
addr                                                   builtin function         dcl 761 ref 139 139 444 565 682 682
after                                                  builtin function         dcl 761 ref 557
binary                                                 builtin function         dcl 761 ref 184 242 284
blockp                          000156 automatic       pointer                  dcl 9-19 set ref 92* 93 96* 100* 105 106 109 109
                                                                                  112* 112 115 115 115 115 187* 195 195 198 202 203
                                                                                  232 238 239 240 242 245 247 267 278 280 286 286
break                     0(20)        based           bit(1)                   level 3 packed packed unaligned dcl 9-28 set ref
                                                                                  300*
buffer                                 based           structure                level 1 dcl 9-28
buffer_pad               24(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 1-16
                                                                                  set ref 62*
bufl                            000226 automatic       fixed bin(17,0)          dcl 297 set ref 303* 306 307 308
bufp                            000224 automatic       pointer                  dcl 296 set ref 302* 303 308 309 312 312 327
byte                      0(19)        based           bit(8)                   array level 3 packed packed unaligned dcl 730 set
                                                                                  ref 139*
chain_head                      000162 automatic       bit(18)                  level 3 packed packed unaligned dcl 10-38 set ref 92
chain_ptr                       000122 automatic       pointer                  dcl 722 set ref 183* 184 187 220
chain_tail                0(18) 000162 automatic       bit(18)                  level 3 packed packed unaligned dcl 10-38 set ref
                                                                                  112
channel_manager$control         000046 constant        entry                    external dcl 5-13 ref 323 359 383 622 637 641 682
                                                                                  688
channel_manager$interrupt       000050 constant        entry                    external dcl 5-25 ref 82 118 154 222 366 367 390 496
channel_manager$write           000044 constant        entry                    external dcl 5-10 ref 318
channels                  1            based           structure                array level 2 dcl 3-10
chars                     1            based           char(1)                  array level 2 packed packed unaligned dcl 9-28 set
                                                                                  ref 105 106* 106 115 115 115 115 195 278 278 308
                                                                                  309* 309
cleanup                         000132 stack reference condition                dcl 759 ref 546
cmdr_bytes                0(18)        based           structure                array level 2 packed packed unaligned dcl 730
cmdr_status                            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 730 ref
                                                                                  139
code                            000100 automatic       fixed bin(35,0)          dcl 715 set ref 169* 182* 224 318* 319 320* 354*
                                                                                  357* 359* 363* 372* 378* 383* 388* 393* 395 498*
                                                                                  622* 657* 682* 683 684 688* 689 690 697* 699
collate9                                               builtin function         dcl 761 ref 195
command                  20(09)        based           bit(9)                   level 3 packed packed unaligned dcl 1-16 set ref
                                                                                  678*
currentsize                                            builtin function         dcl 761 ref 580 580
devx                            000102 automatic       fixed bin(17,0)          dcl 717 in procedure "lap_simplex" set ref 536* 558
devx                     10            based           fixed bin(17,0)          level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 96* 100* 272*
                                                                                  316* 318* 323* 359* 383* 514* 558* 622* 637* 641*
                                                                                  682* 688*
devx                     11            based           fixed bin(17,0)          array level 3 in structure "mux_init_info" dcl 3-10
                                                                                  in procedure "lap_simplex" ref 559
dialup_info                     000160 automatic       structure                level 1 dcl 10-30 in procedure "lap_simplex"
dialup_info              22            based           structure                level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 60* 61
divide                                                 builtin function         dcl 761 ref 269 680
entries                   6            based           structure                array level 2 dcl 7-10 set ref 444
error                     4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 7-26 set ref
                                                                                  450* 457*
error_table_$action_not_performed
                                000022 external static fixed bin(35,0)          dcl 744 ref 668
error_table_$bad_arg            000024 external static fixed bin(35,0)          dcl 745 ref 475
error_table_$bad_mode           000026 external static fixed bin(35,0)          dcl 746 ref 449 456
error_table_$invalid_state      000030 external static fixed bin(35,0)          dcl 747 ref 357 363 388
error_table_$noalloc            000032 external static fixed bin(35,0)          dcl 748 ref 553
error_table_$null_info_ptr      000034 external static fixed bin(35,0)          dcl 749 ref 372 378
error_table_$undefined_order_request
                                000036 external static fixed bin(35,0)          dcl 750 ref 393 644 697
error_table_$unimplemented_version
                                000040 external static fixed bin(35,0)          dcl 751 ref 437 663
event_channel             2            based           fixed bin(71,0)          level 2 dcl 1-40 ref 674
flags                     4            based           structure                level 2 in structure "mcle" dcl 7-26 in procedure
                                                                                  "lap_simplex"
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 9-28 in procedure "lap_simplex" set
                                                                                  ref 240* 282*
flags                    13            based           structure                level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 672*
force                     4(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-26 ref 454
frame_end                34            based           pointer                  level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 242 247* 300
                                                                                  335* 517* 562*
frame_end                       000125 automatic       fixed bin(17,0)          dcl 724 in procedure "lap_simplex" set ref 195* 197
                                                                                  202 267 278
frame_ready              27            based           bit(1)                   level 2 dcl 1-16 set ref 204* 210* 214 337* 519*
frame_size               30            based           fixed bin(17,0)          level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 232 238* 238
                                                                                  320* 336* 381 518*
frame_size               20(18)        based           fixed bin(18,0)          level 3 in structure "lap_data" packed packed
                                                                                  unsigned unaligned dcl 1-16 in procedure
                                                                                  "lap_simplex" set ref 680
frame_start              32            based           pointer                  level 2 dcl 1-16 set ref 242 245* 302 316* 318* 327
                                                                                  327 334 512 514* 516* 561*
hbound                                                 builtin function         dcl 761 ref 49
ignore_code                     000101 automatic       fixed bin(35,0)          dcl 716 set ref 65* 323*
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "lap_simplex"
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "lap_simplex"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "lap_simplex"
info_ptr                        000104 automatic       pointer                  dcl 718 set ref 353* 372 378 381 383*
init_sw                         000010 internal static bit(1)                   initial dcl 737 set ref 540 542*
input_chain                     000162 automatic       structure                level 2 packed packed unaligned dcl 10-38
input_count               1     000162 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 10-38
                                                                                  set ref 110* 110
int_data                        000120 automatic       bit(72)                  dcl 721 set ref 47* 50* 60 90 127 139 139
int_type                        000116 automatic       fixed bin(17,0)          dcl 720 set ref 46* 49 49 49 50* 70* 75*
lap_cmdr_status                        based           structure                level 1 dcl 730
lap_data                               based           structure                level 1 dcl 1-16 set ref 548 548 551 551 580 580
lap_data_ptr                    000142 automatic       pointer                  dcl 1-14 set ref 45* 50 58 60 61 61 62 63 65 65 66
                                                                                  80 82 92 95 96 100 100 118 130 139 154 169 169 172
                                                                                  186 204 210 214 222 222 232 232 233 238 238 242
                                                                                  242 245 247 270 272 274 300 302 316 316 316 318
                                                                                  318 320 320 323 327 327 328 334 335 336 337 338
                                                                                  340 357 359 363 366 366 366 367 381 383 388 390
                                                                                  472* 474 496 498 498 502 512 514 514 516 517 518
                                                                                  519 545* 548 548 548 548* 551 551 551* 552 557 558
                                                                                  559 560 561 562 565 568 579* 580 580 580* 593* 594
                                                                                  605* 606 621* 622 622 632* 637 641 655* 667 672
                                                                                  673 674 675 677 678 680 680 682 682 682 688 694
lap_down_status                 000130 automatic       structure                level 1 dcl 728 set ref 127*
lap_line_control_info                  based           structure                level 1 dcl 2-19
lap_line_status_info                   based           structure                level 1 dcl 2-39
lap_load_info                          based           structure                level 1 dcl 1-40
lap_load_info_ptr               000140 automatic       pointer                  dcl 1-13 set ref 660* 662 673 674 675
last_char                              defined         char(1)                  packed unaligned dcl 114 set ref 115* 115
last_function_process
                          0(18) 000130 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 728 set ref 130
lbound                                                 builtin function         dcl 761 ref 49
lct                                    based           structure                level 1 dcl 4-11
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 565
lctep                           000150 automatic       pointer                  dcl 4-8 set ref 565* 566
lctp                            000146 automatic       pointer                  dcl 4-7 set ref 564* 565
leftover_chars                  000212 automatic       fixed bin(17,0)          dcl 257 set ref 267* 269 278 278 281 286
line_type                24            based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 1-16
                                                                                  set ref 63*
load_event_channel       16            based           fixed bin(71,0)          level 2 dcl 1-16 set ref 65* 169* 498* 674*
load_process_id          14            based           bit(36)                  level 2 dcl 1-16 set ref 65* 169* 498* 673*
main_state                1(09) 000130 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 728 set
                                                                                  ref 130
major_channel_info        3            based           structure                level 2 dcl 4-20
max_frame_size           26            based           fixed bin(17,0)          level 2 dcl 1-16 set ref 232 680*
mcl                                    based           structure                level 1 dcl 7-10
mcl_version_2                          constant        fixed bin(17,0)          initial dcl 7-8 ref 436
mcle                                   based           structure                level 1 dcl 7-26
mclep                           000154 automatic       pointer                  dcl 7-24 set ref 444* 445 445 446 447 450 454 454
                                                                                  457 460
mclp                            000152 automatic       pointer                  dcl 7-7 set ref 434* 436 443 444
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "lap_simplex"
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "lap_simplex"
miip                            000144 automatic       pointer                  dcl 3-6 set ref 537* 557 559
mode_error                      000236 automatic       fixed bin(35,0)          dcl 430 set ref 441* 449* 456* 463
mode_idx                        000127 automatic       fixed bin(17,0)          dcl 726 set ref 443* 444*
mode_name                              based           char(16)                 level 2 packed packed unaligned dcl 7-26 ref 445 445
mode_switch               4            based           bit(1)                   level 3 packed packed unaligned dcl 7-26 ref 447
mode_value                             based           structure                level 1 dcl 8-16
mpx_mode                  4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-26 set ref
                                                                                  446* 454 460*
mux_init_info                          based           structure                level 1 dcl 3-10
n_entries                 1            based           fixed bin(17,0)          level 2 dcl 7-10 ref 443
name                                   based           char(32)                 level 2 in structure "lap_data" packed packed
                                                                                  unaligned dcl 1-16 in procedure "lap_simplex" set
                                                                                  ref 50* 130* 139* 233* 320* 328* 474* 557*
name                      1            based           char(32)                 array level 3 in structure "mux_init_info" packed
                                                                                  packed unaligned dcl 3-10 in procedure
                                                                                  "lap_simplex" ref 557
new_buf_size                    000213 automatic       fixed bin(17,0)          dcl 258 set ref 269* 270*
new_bufp                        000214 automatic       pointer                  dcl 259 set ref 270* 271 278 280 281 282 284
new_string                             defined         char                     packed unaligned dcl 104 in begin block on line 102
                                                                                  set ref 106*
new_string                             defined         char                     packed unaligned dcl 307 in begin block on line 305
                                                                                  set ref 309*
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 9-28
                                                                                  set ref 198 203 239* 242* 280* 280
next_block                      000124 automatic       fixed bin(18,0)          dcl 723 set ref 184* 186 187 198* 203* 217 220 284*
null                                                   builtin function         dcl 761 ref 217 242 271 323 323 327 334 335 359 359
                                                                                  372 378 512 516 517 538 545 548 552 561 562 582
                                                                                  622 622 688 688
old_string                      000100 automatic       char                     packed unaligned dcl 306 in begin block on line 305
                                                                                  set ref 308* 309
old_string                      000100 automatic       char                     packed unaligned dcl 103 in begin block on line 102
                                                                                  set ref 105* 106
order                           000106 automatic       char(32)                 packed unaligned dcl 719 set ref 352* 356 362 371
                                                                                  377 387 633* 636 637* 640 641* 656* 659
output_pending            2            based           bit(1)                   level 2 dcl 12-23 set ref 381*
pad                      20(04)        based           bit(5)                   level 3 packed packed unaligned dcl 1-16 set ref
                                                                                  677*
pointer                                                builtin function         dcl 761 ref 92 112 187 220
primary_sub_state         1(18) 000130 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 728 set
                                                                                  ref 130
process_id                4            based           bit(36)                  level 2 dcl 1-40 ref 673
pxss$ring_0_wakeup              000012 constant        entry                    external dcl 739 ref 65 169 498
real_buffer_lth                 000126 automatic       fixed bin(17,0)          dcl 725 set ref 93* 95 103 104 105
rel                                                    builtin function         dcl 761 ref 184 242 284
reverse                                                builtin function         dcl 761 ref 557 557
rtx_info                        000162 automatic       structure                level 1 dcl 10-38 set ref 90* 118 118
sc_dialup_info           24            based           structure                level 2 dcl 1-16 set ref 61* 366 366
search                                                 builtin function         dcl 761 ref 195
secondary_sub_state       1(27) 000130 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 728 set
                                                                                  ref 130
send_output              13            based           bit(1)                   level 3 packed packed unaligned dcl 1-16 set ref 80*
                                                                                  186 222 274* 338* 340*
simplex_started          13(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-16 set ref
                                                                                  594* 606*
size                                                   builtin function         dcl 761 ref 548 548 551 551
state                    12            based           fixed bin(17,0)          level 2 dcl 1-16 set ref 58 66* 95 172* 357 363 388
                                                                                  502* 560* 622 667 694*
status_type                     000130 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 728 set
                                                                                  ref 130
string                                                 builtin function         dcl 761 set ref 105 195 240* 278 278 282* 308 672*
subchannel               11            based           fixed bin(17,0)          level 2 in structure "lap_data" dcl 1-16
                                                                                  in procedure "lap_simplex" set ref 82* 100* 118*
                                                                                  154* 222* 270* 316* 366* 367* 390* 496* 559* 565
subchannel                3(18)        based           fixed bin(17,0)          level 3 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "lap_simplex" set ref 566*
substr                                                 builtin function         dcl 761 set ref 105 195 195 278* 278 308
syserr                          000014 constant        entry                    external dcl 740 ref 50 130 139 233 328 474
syserr$error_code               000016 constant        entry                    external dcl 741 ref 320
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 9-28
                                                                                  set ref 93 109* 109 115 115 195 202 232 238 267
                                                                                  281* 286* 286 303 312* 312
tty_buf$lct_ptr                 000042 external static pointer                  dcl 753 ref 564
tty_space_man$free_chain        000060 constant        entry                    external dcl 6-16 ref 96 514
tty_space_man$free_space        000054 constant        entry                    external dcl 6-12 ref 548 580
tty_space_man$get_buffer        000056 constant        entry                    external dcl 6-13 ref 270
tty_space_man$get_space         000052 constant        entry                    external dcl 6-10 ref 551
tty_space_man$needs_space       000064 constant        entry                    external dcl 6-18 ref 272
tty_space_man$switch_chain      000062 constant        entry                    external dcl 6-17 ref 100 316
tty_write_status_info                  based           structure                level 1 dcl 12-23
unspec                                                 builtin function         dcl 761 set ref 60* 90* 115* 115 118 118 127* 366
                                                                                  366
version                                based           fixed bin(17,0)          level 2 in structure "mcl" dcl 7-10 in procedure
                                                                                  "lap_simplex" ref 436
version                                based           char(8)                  level 2 in structure "lap_load_info" dcl 1-40
                                                                                  in procedure "lap_simplex" ref 662
which_state_process       1     000130 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 728 set
                                                                                  ref 130
wire_proc$wire_me               000020 constant        entry                    external dcl 742 ref 541

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 10-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 10-23
DEACTIVATE_COMMAND                     internal static bit(9)                   initial packed unaligned dcl 2-34
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 10-19
DISCONNECT_COMMAND                     internal static bit(9)                   initial packed unaligned dcl 2-35
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 10-14
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 10-16
LINE_1050                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_2741                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_ARDS                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASYNC1                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASYNC2                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_ASYNC3                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_BSC                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_COLTS                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_DOWN_STATUS                       internal static fixed bin(18,0)          initial unsigned dcl 2-48
LINE_DSA                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_ETX                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_G115                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_HASP_OPR                          internal static fixed bin(17,0)          initial dcl 11-22
LINE_HDLC                              internal static fixed bin(17,0)          initial dcl 11-22
LINE_MC                                internal static fixed bin(17,0)          initial dcl 11-22
LINE_POLLED_VIP                        internal static fixed bin(17,0)          initial dcl 11-22
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 10-18
LINE_SYNC1                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNC2                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNC3                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_SYNCH                             internal static fixed bin(17,0)          initial dcl 11-22
LINE_TELNET                            internal static fixed bin(17,0)          initial dcl 11-22
LINE_UNKNOWN                           internal static fixed bin(17,0)          initial dcl 11-22
LINE_VIP                               internal static fixed bin(17,0)          initial dcl 11-22
LINE_X25LAP                            internal static fixed bin(17,0)          initial dcl 11-22
Log_message_or_discard                 internal static fixed bin(17,0)          initial dcl 13-14
QUIT                                   internal static fixed bin(17,0)          initial dcl 10-17
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 10-21
TIMER                                  internal static fixed bin(17,0)          initial dcl 10-24
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 10-25
Write_and_crash_system                 internal static fixed bin(17,0)          initial dcl 13-14
Write_on_console                       internal static fixed bin(17,0)          initial dcl 13-14
Write_with_alarm_and_terminate         internal static fixed bin(17,0)          initial dcl 13-14
channel_manager$check_modes     000000 constant        entry                    external dcl 5-19
channel_manager$get_modes       000000 constant        entry                    external dcl 5-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 5-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 5-31
channel_manager$read            000000 constant        entry                    external dcl 5-7
channel_manager$set_modes       000000 constant        entry                    external dcl 5-16
free_block                             based           structure                level 1 dcl 9-23
free_blockp                            automatic       pointer                  dcl 9-20
interrupt_info                         automatic       bit(72)                  dcl 10-28
lap_line_control_info_ptr              automatic       pointer                  dcl 2-17
lap_line_status_info_ptr               automatic       pointer                  dcl 2-37
lcnt                                   based           structure                level 1 dcl 4-65
lcntp                                  automatic       pointer                  dcl 4-63
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
line_types                             internal static char(16)                 initial array packed unaligned dcl 11-54
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 9-43
max_line_type                          internal static fixed bin(17,0)          initial dcl 11-48
mii_chan_count                         automatic       fixed bin(17,0)          dcl 3-7
mode_string_info                       based           structure                level 1 dcl 8-9
mode_string_info_ptr                   automatic       pointer                  dcl 8-14
mode_string_info_version_2             internal static fixed bin(17,0)          initial dcl 8-30
mode_value_ptr                         automatic       pointer                  dcl 8-6
mode_value_version_3                   internal static fixed bin(17,0)          initial dcl 8-30
n_sync_line_types                      internal static fixed bin(17,0)          initial dcl 11-50
number_of_modes                        automatic       fixed bin(17,0)          dcl 8-6
saved_meters                           based           structure                level 1 dcl 4-68
sync_line_type                         internal static fixed bin(17,0)          initial array dcl 11-52
timer_info                             automatic       structure                level 1 dcl 10-50
tty_read_status_info                   based           structure                level 1 dcl 12-17
tty_read_status_info_ptr               automatic       pointer                  dcl 12-21
tty_space_man$free_buffer       000000 constant        entry                    external dcl 6-14
tty_space_man$get_chain         000000 constant        entry                    external dcl 6-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 6-11
tty_write_status_info_ptr              automatic       pointer                  dcl 12-27

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_INTERRUPT                   001255 constant        label                    dcl 50 ref 58 86 97 139 149 164
INTERRUPT                       000000 constant        label                    array(17) dcl 58 ref 49 49 49
SETUP_RETURNS_FOR_ERROR         002542 constant        label                    dcl 482 ref 476
WRITE_FINISHES                  002070 constant        label                    dcl 217 ref 275
add_buffer_to_frame             003502 constant        entry                    internal dcl 229 ref 199 205 211
crash                           004320 constant        entry                    internal dcl 488 ref 70 75 171 234
do_modes                        004142 constant        entry                    internal dcl 426 ref 403 411
free_pending_frame              004370 constant        entry                    internal dcl 509 ref 235 322 330 374 494
lap_simplex                     001213 constant        entry                    external dcl 11
lap_simplex$check_modes         002444 constant        entry                    external dcl 400
lap_simplex$control             002133 constant        entry                    external dcl 347
lap_simplex$get_modes           002511 constant        entry                    external dcl 416
lap_simplex$hpriv_control       003270 constant        entry                    external dcl 652
lap_simplex$init_multiplexer    002550 constant        entry                    external dcl 533
lap_simplex$interrupt           001225 constant        entry                    external dcl 42
lap_simplex$priv_control        003141 constant        entry                    external dcl 629
lap_simplex$set_modes           002465 constant        entry                    external dcl 408
lap_simplex$shutdown            003063 constant        entry                    external dcl 618
lap_simplex$start               003015 constant        entry                    external dcl 590
lap_simplex$stop                003040 constant        entry                    external dcl 602
lap_simplex$terminate_multiplexer
                                002757 constant        entry                    external dcl 576
lap_simplex$write               001773 constant        entry                    external dcl 177
setup                           004254 constant        entry                    internal dcl 469 ref 180 350 419 433
split_buffer                    003571 constant        entry                    internal dcl 254 ref 209
write_frame                     003666 constant        entry                    internal dcl 293 ref 214

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5242        5330    4450        5252
Length      6110    4450        66         544     571           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lap_simplex                         434 external procedure  is an external procedure.  
begin block on line 102              69 begin block         uses auto adjustable storage.  
begin block on line 113                 begin block         shares stack frame of external procedure lap_simplex.  
add_buffer_to_frame                     internal procedure  shares stack frame of external procedure lap_simplex.  
split_buffer                            internal procedure  shares stack frame of external procedure lap_simplex.  
write_frame                             internal procedure  shares stack frame of external procedure lap_simplex.  
begin block on line 305              69 begin block         uses auto adjustable storage.  
do_modes                                internal procedure  shares stack frame of external procedure lap_simplex.  
setup                                   internal procedure  shares stack frame of external procedure lap_simplex.  
crash                                   internal procedure  shares stack frame of external procedure lap_simplex.  
free_pending_frame                      internal procedure  shares stack frame of external procedure lap_simplex.  
on unit on line 546                  72 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 init_sw                     lap_simplex

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 102  000100 old_string                  begin block on line 102
begin block on line 305  000100 old_string                  begin block on line 305
lap_simplex              000100 code                        lap_simplex
                         000101 ignore_code                 lap_simplex
                         000102 devx                        lap_simplex
                         000104 info_ptr                    lap_simplex
                         000106 order                       lap_simplex
                         000116 int_type                    lap_simplex
                         000120 int_data                    lap_simplex
                         000122 chain_ptr                   lap_simplex
                         000124 next_block                  lap_simplex
                         000125 frame_end                   lap_simplex
                         000126 real_buffer_lth             lap_simplex
                         000127 mode_idx                    lap_simplex
                         000130 lap_down_status             lap_simplex
                         000140 lap_load_info_ptr           lap_simplex
                         000142 lap_data_ptr                lap_simplex
                         000144 miip                        lap_simplex
                         000146 lctp                        lap_simplex
                         000150 lctep                       lap_simplex
                         000152 mclp                        lap_simplex
                         000154 mclep                       lap_simplex
                         000156 blockp                      lap_simplex
                         000160 dialup_info                 lap_simplex
                         000162 rtx_info                    lap_simplex
                         000212 leftover_chars              split_buffer
                         000213 new_buf_size                split_buffer
                         000214 new_bufp                    split_buffer
                         000224 bufp                        write_frame
                         000226 bufl                        write_frame
                         000236 mode_error                  do_modes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin_block   leave_begin_block   call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           reverse_cs
set_chars_eis       search_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$control       channel_manager$interrupt     channel_manager$write         pxss$ring_0_wakeup
syserr                        syserr$error_code             tty_space_man$free_chain      tty_space_man$free_space
tty_space_man$get_buffer      tty_space_man$get_space       tty_space_man$needs_space     tty_space_man$switch_chain
wire_proc$wire_me

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$bad_mode
error_table_$invalid_state    error_table_$noalloc          error_table_$null_info_ptr
error_table_$undefined_order_request                        error_table_$unimplemented_version
tty_buf$lct_ptr


CONSTANTS
004423  aa     677777777777

004424  aa     377777777777

004425  aa     777777007777

004426  aa     000002000000
004427  aa     000000000000
004430  ta     000561000000
004431  aa     000000000000

004432  aa     740777777777

004433  aa     577777777777

004434  aa     000002000000
004435  aa     000000000000
004436  aa     600000000041
004437  aa     000365000000

004440  aa     000002000000
004441  aa     000000000000
004442  ta     000553000000
004443  aa     000000000000

004444  aa     000002000000
004445  aa     000000000000
004446  aa     600000000041
004447  aa     000116000000

000021  aa     000000000013

000022  aa     000000000006

000023  aa  122 145 143 151	Reci
000024  aa  145 166 145 144	eved
000025  aa  040 151 156 166	 inv
000026  aa  141 154 151 144	alid
000027  aa  040 143 157 155	 com
000030  aa  155 141 156 144	mand
000031  aa  040 157 162 040	 or 
000032  aa  144 141 164 141	data
000033  aa  122 145 143 151	Reci
000034  aa  145 166 145 144	eved
000035  aa  040 104 111 123	 DIS
000036  aa  103 040 040 040	C   
000037  aa  040 040 040 040	    
000040  aa  040 040 040 040	    
000041  aa  040 040 040 040	    
000042  aa  040 040 040 040	    
000043  aa  122 145 143 151	Reci
000044  aa  145 166 145 144	eved
000045  aa  040 104 115 040	 DM 
000046  aa  050 154 141 160	(lap
000047  aa  142 051 040 040	b)  
000050  aa  040 040 040 040	    
000051  aa  040 040 040 040	    
000052  aa  040 040 040 040	    
000053  aa  122 145 143 151	Reci
000054  aa  145 166 145 144	eved
000055  aa  040 123 101 122	 SAR
000056  aa  115 040 050 154	M (l
000057  aa  141 160 051 040	ap) 
000060  aa  040 040 040 040	    
000061  aa  040 040 040 040	    
000062  aa  040 040 040 040	    
000063  aa  122 145 143 151	Reci
000064  aa  145 166 145 144	eved
000065  aa  040 123 101 102	 SAB
000066  aa  115 040 050 154	M (l
000067  aa  141 160 142 051	apb)
000070  aa  040 040 040 040	    
000071  aa  040 040 040 040	    
000072  aa  040 040 040 040	    
000073  aa  122 145 143 151	Reci
000074  aa  145 166 145 144	eved
000075  aa  040 125 101 040	 UA 
000076  aa  040 040 040 040	    
000077  aa  040 040 040 040	    
000100  aa  040 040 040 040	    
000101  aa  040 040 040 040	    
000102  aa  040 040 040 040	    
000103  aa  122 145 143 151	Reci
000104  aa  145 166 145 144	eved
000105  aa  040 103 115 104	 CMD
000106  aa  122 057 106 122	R/FR
000107  aa  115 122 040 040	MR  
000110  aa  040 040 040 040	    
000111  aa  040 040 040 040	    
000112  aa  040 040 040 040	    
000113  aa  122 145 143 151	Reci
000114  aa  145 166 145 144	eved
000115  aa  040 122 122 040	 RR 
000116  aa  040 040 040 040	    
000117  aa  040 040 040 040	    
000120  aa  040 040 040 040	    
000121  aa  040 040 040 040	    
000122  aa  040 040 040 040	    
000123  aa  122 145 143 151	Reci
000124  aa  145 166 145 144	eved
000125  aa  040 122 116 122	 RNR
000126  aa  040 040 040 040	    
000127  aa  040 040 040 040	    
000130  aa  040 040 040 040	    
000131  aa  040 040 040 040	    
000132  aa  040 040 040 040	    
000133  aa  122 145 143 151	Reci
000134  aa  145 166 145 144	eved
000135  aa  040 122 105 112	 REJ
000136  aa  040 040 040 040	    
000137  aa  040 040 040 040	    
000140  aa  040 040 040 040	    
000141  aa  040 040 040 040	    
000142  aa  040 040 040 040	    
000143  aa  122 145 143 151	Reci
000144  aa  145 166 145 144	eved
000145  aa  040 142 141 144	 bad
000146  aa  040 143 157 155	 com
000147  aa  155 141 156 144	mand
000150  aa  040 157 162 040	 or 
000151  aa  162 145 163 160	resp
000152  aa  157 156 163 145	onse
000153  aa  124 151 155 145	Time
000154  aa  162 040 050 124	r (T
000155  aa  061 051 040 145	1) e
000156  aa  170 160 151 162	xpir
000157  aa  145 144 040 167	ed w
000160  aa  151 164 150 040	ith 
000161  aa  162 143 074 116	rc<N
000162  aa  062 040 040 040	2   
000163  aa  124 151 155 145	Time
000164  aa  162 040 050 124	r (T
000165  aa  061 051 040 145	1) e
000166  aa  170 160 151 162	xpir
000167  aa  145 144 040 167	ed w
000170  aa  151 164 150 040	ith 
000171  aa  162 143 075 116	rc=N
000172  aa  062 040 040 040	2   
000173  aa  122 145 143 151	Reci
000174  aa  145 166 145 144	eved
000175  aa  040 142 141 144	 bad
000176  aa  040 146 151 156	 fin
000177  aa  141 154 040 142	al b
000200  aa  151 164 040 040	it  
000201  aa  040 040 040 040	    
000202  aa  040 040 040 040	    
000203  aa  122 145 143 151	Reci
000204  aa  145 166 145 144	eved
000205  aa  040 142 141 144	 bad
000206  aa  040 111 055 146	 I-f
000207  aa  162 141 155 145	rame
000210  aa  040 050 116 050	 (N(
000211  aa  122 051 051 040	R)) 
000212  aa  040 040 040 040	    
000213  aa  122 145 143 151	Reci
000214  aa  145 166 145 144	eved
000215  aa  040 142 141 144	 bad
000216  aa  040 111 055 146	 I-f
000217  aa  162 141 155 145	rame
000220  aa  040 050 116 050	 (N(
000221  aa  123 051 051 040	S)) 
000222  aa  040 040 040 040	    
000223  aa  122 145 143 151	Reci
000224  aa  145 166 145 144	eved
000225  aa  040 111 055 146	 I-f
000226  aa  162 141 155 145	rame
000227  aa  040 040 040 040	    
000230  aa  040 040 040 040	    
000231  aa  040 040 040 040	    
000232  aa  040 040 040 040	    
000233  aa  122 145 143 151	Reci
000234  aa  145 166 145 144	eved
000235  aa  040 160 157 154	 pol
000236  aa  154 040 122 122	l RR
000237  aa  040 143 157 155	 com
000240  aa  155 141 156 144	mand
000241  aa  040 050 154 141	 (la
000242  aa  160 142 051 040	pb) 
000243  aa  122 145 143 151	Reci
000244  aa  145 166 145 144	eved
000245  aa  040 160 157 154	 pol
000246  aa  154 040 122 116	l RN
000247  aa  122 040 143 157	R co
000250  aa  155 155 141 156	mman
000251  aa  144 040 050 154	d (l
000252  aa  141 160 142 051	apb)
000253  aa  122 145 143 151	Reci
000254  aa  145 166 145 144	eved
000255  aa  040 160 157 154	 pol
000256  aa  154 040 122 105	l RE
000257  aa  112 040 143 157	J co
000260  aa  155 155 141 156	mman
000261  aa  144 040 050 154	d (l
000262  aa  141 160 142 051	apb)

000263  aa  114 151 156 153	Link
000264  aa  040 144 157 167	 dow
000265  aa  156 072 040 163	n: s
000266  aa  145 145 040 146	ee f
000267  aa  162 141 155 145	rame
000270  aa  040 040 040 040	    
000271  aa  040 040 040 040	    
000272  aa  040 040 040 040	    
000273  aa  114 151 156 153	Link
000274  aa  040 144 157 167	 dow
000275  aa  156 072 040 144	n: d
000276  aa  157 167 156 040	own 
000277  aa  040 040 040 040	    
000300  aa  040 040 040 040	    
000301  aa  040 040 040 040	    
000302  aa  040 040 040 040	    
000303  aa  114 151 156 153	Link
000304  aa  040 144 157 167	 dow
000305  aa  156 072 040 124	n: T
000306  aa  063 040 040 040	3   
000307  aa  040 040 040 040	    
000310  aa  040 040 040 040	    
000311  aa  040 040 040 040	    
000312  aa  040 040 040 040	    
000313  aa  114 151 156 153	Link
000314  aa  040 144 157 167	 dow
000315  aa  156 072 040 123	n: S
000316  aa  101 102 115 040	ABM 
000317  aa  163 145 156 164	sent
000320  aa  040 040 040 040	    
000321  aa  040 040 040 040	    
000322  aa  040 040 040 040	    
000323  aa  114 151 156 153	Link
000324  aa  040 144 157 167	 dow
000325  aa  156 072 040 163	n: s
000326  aa  145 164 040 165	et u
000327  aa  160 040 040 040	p   
000330  aa  040 040 040 040	    
000331  aa  040 040 040 040	    
000332  aa  040 040 040 040	    
000333  aa  120 162 151 155	Prim
000334  aa  141 162 171 040	ary 
000335  aa  156 157 162 155	norm
000336  aa  141 154 040 040	al  
000337  aa  040 040 040 040	    
000340  aa  040 040 040 040	    
000341  aa  040 040 040 040	    
000342  aa  040 040 040 040	    
000343  aa  120 162 151 155	Prim
000344  aa  141 162 171 040	ary 
000345  aa  162 145 155 157	remo
000346  aa  164 145 040 142	te b
000347  aa  165 163 171 040	usy 
000350  aa  040 040 040 040	    
000351  aa  040 040 040 040	    
000352  aa  040 040 040 040	    
000353  aa  120 162 151 155	Prim
000354  aa  141 162 171 040	ary 
000355  aa  124 061 040 145	T1 e
000356  aa  170 160 151 162	xpir
000357  aa  145 144 040 040	ed  
000360  aa  040 040 040 040	    
000361  aa  040 040 040 040	    
000362  aa  040 040 040 040	    
000363  aa  120 162 151 155	Prim
000364  aa  141 162 171 040	ary 
000365  aa  123 101 122 115	SARM
000366  aa  040 162 145 163	 res
000367  aa  145 164 040 040	et  
000370  aa  040 040 040 040	    
000371  aa  040 040 040 040	    
000372  aa  040 040 040 040	    
000373  aa  123 145 143 157	Seco
000374  aa  156 144 141 162	ndar
000375  aa  171 040 156 157	y no
000376  aa  162 155 141 154	rmal
000377  aa  040 040 040 040	    
000400  aa  040 040 040 040	    
000401  aa  040 040 040 040	    
000402  aa  040 040 040 040	    
000403  aa  123 145 143 157	Seco
000404  aa  156 144 141 162	ndar
000405  aa  171 040 154 157	y lo
000406  aa  143 141 154 040	cal 
000407  aa  142 165 163 171	busy
000410  aa  040 040 040 040	    
000411  aa  040 040 040 040	    
000412  aa  040 040 040 040	    
000413  aa  123 145 143 157	Seco
000414  aa  156 144 141 162	ndar
000415  aa  171 040 162 145	y re
000416  aa  152 145 143 164	ject
000417  aa  040 040 040 040	    
000420  aa  040 040 040 040	    
000421  aa  040 040 040 040	    
000422  aa  040 040 040 040	    
000423  aa  123 145 143 157	Seco
000424  aa  156 144 141 162	ndar
000425  aa  171 040 103 115	y CM
000426  aa  104 122 040 163	DR s
000427  aa  145 156 144 040	end 
000430  aa  040 040 040 040	    
000431  aa  040 040 040 040	    
000432  aa  040 040 040 040	    
000433  aa  114 151 156 153	Link
000434  aa  040 165 160 040	 up 
000435  aa  106 122 115 122	FRMR
000436  aa  040 163 145 156	 sen
000437  aa  144 040 040 040	d   
000440  aa  040 040 040 040	    
000441  aa  040 040 040 040	    
000442  aa  040 040 040 040	    
000443  aa  114 151 156 153	Link
000444  aa  040 165 160 040	 up 
000445  aa  162 145 163 145	rese
000446  aa  164 040 163 164	t st
000447  aa  141 162 164 145	arte
000450  aa  144 040 050 154	d (l
000451  aa  141 160 142 051	apb)
000452  aa  040 040 040 040	    

000453  aa  104 157 167 156	Down
000454  aa  040 040 040 040	    
000455  aa  040 040 040 040	    
000456  aa  040 040 040 040	    
000457  aa  040 040 040 040	    
000460  aa  040 040 040 040	    
000461  aa  040 040 040 040	    
000462  aa  040 040 040 040	    
000463  aa  124 063 040 040	T3  
000464  aa  040 040 040 040	    
000465  aa  040 040 040 040	    
000466  aa  040 040 040 040	    
000467  aa  040 040 040 040	    
000470  aa  040 040 040 040	    
000471  aa  040 040 040 040	    
000472  aa  040 040 040 040	    
000473  aa  123 101 102 115	SABM
000474  aa  040 123 145 156	 Sen
000475  aa  164 040 040 040	t   
000476  aa  040 040 040 040	    
000477  aa  040 040 040 040	    
000500  aa  040 040 040 040	    
000501  aa  040 040 040 040	    
000502  aa  040 040 040 040	    
000503  aa  123 145 164 040	Set 
000504  aa  125 160 040 040	Up  
000505  aa  040 040 040 040	    
000506  aa  040 040 040 040	    
000507  aa  040 040 040 040	    
000510  aa  040 040 040 040	    
000511  aa  040 040 040 040	    
000512  aa  040 040 040 040	    
000513  aa  125 160 040 040	Up  
000514  aa  040 040 040 040	    
000515  aa  040 040 040 040	    
000516  aa  040 040 040 040	    
000517  aa  040 040 040 040	    
000520  aa  040 040 040 040	    
000521  aa  040 040 040 040	    
000522  aa  040 040 040 040	    

000524  aa  154 141 160 154	lapl
000525  aa  157 141 144 061	oad1

000526  aa     000000000000
000527  aa     000000000003

000530  aa     000000000000
000531  aa     000000000002

000532  aa     000000000000
000533  aa     000000000001

000534  aa     524000000054

000535  aa  162 141 167 151	rawi

000536  aa  162 141 167 157	rawo

000537  aa     514000000001

000540  aa     524000000103

000541  aa     524000000056

000542  aa     524000000063

000543  aa  167 162 165 000	wru

000544  aa     524000000014

000545  aa     524000000006

000546  aa     524000000136

000547  aa     524000000153

000550  aa     400000000000

000551  aa     526000000040

000552  aa     524000000067

000553  aa     000000000021

000554  aa     000000000004

000555  aa     404000000043

000556  aa     000000000003

000557  aa     514000000110

000560  aa     526077777777

000561  aa     000000000002

000562  aa     464000000000

000563  aa     000000000001

000564  aa     404000000021

000566  aa  154 157 141 144	load
000567  aa  137 155 160 170	_mpx

000570  aa  141 142 157 162	abor
000571  aa  164 000 000 000	t

000572  aa  154 151 163 164	list
000573  aa  145 156 000 000	en

000574  aa  150 141 156 147	hang
000575  aa  165 160 000 000	up

000576  aa     077777000043
000577  aa     000001000000

000600  aa     000000000000
000601  aa     000000000000

000602  aa  143 154 145 141	clea
000603  aa  156 165 160 000	nup

000604  aa  154 151 156 145	line
000605  aa  137 143 157 156	_con
000606  aa  164 162 157 154	trol

000607  aa  147 145 164 137	get_
000610  aa  155 145 164 145	mete
000611  aa  162 163 000 000	rs

000612  aa  143 157 160 171	copy
000613  aa  137 155 145 164	_met
000614  aa  145 162 163 000	ers

000615  aa  167 162 151 164	writ
000616  aa  145 137 163 164	e_st
000617  aa  141 164 165 163	atus

000620  aa     516100000010
000621  aa     000000000001
000622  aa     000000000003
000623  aa     000000000011

000624  aa  154 141 160 137	lap_
000625  aa  163 151 155 160	simp
000626  aa  154 145 170 050	lex(
000627  aa  136 141 051 072	^a):
000630  aa  040 111 156 166	 Inv
000631  aa  141 154 151 144	alid
000632  aa  040 163 165 142	 sub
000633  aa  143 150 141 156	chan
000634  aa  156 145 154 040	nel 
000635  aa  151 156 144 145	inde
000636  aa  170 040 136 144	x ^d

000637  aa  154 141 160 137	lap_
000640  aa  163 151 155 160	simp
000641  aa  154 145 170 050	lex(
000642  aa  136 141 051 072	^a):
000643  aa  040 105 162 162	 Err
000644  aa  157 162 040 146	or f
000645  aa  162 157 155 040	rom 
000646  aa  167 162 151 164	writ
000647  aa  145 040 157 146	e of
000650  aa  040 136 144 040	 ^d 
000651  aa  143 150 141 162	char
000652  aa  163 056 000 000	s.

000653  aa  154 141 160 137	lap_
000654  aa  163 151 155 160	simp
000655  aa  154 145 170 050	lex(
000656  aa  136 141 051 072	^a):
000657  aa  040 101 164 164	 Att
000660  aa  145 155 160 164	empt
000661  aa  040 164 157 040	 to 
000662  aa  167 162 151 164	writ
000663  aa  145 040 157 166	e ov
000664  aa  145 162 154 145	erle
000665  aa  156 147 164 150	ngth
000666  aa  040 146 162 141	 fra
000667  aa  155 145 056 000	me.

000670  aa  154 141 160 137	lap_
000671  aa  163 151 155 160	simp
000672  aa  154 145 170 050	lex(
000673  aa  136 141 051 072	^a):
000674  aa  040 125 156 145	 Une
000675  aa  170 160 145 143	xpec
000676  aa  164 145 144 040	ted 
000677  aa  151 156 164 145	inte
000700  aa  162 162 165 160	rrup
000701  aa  164 040 136 144	t ^d
000702  aa  040 136 056 063	 ^.3
000703  aa  142 040 162 145	b re
000704  aa  143 145 151 166	ceiv
000705  aa  145 144 056 000	ed.

000706  aa  154 141 160 137	lap_
000707  aa  163 151 155 160	simp
000710  aa  154 145 170 050	lex(
000711  aa  136 141 051 072	^a):
000712  aa  040 127 162 151	 Wri
000713  aa  164 145 040 146	te f
000714  aa  141 151 154 145	aile
000715  aa  144 040 164 157	d to
000716  aa  040 164 141 153	 tak
000717  aa  145 040 167 150	e wh
000720  aa  157 154 145 040	ole 
000721  aa  146 162 141 155	fram
000722  aa  145 054 040 144	e, d
000723  aa  151 163 143 141	isca
000724  aa  162 144 151 156	rdin
000725  aa  147 040 162 145	g re
000726  aa  163 164 056 000	st.

000727  aa  154 141 160 137	lap_
000730  aa  163 151 155 160	simp
000731  aa  154 145 170 050	lex(
000732  aa  136 141 051 072	^a):
000733  aa  040 114 151 156	 Lin
000734  aa  153 040 144 151	k di
000735  aa  163 143 157 156	scon
000736  aa  156 145 143 164	nect
000737  aa  145 144 040 144	ed d
000740  aa  165 145 040 164	ue t
000741  aa  157 040 155 151	o mi
000742  aa  163 055 155 141	s-ma
000743  aa  164 143 150 145	tche
000744  aa  144 040 146 162	d fr
000745  aa  141 155 145 040	ame 
000746  aa  163 151 172 145	size
000747  aa  163 056 040 103	s. C
000750  aa  115 104 122 057	MDR/
000751  aa  106 122 115 122	FRMR
000752  aa  040 146 162 141	 fra
000753  aa  155 145 072 040	me: 
000754  aa  136 050 040 136	^( ^
000755  aa  056 064 142 136	.4b^
000756  aa  051 056 000 000	).

000757  aa  154 141 160 137	lap_
000760  aa  163 151 155 160	simp
000761  aa  154 145 170 050	lex(
000762  aa  136 141 051 072	^a):
000763  aa  040 106 141 151	 Fai
000764  aa  154 165 162 145	lure
000765  aa  054 040 114 151	, Li
000766  aa  156 153 040 163	nk s
000767  aa  164 141 164 145	tate
000770  aa  072 040 136 141	: ^a
000771  aa  054 040 103 165	, Cu
000772  aa  162 162 145 156	rren
000773  aa  164 040 141 143	t ac
000774  aa  164 151 157 156	tion
000775  aa  072 040 136 141	: ^a
000776  aa  054 040 151 156	, in
000777  aa  040 136 141 054	 ^a,
001000  aa  040 120 162 151	 Pri
001001  aa  155 141 162 171	mary
001002  aa  040 163 164 141	 sta
001003  aa  164 145 072 040	te: 
001004  aa  136 141 054 040	^a, 
001005  aa  123 145 143 157	Seco
001006  aa  156 144 141 162	ndar
001007  aa  171 040 163 164	y st
001010  aa  141 164 145 072	ate:
001011  aa  040 136 141 000	 ^a

001012  aa  000 001 002 003	 
001013  aa  004 005 006 007	
001014  aa  010 011 012 013		

001015  aa  014 015 016 017	
001016  aa  020 021 022 023	
001017  aa  024 025 026 027	
001020  aa  030 031 032 033	
001021  aa  034 035 036 037	
001022  aa  040 041 042 043	 !"#
001023  aa  044 045 046 047	$%&'
001024  aa  050 051 052 053	()*+
001025  aa  054 055 056 057	,-./
001026  aa  060 061 062 063	0123
001027  aa  064 065 066 067	4567
001030  aa  070 071 072 073	89:;
001031  aa  074 075 076 077	<=>?
001032  aa  100 101 102 103	@ABC
001033  aa  104 105 106 107	DEFG
001034  aa  110 111 112 113	HIJK
001035  aa  114 115 116 117	LMNO
001036  aa  120 121 122 123	PQRS
001037  aa  124 125 126 127	TUVW
001040  aa  130 131 132 133	XYZ[
001041  aa  134 135 136 137	\]^_
001042  aa  140 141 142 143	`abc
001043  aa  144 145 146 147	defg
001044  aa  150 151 152 153	hijk
001045  aa  154 155 156 157	lmno
001046  aa  160 161 162 163	pqrs
001047  aa  164 165 166 167	tuvw
001050  aa  170 171 172 173	xyz{
001051  aa  174 175 176 177	|}~
001052  aa  200 201 202 203	
001053  aa  204 205 206 207	
001054  aa  210 211 212 213	
001055  aa  214 215 216 217	
001056  aa  220 221 222 223	
001057  aa  224 225 226 227	
001060  aa  230 231 232 233	
001061  aa  234 235 236 237	
001062  aa  240 241 242 243	
001063  aa  244 245 246 247	
001064  aa  250 251 252 253	
001065  aa  254 255 256 257	
001066  aa  260 261 262 263	
001067  aa  264 265 266 267	
001070  aa  270 271 272 273	
001071  aa  274 275 276 277	
001072  aa  300 301 302 303	
001073  aa  304 305 306 307	
001074  aa  310 311 312 313	
001075  aa  314 315 316 317	
001076  aa  320 321 322 323	
001077  aa  324 325 326 327	
001100  aa  330 331 332 333	
001101  aa  334 335 336 337	
001102  aa  340 341 342 343	
001103  aa  344 345 346 347	
001104  aa  350 351 352 353	
001105  aa  354 355 356 357	
001106  aa  360 361 362 363	
001107  aa  364 365 366 367	
001110  aa  370 371 372 373	
001111  aa  374 375 376 377	
001112  aa  400 401 402 403	 
001113  aa  404 405 406 407	
001114  aa  410 411 412 413		

001115  aa  414 415 416 417	
001116  aa  420 421 422 423	
001117  aa  424 425 426 427	
001120  aa  430 431 432 433	
001121  aa  434 435 436 437	
001122  aa  440 441 442 443	 !"#
001123  aa  444 445 446 447	$%&'
001124  aa  450 451 452 453	()*+
001125  aa  454 455 456 457	,-./
001126  aa  460 461 462 463	0123
001127  aa  464 465 466 467	4567
001130  aa  470 471 472 473	89:;
001131  aa  474 475 476 477	<=>?
001132  aa  500 501 502 503	@ABC
001133  aa  504 505 506 507	DEFG
001134  aa  510 511 512 513	HIJK
001135  aa  514 515 516 517	LMNO
001136  aa  520 521 522 523	PQRS
001137  aa  524 525 526 527	TUVW
001140  aa  530 531 532 533	XYZ[
001141  aa  534 535 536 537	\]^_
001142  aa  540 541 542 543	`abc
001143  aa  544 545 546 547	defg
001144  aa  550 551 552 553	hijk
001145  aa  554 555 556 557	lmno
001146  aa  560 561 562 563	pqrs
001147  aa  564 565 566 567	tuvw
001150  aa  570 571 572 573	xyz{
001151  aa  574 575 576 577	|}~
001152  aa  600 601 602 603	
001153  aa  604 605 606 607	
001154  aa  610 611 612 613	
001155  aa  614 615 616 617	
001156  aa  620 621 622 623	
001157  aa  624 625 626 627	
001160  aa  630 631 632 633	
001161  aa  634 635 636 637	
001162  aa  640 641 642 643	
001163  aa  644 645 646 647	
001164  aa  650 651 652 653	
001165  aa  654 655 656 657	
001166  aa  660 661 662 663	
001167  aa  664 665 666 667	
001170  aa  670 671 672 673	
001171  aa  674 675 676 677	
001172  aa  700 701 702 703	
001173  aa  704 705 706 707	
001174  aa  710 711 712 713	
001175  aa  714 715 716 717	
001176  aa  720 721 722 723	
001177  aa  724 725 726 727	
001200  aa  730 731 732 733	
001201  aa  734 735 736 737	
001202  aa  740 741 742 743	
001203  aa  744 745 746 747	
001204  aa  750 751 752 753	
001205  aa  754 755 756 757	
001206  aa  760 761 762 763	
001207  aa  764 765 766 767	
001210  aa  770 771 772 773	
001211  aa  774 775 776 777	

LABEL ARRAYS
000000  aa   001311 7100 04	tra  	713,ic		001311
000001  aa   001350 7100 04	tra  	744,ic		001351
000002  aa   001352 7100 04	tra  	746,ic		001354
000003  aa   001354 7100 04	tra  	748,ic		001357
000004  aa   001374 7100 04	tra  	764,ic		001400
000005  aa   001374 7100 04	tra  	764,ic		001401
000006  aa   001550 7100 04	tra  	872,ic		001556
000007  aa   001547 7100 04	tra  	871,ic		001556
000010  aa   001547 7100 04	tra  	871,ic		001557
000011  aa   001707 7100 04	tra  	967,ic		001720
000012  aa   001706 7100 04	tra  	966,ic		001720
000013  aa   001706 7100 04	tra  	966,ic		001721
000014  aa   001724 7100 04	tra  	980,ic		001740
000015  aa   001723 7100 04	tra  	979,ic		001740
000016  aa   001723 7100 04	tra  	979,ic		001741
000017  aa   001722 7100 04	tra  	978,ic		001741
000020  aa   001722 7100 04	tra  	978,ic		001742

BEGIN PROCEDURE lap_simplex
ENTRY TO lap_simplex                                        STATEMENT 1 ON LINE 11
lap_simplex:
     procedure;

001212  da     000255200000
001213  aa   000700 6270 00	eax7 	448
001214  aa  7 00034 3521 20	epp2 	pr7|28,*
001215  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001216  aa     000000000000
001217  aa     000000000000
						STATEMENT 1 ON LINE 42
lap_simplex$interrupt:
     entry (P_lap_data_ptr, P_int_type, P_int_data);

001220  aa   000015 7100 04	tra  	13,ic		001235
ENTRY TO lap_simplex$interrupt                              STATEMENT 1 ON LINE 42
lap_simplex$interrupt:
     entry (P_lap_data_ptr, P_int_type, P_int_data);

001221  at     000003000562
001222  tt     000564000557
001223  ta     001221000000
001224  da     000271300000
001225  aa   000700 6270 00	eax7 	448
001226  aa  7 00034 3521 20	epp2 	pr7|28,*
001227  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001230  aa     000006000000
001231  aa     000000000000
001232  aa  6 00032 3735 20	epp7 	pr6|26,*
001233  aa  7 00002 3715 20	epp5 	pr7|2,*
001234  aa  6 00172 6515 00	spri5	pr6|122
						STATEMENT 1 ON LINE 45
	lap_data_ptr = P_lap_data_ptr;

001235  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
001236  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
001237  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 46
	int_type = P_int_type;

001240  aa  6 00032 3715 20	epp5 	pr6|26,*
001241  aa  5 00004 2361 20	ldq  	pr5|4,*		P_int_type
001242  aa  6 00116 7561 00	stq  	pr6|78		int_type
						STATEMENT 1 ON LINE 47
	int_data = P_int_data;

001243  aa  5 00006 3535 20	epp3 	pr5|6,*
001244  aa  3 00000 2351 00	lda  	pr3|0		P_int_data
001245  aa  3 00001 2361 00	ldq  	pr3|1		P_int_data
001246  aa  6 00120 7571 00	staq 	pr6|80		int_data
						STATEMENT 1 ON LINE 49
	if (int_type < lbound (INTERRUPT, 1)) | (int_type > hbound (INTERRUPT, 1)) then do;

001247  aa  6 00116 2361 00	ldq  	pr6|78		int_type
001250  aa   000001 1160 07	cmpq 	1,dl
001251  aa   000004 6040 04	tmi  	4,ic		001255
001252  aa   000021 1160 07	cmpq 	17,dl
001253  aa   000002 6054 04	tpnz 	2,ic		001255
001254  ta   777777 7100 06	tra  	-1,ql
						STATEMENT 1 ON LINE 50
BAD_INTERRUPT:
	     call syserr (Log_message, "lap_simplex(^a): Unexpected interrupt ^d ^.3b received.", lap_data.name,
		int_type, int_data);

001255  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001256  aa   777413 00 0070	desc9a	-245,56		000670 = 154141160137
001257  aa  6 00262 00 0070	desc9a	pr6|178,56
001260  aa   777274 3520 04	epp2 	-324,ic		000554 = 000000000004
001261  aa  6 00302 2521 00	spri2	pr6|194
001262  aa  6 00262 3521 00	epp2 	pr6|178
001263  aa  6 00304 2521 00	spri2	pr6|196
001264  aa  6 00142 3521 20	epp2 	pr6|98,*		lap_data.name
001265  aa  6 00306 2521 00	spri2	pr6|198
001266  aa  6 00116 3521 00	epp2 	pr6|78		int_type
001267  aa  6 00310 2521 00	spri2	pr6|200
001270  aa  6 00120 3521 00	epp2 	pr6|80		int_data
001271  aa  6 00312 2521 00	spri2	pr6|202
001272  aa   777272 3520 04	epp2 	-326,ic		000564 = 404000000021
001273  aa  6 00314 2521 00	spri2	pr6|204
001274  aa  6 00322 2521 00	spri2	pr6|210
001275  aa   777255 3520 04	epp2 	-339,ic		000552 = 524000000067
001276  aa  6 00316 2521 00	spri2	pr6|206
001277  aa   777252 3520 04	epp2 	-342,ic		000551 = 526000000040
001300  aa  6 00320 2521 00	spri2	pr6|208
001301  aa   777256 3520 04	epp2 	-338,ic		000557 = 514000000110
001302  aa  6 00324 2521 00	spri2	pr6|212
001303  aa  6 00300 6211 00	eax1 	pr6|192
001304  aa   024000 4310 07	fld  	10240,dl
001305  aa  6 00044 3701 20	epp4 	pr6|36,*
001306  la  4 00014 3521 20	epp2 	pr4|12,*		syserr
001307  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 53
	     return;

001310  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 54
	     end;

						STATEMENT 1 ON LINE 58
INTERRUPT (1):					/* DIALUP - major channel has dialed up */
	if (lap_data.state ^= LAP_LISTENING) then goto BAD_INTERRUPT;

001311  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001312  aa  7 00012 2361 00	ldq  	pr7|10		lap_data.state
001313  aa   000001 1160 07	cmpq 	1,dl
001314  aa   777741 6010 04	tnz  	-31,ic		001255
						STATEMENT 1 ON LINE 60
	unspec (lap_data.dialup_info) = int_data;

001315  aa  6 00120 2371 00	ldaq 	pr6|80		int_data
001316  aa  7 00022 7551 00	sta  	pr7|18
001317  aa  7 00023 7561 00	stq  	pr7|19
						STATEMENT 1 ON LINE 61
	lap_data.sc_dialup_info = lap_data.dialup_info;

001320  aa  7 00022 2351 00	lda  	pr7|18		lap_data.dialup_info
001321  aa  7 00023 2361 00	ldq  	pr7|19		lap_data.dialup_info
001322  aa  7 00024 7551 00	sta  	pr7|20		lap_data.sc_dialup_info
001323  aa  7 00025 7561 00	stq  	pr7|21		lap_data.sc_dialup_info
						STATEMENT 1 ON LINE 62
	lap_data.sc_dialup_info.buffer_pad = L2_HEADER_PAD;

001324  aa   000002 2350 03	lda  	2,du
001325  aa  7 00024 5511 20	stba 	pr7|20,20		lap_data.buffer_pad
						STATEMENT 1 ON LINE 63
	lap_data.sc_dialup_info.line_type = LINE_ASCII;

001326  aa   001000 2350 03	lda  	512,du
001327  aa  7 00024 5511 40	stba 	pr7|20,40		lap_data.line_type
						STATEMENT 1 ON LINE 65
	call pxss$ring_0_wakeup (lap_data.load_process_id, lap_data.load_event_channel, MPX_UP, ignore_code);

001330  aa  7 00014 3521 00	epp2 	pr7|12		lap_data.load_process_id
001331  aa  6 00264 2521 00	spri2	pr6|180
001332  aa  7 00016 3521 00	epp2 	pr7|14		lap_data.load_event_channel
001333  aa  6 00266 2521 00	spri2	pr6|182
001334  aa   777176 3520 04	epp2 	-386,ic		000532 = 000000000000
001335  aa  6 00270 2521 00	spri2	pr6|184
001336  aa  6 00101 3521 00	epp2 	pr6|65		ignore_code
001337  aa  6 00272 2521 00	spri2	pr6|186
001340  aa  6 00262 6211 00	eax1 	pr6|178
001341  aa   020000 4310 07	fld  	8192,dl
001342  aa  6 00044 3701 20	epp4 	pr6|36,*
001343  la  4 00012 3521 20	epp2 	pr4|10,*		pxss$ring_0_wakeup
001344  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 66
	lap_data.state = LAP_ACTIVE;

001345  aa   000002 2360 07	ldq  	2,dl
001346  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001347  aa  7 00012 7561 00	stq  	pr7|10		lap_data.state
						STATEMENT 1 ON LINE 67
	return;

001350  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 70
INTERRUPT (2):					/* HANGUP - major channel has hung up */
	call crash (int_type);

001351  aa   003073 3520 04	epp2 	1595,ic		004444 = 000002000000
001352  aa   002746 6700 04	tsp4 	1510,ic		004320
						STATEMENT 1 ON LINE 72
	return;

001353  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 75
INTERRUPT (3):					/* CRASH - parent multiplexer has died */
	call crash (int_type);

001354  aa   003070 3520 04	epp2 	1592,ic		004444 = 000002000000
001355  aa   002743 6700 04	tsp4 	1507,ic		004320
						STATEMENT 1 ON LINE 77
	return;

001356  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 80
INTERRUPT (4):					/* SEND_OUTPUT - it's safe to write next output frame now */
	lap_data.flags.send_output = "1"b;

001357  aa   400000 2350 03	lda  	131072,du
001360  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001361  aa  7 00013 2551 00	orsa 	pr7|11		lap_data.send_output
						STATEMENT 1 ON LINE 82
	call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, (""b));

001362  aa   777216 2370 04	ldaq 	-370,ic		000600 = 000000000000 000000000000
001363  aa  6 00326 7571 00	staq 	pr6|214
001364  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
001365  aa  6 00264 2521 00	spri2	pr6|180
001366  aa   777166 3520 04	epp2 	-394,ic		000554 = 000000000004
001367  aa  6 00266 2521 00	spri2	pr6|182
001370  aa  6 00326 3521 00	epp2 	pr6|214
001371  aa  6 00270 2521 00	spri2	pr6|184
001372  aa  6 00262 6211 00	eax1 	pr6|178
001373  aa   014000 4310 07	fld  	6144,dl
001374  aa  6 00044 3701 20	epp4 	pr6|36,*
001375  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
001376  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 83
	return;

001377  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 86
INTERRUPT (5):					/* INPUT_AVAILABLE */
	goto BAD_INTERRUPT;

001400  aa   777655 7100 04	tra  	-83,ic		001255
						STATEMENT 1 ON LINE 90
INTERRUPT (6):					/* ACCEPT INPUT - process an input frame */
	unspec (rtx_info) = int_data;

001401  aa  6 00120 2371 00	ldaq 	pr6|80		int_data
001402  aa  6 00162 7571 00	staq 	pr6|114
						STATEMENT 1 ON LINE 92
	blockp = pointer (lap_data_ptr, rtx_info.chain_head);

001403  aa  6 00162 2351 00	lda  	pr6|114		rtx_info.chain_head
001404  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001405  aa  6 00142 3521 20	epp2 	pr6|98,*		lap_data_ptr
001406  aa   000000 3120 01	eawp2	0,au
001407  aa  6 00156 2521 00	spri2	pr6|110		blockp
						STATEMENT 1 ON LINE 93
	real_buffer_lth = buffer.tally - L2_HEADER_PAD;

001410  aa  2 00000 2361 00	ldq  	pr2|0		buffer.tally
001411  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001412  aa   000002 1760 07	sbq  	2,dl
001413  aa  6 00126 7561 00	stq  	pr6|86		real_buffer_lth
						STATEMENT 1 ON LINE 95
	if ((lap_data.state < LAP_ACTIVE) | (real_buffer_lth <= 0)) then do;

001414  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001415  aa  7 00012 2361 00	ldq  	pr7|10		lap_data.state
001416  aa   000002 1160 07	cmpq 	2,dl
001417  aa   000003 6040 04	tmi  	3,ic		001422
001420  aa  6 00126 2361 00	ldq  	pr6|86		real_buffer_lth
001421  aa   000015 6054 04	tpnz 	13,ic		001436
						STATEMENT 1 ON LINE 96
	     call tty_space_man$free_chain (lap_data.devx, INPUT, blockp);

001422  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
001423  aa  6 00264 2521 00	spri2	pr6|180
001424  aa   777102 3520 04	epp2 	-446,ic		000526 = 000000000000
001425  aa  6 00266 2521 00	spri2	pr6|182
001426  aa  6 00156 3521 00	epp2 	pr6|110		blockp
001427  aa  6 00270 2521 00	spri2	pr6|184
001430  aa  6 00262 6211 00	eax1 	pr6|178
001431  aa   014000 4310 07	fld  	6144,dl
001432  aa  6 00044 3701 20	epp4 	pr6|36,*
001433  la  4 00060 3521 20	epp2 	pr4|48,*		tty_space_man$free_chain
001434  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 97
	     goto BAD_INTERRUPT;

001435  aa   777620 7100 04	tra  	-112,ic		001255
						STATEMENT 1 ON LINE 98
	     end;

						STATEMENT 1 ON LINE 100
	call tty_space_man$switch_chain (lap_data.devx, lap_data.subchannel, INPUT, INPUT, blockp);

001436  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
001437  aa  6 00264 2521 00	spri2	pr6|180
001440  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
001441  aa  6 00266 2521 00	spri2	pr6|182
001442  aa   777064 3520 04	epp2 	-460,ic		000526 = 000000000000
001443  aa  6 00270 2521 00	spri2	pr6|184
001444  aa  6 00272 2521 00	spri2	pr6|186
001445  aa  6 00156 3521 00	epp2 	pr6|110		blockp
001446  aa  6 00274 2521 00	spri2	pr6|188
001447  aa  6 00262 6211 00	eax1 	pr6|178
001450  aa   024000 4310 07	fld  	10240,dl
001451  aa  6 00044 3701 20	epp4 	pr6|36,*
001452  la  4 00062 3521 20	epp2 	pr4|50,*		tty_space_man$switch_chain
001453  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 102
	begin;

001454  aa   000120 6270 00	eax7 	80
001455  aa  0 00614 2721 00	tsp2 	pr0|396		enter_begin_block
001456  aa     000000000000
BEGIN BLOCK  1
PROLOGUE SEQUENCE                                           STATEMENT 1 ON LINE 103
001457  aa  6 00040 3735 20	epp7 	pr6|32,*
001460  aa  7 00126 2361 00	ldq  	pr7|86		real_buffer_lth
001461  aa  6 00100 7561 00	stq  	pr6|64
001462  aa   000003 0760 07	adq  	3,dl
001463  aa   000002 7320 00	qrs  	2
001464  aa  6 00101 7561 00	stq  	pr6|65
001465  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
001466  aa  6 00102 2521 00	spri2	pr6|66
						STATEMENT 1 ON LINE 104
001467  aa  7 00126 2361 00	ldq  	pr7|86		real_buffer_lth
001470  aa  6 00104 7561 00	stq  	pr6|68
MAIN SEQUENCE                                               STATEMENT 1 ON LINE 105
	     old_string = substr (string (buffer.chars), L2_HEADER_PAD + 1, real_buffer_lth);

001471  aa   000002 7270 07	lxl7 	2,dl
001472  aa  7 00156 3715 20	epp5 	pr7|110,*		blockp
001473  aa  6 00100 2351 00	lda  	pr6|64
001474  aa  040 140 100 557	mlr  	(pr,rl,x7),(pr,rl),fill(040)
001475  aa  5 00001 00 0006	desc9a	pr5|1,ql
001476  aa  2 00000 00 0005	desc9a	pr2|0,al		old_string
						STATEMENT 1 ON LINE 106
	     new_string = old_string;

001477  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001500  aa  2 00000 00 0005	desc9a	pr2|0,al		old_string
001501  aa  5 00001 00 0006	desc9a	pr5|1,ql		new_string
						STATEMENT 1 ON LINE 107
	end;

001502  aa  0 00615 7001 00	tsx0 	pr0|397		leave_begin_block
  END BLOCK  1
						STATEMENT 1 ON LINE 109
	buffer.tally = buffer.tally - L2_HEADER_PAD;

001503  aa  6 00156 2361 20	ldq  	pr6|110,*		buffer.tally
001504  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001505  aa   000002 1760 07	sbq  	2,dl
001506  aa  6 00156 3735 20	epp7 	pr6|110,*		buffer.tally
001507  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 110
	rtx_info.input_count = rtx_info.input_count - L2_HEADER_PAD;

001510  aa  6 00163 2351 00	lda  	pr6|115		rtx_info.input_count
001511  aa   000066 7730 00	lrl  	54
001512  aa   000002 1760 07	sbq  	2,dl
001513  aa   000066 7370 00	lls  	54
001514  aa  6 00163 5511 60	stba 	pr6|115,60	rtx_info.input_count
						STATEMENT 1 ON LINE 112
	blockp = pointer (blockp, rtx_info.chain_tail);

001515  aa  6 00162 2351 00	lda  	pr6|114		rtx_info.chain_tail
001516  aa   000022 7350 00	als  	18
001517  aa  6 00156 3521 20	epp2 	pr6|110,*		blockp
001520  aa   000000 3120 01	eawp2	0,au
001521  aa  6 00156 2521 00	spri2	pr6|110		blockp
						STATEMENT 1 ON LINE 113
	begin;

BEGIN BLOCK  2                                              STATEMENT 1 ON LINE 115
	     unspec (last_char) = unspec (last_char) | "400"b3;

001522  aa  6 00156 2361 20	ldq  	pr6|110,*		buffer.tally
001523  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001524  aa   000011 4020 07	mpy  	9,dl
001525  aa  6 00156 3735 20	epp7 	pr6|110,*		blockp
001526  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001527  aa  7 00000 60 0011	descb	pr7|0(27),9
001530  aa  6 00056 00 0044	descb	pr6|46,36
001531  aa  6 00056 2351 00	lda  	pr6|46
001532  aa   400000 2750 03	ora  	131072,du
001533  aa  6 00056 7551 00	sta  	pr6|46
001534  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
001535  aa  6 00056 00 0011	descb	pr6|46,9
001536  aa  7 00000 60 0011	descb	pr7|0(27),9
						STATEMENT 1 ON LINE 116
	end;

  END BLOCK  2
						STATEMENT 1 ON LINE 118
	call channel_manager$interrupt (lap_data.subchannel, ACCEPT_INPUT, unspec (rtx_info));

001537  aa  6 00162 2371 00	ldaq 	pr6|114
001540  aa  6 00326 7571 00	staq 	pr6|214
001541  aa  6 00142 3715 20	epp5 	pr6|98,*		lap_data_ptr
001542  aa  5 00011 3521 00	epp2 	pr5|9		lap_data.subchannel
001543  aa  6 00264 2521 00	spri2	pr6|180
001544  aa   776256 3520 04	epp2 	-850,ic		000022 = 000000000006
001545  aa  6 00266 2521 00	spri2	pr6|182
001546  aa  6 00326 3521 00	epp2 	pr6|214
001547  aa  6 00270 2521 00	spri2	pr6|184
001550  aa  6 00262 6211 00	eax1 	pr6|178
001551  aa   014000 4310 07	fld  	6144,dl
001552  aa  6 00044 3701 20	epp4 	pr6|36,*
001553  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
001554  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 119
	return;

001555  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 122
INTERRUPT (7):					/* INPUT REJECTED - ignore */
INTERRUPT (8):					/* QUIT - ignore */
	return;

001556  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 127
INTERRUPT (9):					/* LINE_STATUS - LAP link has gone down */
	unspec (lap_down_status) = int_data;

001557  aa  6 00120 2371 00	ldaq 	pr6|80		int_data
001560  aa  6 00130 7571 00	staq 	pr6|88
						STATEMENT 1 ON LINE 130
	if lap_down_status.status_type = 1
	then call syserr (Log_message,
		"lap_simplex(^a): Failure, Link state: ^a, Current action: ^a, in ^a, Primary state: ^a, Secondary state: ^a",
		lap_data.name, FRAME_STATE_ARRAY (lap_down_status.main_state),
		FRAME_FUNCTION_CODE (lap_down_status.last_function_process),
		FRAME_SUB_STATE_ARRAY (lap_down_status.which_state_process),
		FRAME_SUB_STATE_ARRAY (lap_down_status.primary_sub_state),
		FRAME_SUB_STATE_ARRAY (lap_down_status.secondary_sub_state));

001561  aa  6 00130 2351 00	lda  	pr6|88		lap_down_status.status_type
001562  aa   000066 7730 00	lrl  	54
001563  aa   000001 1160 07	cmpq 	1,dl
001564  aa   000075 6010 04	tnz  	61,ic		001661
001565  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001566  aa   777172 00 0154	desc9a	-390,108		000757 = 154141160137
001567  aa  6 00330 00 0154	desc9a	pr6|216,108
001570  aa  6 00131 2351 00	lda  	pr6|89		lap_down_status.main_state
001571  aa   000011 7350 00	als  	9
001572  aa   000077 7730 00	lrl  	63
001573  aa   000003 7360 00	qls  	3
001574  aa  6 00130 2351 00	lda  	pr6|88		lap_down_status.last_function_process
001575  aa   000022 7350 00	als  	18
001576  aa   000000 6270 06	eax7 	0,ql
001577  aa   000066 7330 00	lrs  	54
001600  aa   000003 7360 00	qls  	3
001601  aa  6 00131 2351 00	lda  	pr6|89		lap_down_status.which_state_process
001602  aa   000000 6260 06	eax6 	0,ql
001603  aa   000077 7730 00	lrl  	63
001604  aa   000003 7360 00	qls  	3
001605  aa  6 00131 2351 00	lda  	pr6|89		lap_down_status.primary_sub_state
001606  aa   000022 7350 00	als  	18
001607  aa   000000 6250 06	eax5 	0,ql
001610  aa   000077 7730 00	lrl  	63
001611  aa   000003 7360 00	qls  	3
001612  aa  6 00131 2351 00	lda  	pr6|89		lap_down_status.secondary_sub_state
001613  aa   000033 7350 00	als  	27
001614  aa   000000 6240 06	eax4 	0,ql
001615  aa   000077 7730 00	lrl  	63
001616  aa   000003 7360 00	qls  	3
001617  aa   776735 3520 04	epp2 	-547,ic		000554 = 000000000004
001620  aa  6 00372 2521 00	spri2	pr6|250
001621  aa  6 00330 3521 00	epp2 	pr6|216
001622  aa  6 00374 2521 00	spri2	pr6|252
001623  aa  6 00142 3521 20	epp2 	pr6|98,*		lap_data.name
001624  aa  6 00376 2521 00	spri2	pr6|254
001625  ta   000443 3520 17	epp2 	291,7
001626  aa  6 00400 2521 00	spri2	pr6|256
001627  ta   000023 3520 16	epp2 	19,6
001630  aa  6 00402 2521 00	spri2	pr6|258
001631  ta   000263 3520 15	epp2 	179,5
001632  aa  6 00404 2521 00	spri2	pr6|260
001633  ta   000263 3520 14	epp2 	179,4
001634  aa  6 00406 2521 00	spri2	pr6|262
001635  ta   000263 3520 06	epp2 	179,ql
001636  aa  6 00410 2521 00	spri2	pr6|264
001637  aa   776725 3520 04	epp2 	-555,ic		000564 = 404000000021
001640  aa  6 00412 2521 00	spri2	pr6|266
001641  aa   776706 3520 04	epp2 	-570,ic		000547 = 524000000153
001642  aa  6 00414 2521 00	spri2	pr6|268
001643  aa   776706 3520 04	epp2 	-570,ic		000551 = 526000000040
001644  aa  6 00416 2521 00	spri2	pr6|270
001645  aa  6 00420 2521 00	spri2	pr6|272
001646  aa  6 00422 2521 00	spri2	pr6|274
001647  aa  6 00424 2521 00	spri2	pr6|276
001650  aa   776701 3520 04	epp2 	-575,ic		000551 = 526000000040
001651  aa  6 00426 2521 00	spri2	pr6|278
001652  aa  6 00430 2521 00	spri2	pr6|280
001653  aa  6 00370 6211 00	eax1 	pr6|248
001654  aa   040000 4310 07	fld  	16384,dl
001655  aa  6 00044 3701 20	epp4 	pr6|36,*
001656  la  4 00014 3521 20	epp2 	pr4|12,*		syserr
001657  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
001660  aa   000037 7100 04	tra  	31,ic		001717
						STATEMENT 1 ON LINE 139
	else if lap_cmdr_status.cmdr_status = 3
	then call syserr (Log_message,
		"lap_simplex(^a): Link disconnected due to mis-matched frame sizes. CMDR/FRMR frame: ^( ^.4b^).",
		lap_data.name, lap_cmdr_status.cmdr_bytes.byte (*));

001661  aa  6 00120 2351 00	lda  	pr6|80		lap_cmdr_status.cmdr_status
001662  aa   000066 7730 00	lrl  	54
001663  aa   000003 1160 07	cmpq 	3,dl
001664  aa   777371 6010 04	tnz  	-263,ic		001255
001665  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001666  aa   777042 00 0140	desc9a	-478,96		000727 = 154141160137
001667  aa  6 00330 00 0140	desc9a	pr6|216,96
001670  aa   776664 3520 04	epp2 	-588,ic		000554 = 000000000004
001671  aa  6 00302 2521 00	spri2	pr6|194
001672  aa  6 00330 3521 00	epp2 	pr6|216
001673  aa  6 00304 2521 00	spri2	pr6|196
001674  aa  6 00142 3521 20	epp2 	pr6|98,*		lap_data.name
001675  aa  6 00306 2521 00	spri2	pr6|198
001676  aa   000023 7270 07	lxl7 	19,dl
001677  aa  6 00120 3521 00	epp2 	pr6|80		lap_cmdr_status.byte
001700  aa  2 00000 5035 17	abd  	pr2|0,7
001701  aa  6 00310 2521 00	spri2	pr6|200
001702  aa   776662 3520 04	epp2 	-590,ic		000564 = 404000000021
001703  aa  6 00312 2521 00	spri2	pr6|202
001704  aa   776642 3520 04	epp2 	-606,ic		000546 = 524000000136
001705  aa  6 00314 2521 00	spri2	pr6|204
001706  aa   776643 3520 04	epp2 	-605,ic		000551 = 526000000040
001707  aa  6 00316 2521 00	spri2	pr6|206
001710  aa   776710 3520 04	epp2 	-568,ic		000620 = 516100000010
001711  aa  6 00320 2521 00	spri2	pr6|208
001712  aa  6 00300 6211 00	eax1 	pr6|192
001713  aa   020000 4310 07	fld  	8192,dl
001714  aa  6 00044 3701 20	epp4 	pr6|36,*
001715  la  4 00014 3521 20	epp2 	pr4|12,*		syserr
001716  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 146
	return;

001717  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 149
INTERRUPT (10):					/* DIAL STATUS - ignore */
INTERRUPT (11):					/* WRU TIMEOUT - ignore */
	goto BAD_INTERRUPT;

001720  aa   777335 7100 04	tra  	-291,ic		001255
						STATEMENT 1 ON LINE 154
INTERRUPT (12):					/* SPACE AVAILABLE - some buffer space was freed that we need */
	call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, ""b);

001721  aa   776657 2370 04	ldaq 	-593,ic		000600 = 000000000000 000000000000
001722  aa  6 00326 7571 00	staq 	pr6|214
001723  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001724  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
001725  aa  6 00264 2521 00	spri2	pr6|180
001726  aa   776626 3520 04	epp2 	-618,ic		000554 = 000000000004
001727  aa  6 00266 2521 00	spri2	pr6|182
001730  aa  6 00326 3521 00	epp2 	pr6|214
001731  aa  6 00270 2521 00	spri2	pr6|184
001732  aa  6 00262 6211 00	eax1 	pr6|178
001733  aa   014000 4310 07	fld  	6144,dl
001734  aa  6 00044 3701 20	epp4 	pr6|36,*
001735  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
001736  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 156
	return;

001737  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 159
INTERRUPT (13):					/* ACKNOWLEDGE_ECHNEGO_INIT */
INTERRUPT (14):					/* ACKNOWLEDGE_ECHNEGO_STOP */
	return;

001740  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 164
INTERRUPT (15):					/* TIMER */
INTERRUPT (16):					/* USER_INTERRUPT */
	goto BAD_INTERRUPT;

001741  aa   777314 7100 04	tra  	-308,ic		001255
						STATEMENT 1 ON LINE 169
INTERRUPT (17):					/* MASKED - treat like HANGUP but use different wakeup message */
	call pxss$ring_0_wakeup (lap_data.load_process_id, lap_data.load_event_channel, MPX_MASKED, code);

001742  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001743  aa  7 00014 3521 00	epp2 	pr7|12		lap_data.load_process_id
001744  aa  6 00264 2521 00	spri2	pr6|180
001745  aa  7 00016 3521 00	epp2 	pr7|14		lap_data.load_event_channel
001746  aa  6 00266 2521 00	spri2	pr6|182
001747  aa   776557 3520 04	epp2 	-657,ic		000526 = 000000000000
001750  aa  6 00270 2521 00	spri2	pr6|184
001751  aa  6 00100 3521 00	epp2 	pr6|64		code
001752  aa  6 00272 2521 00	spri2	pr6|186
001753  aa  6 00262 6211 00	eax1 	pr6|178
001754  aa   020000 4310 07	fld  	8192,dl
001755  aa  6 00044 3701 20	epp4 	pr6|36,*
001756  la  4 00012 3521 20	epp2 	pr4|10,*		pxss$ring_0_wakeup
001757  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 171
	call crash (MASKED);

001760  aa   002460 3520 04	epp2 	1328,ic		004440 = 000002000000
001761  aa   002337 6700 04	tsp4 	1247,ic		004320
						STATEMENT 1 ON LINE 172
	lap_data.state = LAP_HUNGUP;

001762  aa   000000 2360 07	ldq  	0,dl
001763  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
001764  aa  7 00012 7561 00	stq  	pr7|10		lap_data.state
						STATEMENT 1 ON LINE 173
	return;

001765  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$write                                  STATEMENT 1 ON LINE 177
lap_simplex$write:
     entry (P_lap_data_ptr, P_subchan_idx, P_chain_ptr, P_code);

001766  at     000004000562
001767  tt     000564000562
001770  ta     000555000000
001771  ta     001766000000
001772  da     000304300000
001773  aa   000700 6270 00	eax7 	448
001774  aa  7 00034 3521 20	epp2 	pr7|28,*
001775  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001776  aa     000010000000
001777  aa     000000000000
002000  aa  6 00032 3735 20	epp7 	pr6|26,*
002001  aa  7 00002 3715 20	epp5 	pr7|2,*
002002  aa  6 00172 6515 00	spri5	pr6|122
002003  aa  7 00010 3535 20	epp3 	pr7|8,*
002004  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 180
	call setup ();

002005  aa   002247 6700 04	tsp4 	1191,ic		004254
						STATEMENT 1 ON LINE 182
	code = 0;

002006  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 183
	chain_ptr = P_chain_ptr;

002007  aa  6 00032 3735 20	epp7 	pr6|26,*
002010  aa  7 00006 3715 20	epp5 	pr7|6,*		P_chain_ptr
002011  aa  5 00000 3715 20	epp5 	pr5|0,*		P_chain_ptr
002012  aa  6 00122 6515 00	spri5	pr6|82		chain_ptr
						STATEMENT 1 ON LINE 184
	next_block = binary (rel (chain_ptr), 18);

002013  aa  5 00000 6351 00	eaa  	pr5|0		chain_ptr
002014  aa   000066 7730 00	lrl  	54
002015  aa  6 00124 7561 00	stq  	pr6|84		next_block
						STATEMENT 1 ON LINE 186
	do while ((next_block ^= 0) & lap_data.send_output);

002016  aa  6 00124 2361 00	ldq  	pr6|84		next_block
002017  aa   000051 6000 04	tze  	41,ic		002070
002020  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
002021  aa  7 00013 2351 00	lda  	pr7|11		lap_data.send_output
002022  aa   400000 3150 03	cana 	131072,du
002023  aa   000045 6000 04	tze  	37,ic		002070
						STATEMENT 1 ON LINE 187
	     blockp = pointer (chain_ptr, next_block);

002024  aa  6 00122 3521 20	epp2 	pr6|82,*		chain_ptr
002025  aa   000000 3120 06	eawp2	0,ql
002026  aa  6 00156 2521 00	spri2	pr6|110		blockp
						STATEMENT 1 ON LINE 195
	     frame_end = search (substr (string (buffer.chars), 1, buffer.tally), substr (collate9 (), 257, 256));

002027  aa  2 00000 2361 00	ldq  	pr2|0		buffer.tally
002030  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002031  aa  2 00001 3521 00	epp2 	pr2|1
002032  aa   777060 3514 04	epp1 	-464,ic		001112 = 400401402403
002033  aa   000400 2350 07	lda  	256,dl
002034  aa  6 00365 7561 00	stq  	pr6|245		buffer.tally
002035  aa  0 01245 7001 00	tsx0 	pr0|677		search_eis
002036  aa  6 00125 7561 00	stq  	pr6|85		frame_end
						STATEMENT 1 ON LINE 197
	     if frame_end = 0 then do;

002037  aa   000006 6010 04	tnz  	6,ic		002045
						STATEMENT 1 ON LINE 198
		next_block = buffer.next;

002040  aa  6 00156 2351 20	lda  	pr6|110,*		buffer.next
002041  aa   000066 7730 00	lrl  	54
002042  aa  6 00124 7561 00	stq  	pr6|84		next_block
						STATEMENT 1 ON LINE 199
		call add_buffer_to_frame ();

002043  aa   001437 6700 04	tsp4 	799,ic		003502
						STATEMENT 1 ON LINE 200
		end;

002044  aa   000017 7100 04	tra  	15,ic		002063
						STATEMENT 1 ON LINE 202
	     else if frame_end = buffer.tally then do;

002045  aa  6 00365 1161 00	cmpq 	pr6|245		buffer.tally
002046  aa   000010 6010 04	tnz  	8,ic		002056
						STATEMENT 1 ON LINE 203
		next_block = buffer.next;

002047  aa  6 00156 2351 20	lda  	pr6|110,*		buffer.next
002050  aa   000066 7730 00	lrl  	54
002051  aa  6 00124 7561 00	stq  	pr6|84		next_block
						STATEMENT 1 ON LINE 204
		lap_data.frame_ready = "1"b;

002052  aa   400000 2350 03	lda  	131072,du
002053  aa  7 00027 7551 00	sta  	pr7|23		lap_data.frame_ready
						STATEMENT 1 ON LINE 205
		call add_buffer_to_frame ();

002054  aa   001426 6700 04	tsp4 	790,ic		003502
						STATEMENT 1 ON LINE 206
		end;

002055  aa   000006 7100 04	tra  	6,ic		002063
						STATEMENT 1 ON LINE 208
	     else do;

						STATEMENT 1 ON LINE 209
		call split_buffer ();

002056  aa   001513 6700 04	tsp4 	843,ic		003571
						STATEMENT 1 ON LINE 210
		lap_data.frame_ready = "1"b;

002057  aa   400000 2350 03	lda  	131072,du
002060  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
002061  aa  7 00027 7551 00	sta  	pr7|23		lap_data.frame_ready
						STATEMENT 1 ON LINE 211
		call add_buffer_to_frame ();

002062  aa   001420 6700 04	tsp4 	784,ic		003502
						STATEMENT 1 ON LINE 212
		end;

						STATEMENT 1 ON LINE 214
	     if lap_data.frame_ready then call write_frame ();

002063  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
002064  aa  7 00027 2351 00	lda  	pr7|23		lap_data.frame_ready
002065  aa   777731 6000 04	tze  	-39,ic		002016
002066  aa   001600 6700 04	tsp4 	896,ic		003666
						STATEMENT 1 ON LINE 215
	end;

002067  aa   777727 7100 04	tra  	-41,ic		002016
						STATEMENT 1 ON LINE 217
WRITE_FINISHES:
	if (next_block = 0)
	then P_chain_ptr = null ();

002070  aa  6 00124 2361 00	ldq  	pr6|84		next_block
002071  aa   000005 6010 04	tnz  	5,ic		002076
002072  aa   776504 2370 04	ldaq 	-700,ic		000576 = 077777000043 000001000000
002073  aa  6 00032 3735 20	epp7 	pr6|26,*
002074  aa  7 00006 7571 20	staq 	pr7|6,*		P_chain_ptr
002075  aa   000005 7100 04	tra  	5,ic		002102
						STATEMENT 1 ON LINE 220
	else P_chain_ptr = pointer (chain_ptr, next_block);

002076  aa  6 00122 3521 20	epp2 	pr6|82,*		chain_ptr
002077  aa   000000 3120 06	eawp2	0,ql
002100  aa  6 00032 3735 20	epp7 	pr6|26,*
002101  aa  7 00006 2521 20	spri2	pr7|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 222
	if lap_data.send_output then call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, ""b);

002102  aa  6 00142 3715 20	epp5 	pr6|98,*		lap_data_ptr
002103  aa  5 00013 2351 00	lda  	pr5|11		lap_data.send_output
002104  aa   400000 3150 03	cana 	131072,du
002105  aa   000016 6000 04	tze  	14,ic		002123
002106  aa   776472 2370 04	ldaq 	-710,ic		000600 = 000000000000 000000000000
002107  aa  6 00326 7571 00	staq 	pr6|214
002110  aa  5 00011 3521 00	epp2 	pr5|9		lap_data.subchannel
002111  aa  6 00264 2521 00	spri2	pr6|180
002112  aa   776442 3520 04	epp2 	-734,ic		000554 = 000000000004
002113  aa  6 00266 2521 00	spri2	pr6|182
002114  aa  6 00326 3521 00	epp2 	pr6|214
002115  aa  6 00270 2521 00	spri2	pr6|184
002116  aa  6 00262 6211 00	eax1 	pr6|178
002117  aa   014000 4310 07	fld  	6144,dl
002120  aa  6 00044 3701 20	epp4 	pr6|36,*
002121  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
002122  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 224
	P_code = code;

002123  aa  6 00100 2361 00	ldq  	pr6|64		code
002124  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 225
	return;

002125  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$control                                STATEMENT 1 ON LINE 347
lap_simplex$control:
     entry (P_lap_data_ptr, P_subchan_idx, P_order, P_info_ptr, P_code);

002126  at     000005000562
002127  tt     000564000560
002130  tt     000562000555
002131  ta     002126000000
002132  da     000317300000
002133  aa   000700 6270 00	eax7 	448
002134  aa  7 00034 3521 20	epp2 	pr7|28,*
002135  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002136  aa     000012000000
002137  aa     000000000000
002140  aa  6 00032 3735 20	epp7 	pr6|26,*
002141  aa  7 00002 3715 20	epp5 	pr7|2,*
002142  aa  6 00172 6515 00	spri5	pr6|122
002143  aa  7 00006 3535 20	epp3 	pr7|6,*
002144  aa  6 00170 2535 00	spri3	pr6|120
002145  aa  6 00042 3515 20	epp1 	pr6|34,*
002146  aa  1 00004 3715 20	epp5 	pr1|4,*
002147  aa  6 00166 6515 00	spri5	pr6|118
002150  aa  7 00010 3535 20	epp3 	pr7|8,*
002151  aa  6 00164 2535 00	spri3	pr6|116
002152  aa  7 00012 3515 20	epp1 	pr7|10,*
002153  aa  6 00174 2515 00	spri1	pr6|124
						STATEMENT 1 ON LINE 350
	call setup ();

002154  aa   002100 6700 04	tsp4 	1088,ic		004254
						STATEMENT 1 ON LINE 352
	order = P_order;

002155  aa  6 00166 2361 20	ldq  	pr6|118,*
002156  aa   000002 6040 04	tmi  	2,ic		002160
002157  aa   777777 3760 07	anq  	262143,dl
002160  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002161  aa  6 00170 3735 20	epp7 	pr6|120,*
002162  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002163  aa  7 00000 00 0006	desc9a	pr7|0,ql		P_order
002164  aa  6 00106 00 0040	desc9a	pr6|70,32		order
						STATEMENT 1 ON LINE 353
	info_ptr = P_info_ptr;

002165  aa  6 00164 3715 20	epp5 	pr6|116,*		P_info_ptr
002166  aa  5 00000 3715 20	epp5 	pr5|0,*		P_info_ptr
002167  aa  6 00104 6515 00	spri5	pr6|68		info_ptr
						STATEMENT 1 ON LINE 354
	code = 0;

002170  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 356
	if (order = "hangup") then do;

002171  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002172  aa  6 00106 00 0040	desc9a	pr6|70,32		order
002173  aa   776403 00 0006	desc9a	-765,6		000574 = 150141156147
002174  aa   000042 6010 04	tnz  	34,ic		002236
						STATEMENT 1 ON LINE 357
	     if (lap_data.state = LAP_HUNGUP)
	     then code = error_table_$invalid_state;

002175  aa  6 00142 3535 20	epp3 	pr6|98,*		lap_data_ptr
002176  aa  3 00012 2361 00	ldq  	pr3|10		lap_data.state
002177  aa   000005 6010 04	tnz  	5,ic		002204
002200  aa  6 00044 3701 20	epp4 	pr6|36,*
002201  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$invalid_state
002202  aa  6 00100 7561 00	stq  	pr6|64		code
002203  aa   000234 7100 04	tra  	156,ic		002437
						STATEMENT 1 ON LINE 359
	     else call channel_manager$control (lap_data.devx, "hangup", null (), code);

002204  aa   776370 2370 04	ldaq 	-776,ic		000574 = 150141156147 165160000000
002205  aa  6 00326 7571 00	staq 	pr6|214
002206  aa   776370 3514 24	epp1 	-776,ic*
002207  aa  6 00432 2515 00	spri1	pr6|282
002210  aa  3 00010 3521 00	epp2 	pr3|8		lap_data.devx
002211  aa  6 00302 2521 00	spri2	pr6|194
002212  aa  6 00326 3521 00	epp2 	pr6|214
002213  aa  6 00304 2521 00	spri2	pr6|196
002214  aa  6 00432 3521 00	epp2 	pr6|282
002215  aa  6 00306 2521 00	spri2	pr6|198
002216  aa  6 00100 3521 00	epp2 	pr6|64		code
002217  aa  6 00310 2521 00	spri2	pr6|200
002220  aa   776344 3520 04	epp2 	-796,ic		000564 = 404000000021
002221  aa  6 00312 2521 00	spri2	pr6|202
002222  aa   776323 3520 04	epp2 	-813,ic		000545 = 524000000006
002223  aa  6 00314 2521 00	spri2	pr6|204
002224  aa   776336 3520 04	epp2 	-802,ic		000562 = 464000000000
002225  aa  6 00316 2521 00	spri2	pr6|206
002226  aa   776327 3520 04	epp2 	-809,ic		000555 = 404000000043
002227  aa  6 00320 2521 00	spri2	pr6|208
002230  aa  6 00300 6211 00	eax1 	pr6|192
002231  aa   020000 4310 07	fld  	8192,dl
002232  aa  6 00044 3701 20	epp4 	pr6|36,*
002233  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
002234  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 360
	     end;

002235  aa   000202 7100 04	tra  	130,ic		002437
						STATEMENT 1 ON LINE 362
	else if (order = "listen") then do;

002236  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002237  aa  6 00106 00 0040	desc9a	pr6|70,32		order
002240  aa   776334 00 0006	desc9a	-804,6		000572 = 154151163164
002241  aa   000046 6010 04	tnz  	38,ic		002307
						STATEMENT 1 ON LINE 363
	     if (lap_data.state ^= LAP_ACTIVE)
	     then code = error_table_$invalid_state;

002242  aa  6 00142 3535 20	epp3 	pr6|98,*		lap_data_ptr
002243  aa  3 00012 2361 00	ldq  	pr3|10		lap_data.state
002244  aa   000002 1160 07	cmpq 	2,dl
002245  aa   000005 6000 04	tze  	5,ic		002252
002246  aa  6 00044 3701 20	epp4 	pr6|36,*
002247  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$invalid_state
002250  aa  6 00100 7561 00	stq  	pr6|64		code
002251  aa   000166 7100 04	tra  	118,ic		002437
						STATEMENT 1 ON LINE 365
	     else do;

						STATEMENT 1 ON LINE 366
		call channel_manager$interrupt (lap_data.subchannel, DIALUP, unspec (lap_data.sc_dialup_info));

002252  aa  3 00024 2351 00	lda  	pr3|20
002253  aa  3 00025 2361 00	ldq  	pr3|21
002254  aa  6 00432 7571 00	staq 	pr6|282
002255  aa  3 00011 3521 00	epp2 	pr3|9		lap_data.subchannel
002256  aa  6 00264 2521 00	spri2	pr6|180
002257  aa   776304 3520 04	epp2 	-828,ic		000563 = 000000000001
002260  aa  6 00266 2521 00	spri2	pr6|182
002261  aa  6 00432 3521 00	epp2 	pr6|282
002262  aa  6 00270 2521 00	spri2	pr6|184
002263  aa  6 00262 6211 00	eax1 	pr6|178
002264  aa   014000 4310 07	fld  	6144,dl
002265  aa  6 00044 3701 20	epp4 	pr6|36,*
002266  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
002267  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 367
		call channel_manager$interrupt (lap_data.subchannel, SEND_OUTPUT, ""b);

002270  aa   776310 2370 04	ldaq 	-824,ic		000600 = 000000000000 000000000000
002271  aa  6 00432 7571 00	staq 	pr6|282
002272  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
002273  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
002274  aa  6 00264 2521 00	spri2	pr6|180
002275  aa   776257 3520 04	epp2 	-849,ic		000554 = 000000000004
002276  aa  6 00266 2521 00	spri2	pr6|182
002277  aa  6 00432 3521 00	epp2 	pr6|282
002300  aa  6 00270 2521 00	spri2	pr6|184
002301  aa  6 00262 6211 00	eax1 	pr6|178
002302  aa   014000 4310 07	fld  	6144,dl
002303  aa  6 00044 3701 20	epp4 	pr6|36,*
002304  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
002305  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 368
		end;

						STATEMENT 1 ON LINE 369
	     end;

002306  aa   000131 7100 04	tra  	89,ic		002437
						STATEMENT 1 ON LINE 371
	else if (order = "abort") then do;

002307  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002310  aa  6 00106 00 0040	desc9a	pr6|70,32		order
002311  aa   776261 00 0005	desc9a	-847,5		000570 = 141142157162
002312  aa   000013 6010 04	tnz  	11,ic		002325
						STATEMENT 1 ON LINE 372
	     if (info_ptr = null ())
	     then code = error_table_$null_info_ptr;

002313  aa  6 00104 2371 00	ldaq 	pr6|68		info_ptr
002314  aa   776262 6770 04	eraq 	-846,ic		000576 = 077777000043 000001000000
002315  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002316  aa   000005 6010 04	tnz  	5,ic		002323
002317  aa  6 00044 3701 20	epp4 	pr6|36,*
002320  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$null_info_ptr
002321  aa  6 00100 7561 00	stq  	pr6|64		code
002322  aa   000115 7100 04	tra  	77,ic		002437
						STATEMENT 1 ON LINE 374
	     else call free_pending_frame ();

002323  aa   002045 6700 04	tsp4 	1061,ic		004370
						STATEMENT 1 ON LINE 375
	     end;

002324  aa   000113 7100 04	tra  	75,ic		002437
						STATEMENT 1 ON LINE 377
	else if (order = "write_status") then do;

002325  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002326  aa  6 00106 00 0040	desc9a	pr6|70,32		order
002327  aa   776270 00 0014	desc9a	-840,12		000615 = 167162151164
002330  aa   000052 6010 04	tnz  	42,ic		002402
						STATEMENT 1 ON LINE 378
	     if (info_ptr = null ())
	     then code = error_table_$null_info_ptr;

002331  aa  6 00104 2371 00	ldaq 	pr6|68		info_ptr
002332  aa   776244 6770 04	eraq 	-860,ic		000576 = 077777000043 000001000000
002333  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002334  aa   000005 6010 04	tnz  	5,ic		002341
002335  aa  6 00044 3701 20	epp4 	pr6|36,*
002336  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$null_info_ptr
002337  aa  6 00100 7561 00	stq  	pr6|64		code
002340  aa   000077 7100 04	tra  	63,ic		002437
						STATEMENT 1 ON LINE 380
	     else do;

						STATEMENT 1 ON LINE 381
		if (lap_data.frame_size ^= 0)
		then info_ptr -> tty_write_status_info.output_pending = "1"b;

002341  aa  6 00142 3535 20	epp3 	pr6|98,*		lap_data_ptr
002342  aa  3 00030 2361 00	ldq  	pr3|24		lap_data.frame_size
002343  aa   000004 6000 04	tze  	4,ic		002347
002344  aa   400000 2350 03	lda  	131072,du
002345  aa  5 00002 7551 00	sta  	pr5|2		tty_write_status_info.output_pending
002346  aa   000071 7100 04	tra  	57,ic		002437
						STATEMENT 1 ON LINE 383
		else call channel_manager$control (lap_data.devx, "write_status", info_ptr, code);

002347  aa   776246 2350 04	lda  	-858,ic		000615 = 167162151164
002350  aa   776246 2360 04	ldq  	-858,ic		000616 = 145137163164
002351  aa  6 00262 7571 00	staq 	pr6|178
002352  aa   776245 2350 04	lda  	-859,ic		000617 = 141164165163
002353  aa  6 00264 7551 00	sta  	pr6|180
002354  aa  3 00010 3521 00	epp2 	pr3|8		lap_data.devx
002355  aa  6 00302 2521 00	spri2	pr6|194
002356  aa  6 00262 3521 00	epp2 	pr6|178
002357  aa  6 00304 2521 00	spri2	pr6|196
002360  aa  6 00104 3521 00	epp2 	pr6|68		info_ptr
002361  aa  6 00306 2521 00	spri2	pr6|198
002362  aa  6 00100 3521 00	epp2 	pr6|64		code
002363  aa  6 00310 2521 00	spri2	pr6|200
002364  aa   776200 3520 04	epp2 	-896,ic		000564 = 404000000021
002365  aa  6 00312 2521 00	spri2	pr6|202
002366  aa   776156 3520 04	epp2 	-914,ic		000544 = 524000000014
002367  aa  6 00314 2521 00	spri2	pr6|204
002370  aa   776172 3520 04	epp2 	-902,ic		000562 = 464000000000
002371  aa  6 00316 2521 00	spri2	pr6|206
002372  aa   776163 3520 04	epp2 	-909,ic		000555 = 404000000043
002373  aa  6 00320 2521 00	spri2	pr6|208
002374  aa  6 00300 6211 00	eax1 	pr6|192
002375  aa   020000 4310 07	fld  	8192,dl
002376  aa  6 00044 3701 20	epp4 	pr6|36,*
002377  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
002400  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 384
		end;

						STATEMENT 1 ON LINE 385
	     end;

002401  aa   000036 7100 04	tra  	30,ic		002437
						STATEMENT 1 ON LINE 387
	else if (order = "wru") then do;

002402  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002403  aa  6 00106 00 0040	desc9a	pr6|70,32		order
002404  aa   776141 00 0003	desc9a	-927,3		000543 = 167162165000
002405  aa   000027 6010 04	tnz  	23,ic		002434
						STATEMENT 1 ON LINE 388
	     if (lap_data.state ^= LAP_ACTIVE)
	     then code = error_table_$invalid_state;

002406  aa  6 00142 3535 20	epp3 	pr6|98,*		lap_data_ptr
002407  aa  3 00012 2361 00	ldq  	pr3|10		lap_data.state
002410  aa   000002 1160 07	cmpq 	2,dl
002411  aa   000005 6000 04	tze  	5,ic		002416
002412  aa  6 00044 3701 20	epp4 	pr6|36,*
002413  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$invalid_state
002414  aa  6 00100 7561 00	stq  	pr6|64		code
002415  aa   000022 7100 04	tra  	18,ic		002437
						STATEMENT 1 ON LINE 390
	     else call channel_manager$interrupt (lap_data.subchannel, WRU_TIMEOUT, ""b);

002416  aa   776162 2370 04	ldaq 	-910,ic		000600 = 000000000000 000000000000
002417  aa  6 00432 7571 00	staq 	pr6|282
002420  aa  3 00011 3521 00	epp2 	pr3|9		lap_data.subchannel
002421  aa  6 00264 2521 00	spri2	pr6|180
002422  aa   775377 3520 04	epp2 	-1281,ic		000021 = 000000000013
002423  aa  6 00266 2521 00	spri2	pr6|182
002424  aa  6 00432 3521 00	epp2 	pr6|282
002425  aa  6 00270 2521 00	spri2	pr6|184
002426  aa  6 00262 6211 00	eax1 	pr6|178
002427  aa   014000 4310 07	fld  	6144,dl
002430  aa  6 00044 3701 20	epp4 	pr6|36,*
002431  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
002432  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 391
	     end;

002433  aa   000004 7100 04	tra  	4,ic		002437
						STATEMENT 1 ON LINE 393
	else code = error_table_$undefined_order_request;

002434  aa  6 00044 3701 20	epp4 	pr6|36,*
002435  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$undefined_order_request
002436  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 395
	P_code = code;

002437  aa  6 00100 2361 00	ldq  	pr6|64		code
002440  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 396
	return;

002441  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$check_modes                            STATEMENT 1 ON LINE 400
lap_simplex$check_modes:
     entry (P_lap_data_ptr, P_subchan_idx, P_mcl_info_ptr, P_code);

002442  ta     001766000000
002443  da     000336300000
002444  aa   000700 6270 00	eax7 	448
002445  aa  7 00034 3521 20	epp2 	pr7|28,*
002446  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002447  aa     000010000000
002450  aa     000000000000
002451  aa  6 00032 3735 20	epp7 	pr6|26,*
002452  aa  7 00002 3715 20	epp5 	pr7|2,*
002453  aa  6 00172 6515 00	spri5	pr6|122
002454  aa  7 00010 3535 20	epp3 	pr7|8,*
002455  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 403
	call do_modes ("0"b);

002456  aa   000000 2350 07	lda  	0,dl
002457  aa  6 00365 7551 00	sta  	pr6|245
002460  aa   001754 3520 04	epp2 	1004,ic		004434 = 000002000000
002461  aa   001461 6700 04	tsp4 	817,ic		004142
						STATEMENT 1 ON LINE 404
	return;

002462  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$set_modes                              STATEMENT 1 ON LINE 408
lap_simplex$set_modes:
     entry (P_lap_data_ptr, P_subchan_idx, P_mcl_info_ptr, P_code);

002463  ta     001766000000
002464  da     000355300000
002465  aa   000700 6270 00	eax7 	448
002466  aa  7 00034 3521 20	epp2 	pr7|28,*
002467  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002470  aa     000010000000
002471  aa     000000000000
002472  aa  6 00032 3735 20	epp7 	pr6|26,*
002473  aa  7 00002 3715 20	epp5 	pr7|2,*
002474  aa  6 00172 6515 00	spri5	pr6|122
002475  aa  7 00010 3535 20	epp3 	pr7|8,*
002476  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 411
	call do_modes ("1"b);

002477  aa   400000 2350 03	lda  	131072,du
002500  aa  6 00365 7551 00	sta  	pr6|245
002501  aa   001733 3520 04	epp2 	987,ic		004434 = 000002000000
002502  aa   001440 6700 04	tsp4 	800,ic		004142
						STATEMENT 1 ON LINE 412
	return;

002503  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$get_modes                              STATEMENT 1 ON LINE 416
lap_simplex$get_modes:
     entry (P_lap_data_ptr, P_subchan_idx, P_modes, P_code);

002504  at     000004000562
002505  tt     000564000560
002506  ta     000555000000
002507  ta     002504000000
002510  da     000374300000
002511  aa   000700 6270 00	eax7 	448
002512  aa  7 00034 3521 20	epp2 	pr7|28,*
002513  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002514  aa     000010000000
002515  aa     000000000000
002516  aa  6 00042 3735 20	epp7 	pr6|34,*
002517  aa  7 00004 2361 20	ldq  	pr7|4,*
002520  aa   000002 6040 04	tmi  	2,ic		002522
002521  aa   777777 3760 07	anq  	262143,dl
002522  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002523  aa  6 00434 7561 00	stq  	pr6|284
002524  aa  6 00032 3715 20	epp5 	pr6|26,*
002525  aa  5 00002 3535 20	epp3 	pr5|2,*
002526  aa  6 00172 2535 00	spri3	pr6|122
002527  aa  5 00010 3515 20	epp1 	pr5|8,*
002530  aa  6 00174 2515 00	spri1	pr6|124
						STATEMENT 1 ON LINE 419
	call setup ();

002531  aa   001523 6700 04	tsp4 	851,ic		004254
						STATEMENT 1 ON LINE 420
	P_code = 0;

002532  aa  6 00174 4501 20	stz  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 421
	P_modes = "";

002533  aa  6 00032 3735 20	epp7 	pr6|26,*
002534  aa  7 00006 3715 20	epp5 	pr7|6,*
002535  aa  6 00434 2351 00	lda  	pr6|284
002536  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
002537  aa   000000 00 0000	desc9a	0,0
002540  aa  5 00000 00 0005	desc9a	pr5|0,al		P_modes
						STATEMENT 1 ON LINE 422
	return;

002541  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 482
SETUP_RETURNS_FOR_ERROR:
	return;

002542  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$init_multiplexer                       STATEMENT 1 ON LINE 533
lap_simplex$init_multiplexer:
     entry (P_devx, P_miip, P_lap_data_ptr, P_code);

002543  at     000004000564
002544  tt     000562000562
002545  ta     000555000000
002546  ta     002543000000
002547  da     000417300000
002550  aa   000700 6270 00	eax7 	448
002551  aa  7 00034 3521 20	epp2 	pr7|28,*
002552  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002553  aa     000010000000
002554  aa     000000000000
002555  aa  6 00032 3735 20	epp7 	pr6|26,*
002556  aa  7 00006 3715 20	epp5 	pr7|6,*
002557  aa  6 00172 6515 00	spri5	pr6|122
002560  aa  7 00010 3535 20	epp3 	pr7|8,*
002561  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 536
	devx = P_devx;

002562  aa  6 00032 3735 20	epp7 	pr6|26,*
002563  aa  7 00002 2361 20	ldq  	pr7|2,*		P_devx
002564  aa  6 00102 7561 00	stq  	pr6|66		devx
						STATEMENT 1 ON LINE 537
	miip = P_miip;

002565  aa  7 00004 3715 20	epp5 	pr7|4,*		P_miip
002566  aa  5 00000 3715 20	epp5 	pr5|0,*		P_miip
002567  aa  6 00144 6515 00	spri5	pr6|100		miip
						STATEMENT 1 ON LINE 538
	P_lap_data_ptr = null ();

002570  aa   776006 2370 04	ldaq 	-1018,ic		000576 = 077777000043 000001000000
002571  aa  6 00172 7571 20	staq 	pr6|122,*		P_lap_data_ptr
						STATEMENT 1 ON LINE 540
	if ^init_sw then do;

002572  aa  6 00044 3701 20	epp4 	pr6|36,*
002573  ia  4 00010 2351 00	lda  	pr4|8		init_sw
002574  aa   000010 6010 04	tnz  	8,ic		002604
						STATEMENT 1 ON LINE 541
	     call wire_proc$wire_me;

002575  aa  6 00056 6211 00	eax1 	pr6|46
002576  aa   000000 4310 07	fld  	0,dl
002577  la  4 00020 3521 20	epp2 	pr4|16,*		wire_proc$wire_me
002600  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 542
	     init_sw = "1"b;

002601  aa   400000 2350 03	lda  	131072,du
002602  aa  6 00044 3701 20	epp4 	pr6|36,*
002603  ia  4 00010 7551 00	sta  	pr4|8		init_sw
						STATEMENT 1 ON LINE 543
	     end;

						STATEMENT 1 ON LINE 545
	lap_data_ptr = null ();

002604  aa   775772 2370 04	ldaq 	-1030,ic		000576 = 077777000043 000001000000
002605  aa  6 00142 7571 00	staq 	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 546
	on cleanup
	     begin;

002606  aa   000007 7260 07	lxl6 	7,dl
002607  aa   775773 3520 04	epp2 	-1029,ic		000602 = 143154145141
002610  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
002611  aa   000004 7100 04	tra  	4,ic		002615
002612  aa     000132000000
002613  aa   000027 7100 04	tra  	23,ic		002642
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 546
	on cleanup
	     begin;

002614  da     000425200000
002615  aa   000120 6270 00	eax7 	80
002616  aa  7 00034 3521 20	epp2 	pr7|28,*
002617  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
002620  aa     000000000000
002621  aa     000000000000
						STATEMENT 1 ON LINE 548
	     if lap_data_ptr ^= null () then call tty_space_man$free_space (size (lap_data), lap_data_ptr);

002622  aa  6 00040 3735 20	epp7 	pr6|32,*
002623  aa  7 00142 2371 00	ldaq 	pr7|98		lap_data_ptr
002624  aa   775752 6770 04	eraq 	-1046,ic		000576 = 077777000043 000001000000
002625  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002626  aa   000013 6000 04	tze  	11,ic		002641
002627  aa   000036 2360 07	ldq  	30,dl
002630  aa  6 00100 7561 00	stq  	pr6|64
002631  aa  6 00100 3521 00	epp2 	pr6|64
002632  aa  6 00104 2521 00	spri2	pr6|68
002633  aa  7 00142 3521 00	epp2 	pr7|98		lap_data_ptr
002634  aa  6 00106 2521 00	spri2	pr6|70
002635  aa  6 00102 6211 00	eax1 	pr6|66
002636  aa   010000 4310 07	fld  	4096,dl
002637  la  4 00054 3521 20	epp2 	pr4|44,*		tty_space_man$free_space
002640  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 549
	end;

002641  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 551
	call tty_space_man$get_space (size (lap_data), lap_data_ptr);

002642  aa   000036 2360 07	ldq  	30,dl
002643  aa  6 00365 7561 00	stq  	pr6|245
002644  aa  6 00365 3521 00	epp2 	pr6|245
002645  aa  6 00264 2521 00	spri2	pr6|180
002646  aa  6 00142 3521 00	epp2 	pr6|98		lap_data_ptr
002647  aa  6 00266 2521 00	spri2	pr6|182
002650  aa  6 00262 6211 00	eax1 	pr6|178
002651  aa   010000 4310 07	fld  	4096,dl
002652  aa  6 00044 3701 20	epp4 	pr6|36,*
002653  la  4 00052 3521 20	epp2 	pr4|42,*		tty_space_man$get_space
002654  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 552
	if lap_data_ptr = null () then do;

002655  aa  6 00142 2371 00	ldaq 	pr6|98		lap_data_ptr
002656  aa   775720 6770 04	eraq 	-1072,ic		000576 = 077777000043 000001000000
002657  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002660  aa   000005 6010 04	tnz  	5,ic		002665
						STATEMENT 1 ON LINE 553
	     P_code = error_table_$noalloc;

002661  aa  6 00044 3701 20	epp4 	pr6|36,*
002662  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$noalloc
002663  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 554
	     return;

002664  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 555
	     end;

						STATEMENT 1 ON LINE 557
	lap_data.name = reverse (after (reverse (mux_init_info.channels (1).name), "."));

002665  aa   000040 2360 07	ldq  	32,dl
002666  aa  6 00144 3735 20	epp7 	pr6|100,*		miip
002667  aa  7 00001 3521 00	epp2 	pr7|1		mux_init_info.name
002670  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
002671  aa  0 01144 7001 00	tsx0 	pr0|612		reverse_cs
002672  aa  6 00050 3715 20	epp5 	pr6|40,*
002673  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002674  aa  5 00000 00 0040	desc9a	pr5|0,32
002675  aa  6 00262 00 0040	desc9a	pr6|178,32
002676  aa  000 003 124 500	scm  	(pr),(du),mask(000)
002677  aa  6 00262 00 0040	desc9a	pr6|178,32
002700  aa   056000 00 0001	desc9a	23552,1
002701  aa  6 00056 0001 00	arg  	pr6|46
002702  aa  6 00056 2361 00	ldq  	pr6|46
002703  aa   000002 6064 04	ttn  	2,ic		002705
002704  aa   000001 0760 07	adq  	1,dl
002705  aa  6 00365 7561 00	stq  	pr6|245
002706  aa   000040 2360 07	ldq  	32,dl
002707  aa  6 00365 1761 00	sbq  	pr6|245
002710  aa  6 00365 2351 00	lda  	pr6|245
002711  aa  6 00262 3521 00	epp2 	pr6|178
002712  aa  2 00000 5005 05	a9bd 	pr2|0,al
002713  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
002714  aa  6 00365 7561 00	stq  	pr6|245
002715  aa  0 01144 7001 00	tsx0 	pr0|612		reverse_cs
002716  aa  6 00142 3535 20	epp3 	pr6|98,*		lap_data_ptr
002717  aa  6 00050 3515 20	epp1 	pr6|40,*
002720  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002721  aa  1 00000 00 0006	desc9a	pr1|0,ql
002722  aa  3 00000 00 0040	desc9a	pr3|0,32		lap_data.name
						STATEMENT 1 ON LINE 558
	lap_data.devx = devx;

002723  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002724  aa  6 00102 2361 00	ldq  	pr6|66		devx
002725  aa  3 00010 7561 00	stq  	pr3|8		lap_data.devx
						STATEMENT 1 ON LINE 559
	lap_data.subchannel = mux_init_info.channels (1).devx;

002726  aa  7 00011 2361 00	ldq  	pr7|9		mux_init_info.devx
002727  aa  3 00011 7561 00	stq  	pr3|9		lap_data.subchannel
						STATEMENT 1 ON LINE 560
	lap_data.state = LAP_HUNGUP;

002730  aa   000000 2360 07	ldq  	0,dl
002731  aa  3 00012 7561 00	stq  	pr3|10		lap_data.state
						STATEMENT 1 ON LINE 561
	lap_data.frame_start = null ();

002732  aa   775644 2370 04	ldaq 	-1116,ic		000576 = 077777000043 000001000000
002733  aa  3 00032 7571 00	staq 	pr3|26		lap_data.frame_start
						STATEMENT 1 ON LINE 562
	lap_data.frame_end = null ();

002734  aa  3 00034 7571 00	staq 	pr3|28		lap_data.frame_end
						STATEMENT 1 ON LINE 564
	lctp = tty_buf$lct_ptr;

002735  aa  6 00044 3701 20	epp4 	pr6|36,*
002736  la  4 00042 3515 20	epp1 	pr4|34,*		tty_buf$lct_ptr
002737  aa  1 00000 3515 20	epp1 	pr1|0,*		tty_buf$lct_ptr
002740  aa  6 00146 2515 00	spri1	pr6|102		lctp
						STATEMENT 1 ON LINE 565
	lctep = addr (lct.lcte_array (lap_data.subchannel));

002741  aa  3 00011 2361 00	ldq  	pr3|9		lap_data.subchannel
002742  aa   000005 7360 00	qls  	5
002743  aa  6 00146 3715 20	epp5 	pr6|102,*		lctp
002744  aa  5 77760 3715 06	epp5 	pr5|-16,ql	lct.lcte_array
002745  aa  6 00150 6515 00	spri5	pr6|104		lctep
						STATEMENT 1 ON LINE 566
	lcte.subchannel = 1;

002746  aa   000001 2350 07	lda  	1,dl
002747  aa  5 00003 5511 14	stba 	pr5|3,14		lcte.subchannel
						STATEMENT 1 ON LINE 568
	P_lap_data_ptr = lap_data_ptr;

002750  aa  6 00172 2535 20	spri3	pr6|122,*		P_lap_data_ptr
						STATEMENT 1 ON LINE 569
	P_code = 0;

002751  aa  6 00174 4501 20	stz  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 570
	return;

002752  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$terminate_multiplexe                   STATEMENT 1 ON LINE 576
lap_simplex$terminate_multiplexer:
     entry (P_lap_data_ptr, P_code);

002753  at     000002000562
002754  ta     000555000000
002755  ta     002753000000
002756  da     000452300000
002757  aa   000700 6270 00	eax7 	448
002760  aa  7 00034 3521 20	epp2 	pr7|28,*
002761  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002762  aa     000004000000
002763  aa     000000000000
002764  aa  6 00032 3735 20	epp7 	pr6|26,*
002765  aa  7 00002 3715 20	epp5 	pr7|2,*
002766  aa  6 00172 6515 00	spri5	pr6|122
002767  aa  7 00004 3535 20	epp3 	pr7|4,*
002770  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 579
	lap_data_ptr = P_lap_data_ptr;

002771  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
002772  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
002773  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 580
	call tty_space_man$free_space (currentsize (lap_data), lap_data_ptr);

002774  aa   000036 2360 07	ldq  	30,dl
002775  aa  6 00365 7561 00	stq  	pr6|245
002776  aa  6 00365 3521 00	epp2 	pr6|245
002777  aa  6 00264 2521 00	spri2	pr6|180
003000  aa  6 00142 3521 00	epp2 	pr6|98		lap_data_ptr
003001  aa  6 00266 2521 00	spri2	pr6|182
003002  aa  6 00262 6211 00	eax1 	pr6|178
003003  aa   010000 4310 07	fld  	4096,dl
003004  aa  6 00044 3701 20	epp4 	pr6|36,*
003005  la  4 00054 3521 20	epp2 	pr4|44,*		tty_space_man$free_space
003006  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 582
	P_lap_data_ptr = null ();

003007  aa   775567 2370 04	ldaq 	-1161,ic		000576 = 077777000043 000001000000
003010  aa  6 00172 7571 20	staq 	pr6|122,*		P_lap_data_ptr
						STATEMENT 1 ON LINE 583
	P_code = 0;

003011  aa  6 00174 4501 20	stz  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 584
	return;

003012  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$start                                  STATEMENT 1 ON LINE 590
lap_simplex$start:
     entry (P_lap_data_ptr, P_code);

003013  ta     002753000000
003014  da     000467300000
003015  aa   000700 6270 00	eax7 	448
003016  aa  7 00034 3521 20	epp2 	pr7|28,*
003017  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003020  aa     000004000000
003021  aa     000000000000
003022  aa  6 00032 3735 20	epp7 	pr6|26,*
003023  aa  7 00002 3715 20	epp5 	pr7|2,*
003024  aa  6 00172 6515 00	spri5	pr6|122
003025  aa  7 00004 3535 20	epp3 	pr7|4,*
003026  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 593
	lap_data_ptr = P_lap_data_ptr;

003027  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
003030  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
003031  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 594
	lap_data.simplex_started = "1"b;

003032  aa   200000 2350 03	lda  	65536,du
003033  aa  7 00013 2551 00	orsa 	pr7|11		lap_data.simplex_started
						STATEMENT 1 ON LINE 595
	P_code = 0;

003034  aa  6 00174 4501 20	stz  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 596
	return;

003035  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$stop                                   STATEMENT 1 ON LINE 602
lap_simplex$stop:
     entry (P_lap_data_ptr, P_code);

003036  ta     002753000000
003037  da     000504300000
003040  aa   000700 6270 00	eax7 	448
003041  aa  7 00034 3521 20	epp2 	pr7|28,*
003042  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003043  aa     000004000000
003044  aa     000000000000
003045  aa  6 00032 3735 20	epp7 	pr6|26,*
003046  aa  7 00002 3715 20	epp5 	pr7|2,*
003047  aa  6 00172 6515 00	spri5	pr6|122
003050  aa  7 00004 3535 20	epp3 	pr7|4,*
003051  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 605
	lap_data_ptr = P_lap_data_ptr;

003052  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
003053  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
003054  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 606
	lap_data.simplex_started = "0"b;

003055  aa   001356 2350 04	lda  	750,ic		004433 = 577777777777
003056  aa  7 00013 3551 00	ansa 	pr7|11		lap_data.simplex_started
						STATEMENT 1 ON LINE 607
	P_code = 0;

003057  aa  6 00174 4501 20	stz  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 608
	return;

003060  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$shutdown                               STATEMENT 1 ON LINE 618
lap_simplex$shutdown:
     entry (P_lap_data_ptr, P_code);

003061  ta     002753000000
003062  da     000523300000
003063  aa   000700 6270 00	eax7 	448
003064  aa  7 00034 3521 20	epp2 	pr7|28,*
003065  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003066  aa     000004000000
003067  aa     000000000000
003070  aa  6 00032 3735 20	epp7 	pr6|26,*
003071  aa  7 00002 3715 20	epp5 	pr7|2,*
003072  aa  6 00172 6515 00	spri5	pr6|122
003073  aa  7 00004 3535 20	epp3 	pr7|4,*
003074  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 621
	lap_data_ptr = P_lap_data_ptr;

003075  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
003076  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
003077  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 622
	if (lap_data.state > LAP_HUNGUP) then call channel_manager$control (lap_data.devx, "hangup", null (), code);

003100  aa  7 00012 2361 00	ldq  	pr7|10		lap_data.state
003101  aa   000032 6044 04	tmoz 	26,ic		003133
003102  aa   775472 2370 04	ldaq 	-1222,ic		000574 = 150141156147 165160000000
003103  aa  6 00432 7571 00	staq 	pr6|282
003104  aa   775472 3714 24	epp5 	-1222,ic*
003105  aa  6 00326 6515 00	spri5	pr6|214
003106  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003107  aa  6 00302 2521 00	spri2	pr6|194
003110  aa  6 00432 3521 00	epp2 	pr6|282
003111  aa  6 00304 2521 00	spri2	pr6|196
003112  aa  6 00326 3521 00	epp2 	pr6|214
003113  aa  6 00306 2521 00	spri2	pr6|198
003114  aa  6 00100 3521 00	epp2 	pr6|64		code
003115  aa  6 00310 2521 00	spri2	pr6|200
003116  aa   775446 3520 04	epp2 	-1242,ic		000564 = 404000000021
003117  aa  6 00312 2521 00	spri2	pr6|202
003120  aa   775425 3520 04	epp2 	-1259,ic		000545 = 524000000006
003121  aa  6 00314 2521 00	spri2	pr6|204
003122  aa   775440 3520 04	epp2 	-1248,ic		000562 = 464000000000
003123  aa  6 00316 2521 00	spri2	pr6|206
003124  aa   775431 3520 04	epp2 	-1255,ic		000555 = 404000000043
003125  aa  6 00320 2521 00	spri2	pr6|208
003126  aa  6 00300 6211 00	eax1 	pr6|192
003127  aa   020000 4310 07	fld  	8192,dl
003130  aa  6 00044 3701 20	epp4 	pr6|36,*
003131  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
003132  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 623
	return;

003133  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$priv_control                           STATEMENT 1 ON LINE 629
lap_simplex$priv_control:
     entry (P_lap_data_ptr, P_order, P_info_ptr, P_code);

003134  at     000004000562
003135  tt     000560000562
003136  ta     000555000000
003137  ta     003134000000
003140  da     000544300000
003141  aa   000700 6270 00	eax7 	448
003142  aa  7 00034 3521 20	epp2 	pr7|28,*
003143  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
003144  aa     000010000000
003145  aa     000000000000
003146  aa  6 00032 3735 20	epp7 	pr6|26,*
003147  aa  7 00002 3715 20	epp5 	pr7|2,*
003150  aa  6 00172 6515 00	spri5	pr6|122
003151  aa  7 00004 3535 20	epp3 	pr7|4,*
003152  aa  6 00170 2535 00	spri3	pr6|120
003153  aa  6 00042 3515 20	epp1 	pr6|34,*
003154  aa  1 00002 3715 20	epp5 	pr1|2,*
003155  aa  6 00166 6515 00	spri5	pr6|118
003156  aa  7 00006 3535 20	epp3 	pr7|6,*
003157  aa  6 00164 2535 00	spri3	pr6|116
003160  aa  7 00010 3515 20	epp1 	pr7|8,*
003161  aa  6 00174 2515 00	spri1	pr6|124
						STATEMENT 1 ON LINE 632
	lap_data_ptr = P_lap_data_ptr;

003162  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
003163  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
003164  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 633
	order = P_order;

003165  aa  6 00166 2361 20	ldq  	pr6|118,*
003166  aa   000002 6040 04	tmi  	2,ic		003170
003167  aa   777777 3760 07	anq  	262143,dl
003170  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003171  aa  6 00170 3715 20	epp5 	pr6|120,*
003172  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
003173  aa  5 00000 00 0006	desc9a	pr5|0,ql		P_order
003174  aa  6 00106 00 0040	desc9a	pr6|70,32		order
						STATEMENT 1 ON LINE 634
	P_code = 0;

003175  aa  6 00174 4501 20	stz  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 636
	if /* case */ order = "copy_meters" then do;

003176  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003177  aa  6 00106 00 0040	desc9a	pr6|70,32		order
003200  aa   775414 00 0013	desc9a	-1268,11		000612 = 143157160171
003201  aa   000027 6010 04	tnz  	23,ic		003230
						STATEMENT 1 ON LINE 637
	     call channel_manager$control (lap_data.devx, order, P_info_ptr, P_code);

003202  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003203  aa  6 00302 2521 00	spri2	pr6|194
003204  aa  6 00106 3521 00	epp2 	pr6|70		order
003205  aa  6 00304 2521 00	spri2	pr6|196
003206  aa  6 00164 3521 20	epp2 	pr6|116,*		P_info_ptr
003207  aa  6 00306 2521 00	spri2	pr6|198
003210  aa  6 00174 3521 20	epp2 	pr6|124,*		P_code
003211  aa  6 00310 2521 00	spri2	pr6|200
003212  aa   775352 3520 04	epp2 	-1302,ic		000564 = 404000000021
003213  aa  6 00312 2521 00	spri2	pr6|202
003214  aa   775335 3520 04	epp2 	-1315,ic		000551 = 526000000040
003215  aa  6 00314 2521 00	spri2	pr6|204
003216  aa   775344 3520 04	epp2 	-1308,ic		000562 = 464000000000
003217  aa  6 00316 2521 00	spri2	pr6|206
003220  aa   775335 3520 04	epp2 	-1315,ic		000555 = 404000000043
003221  aa  6 00320 2521 00	spri2	pr6|208
003222  aa  6 00300 6211 00	eax1 	pr6|192
003223  aa   020000 4310 07	fld  	8192,dl
003224  aa  6 00044 3701 20	epp4 	pr6|36,*
003225  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
003226  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 638
	     end;

003227  aa   000036 7100 04	tra  	30,ic		003265
						STATEMENT 1 ON LINE 640
	else if order = "get_meters" then do;

003230  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003231  aa  6 00106 00 0040	desc9a	pr6|70,32		order
003232  aa   775357 00 0012	desc9a	-1297,10		000607 = 147145164137
003233  aa   000027 6010 04	tnz  	23,ic		003262
						STATEMENT 1 ON LINE 641
	     call channel_manager$control (lap_data.devx, order, P_info_ptr, P_code);

003234  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003235  aa  6 00302 2521 00	spri2	pr6|194
003236  aa  6 00106 3521 00	epp2 	pr6|70		order
003237  aa  6 00304 2521 00	spri2	pr6|196
003240  aa  6 00164 3521 20	epp2 	pr6|116,*		P_info_ptr
003241  aa  6 00306 2521 00	spri2	pr6|198
003242  aa  6 00174 3521 20	epp2 	pr6|124,*		P_code
003243  aa  6 00310 2521 00	spri2	pr6|200
003244  aa   775320 3520 04	epp2 	-1328,ic		000564 = 404000000021
003245  aa  6 00312 2521 00	spri2	pr6|202
003246  aa   775303 3520 04	epp2 	-1341,ic		000551 = 526000000040
003247  aa  6 00314 2521 00	spri2	pr6|204
003250  aa   775312 3520 04	epp2 	-1334,ic		000562 = 464000000000
003251  aa  6 00316 2521 00	spri2	pr6|206
003252  aa   775303 3520 04	epp2 	-1341,ic		000555 = 404000000043
003253  aa  6 00320 2521 00	spri2	pr6|208
003254  aa  6 00300 6211 00	eax1 	pr6|192
003255  aa   020000 4310 07	fld  	8192,dl
003256  aa  6 00044 3701 20	epp4 	pr6|36,*
003257  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
003260  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 642
	     end;

003261  aa   000004 7100 04	tra  	4,ic		003265
						STATEMENT 1 ON LINE 644
	else P_code = error_table_$undefined_order_request;

003262  aa  6 00044 3701 20	epp4 	pr6|36,*
003263  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$undefined_order_request
003264  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 646
	return;

003265  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO lap_simplex$hpriv_control                          STATEMENT 1 ON LINE 652
lap_simplex$hpriv_control:
     entry (P_lap_data_ptr, P_order, P_info_ptr, P_code);

003266  ta     003134000000
003267  da     000565300000
003270  aa   000700 6270 00	eax7 	448
003271  aa  7 00034 3521 20	epp2 	pr7|28,*
003272  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
003273  aa     000010000000
003274  aa     000000000000
003275  aa  6 00032 3735 20	epp7 	pr6|26,*
003276  aa  7 00002 3715 20	epp5 	pr7|2,*
003277  aa  6 00172 6515 00	spri5	pr6|122
003300  aa  7 00004 3535 20	epp3 	pr7|4,*
003301  aa  6 00170 2535 00	spri3	pr6|120
003302  aa  6 00042 3515 20	epp1 	pr6|34,*
003303  aa  1 00002 3715 20	epp5 	pr1|2,*
003304  aa  6 00166 6515 00	spri5	pr6|118
003305  aa  7 00006 3535 20	epp3 	pr7|6,*
003306  aa  6 00164 2535 00	spri3	pr6|116
003307  aa  7 00010 3515 20	epp1 	pr7|8,*
003310  aa  6 00174 2515 00	spri1	pr6|124
						STATEMENT 1 ON LINE 655
	lap_data_ptr = P_lap_data_ptr;

003311  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
003312  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
003313  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 656
	order = P_order;

003314  aa  6 00166 2361 20	ldq  	pr6|118,*
003315  aa   000002 6040 04	tmi  	2,ic		003317
003316  aa   777777 3760 07	anq  	262143,dl
003317  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003320  aa  6 00170 3715 20	epp5 	pr6|120,*
003321  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
003322  aa  5 00000 00 0006	desc9a	pr5|0,ql		P_order
003323  aa  6 00106 00 0040	desc9a	pr6|70,32		order
						STATEMENT 1 ON LINE 657
	code = 0;

003324  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 659
	if /* case */ order = "load_mpx" then do;

003325  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003326  aa  6 00106 00 0040	desc9a	pr6|70,32		order
003327  aa   775241 00 0010	desc9a	-1375,8		000566 = 154157141144
003330  aa   000144 6010 04	tnz  	100,ic		003474
						STATEMENT 1 ON LINE 660
	     lap_load_info_ptr = P_info_ptr;

003331  aa  6 00164 3535 20	epp3 	pr6|116,*		P_info_ptr
003332  aa  3 00000 3535 20	epp3 	pr3|0,*		P_info_ptr
003333  aa  6 00140 2535 00	spri3	pr6|96		lap_load_info_ptr
						STATEMENT 1 ON LINE 662
	     if lap_load_info.version ^= LAP_LOAD_INFO_VERSION_1 then do;

003334  aa  3 00000 2351 00	lda  	pr3|0		lap_load_info.version
003335  aa  3 00001 2361 00	ldq  	pr3|1		lap_load_info.version
003336  aa   775166 1170 04	cmpaq	-1418,ic		000524 = 154141160154 157141144061
003337  aa   000005 6000 04	tze  	5,ic		003344
						STATEMENT 1 ON LINE 663
		P_code = error_table_$unimplemented_version;

003340  aa  6 00044 3701 20	epp4 	pr6|36,*
003341  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$unimplemented_version
003342  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 664
		return;

003343  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 665
		end;

						STATEMENT 1 ON LINE 667
	     if lap_data.state > LAP_HUNGUP then do;

003344  aa  7 00012 2361 00	ldq  	pr7|10		lap_data.state
003345  aa   000005 6044 04	tmoz 	5,ic		003352
						STATEMENT 1 ON LINE 668
		P_code = error_table_$action_not_performed;

003346  aa  6 00044 3701 20	epp4 	pr6|36,*
003347  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$action_not_performed
003350  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 669
		return;

003351  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 670
		end;

						STATEMENT 1 ON LINE 672
	     string (lap_data.flags) = ""b;

003352  aa  7 00013 4501 00	stz  	pr7|11
						STATEMENT 1 ON LINE 673
	     lap_data.load_process_id = lap_load_info.process_id;

003353  aa  3 00004 2351 00	lda  	pr3|4		lap_load_info.process_id
003354  aa  7 00014 7551 00	sta  	pr7|12		lap_data.load_process_id
						STATEMENT 1 ON LINE 674
	     lap_data.load_event_channel = lap_load_info.event_channel;

003355  aa  3 00002 2371 00	ldaq 	pr3|2		lap_load_info.event_channel
003356  aa  7 00016 7571 00	staq 	pr7|14		lap_data.load_event_channel
						STATEMENT 1 ON LINE 675
	     lap_data.activate_order = lap_load_info.activate_order;

003357  aa  3 00005 2351 00	lda  	pr3|5		lap_load_info.activate_order
003360  aa  3 00006 2361 00	ldq  	pr3|6		lap_load_info.activate_order
003361  aa  7 00020 7571 00	staq 	pr7|16		lap_data.activate_order
						STATEMENT 1 ON LINE 677
	     lap_data.activate_order.pad = ""b;

003362  aa   001050 2350 04	lda  	552,ic		004432 = 740777777777
003363  aa  7 00020 3551 00	ansa 	pr7|16		lap_data.pad
						STATEMENT 1 ON LINE 678
	     lap_data.activate_order.command = ACTIVATE_COMMAND;

003364  aa   000001 2350 03	lda  	1,du
003365  aa  7 00020 5511 20	stba 	pr7|16,20		lap_data.command
						STATEMENT 1 ON LINE 680
	     lap_data.max_frame_size = divide (lap_data.activate_order.frame_size + 7, 8, 17, 0);

003366  aa  7 00020 2361 00	ldq  	pr7|16		lap_data.frame_size
003367  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003370  aa   000007 0760 07	adq  	7,dl
003371  aa   000010 5060 07	div  	8,dl
003372  aa  7 00026 7561 00	stq  	pr7|22		lap_data.max_frame_size
						STATEMENT 1 ON LINE 682
	     call channel_manager$control (lap_data.devx, "line_control", addr (lap_data.activate_order), code);

003373  aa   775211 2370 04	ldaq 	-1399,ic		000604 = 154151156145 137143157156
003374  aa  6 00262 7571 00	staq 	pr6|178
003375  aa   775211 2350 04	lda  	-1399,ic		000606 = 164162157154
003376  aa  6 00264 7551 00	sta  	pr6|180
003377  aa  7 00020 3515 00	epp1 	pr7|16		lap_data.activate_order
003400  aa  6 00326 2515 00	spri1	pr6|214
003401  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003402  aa  6 00302 2521 00	spri2	pr6|194
003403  aa  6 00262 3521 00	epp2 	pr6|178
003404  aa  6 00304 2521 00	spri2	pr6|196
003405  aa  6 00326 3521 00	epp2 	pr6|214
003406  aa  6 00306 2521 00	spri2	pr6|198
003407  aa  6 00100 3521 00	epp2 	pr6|64		code
003410  aa  6 00310 2521 00	spri2	pr6|200
003411  aa   775153 3520 04	epp2 	-1429,ic		000564 = 404000000021
003412  aa  6 00312 2521 00	spri2	pr6|202
003413  aa   775131 3520 04	epp2 	-1447,ic		000544 = 524000000014
003414  aa  6 00314 2521 00	spri2	pr6|204
003415  aa   775145 3520 04	epp2 	-1435,ic		000562 = 464000000000
003416  aa  6 00316 2521 00	spri2	pr6|206
003417  aa   775136 3520 04	epp2 	-1442,ic		000555 = 404000000043
003420  aa  6 00320 2521 00	spri2	pr6|208
003421  aa  6 00300 6211 00	eax1 	pr6|192
003422  aa   020000 4310 07	fld  	8192,dl
003423  aa  6 00044 3701 20	epp4 	pr6|36,*
003424  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
003425  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 683
	     if code ^= 0 then do;

003426  aa  6 00100 2361 00	ldq  	pr6|64		code
003427  aa   000003 6000 04	tze  	3,ic		003432
						STATEMENT 1 ON LINE 684
		P_code = code;

003430  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 685
		return;

003431  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 686
		end;

						STATEMENT 1 ON LINE 688
	     call channel_manager$control (lap_data.devx, "listen", null (), code);

003432  aa   775140 2370 04	ldaq 	-1440,ic		000572 = 154151163164 145156000000
003433  aa  6 00326 7571 00	staq 	pr6|214
003434  aa   775142 3734 24	epp7 	-1438,ic*
003435  aa  6 00432 6535 00	spri7	pr6|282
003436  aa  6 00142 3715 20	epp5 	pr6|98,*		lap_data_ptr
003437  aa  5 00010 3521 00	epp2 	pr5|8		lap_data.devx
003440  aa  6 00302 2521 00	spri2	pr6|194
003441  aa  6 00326 3521 00	epp2 	pr6|214
003442  aa  6 00304 2521 00	spri2	pr6|196
003443  aa  6 00432 3521 00	epp2 	pr6|282
003444  aa  6 00306 2521 00	spri2	pr6|198
003445  aa  6 00100 3521 00	epp2 	pr6|64		code
003446  aa  6 00310 2521 00	spri2	pr6|200
003447  aa   775115 3520 04	epp2 	-1459,ic		000564 = 404000000021
003450  aa  6 00312 2521 00	spri2	pr6|202
003451  aa   775074 3520 04	epp2 	-1476,ic		000545 = 524000000006
003452  aa  6 00314 2521 00	spri2	pr6|204
003453  aa   775107 3520 04	epp2 	-1465,ic		000562 = 464000000000
003454  aa  6 00316 2521 00	spri2	pr6|206
003455  aa   775100 3520 04	epp2 	-1472,ic		000555 = 404000000043
003456  aa  6 00320 2521 00	spri2	pr6|208
003457  aa  6 00300 6211 00	eax1 	pr6|192
003460  aa   020000 4310 07	fld  	8192,dl
003461  aa  6 00044 3701 20	epp4 	pr6|36,*
003462  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
003463  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 689
	     if code ^= 0 then do;

003464  aa  6 00100 2361 00	ldq  	pr6|64		code
003465  aa   000003 6000 04	tze  	3,ic		003470
						STATEMENT 1 ON LINE 690
		P_code = code;

003466  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 691
		return;

003467  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 692
		end;

						STATEMENT 1 ON LINE 694
	     lap_data.state = LAP_LISTENING;

003470  aa   000001 2360 07	ldq  	1,dl
003471  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003472  aa  7 00012 7561 00	stq  	pr7|10		lap_data.state
						STATEMENT 1 ON LINE 695
	     end;

003473  aa   000004 7100 04	tra  	4,ic		003477
						STATEMENT 1 ON LINE 697
	else code = error_table_$undefined_order_request;

003474  aa  6 00044 3701 20	epp4 	pr6|36,*
003475  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$undefined_order_request
003476  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 699
	P_code = code;

003477  aa  6 00100 2361 00	ldq  	pr6|64		code
003500  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 700
	return;

003501  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 884
     end lap_simplex;

BEGIN PROCEDURE add_buffer_to_frame
ENTRY TO add_buffer_to_frame                                STATEMENT 1 ON LINE 229
add_buffer_to_frame:
     procedure ();

003502  aa  6 00176 6501 00	spri4	pr6|126
						STATEMENT 1 ON LINE 232
	if (buffer.tally + lap_data.frame_size) > lap_data.max_frame_size then do;

003503  aa  6 00156 2361 20	ldq  	pr6|110,*		buffer.tally
003504  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003505  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003506  aa  7 00030 0761 00	adq  	pr7|24		lap_data.frame_size
003507  aa  7 00026 1161 00	cmpq 	pr7|22		lap_data.max_frame_size
003510  aa   000030 6044 04	tmoz 	24,ic		003540
						STATEMENT 1 ON LINE 233
	     call syserr (Log_message, "lap_simplex(^a): Attempt to write overlength frame.", lap_data.name);

003511  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003512  aa   775142 00 0064	desc9a	-1438,52		000653 = 154141160137
003513  aa  6 00436 00 0064	desc9a	pr6|286,52
003514  aa   775040 3520 04	epp2 	-1504,ic		000554 = 000000000004
003515  aa  6 00456 2521 00	spri2	pr6|302
003516  aa  6 00436 3521 00	epp2 	pr6|286
003517  aa  6 00460 2521 00	spri2	pr6|304
003520  aa  7 00000 3521 00	epp2 	pr7|0		lap_data.name
003521  aa  6 00462 2521 00	spri2	pr6|306
003522  aa   775042 3520 04	epp2 	-1502,ic		000564 = 404000000021
003523  aa  6 00464 2521 00	spri2	pr6|308
003524  aa   775016 3520 04	epp2 	-1522,ic		000542 = 524000000063
003525  aa  6 00466 2521 00	spri2	pr6|310
003526  aa   775023 3520 04	epp2 	-1517,ic		000551 = 526000000040
003527  aa  6 00470 2521 00	spri2	pr6|312
003530  aa  6 00454 6211 00	eax1 	pr6|300
003531  aa   014000 4310 07	fld  	6144,dl
003532  aa  6 00044 3701 20	epp4 	pr6|36,*
003533  la  4 00014 3521 20	epp2 	pr4|12,*		syserr
003534  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 234
	     call crash (HANGUP);

003535  aa   000671 3520 04	epp2 	441,ic		004426 = 000002000000
003536  aa   000562 6700 04	tsp4 	370,ic		004320
						STATEMENT 1 ON LINE 235
	     call free_pending_frame ();

003537  aa   000631 6700 04	tsp4 	409,ic		004370
						STATEMENT 1 ON LINE 236
	     end;

						STATEMENT 1 ON LINE 238
	lap_data.frame_size = lap_data.frame_size + buffer.tally;

003540  aa  6 00156 2361 20	ldq  	pr6|110,*		buffer.tally
003541  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003542  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003543  aa  7 00030 0561 00	asq  	pr7|24		lap_data.frame_size
						STATEMENT 1 ON LINE 239
	buffer.next = 0;

003544  aa   000000 2350 07	lda  	0,dl
003545  aa  6 00156 3715 20	epp5 	pr6|110,*		buffer.next
003546  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 240
	string (buffer.flags) = ""b;

003547  aa   000656 2350 04	lda  	430,ic		004425 = 777777007777
003550  aa  6 00156 3551 20	ansa 	pr6|110,*
						STATEMENT 1 ON LINE 242
	if (lap_data.frame_start ^= null ())
	then					/* Add it to the end if there's something there */
	     lap_data.frame_end -> buffer.next = binary (rel (blockp), 18);

003551  aa  7 00032 2371 00	ldaq 	pr7|26		lap_data.frame_start
003552  aa   775024 6770 04	eraq 	-1516,ic		000576 = 077777000043 000001000000
003553  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003554  aa   000007 6000 04	tze  	7,ic		003563
003555  aa  6 00156 6351 20	eaa  	pr6|110,*		blockp
003556  aa   000066 7730 00	lrl  	54
003557  aa   000066 7370 00	lls  	54
003560  aa  7 00034 3535 20	epp3 	pr7|28,*		buffer.next
003561  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
003562  aa   000003 7100 04	tra  	3,ic		003565
						STATEMENT 1 ON LINE 245
	else lap_data.frame_start = blockp;

003563  aa  6 00156 3535 20	epp3 	pr6|110,*		blockp
003564  aa  7 00032 2535 00	spri3	pr7|26		lap_data.frame_start
						STATEMENT 1 ON LINE 247
	lap_data.frame_end = blockp;

003565  aa  6 00156 3735 20	epp7 	pr6|110,*		blockp
003566  aa  6 00142 3535 20	epp3 	pr6|98,*		lap_data_ptr
003567  aa  3 00034 6535 00	spri7	pr3|28		lap_data.frame_end
						STATEMENT 1 ON LINE 249
	return;

003570  aa  6 00176 6101 00	rtcd 	pr6|126
						STATEMENT 1 ON LINE 250
     end add_buffer_to_frame;

  END PROCEDURE add_buffer_to_frame
BEGIN PROCEDURE split_buffer
ENTRY TO split_buffer                                       STATEMENT 1 ON LINE 254
split_buffer:
     procedure ();

003571  aa  6 00204 6501 00	spri4	pr6|132
						STATEMENT 1 ON LINE 267
	leftover_chars = buffer.tally - frame_end;

003572  aa  6 00156 2361 20	ldq  	pr6|110,*		buffer.tally
003573  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003574  aa  6 00125 1761 00	sbq  	pr6|85		frame_end
003575  aa  6 00212 7561 00	stq  	pr6|138		leftover_chars
						STATEMENT 1 ON LINE 269
	new_buf_size = 16 * (1 + divide ((leftover_chars + 7), 64, 17, 0));

003576  aa   000007 0760 07	adq  	7,dl
003577  aa   000100 5060 07	div  	64,dl
003600  aa   000001 0760 07	adq  	1,dl
003601  aa   000004 7360 00	qls  	4
003602  aa  6 00213 7561 00	stq  	pr6|139		new_buf_size
						STATEMENT 1 ON LINE 270
	call tty_space_man$get_buffer (lap_data.subchannel, new_buf_size, OUTPUT, new_bufp);

003603  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003604  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
003605  aa  6 00474 2521 00	spri2	pr6|316
003606  aa  6 00213 3521 00	epp2 	pr6|139		new_buf_size
003607  aa  6 00476 2521 00	spri2	pr6|318
003610  aa   774740 3520 04	epp2 	-1568,ic		000550 = 400000000000
003611  aa  6 00500 2521 00	spri2	pr6|320
003612  aa  6 00214 3521 00	epp2 	pr6|140		new_bufp
003613  aa  6 00502 2521 00	spri2	pr6|322
003614  aa  6 00472 6211 00	eax1 	pr6|314
003615  aa   020000 4310 07	fld  	8192,dl
003616  aa  6 00044 3701 20	epp4 	pr6|36,*
003617  la  4 00056 3521 20	epp2 	pr4|46,*		tty_space_man$get_buffer
003620  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 271
	if (new_bufp = null ()) then do;

003621  aa  6 00214 2371 00	ldaq 	pr6|140		new_bufp
003622  aa   774754 6770 04	eraq 	-1556,ic		000576 = 077777000043 000001000000
003623  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003624  aa   000015 6010 04	tnz  	13,ic		003641
						STATEMENT 1 ON LINE 272
	     call tty_space_man$needs_space (lap_data.devx);

003625  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003626  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003627  aa  6 00474 2521 00	spri2	pr6|316
003630  aa  6 00472 6211 00	eax1 	pr6|314
003631  aa   004000 4310 07	fld  	2048,dl
003632  aa  6 00044 3701 20	epp4 	pr6|36,*
003633  la  4 00064 3521 20	epp2 	pr4|52,*		tty_space_man$needs_space
003634  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 274
	     lap_data.send_output = "0"b;

003635  aa   000567 2350 04	lda  	375,ic		004424 = 377777777777
003636  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003637  aa  7 00013 3551 00	ansa 	pr7|11		lap_data.send_output
						STATEMENT 1 ON LINE 275
	     goto WRITE_FINISHES;

003640  aa   776230 7100 04	tra  	-872,ic		002070
						STATEMENT 1 ON LINE 276
	     end;

						STATEMENT 1 ON LINE 278
	substr (string (new_bufp -> buffer.chars), 1, leftover_chars) =
	     substr (string (buffer.chars), frame_end + 1, leftover_chars);

003641  aa  6 00214 3735 20	epp7 	pr6|140,*		new_bufp
003642  aa  6 00125 7271 00	lxl7 	pr6|85		frame_end
003643  aa  6 00156 3715 20	epp5 	pr6|110,*		blockp
003644  aa  6 00212 7261 00	lxl6 	pr6|138		leftover_chars
003645  aa  040 140 100 557	mlr  	(pr,rl,x7),(pr,rl),fill(040)
003646  aa  5 00001 00 0016	desc9a	pr5|1,x6
003647  aa  7 00001 00 0016	desc9a	pr7|1,x6
						STATEMENT 1 ON LINE 280
	new_bufp -> buffer.next = buffer.next;

003650  aa  5 00000 2351 00	lda  	pr5|0		buffer.next
003651  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 281
	new_bufp -> buffer.tally = leftover_chars;

003652  aa  6 00212 2361 00	ldq  	pr6|138		leftover_chars
003653  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 282
	string (new_bufp -> buffer.flags) = ""b;

003654  aa   000551 2350 04	lda  	361,ic		004425 = 777777007777
003655  aa  7 00000 3551 00	ansa 	pr7|0
						STATEMENT 1 ON LINE 284
	next_block = binary (rel (new_bufp), 18);

003656  aa  7 00000 6351 00	eaa  	pr7|0		new_bufp
003657  aa   000066 7730 00	lrl  	54
003660  aa  6 00124 7561 00	stq  	pr6|84		next_block
						STATEMENT 1 ON LINE 286
	buffer.tally = buffer.tally - leftover_chars;

003661  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
003662  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003663  aa  6 00212 1761 00	sbq  	pr6|138		leftover_chars
003664  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 288
	return;

003665  aa  6 00204 6101 00	rtcd 	pr6|132
						STATEMENT 1 ON LINE 289
     end split_buffer;

  END PROCEDURE split_buffer
BEGIN PROCEDURE write_frame
ENTRY TO write_frame                                        STATEMENT 1 ON LINE 293
write_frame:
     procedure ();

003666  aa  6 00216 6501 00	spri4	pr6|142
						STATEMENT 1 ON LINE 300
	lap_data.frame_end -> buffer.break = "1"b;

003667  aa   100000 2350 07	lda  	32768,dl
003670  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003671  aa  7 00034 2551 20	orsa 	pr7|28,*		buffer.break
						STATEMENT 1 ON LINE 302
	bufp = lap_data.frame_start;

003672  aa  7 00032 3715 20	epp5 	pr7|26,*		lap_data.frame_start
003673  aa  6 00224 6515 00	spri5	pr6|148		bufp
						STATEMENT 1 ON LINE 303
	bufl = bufp -> buffer.tally;

003674  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
003675  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003676  aa  6 00226 7561 00	stq  	pr6|150		bufl
						STATEMENT 1 ON LINE 305
	begin;

003677  aa   000120 6270 00	eax7 	80
003700  aa  0 00614 2721 00	tsp2 	pr0|396		enter_begin_block
003701  aa     000000000000
BEGIN BLOCK  3
PROLOGUE SEQUENCE                                           STATEMENT 1 ON LINE 306
003702  aa  6 00040 3735 20	epp7 	pr6|32,*
003703  aa  7 00226 2361 00	ldq  	pr7|150		bufl
003704  aa  6 00100 7561 00	stq  	pr6|64
003705  aa   000003 0760 07	adq  	3,dl
003706  aa   000002 7320 00	qrs  	2
003707  aa  6 00101 7561 00	stq  	pr6|65
003710  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
003711  aa  6 00102 2521 00	spri2	pr6|66
						STATEMENT 1 ON LINE 307
003712  aa  7 00226 2361 00	ldq  	pr7|150		bufl
003713  aa  6 00104 7561 00	stq  	pr6|68
MAIN SEQUENCE                                               STATEMENT 1 ON LINE 308
	     old_string = substr (string (bufp -> buffer.chars), 1, bufl);

003714  aa  7 00224 3715 20	epp5 	pr7|148,*		bufp
003715  aa  6 00100 2351 00	lda  	pr6|64
003716  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003717  aa  5 00001 00 0006	desc9a	pr5|1,ql
003720  aa  2 00000 00 0005	desc9a	pr2|0,al		old_string
						STATEMENT 1 ON LINE 309
	     new_string = old_string;

003721  aa   000002 2360 07	ldq  	2,dl
003722  aa  6 00104 2351 00	lda  	pr6|68
003723  aa  5 00001 3535 00	epp3 	pr5|1		new_string
003724  aa  3 00000 5005 06	a9bd 	pr3|0,ql
003725  aa  6 00100 2361 00	ldq  	pr6|64
003726  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003727  aa  2 00000 00 0006	desc9a	pr2|0,ql		old_string
003730  aa  3 00000 00 0005	desc9a	pr3|0,al		new_string
						STATEMENT 1 ON LINE 310
	end;

003731  aa  0 00615 7001 00	tsx0 	pr0|397		leave_begin_block
  END BLOCK  3
						STATEMENT 1 ON LINE 312
	bufp -> buffer.tally = bufp -> buffer.tally + L2_HEADER_PAD;

003732  aa  6 00224 2361 20	ldq  	pr6|148,*		buffer.tally
003733  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003734  aa   000002 0760 07	adq  	2,dl
003735  aa  6 00224 3735 20	epp7 	pr6|148,*		buffer.tally
003736  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 316
	call tty_space_man$switch_chain (lap_data.subchannel, lap_data.devx, OUTPUT, OUTPUT, lap_data.frame_start);

003737  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003740  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
003741  aa  6 00506 2521 00	spri2	pr6|326
003742  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003743  aa  6 00510 2521 00	spri2	pr6|328
003744  aa   774604 3520 04	epp2 	-1660,ic		000550 = 400000000000
003745  aa  6 00512 2521 00	spri2	pr6|330
003746  aa  6 00514 2521 00	spri2	pr6|332
003747  aa  7 00032 3521 00	epp2 	pr7|26		lap_data.frame_start
003750  aa  6 00516 2521 00	spri2	pr6|334
003751  aa  6 00504 6211 00	eax1 	pr6|324
003752  aa   024000 4310 07	fld  	10240,dl
003753  aa  6 00044 3701 20	epp4 	pr6|36,*
003754  la  4 00062 3521 20	epp2 	pr4|50,*		tty_space_man$switch_chain
003755  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 318
	call channel_manager$write (lap_data.devx, lap_data.frame_start, code);

003756  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
003757  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
003760  aa  6 00506 2521 00	spri2	pr6|326
003761  aa  7 00032 3521 00	epp2 	pr7|26		lap_data.frame_start
003762  aa  6 00510 2521 00	spri2	pr6|328
003763  aa  6 00100 3521 00	epp2 	pr6|64		code
003764  aa  6 00512 2521 00	spri2	pr6|330
003765  aa  6 00504 6211 00	eax1 	pr6|324
003766  aa   014000 4310 07	fld  	6144,dl
003767  aa  6 00044 3701 20	epp4 	pr6|36,*
003770  la  4 00044 3521 20	epp2 	pr4|36,*		channel_manager$write
003771  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 319
	if (code ^= 0) then do;

003772  aa  6 00100 2361 00	ldq  	pr6|64		code
003773  aa   000071 6000 04	tze  	57,ic		004064
						STATEMENT 1 ON LINE 320
	     call syserr$error_code (Log_message, code, "lap_simplex(^a): Error from write of ^d chars.", lap_data.name,
		lap_data.frame_size);

003774  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003775  aa   774643 00 0060	desc9a	-1629,48		000637 = 154141160137
003776  aa  6 00504 00 0060	desc9a	pr6|324,48
003777  aa   774555 3520 04	epp2 	-1683,ic		000554 = 000000000004
004000  aa  6 00522 2521 00	spri2	pr6|338
004001  aa  6 00100 3521 00	epp2 	pr6|64		code
004002  aa  6 00524 2521 00	spri2	pr6|340
004003  aa  6 00504 3521 00	epp2 	pr6|324
004004  aa  6 00526 2521 00	spri2	pr6|342
004005  aa  6 00142 3521 20	epp2 	pr6|98,*		lap_data.name
004006  aa  6 00530 2521 00	spri2	pr6|344
004007  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004010  aa  7 00030 3521 00	epp2 	pr7|24		lap_data.frame_size
004011  aa  6 00532 2521 00	spri2	pr6|346
004012  aa   774552 3520 04	epp2 	-1686,ic		000564 = 404000000021
004013  aa  6 00534 2521 00	spri2	pr6|348
004014  aa  6 00544 2521 00	spri2	pr6|356
004015  aa   774540 3520 04	epp2 	-1696,ic		000555 = 404000000043
004016  aa  6 00536 2521 00	spri2	pr6|350
004017  aa   774522 3520 04	epp2 	-1710,ic		000541 = 524000000056
004020  aa  6 00540 2521 00	spri2	pr6|352
004021  aa   774530 3520 04	epp2 	-1704,ic		000551 = 526000000040
004022  aa  6 00542 2521 00	spri2	pr6|354
004023  aa  6 00520 6211 00	eax1 	pr6|336
004024  aa   024000 4310 07	fld  	10240,dl
004025  aa  6 00044 3701 20	epp4 	pr6|36,*
004026  la  4 00016 3521 20	epp2 	pr4|14,*		syserr$error_code
004027  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 322
	     call free_pending_frame ();

004030  aa   000340 6700 04	tsp4 	224,ic		004370
						STATEMENT 1 ON LINE 323
	     call channel_manager$control (lap_data.devx, "hangup", null (), ignore_code);

004031  aa   774543 2370 04	ldaq 	-1693,ic		000574 = 150141156147 165160000000
004032  aa  6 00546 7571 00	staq 	pr6|358
004033  aa   774543 3734 24	epp7 	-1693,ic*
004034  aa  6 00550 6535 00	spri7	pr6|360
004035  aa  6 00142 3715 20	epp5 	pr6|98,*		lap_data_ptr
004036  aa  5 00010 3521 00	epp2 	pr5|8		lap_data.devx
004037  aa  6 00522 2521 00	spri2	pr6|338
004040  aa  6 00546 3521 00	epp2 	pr6|358
004041  aa  6 00524 2521 00	spri2	pr6|340
004042  aa  6 00550 3521 00	epp2 	pr6|360
004043  aa  6 00526 2521 00	spri2	pr6|342
004044  aa  6 00101 3521 00	epp2 	pr6|65		ignore_code
004045  aa  6 00530 2521 00	spri2	pr6|344
004046  aa   774516 3520 04	epp2 	-1714,ic		000564 = 404000000021
004047  aa  6 00532 2521 00	spri2	pr6|346
004050  aa   774475 3520 04	epp2 	-1731,ic		000545 = 524000000006
004051  aa  6 00534 2521 00	spri2	pr6|348
004052  aa   774510 3520 04	epp2 	-1720,ic		000562 = 464000000000
004053  aa  6 00536 2521 00	spri2	pr6|350
004054  aa   774501 3520 04	epp2 	-1727,ic		000555 = 404000000043
004055  aa  6 00540 2521 00	spri2	pr6|352
004056  aa  6 00520 6211 00	eax1 	pr6|336
004057  aa   020000 4310 07	fld  	8192,dl
004060  aa  6 00044 3701 20	epp4 	pr6|36,*
004061  la  4 00046 3521 20	epp2 	pr4|38,*		channel_manager$control
004062  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 324
	     return;

004063  aa  6 00216 6101 00	rtcd 	pr6|142
						STATEMENT 1 ON LINE 325
	     end;

						STATEMENT 1 ON LINE 327
	if (lap_data.frame_start ^= null ()) & (lap_data.frame_start ^= bufp) then do;

004064  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004065  aa  7 00032 2371 00	ldaq 	pr7|26		lap_data.frame_start
004066  aa   774510 6770 04	eraq 	-1720,ic		000576 = 077777000043 000001000000
004067  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004070  aa   000033 6000 04	tze  	27,ic		004123
004071  aa  7 00032 2371 00	ldaq 	pr7|26		lap_data.frame_start
004072  aa  6 00224 6771 00	eraq 	pr6|148		bufp
004073  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004074  aa   000027 6000 04	tze  	23,ic		004123
						STATEMENT 1 ON LINE 328
	     call syserr (Log_message, "lap_simplex(^a): Write failed to take whole frame, discarding rest.",
		lap_data.name);

004075  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004076  aa   774611 00 0104	desc9a	-1655,68		000706 = 154141160137
004077  aa  6 00520 00 0104	desc9a	pr6|336,68
004100  aa   774454 3520 04	epp2 	-1748,ic		000554 = 000000000004
004101  aa  6 00554 2521 00	spri2	pr6|364
004102  aa  6 00520 3521 00	epp2 	pr6|336
004103  aa  6 00556 2521 00	spri2	pr6|366
004104  aa  7 00000 3521 00	epp2 	pr7|0		lap_data.name
004105  aa  6 00560 2521 00	spri2	pr6|368
004106  aa   774456 3520 04	epp2 	-1746,ic		000564 = 404000000021
004107  aa  6 00562 2521 00	spri2	pr6|370
004110  aa   774430 3520 04	epp2 	-1768,ic		000540 = 524000000103
004111  aa  6 00564 2521 00	spri2	pr6|372
004112  aa   774437 3520 04	epp2 	-1761,ic		000551 = 526000000040
004113  aa  6 00566 2521 00	spri2	pr6|374
004114  aa  6 00552 6211 00	eax1 	pr6|362
004115  aa   014000 4310 07	fld  	6144,dl
004116  aa  6 00044 3701 20	epp4 	pr6|36,*
004117  la  4 00014 3521 20	epp2 	pr4|12,*		syserr
004120  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 330
	     call free_pending_frame ();

004121  aa   000247 6700 04	tsp4 	167,ic		004370
						STATEMENT 1 ON LINE 331
	     return;

004122  aa  6 00216 6101 00	rtcd 	pr6|142
						STATEMENT 1 ON LINE 332
	     end;

						STATEMENT 1 ON LINE 334
	if (lap_data.frame_start = null ()) then do;

004123  aa  7 00032 2371 00	ldaq 	pr7|26		lap_data.frame_start
004124  aa   774452 6770 04	eraq 	-1750,ic		000576 = 077777000043 000001000000
004125  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004126  aa   000011 6010 04	tnz  	9,ic		004137
						STATEMENT 1 ON LINE 335
	     lap_data.frame_end = null ();

004127  aa   774447 2370 04	ldaq 	-1753,ic		000576 = 077777000043 000001000000
004130  aa  7 00034 7571 00	staq 	pr7|28		lap_data.frame_end
						STATEMENT 1 ON LINE 336
	     lap_data.frame_size = 0;

004131  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004132  aa  7 00030 4501 00	stz  	pr7|24		lap_data.frame_size
						STATEMENT 1 ON LINE 337
	     lap_data.frame_ready = "0"b;

004133  aa  7 00027 4501 00	stz  	pr7|23		lap_data.frame_ready
						STATEMENT 1 ON LINE 338
	     lap_data.send_output = "1"b;

004134  aa   400000 2350 03	lda  	131072,du
004135  aa  7 00013 2551 00	orsa 	pr7|11		lap_data.send_output
						STATEMENT 1 ON LINE 339
	     end;

004136  aa   000003 7100 04	tra  	3,ic		004141
						STATEMENT 1 ON LINE 340
	else lap_data.send_output = "0"b;

004137  aa   000265 2350 04	lda  	181,ic		004424 = 377777777777
004140  aa  7 00013 3551 00	ansa 	pr7|11		lap_data.send_output
						STATEMENT 1 ON LINE 342
	return;

004141  aa  6 00216 6101 00	rtcd 	pr6|142
						STATEMENT 1 ON LINE 343
     end write_frame;

  END PROCEDURE write_frame
BEGIN PROCEDURE do_modes
ENTRY TO do_modes                                           STATEMENT 1 ON LINE 426
do_modes:
     procedure (P_set_sw);

004142  aa  6 00230 6501 00	spri4	pr6|152
004143  aa  6 00232 2521 00	spri2	pr6|154
						STATEMENT 1 ON LINE 433
	call setup ();

004144  aa   000110 6700 04	tsp4 	72,ic		004254
						STATEMENT 1 ON LINE 434
	mclp = P_mcl_info_ptr;

004145  aa  6 00032 3735 20	epp7 	pr6|26,*
004146  aa  7 00006 3715 20	epp5 	pr7|6,*		P_mcl_info_ptr
004147  aa  5 00000 3715 20	epp5 	pr5|0,*		P_mcl_info_ptr
004150  aa  6 00152 6515 00	spri5	pr6|106		mclp
						STATEMENT 1 ON LINE 436
	if mcl.version ^= mcl_version_2 then do;

004151  aa  5 00000 2361 00	ldq  	pr5|0		mcl.version
004152  aa   000002 1160 07	cmpq 	2,dl
004153  aa   000005 6000 04	tze  	5,ic		004160
						STATEMENT 1 ON LINE 437
	     P_code = error_table_$unimplemented_version;

004154  aa  6 00044 3701 20	epp4 	pr6|36,*
004155  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$unimplemented_version
004156  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 438
	     return;

004157  aa  6 00230 6101 00	rtcd 	pr6|152
						STATEMENT 1 ON LINE 439
	     end;

						STATEMENT 1 ON LINE 441
	mode_error = 0;

004160  aa  6 00236 4501 00	stz  	pr6|158		mode_error
						STATEMENT 1 ON LINE 443
	do mode_idx = 1 to mcl.n_entries;

004161  aa  5 00001 2361 00	ldq  	pr5|1		mcl.n_entries
004162  aa  6 00237 7561 00	stq  	pr6|159
004163  aa   000001 2360 07	ldq  	1,dl
004164  aa  6 00127 7561 00	stq  	pr6|87		mode_idx
004165  aa   000000 0110 03	nop  	0,du
004166  aa  6 00127 2361 00	ldq  	pr6|87		mode_idx
004167  aa  6 00237 1161 00	cmpq 	pr6|159
004170  aa   000061 6054 04	tpnz 	49,ic		004251
						STATEMENT 1 ON LINE 444
	     mclep = addr (mcl.entries (mode_idx));

004171  aa   000005 4020 07	mpy  	5,dl
004172  aa  6 00152 3735 20	epp7 	pr6|106,*		mclp
004173  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
004174  aa  6 00154 6535 00	spri7	pr6|108		mclep
						STATEMENT 1 ON LINE 445
	     if (mcle.mode_name = "rawo") | (mcle.mode_name = "rawi") then do;

004175  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004176  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
004177  aa   774341 00 0004	desc9a	-1823,4		000536 = 162141167157
004200  aa   000005 6000 04	tze  	5,ic		004205
004201  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004202  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
004203  aa   774334 00 0004	desc9a	-1828,4		000535 = 162141167151
004204  aa   000021 6010 04	tnz  	17,ic		004225
						STATEMENT 1 ON LINE 446
		if ^P_set_sw then mcle.mpx_mode = "1"b;

004205  aa  6 00232 3715 20	epp5 	pr6|154,*
004206  aa  5 00002 2351 20	lda  	pr5|2,*		P_set_sw
004207  aa   400000 3150 03	cana 	131072,du
004210  aa   000004 6010 04	tnz  	4,ic		004214
004211  aa   100000 2350 03	lda  	32768,du
004212  aa  7 00004 2551 00	orsa 	pr7|4		mcle.mpx_mode
004213  aa   000034 7100 04	tra  	28,ic		004247
						STATEMENT 1 ON LINE 447
		else if (mcle.mode_switch = "0"b) then do;

004214  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
004215  aa   400000 3150 03	cana 	131072,du
004216  aa   000031 6010 04	tnz  	25,ic		004247
						STATEMENT 1 ON LINE 449
		     mode_error = error_table_$bad_mode;

004217  aa  6 00044 3701 20	epp4 	pr6|36,*
004220  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$bad_mode
004221  aa  6 00236 7561 00	stq  	pr6|158		mode_error
						STATEMENT 1 ON LINE 450
		     mcle.error = "1"b;

004222  aa   040000 2350 03	lda  	16384,du
004223  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
						STATEMENT 1 ON LINE 451
		     end;

						STATEMENT 1 ON LINE 452
		end;

004224  aa   000023 7100 04	tra  	19,ic		004247
						STATEMENT 1 ON LINE 454
	     else if P_set_sw
	     then if (mcle.mpx_mode & ^mcle.force) then do;

004225  aa  6 00232 3715 20	epp5 	pr6|154,*
004226  aa  5 00002 2351 20	lda  	pr5|2,*		P_set_sw
004227  aa   400000 3150 03	cana 	131072,du
004230  aa   000017 6000 04	tze  	15,ic		004247
004231  aa  7 00004 2351 00	lda  	pr7|4		mcle.mpx_mode
004232  aa   100000 3150 03	cana 	32768,du
004233  aa   000012 6000 04	tze  	10,ic		004245
004234  aa  7 00004 2351 00	lda  	pr7|4		mcle.force
004235  aa   200000 3150 03	cana 	65536,du
004236  aa   000007 6010 04	tnz  	7,ic		004245
						STATEMENT 1 ON LINE 456
		     mode_error = error_table_$bad_mode;

004237  aa  6 00044 3701 20	epp4 	pr6|36,*
004240  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$bad_mode
004241  aa  6 00236 7561 00	stq  	pr6|158		mode_error
						STATEMENT 1 ON LINE 457
		     mcle.error = "1"b;

004242  aa   040000 2350 03	lda  	16384,du
004243  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
						STATEMENT 1 ON LINE 458
		     end;

004244  aa   000003 7100 04	tra  	3,ic		004247
						STATEMENT 1 ON LINE 460
		else mcle.mpx_mode = "0"b;

004245  aa   000156 2350 04	lda  	110,ic		004423 = 677777777777
004246  aa  7 00004 3551 00	ansa 	pr7|4		mcle.mpx_mode
						STATEMENT 1 ON LINE 461
	end;

004247  aa  6 00127 0541 00	aos  	pr6|87		mode_idx
004250  aa   777716 7100 04	tra  	-50,ic		004166
						STATEMENT 1 ON LINE 463
	P_code = mode_error;

004251  aa  6 00236 2361 00	ldq  	pr6|158		mode_error
004252  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 464
	return;

004253  aa  6 00230 6101 00	rtcd 	pr6|152
						STATEMENT 1 ON LINE 465
     end do_modes;

  END PROCEDURE do_modes
BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 469
setup:
     procedure ();

004254  aa  6 00240 6501 00	spri4	pr6|160
						STATEMENT 1 ON LINE 472
	lap_data_ptr = P_lap_data_ptr;

004255  aa  6 00172 3735 20	epp7 	pr6|122,*		P_lap_data_ptr
004256  aa  7 00000 3735 20	epp7 	pr7|0,*		P_lap_data_ptr
004257  aa  6 00142 6535 00	spri7	pr6|98		lap_data_ptr
						STATEMENT 1 ON LINE 473
	if (P_subchan_idx ^= 1) then do;

004260  aa  6 00032 3715 20	epp5 	pr6|26,*
004261  aa  5 00004 2361 20	ldq  	pr5|4,*		P_subchan_idx
004262  aa   000001 1160 07	cmpq 	1,dl
004263  aa   000034 6000 04	tze  	28,ic		004317
						STATEMENT 1 ON LINE 474
	     call syserr (Write_with_alarm, "lap_simplex(^a): Invalid subchannel index ^d", lap_data.name, P_subchan_idx);

004264  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004265  aa   774340 00 0054	desc9a	-1824,44		000624 = 154141160137
004266  aa  6 00570 00 0054	desc9a	pr6|376,44
004267  aa   774267 3520 04	epp2 	-1865,ic		000556 = 000000000003
004270  aa  6 00606 2521 00	spri2	pr6|390
004271  aa  6 00570 3521 00	epp2 	pr6|376
004272  aa  6 00610 2521 00	spri2	pr6|392
004273  aa  7 00000 3521 00	epp2 	pr7|0		lap_data.name
004274  aa  6 00612 2521 00	spri2	pr6|394
004275  aa  5 00004 3521 20	epp2 	pr5|4,*		P_subchan_idx
004276  aa  6 00614 2521 00	spri2	pr6|396
004277  aa   774265 3520 04	epp2 	-1867,ic		000564 = 404000000021
004300  aa  6 00616 2521 00	spri2	pr6|398
004301  aa  6 00624 2521 00	spri2	pr6|404
004302  aa   774232 3520 04	epp2 	-1894,ic		000534 = 524000000054
004303  aa  6 00620 2521 00	spri2	pr6|400
004304  aa   774245 3520 04	epp2 	-1883,ic		000551 = 526000000040
004305  aa  6 00622 2521 00	spri2	pr6|402
004306  aa  6 00604 6211 00	eax1 	pr6|388
004307  aa   020000 4310 07	fld  	8192,dl
004310  aa  6 00044 3701 20	epp4 	pr6|36,*
004311  la  4 00014 3521 20	epp2 	pr4|12,*		syserr
004312  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 475
	     P_code = error_table_$bad_arg;

004313  aa  6 00044 3701 20	epp4 	pr6|36,*
004314  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$bad_arg
004315  aa  6 00174 7561 20	stq  	pr6|124,*		P_code
						STATEMENT 1 ON LINE 476
	     goto SETUP_RETURNS_FOR_ERROR;

004316  aa   776224 7100 04	tra  	-876,ic		002542
						STATEMENT 1 ON LINE 477
	     end;

						STATEMENT 1 ON LINE 479
	return;

004317  aa  6 00240 6101 00	rtcd 	pr6|160
						STATEMENT 1 ON LINE 480
     end setup;

  END PROCEDURE setup
BEGIN PROCEDURE crash
ENTRY TO crash                                              STATEMENT 1 ON LINE 488
crash:
     procedure (P_type);

004320  aa  6 00246 6501 00	spri4	pr6|166
004321  aa  6 00250 2521 00	spri2	pr6|168
						STATEMENT 1 ON LINE 494
	call free_pending_frame ();

004322  aa   000046 6700 04	tsp4 	38,ic		004370
						STATEMENT 1 ON LINE 496
	call channel_manager$interrupt (lap_data.subchannel, P_type, ""b);

004323  aa   774255 2370 04	ldaq 	-1875,ic		000600 = 000000000000 000000000000
004324  aa  6 00626 7571 00	staq 	pr6|406
004325  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004326  aa  7 00011 3521 00	epp2 	pr7|9		lap_data.subchannel
004327  aa  6 00632 2521 00	spri2	pr6|410
004330  aa  6 00250 3715 20	epp5 	pr6|168,*
004331  aa  5 00002 3521 20	epp2 	pr5|2,*		P_type
004332  aa  6 00634 2521 00	spri2	pr6|412
004333  aa  6 00626 3521 00	epp2 	pr6|406
004334  aa  6 00636 2521 00	spri2	pr6|414
004335  aa  6 00630 6211 00	eax1 	pr6|408
004336  aa   014000 4310 07	fld  	6144,dl
004337  aa  6 00044 3701 20	epp4 	pr6|36,*
004340  la  4 00050 3521 20	epp2 	pr4|40,*		channel_manager$interrupt
004341  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 498
	if (P_type ^= CRASH)
	then					/* Unless he's already obviously aware, */
	     call pxss$ring_0_wakeup (lap_data.load_process_id, lap_data.load_event_channel, MPX_DOWN, code);

004342  aa  6 00250 3735 20	epp7 	pr6|168,*
004343  aa  7 00002 2361 20	ldq  	pr7|2,*		P_type
004344  aa   000003 1160 07	cmpq 	3,dl
004345  aa   000017 6000 04	tze  	15,ic		004364
004346  aa  6 00142 3715 20	epp5 	pr6|98,*		lap_data_ptr
004347  aa  5 00014 3521 00	epp2 	pr5|12		lap_data.load_process_id
004350  aa  6 00642 2521 00	spri2	pr6|418
004351  aa  5 00016 3521 00	epp2 	pr5|14		lap_data.load_event_channel
004352  aa  6 00644 2521 00	spri2	pr6|420
004353  aa   774155 3520 04	epp2 	-1939,ic		000530 = 000000000000
004354  aa  6 00646 2521 00	spri2	pr6|422
004355  aa  6 00100 3521 00	epp2 	pr6|64		code
004356  aa  6 00650 2521 00	spri2	pr6|424
004357  aa  6 00640 6211 00	eax1 	pr6|416
004360  aa   020000 4310 07	fld  	8192,dl
004361  aa  6 00044 3701 20	epp4 	pr6|36,*
004362  la  4 00012 3521 20	epp2 	pr4|10,*		pxss$ring_0_wakeup
004363  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 502
	lap_data.state = LAP_HUNGUP;

004364  aa   000000 2360 07	ldq  	0,dl
004365  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004366  aa  7 00012 7561 00	stq  	pr7|10		lap_data.state
						STATEMENT 1 ON LINE 504
	return;

004367  aa  6 00246 6101 00	rtcd 	pr6|166
						STATEMENT 1 ON LINE 505
     end crash;

  END PROCEDURE crash
BEGIN PROCEDURE free_pending_frame
ENTRY TO free_pending_frame                                 STATEMENT 1 ON LINE 509
free_pending_frame:
     procedure ();

004370  aa  6 00254 6501 00	spri4	pr6|172
						STATEMENT 1 ON LINE 512
	if (lap_data.frame_start = null ()) then return;

004371  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004372  aa  7 00032 2371 00	ldaq 	pr7|26		lap_data.frame_start
004373  aa   774203 6770 04	eraq 	-1917,ic		000576 = 077777000043 000001000000
004374  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004375  aa   000002 6010 04	tnz  	2,ic		004377
004376  aa  6 00254 6101 00	rtcd 	pr6|172
						STATEMENT 1 ON LINE 514
	call tty_space_man$free_chain (lap_data.devx, OUTPUT, lap_data.frame_start);

004377  aa  7 00010 3521 00	epp2 	pr7|8		lap_data.devx
004400  aa  6 00654 2521 00	spri2	pr6|428
004401  aa   774147 3520 04	epp2 	-1945,ic		000550 = 400000000000
004402  aa  6 00656 2521 00	spri2	pr6|430
004403  aa  7 00032 3521 00	epp2 	pr7|26		lap_data.frame_start
004404  aa  6 00660 2521 00	spri2	pr6|432
004405  aa  6 00652 6211 00	eax1 	pr6|426
004406  aa   014000 4310 07	fld  	6144,dl
004407  aa  6 00044 3701 20	epp4 	pr6|36,*
004410  la  4 00060 3521 20	epp2 	pr4|48,*		tty_space_man$free_chain
004411  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 516
	lap_data.frame_start = null ();

004412  aa   774164 2370 04	ldaq 	-1932,ic		000576 = 077777000043 000001000000
004413  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004414  aa  7 00032 7571 00	staq 	pr7|26		lap_data.frame_start
						STATEMENT 1 ON LINE 517
	lap_data.frame_end = null ();

004415  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004416  aa  7 00034 7571 00	staq 	pr7|28		lap_data.frame_end
						STATEMENT 1 ON LINE 518
	lap_data.frame_size = 0;

004417  aa  6 00142 3735 20	epp7 	pr6|98,*		lap_data_ptr
004420  aa  7 00030 4501 00	stz  	pr7|24		lap_data.frame_size
						STATEMENT 1 ON LINE 519
	lap_data.frame_ready = "0"b;

004421  aa  7 00027 4501 00	stz  	pr7|23		lap_data.frame_ready
						STATEMENT 1 ON LINE 521
	return;

004422  aa  6 00254 6101 00	rtcd 	pr6|172
						STATEMENT 1 ON LINE 522
     end free_pending_frame;

  END PROCEDURE free_pending_frame
  END PROCEDURE lap_simplex


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
