\documentclass[notitlepage]{report}
\usepackage {listings}
\usepackage{ulem}
\renewcommand{\thesection}{\arabic{part}.\arabic{section}}
\makeatletter
\@addtoreset{section}{part}
\makeatother

\begin{document}
\title{Implementation Notes}
%\author{}
%\date{}
\maketitle

\part{Terminology}

\section{Hardware}

\subsection{History}


\subsubsection{Systems}

\begin{description}

    \item[GE-600 Series]  \hfill \\

    \begin{description}

        \item[GE-635]

        \item[GE-645] GE-635 with Multics support
        \item[GE-655] Integrated circuit version of GE-635

    \end{description}

    \item[Honeywell 6000 Series] Honeywell version of GE-600 series

    \begin{description}
        \item[6170] GE-655
        \item[6030, 6050] Reduced performance versions
        \item[6025, 6040, 6060, 6080] Added EIS
        \item[6180] GE-645  Hardware support for Multics
        \item[Level 6]
        \item[Level 61]
        \item[Level 62]
        \item[Level 64]
        \item[Level 66] Honeywell's designation for the large-scale computers that ran GCOS, a repackaging of the “6000” line, later called the DPS-8/66.
        \item[Level 68] Honeywell's designation for the large-scale computers that ran Multics.
        \item[DPS-6] Another name for Level 6
        \item[DPS-6plus] version of Level 6 that ran a secure system
        \item[DPS-8] DPS8 is functionally identical to Level 68, but faster.
        \item[DPS-8M]
        \item[DPS-68]
        \item[DPS-88] Later name for the Honeywell ADP and Orion machines. Never ran Multics.
        \item[DPS-90, DPS-9000] No Multics support
    \end{description}

From the AL39 Multics Processor Manual:

\begin {quote}

\ldots processors used in the Multics system. These are the DPS/L68, which
refers to the DPS, L68 or older model processors (excluding the GE-645) and 
DPS 8M, which refers to the DPS 8 family of Multics processors, i.e. DPS 8/70M, DPS 8/62M and DPS 8/52M.

\end {quote}
\end{description} % systems

\subsubsection{Disk Drives}

    \begin{description}

        \item[DS-10] Early disk unit

        \item[DSS191] Same as MSU0400

        \item[DUS170] 

        \item[DSS180] Removable Disk Storage Subsystem 

“Intermediate” size mass storage for Series 6000 systems. 

Up to 18 drives

Each drive 27.5 Million characters, total subsystem capacity of 500 million 
characters

Disk pack: Honeywell Sentinel DCT170 or 2316

        \item[DSS190] Removable Disk Storage Subsystem 

Mass storage for Series 6000 systems.

Up to 16 drives

Each drive 133,320,000 characters, total subsystem capacity of 2.13 billion 
characters

Disk pack: Honeywell M4050

        \item[DSS270] Fixed Head  Disk Storage Subsystem 

Paging disk?  mass storage for Series 6000 systems.

Up to 20 drives

Each drive 15.3 Million characters, total subsystem capacity of 307 million 
characters

Disk pack: N/A

        \item[DSS167] Removable Disk Storage Subsystem 

Mass storage for Series 6000 systems.

6 drives or  9 drives (1 is spare, 8 active)

Each drive 15 Million characters, total subsystem capacity of 120 million 
characters

Disk pack:  ?

        \item[DSS170] Removable Disk Storage Subsystem 

“Intermediate” size mass storage for Series 6000 systems.

8 plus 1 spare drive

Each drive 27.5 Million characters, total subsystem capacity of 500 million 
characters

Disk pack: ?

        \item[MSU0500/0501]

Dual spindle, non-removable 1 million 9 bit bytes

        \item[MSU0400/0402/0451]

    \end{description} % Disk Drives

\subsubsection{Tapes Drives}

    \begin{description}

        \item[MTH 200, 201, 300, 301, 372, 373] Seven track
        \item[MTH 494, 405, 492, 493, 502, 505] Nine track

    \end{description} % Tape Drives

\subsubsection{Printers}

    \begin{description}

        \item[PRT300, 201]
        \item[PRU0901/1201] Large systems printer
        \item[PRU7070/7071]
        \item[PRU7076/7076]

    \end{description} % Printers

\subsubsection{Card Readers/Punches}

    \begin{description}

        \item[CRZ201] Reader
        \item[CPZ201] Punch

    \end{description}

\subsection{Input Output Multiplexers (IOM)}

    \begin{description}
        \item[Interface terminology] \hfill \\

            \begin{description}
              \item[Common Peripheral Interface (CPI)] Card reader, Slow tape drives
              \item[Peripheral System Interface (PSI)] Fast Tape Drives
            \end{description}

        \item [GIOC]i 645 System I/O controller

        \item [IOM] 6180 System I/O controller

        \item [IMU] ``Information Multiplexer Unit'' DPS8 ? System I/O 
controller. Functional replacement for IOM.

    \end{description}

\subsection {System Control Units (SCU)}

    \begin {description}
        \item [SCU] Series 60 Level 66 controller
        \item [SC] Level 68 
        \item [4MW SCU] Later version of SC
    \end {description}

\part{Subsystem Model in the simulator}

\section{SCU}

From the Multicians' Multics Glossary:

\begin{quote}
SCU

[BSG] (1) System Control Unit, or Memory Controller. The multiported, 
arbitrating interface to each bank of memory (usually 128 or 256 KWords), each
port connecting to a port of an ``active device'' (CPU, GIOC or IOM, bulk store
or drum controller). On the 645, the clock occupied an SCU as well. The SCUs
have their own repertoire of opcodes and registers, including those by which
system interrupts are set by one active unit for another. (See connect.) The
flexibility of this architecture was significant among the reasons why the GE
600 line was chosen for Multics. See SCAS.

SCAS

[BSG] (for ``System Controller Addressing Segment'') A supervisor segment with
one page in the memory space described by each SCU (or other passive module) in
the system. The SCAS contains no data, is not demand-paged, and its page table
is not managed by page control. Instructions directed specifically to an SCU as
opposed to the memory it controls are issued to absolute addresses in the SCAS
through pointers (in the SCS) calculated during initialization precisely to
this end. Typical of such instructions are cioc (issue a connect), smic (set an
interrupt), and the instructions to read and set SCU registers (including
interrupt masks). On the 6180, rccl (the instruction to read the SCU-resident
calendar clock) did not require an absolute address, but a port number,
obviating the need for the SCAS to be visible outside ring 0 to support user
clock-reading as had been the case on the 645. The SCAS, which is a segment but
not a data base, is an example of exploiting the paging mechanism for a purpose
other than implementing virtual memory.

connect

[BSG] Communication signal sent from one active device to another. When
received by a processor, as polled for the control unit after each instruction
pair like an interrupt, a special fault (connect fault), very much like an
interrupt, is taken. As with interrupts, processors send ``connects'' to each
other through the SCU, the only possible channel. While an interrupt is set in
an SCU register and fielded by the first ``taker'' of all appropriately masked
CPUs, a connect fault is routed by the SCU to one, specified processor (or I/O
controller), and cannot be masked against (although the recipient's inhibit bit
can postpone it for a short while). Sending a connect to the GIOC or IOM was
the way of instructing it to begin executing I/O commands. See SCAS.

Multics uses connects for forcing all CPUs to take note of SDW and PTW
invalidation (and clear their associative memories and execute a partial cache
clear when appropriate), holding CPUs in the air during critical phases of
dynamic reconfiguration, and the like. If my memory serves me well, functions
such as system crashing, scheduler preemption, and processor startup switched
back and forth between software-generated interrupts and connects throughout
the '70s.
\end {quote}

According to AL39, a DPS 8M supports only two SCUs; the later model SCUs support enough memory such that two SCUs would provide the maximum usable amount of memory. A system could have a third SCU for redundancy, but it would only be configured into the system if needed.

The code base currently abstracts away the SCUs, but they are being implemented.


\begin{itemize}

\item The clock is implemented as a seperate SIMH device.

\item The CPU connects directly to the IOMs. Being fixed.

\item Memory is implemented a a single, device independent model.

\item The SIMH CPU device only supports single CPUs currently, so the CPU to CPU communication issues are ignored for now. To get proper mult-CPU support, the SCU will probably need to be reallzed.
\end {itemize}

\section {IOM}

[cac] The reference document I have been using is 43A239854 ENGINEERING PRODUCT PECIFICATION, PART 1 6000B INPUT/OUT MULTIPLEXER (IOM) CENTRAL

The IOM model abstracts away controller devices such as the MPC. This means the
IOM code is very device aware, including extracting dev\_code values to enable
routing of connections. Unfortunately, this complexity leads to bugs relating
to the confusion of dev\_codes with SIMH UNIT numbers. Adding MPC devices would
isolate the complexities of dev\_code handling from the complexities of
connection handling, is probably a good idea.

\section {Tape}

The device seems good to go; it is a very abstract model, with no hardware modeling beyond a tracking a virtual cable to a port on an IOM.

\section {Disk}

Existing code base is skeletal.

\section {CPU}

AL39 ``Interrupt Sampling''

``The processor always fetches intructions in pairs. At an appropriate point
(as early as possible) in the execution of a pair of instructions, the
next sequential instruction pair is fetched and held is a special 
instruction buffer register. The exact point depends on instruction
sequence and other conditions.

``If the interrupt inhibit bit (bit 28) is not set in the current instruction
word at the point of next sequential instruction pair virtual address 
formation, te processor samples the group 7 faults [Shutdown, Timer Runout,
Connect]. If any of the group 7 faults is found an internal flag is set
reflecting the presence of a fault. The processor next samples the interrupt
present lines from all eight memory interface posts and loads a register
with bits corresponding to the states of the lines. If any bit in the
register is set ON an internal flag is set to reflect te presence of the
bit(s) in the register.

``If the instruction pair virtual address being formed is the result of a
transfer of control condition or if the current instruction is Execute (xec), * Execute Double (xed), Repeat (rpt), Repeat Double (rpd), or Repeat Link
(rpl), the group 7 faults and interrupt present lines are not sampled.

``At an appropriate point in the execution of the current instruction pair,
the process fetches he next instruction pair. At this point, it first tests
the internal flags for group 7 faults and interupts. If either flag is set
it does not fetch the next instruction pair.

``At the completion of the current instruction pair the proessor once again
checks the internal flags. If neither flag is set execution of the next
instruction pair proceeds. If the internal flag for group 7 faults is set,
the processor enters a FAULT cycle for the highest priority group 7
fault present. If the internal flag for interrupts s set, the processor
enters an INTERRUPT CYCLE.''

\begin {lstlisting}
 bool prefetch_valid = false
 bool out_of_seq = false // set after transfer, execute or repeat

 forever {

     if !prefetch_valid {
         inst_pair_buffer = fetch_pair ()
     }

     inst_pair = inst_pair_buffer
     prefetch_valid = false

     for inst# = 0, 1 {

         // Bug; doesn't handle odd IC on entry

         decode_inst (inst_pair [inst#]   

         if inst# == 0 {
            if !inhibit && !out_of_seq {
                g7_flag = sample_g7_faults ()
                int_flag = sample_interrupts ()
            } else {
                g7_flag = false
                int_flag = false
            }
            if !g7_flag && ! int_flag {
                inst_pair_buffer = fetch_pair ()
                prefetch_valid = true
            }
         }

         execute_decoded_inst ()
         if was_transfer
           break       // don't execute second half after a transfer
     }

     if g7_flag
         enter_fault_cycle ()
     if int_flag
         enter_interrupt_cycle ()
 }
\end{lstlisting}

This is not quite right yet; better integration with the out\_of\_seq
conditions is needed. Perhaps the prefetch test also need an address
check, i.e. is the address that was fetched what the processor was
expecting (equal to the Ir).

Further reading on the instruction prefetch indicates that it was quite complicated with multiple instruction pairs cached, which leads to issues with cache invalidation for self-modifying code. At this point, I am coding towards a much simpler model.

\section {CLK}

The clock code is currently disabled, pending better integration into the SIMH interval and DPS8 interrupt mechanisms.

\section {OPCON}

The operator console code is untested and not linked into the code. Eventually, the T4D tape will get around to testing it.

\section {Line printer}

Not yet implemented.

\section {System}

The simulator has been provide with commands to ``cable'' together the various subsystems. The current test configuration is in the file ``src/base\_system.ini'', shown here:

\lstinputlisting{../src/dps8/base_system.ini}



\part {Porting issues}

\paragraph {32 bit support}

The DPS8 is a 36 bit computer, with a double word of 72 bits. In order to 
manipulate these numbers in the assembler and the emulator, int128\_t 
types must be supported by the compiler, or a complex and cumbersome 128 
emulation library is needed.

\part {Notes}

\paragraph {Known device names}

This information is cribbed from 
http://stuff.mit.edu/afs/athena/reference/multics-history/source/Multics/ldd/system\_library\_1/source/bound\_library\_1\_.s.archive,
circa 1987.

\begin{verbatim}

    model name   valid drives

    mpc_msp_model_names (msp Mass Storage Processor)

    dsc0451       450, 451
    msp0451       450, 451
    msp0601       450, 451, 500, 501
    msp0603       450, 451, 500, 501
    msp0607       450, 451, 500, 501
    msp0609       450, 451, 500, 501
    msp0611       450, 451, 500, 501
    msp0612       450, 451, 500, 501
    msp800        450, 451, 500, 501

    mpc_mtp_model_names (mtp Magnetic Tape Processor)

    mtc501        500, 507
    mtc502        500, 507
    mtp0600       500, 507, 600, 601, 602
    mtp0601       500, 507, 600, 601, 602
    mtp0602       500, 507, 600, 601, 602
    mtp0610       500, 507, 600, 601, 602
    mtp0611       500, 507, 600, 601, 602

    ipc_msp_model_names

    fips-ipc      3380, 3381

    ipc_mtp_model_names

    fips-ipc      8200

    mpc_urp_model_names

    urc002
    urp0600
    urp8001
    urp8002
    urp8003
    urp8004

    disk_drive_model_names

    451   msu0451
    500   msu0500
    501   msu0501
    3380  msu3380
    3381  msu3381

    tape_drive_model_names

    500   mtc501, mtc502
    507   mtc502
    600   mtp0600
    601   mtp0601
    602   mtp0602
    610   mtp0610
    630   mtp0630
    8200  mtu8200

    printer_model_names

    301   prt301
    1000  pru1000
    1200  pru1200
    1600  pru1600
    901   pru0901
  
    reader_model_names

    500   cru0500
    501   cru0501
    301   crz301
    201   crz201

    ccu_model_names

    401   ccu401

    punch_model_names

    301   cpz301
    300   cpz300
    201   cpz201

    console_model_names

    6001  csu6001
    6004  csu6004
    6601  csu6601

\end{verbatim}

\paragraph{Addressing model notes}

RJ78A00, pg 6-42:

Interrupts are not received when the instruction is executed by the XEC or XED
instructions, but only when no fault is present.

RJ78A00, pg 6-44:

6.5.3 Instruction Counter Value Stored At Interrupt

The values of the Instruction Counter (IC) stored at interrupt are listed below: 

• Single-word Instructions

The address of the instruction to which processing is to be returned is stored.

When an interrupt is received with the DIS instruction, the DIS instruction
address + 1 is stored.

• Multiword Instructions (excluding CLIMB Instructions)

The address of the instruction to which processing is to be returned is stored. If
interrupt occurs during execution of an interruptible multiword instruction, IC +

0 is stored, and the IR bit 30 is stored as a one.

• CLIMB Instruction

Except when the data stack area is cleared with an OCLIMB, interrupt is not
received during execution of a CLIMB instruction. If an interrupt occurs
during the execution of an OCLIMB, IC + 0 is stored.
\part {Unresolved questions}

\section {Actual H/W behavior}

What should happen is when an \textbf{sscr} instruction is issued to an IOM 
that is configured in MANUAL (not PROGRAM mode)? According to AL39, a
 \textbf{sscr} that tries 
to set an unassigned mask register generates a STORE FAULT.
 (dps8\_scu.c/scu\_sscr()).

\section {t4d\_b.2.tap issues}

t4d seems to require the carry bit sense to be inverted after subtract 
operations; i.e. carry == not borrow.

I would have thought that DIS with interrupt inhibit would be an absolute halt, but t4d issues it after a CIOC.

IR Absolute bit

The T4D code runs in absolute mode (at least so far), and tests the "Absolute bit" in the STI instructions results. The test fails if the bit is on. According to AL39, one would expect the bit to be on when running in Absolute mode. In order for the test to pass, I added an emulator configuration option that inverts the sense of the bit for the STI instruction. The test tape and the documentation disagree. Who is right?

ABSA in absolute mode with bit 29 set

The T4D code does about 1400 executions of the ABSA instruction in absolute mode with bit 29 set (ABSA PR0|0 and the like). According to AL39, executing ABSA in absolute mode is "undefined". Examination of the code surrounding the ABSA instruction seem to indicate that SDW pairs are being set up and tested for BOUND violations, with the instruction returning 0 if no violation, and some not-quite-clear version of the offending address if BOUND violation occured (I think).  Documentation of ABSA behavior for this usage is needed.

DIS with Interrupt Inhibit set

The T4D tape waits for tape block read completion with a DIS instruction with the Interrupt Inhibit bit set. The interrupt pairs TRA to the instruction immediately after the DIS instruction, so the results are approximately the same whether the interrupt is processed, or the DIS instruction just continues on. What is the correct behavior for the DIS with interrupt inhibit set? (I favor the clear the interrupt resume processing without invoking the interrupt cycle as it makes a lot of sense (to me), but I haven't located a discussion of this in the documentation.


\part{Running the emulator}

\section{SIMH Emulator DPS8-M specific commands}

\paragraph{}
This a list of the DPS8-M specific commands that are provided for the SimH emulator framework.

\paragraph{}
For numeric parameters (<n>), the value is interpreted in `C' style; i.e. leading 0 for octal, leading 0x for hexadecimal.

\paragraph{Base set of debug options} (Almost) all of the SIMH devices (clk, cpu, iom, scu, tape) support a base set of debug options. (The device SYS is an abstraction that does not currently have code paths that are part of the VM.)

\begin{lstlisting}
	set [clk|cpu|iom|scu|tape|opcon] debug=[notify|info|err|warn|debug|all]
\end{lstlisting}

\paragraph{Number of CPUS} Some day we will support multiple cpus:

\begin{lstlisting}
	; Not yet implemented: set cpu nunits=<n>
\end{lstlisting}


\paragraph{Set CPU configuration switches}
The following commands perform the functions of the CPU configuration switches:

\begin{lstlisting}
	set cpu config=faultbase=[<n>|Multics]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=num=[0|1|on|off|enable|disable]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=data=<n>
\end{lstlisting}

\begin{lstlisting}
	set cpu config=mode=[0|1|GCOS|MULTICS]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=speed=<n>
\end{lstlisting}

\begin{lstlisting}
	set cpu config=port=[0|1|2|3|A|B|C|D]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=assignment=<n>
\end{lstlisting}

\begin{lstlisting}
	set cpu config=interlace=[off|2|4]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=enable=[0|1|on|off|enable|disable]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=init_enable=[0|1|on|off|enable|disable]
\end{lstlisting}

\begin{lstlisting}
	set cpu config=store_size=[0|1|2|3|4|5|6|7|
	                           32|64|128|256|512|1024|2048|4096|
	                           32K|64|128K|256K|512K|1024K|2048K|4096K|
	                           1M|2M|4M]
\end{lstlisting}

\paragraph{Set CPU VM runtime configuration} The following commands perform various internal configurations of the VM.

\subparagraph{IR Absoulte Bit}
The Test \& Diagnostic tape seems to believe that the ABSOLUTE bit has an inverted value then
described in AL-39, with respect to the STI instruction. When examining the bit in the SCU save data, it does not invert the value. This switches enables code that inverts the value for the STI instruction, allowing the Test \& Diagnostic tape to proceed. (See ``Unresolved Questions''.)

\begin{lstlisting}
	set cpu config=invertabsolute=[0|1|off|on]
\end{lstlisting}

\subparagraph{B29test}
This switch is no longer in use.

\begin{lstlisting}
	set cpu config=b29test=[0|1|off|on]
\end{lstlisting}

\subparagraph{Disenable}
The Unit Test code uses the DIS command as the end of test exit; The Test \& Diagnostics and the 20184 tapes expect DIS to wait for an interrupt. This switch enables the wait behavior.

\begin{lstlisting}
	set cpu config=dis_enable=[0|1|off|on]
\end{lstlisting}

\subparagraph{Auto\_append\_disable}
This switch is no longer in use.
\begin{lstlisting}
	set cpu config=auto_append_disable=[0|1|off|on]
\end{lstlisting}

\subparagraph{LPRP\_highonly}
This switch address two different interpretations of the behavior of the SPRPn instruction. Enable for Test \& Diagnostics or 20184.

\begin{lstlisting}
	set cpu config=lprp_highonly=[0|1|off|on]
\end{lstlisting}

\subparagraph{Steady\_clock}
Both the Test \& Diagnostics and 20184 use wait loops to allow I/O to complete; the loops use the RSW 2 instruction to read the time of day clock; variations in timing cause instruction cycles to jitter, making debugging more difficult. Setting this switch causes RSW 2 to return a deterministic value, so each run of the emulator provides a stable instruction cycle behavior.

\begin{lstlisting}
	set cpu config=steady_clock=[0|1|off|on]
\end{lstlisting}

\subparagraph{Degenerate\_mode}
This switch enables a high experimental code change great potentially reduces the number of lines of code, but may contains some smoke and mirror code.

\begin{lstlisting}
	set cpu config=degenerate_mode=[0|1|off|on]
\end{lstlisting}

\subparagraph{Append\_after}
This switch addresses an unresolved issue with the sequence of events in the instruction execute cycle.

\begin{lstlisting}
	set cpu config=append_after=[0|1|off|on]
\end{lstlisting}

\subparagraph{Super\_user}
This switch is no longer in use.

\begin{lstlisting}
	set cpu config=super_user=[0|1|off|on]
\end{lstlisting}

\subparagraph{EPP\_hack}
This switch is no longer in use.

\begin{lstlisting}
	set cpu config=epp_hack=[0|1|off|on]
\end{lstlisting}

\subparagraph{Halt\_on\_unimplemented}
This switch cause the emulator to halt the simulation on encountering an unimplemented instruction, rather then invoking fault handling.

\begin{lstlisting}
	set cpu config=halt_on_unimplmented=[0|1|off|on]
\end{lstlisting}

\paragraph{Show CPU config}
This command will show the current configuration settings of the CPU.

\begin{lstlisting}
	show cpu config
\end{lstlisting}

\paragraph{Set CPU debugging options}
This command will enable or disable the display information of a wide variety of runtime events and states.

\subparagraph{Trace}
On each execute cycle of the VM, display information about the executed instruction.

\subparagraph{Tracex}
On each execute cycle of the VM, display more detailed information about the executed instruction.

\subparagraph{Messages}
Display general messages about events and states of the emulator.

\subparagraph{Regdumpaqi}
Display the contents of the A, Q and IR registers after each execution execution.

\subparagraph{Regdumpidx}
Display the contents of the index registers after each execution execution.

\subparagraph{Regdumppr}
Display the contents of the PR registers after each execution execution.

\subparagraph{Regdumpadr}
Display the contents of the AR registers after each execution execution.

\subparagraph{Regdumpppr}
Display the contents of the PPR register after each execution execution.

\subparagraph{Regdumppdsbr}
Display the contents of the DSBR register after each execution execution.

\subparagraph{Regdumppflt}
Display the contents of the floating point register after each execution execution.

\subparagraph{Regdump}
All of the above \textit{regdump...} commands.

\subparagraph{Addrmod}
Display messages about the progress of the Address Modification unit.

\subparagraph{Appending}
Display messages about the progress of the Append unit.

\subparagraph{Fault}
Display messages about the progress of fault processing.

\begin{lstlisting}
	set cpu [no]debug=
		[trace | traceex | messages |
		 regdumpaqi | regdumpidx | regdumppr | regdumpadr |
		 regdumpppr | regdumpdsbr | regdumpflt | regdump |
		 addrmod | appending | fault]
\end{lstlisting}

\paragraph{Boot CPU}
Displays a message suggesting booting an IOM.

\begin{lstlisting}
	boot cpu
\end{lstlisting}

\paragraph{CPU registers}
This is a list of registers the SIMH examine and deposit commands work with.

\begin{lstlisting}
	     ic ir a q e 
	     x0 x1 x2 x3 x4 x5 x6 x7
	     ppr.ic ppr.prr
	     ppr.psr prr.p
	     dsbr.addr dsbr.bnd dsbr.u dsbr.stack
	     bar.base bar.bound
	     pr0.snr pr1.snr pr2.snr pr3.snr pr4.snr pr5.snr pr6.snr pr7.snr
	     pr0.rnr pr1.rnr pr2.rnr pr3.rnr pr4.rnr pr5.rnr pr6.rnr pr7.rnr
	     pr0.wordno pr1.wordno pr2.wordno pr3.wordno
	     pr4.wordno pr5.wordno pr6.wordno pr7.wordno
\end{lstlisting}

\paragraph{Number of IOMs}
These command set or show the number of IOMs in the system.

\begin{lstlisting}
	set iom nunits=<n>
	show iom nunits
\end{lstlisting}

\paragraph{Show IOM mailbox}
This command shows the contents of an IOM's mailboxes

\begin{lstlisting}
	show iom<n> mbx
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=
	    [os | boot | iom_base | multiplex_base |
	     tapechan | cardchan | scuport | port | addr |
	     interlace | enable | initenable | halfsize| store_size |
	     bootskip]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=boot=[card|tape]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=iombase=[<n>|Multics]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=multiplexbase=<n>
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=tapechan=<n>
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=cardchan=<n>
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=scuport=<n>
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=port=<n>
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=addr=<n>
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=interlace=[0|1]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=enable=[0|1]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=initenable=[0|1]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=halfsize=[0|1]
\end{lstlisting}

\begin{lstlisting}
	set iom<n> config=store_size=[0|1|2|3|4|5|6|7|
		                          32|64|128|256|512|1024|2048|4096|
		                          32K|64|128K|256K|512K|1024K|2048K|4096K|
		                          1M|2M|4M]
\end{lstlisting}

\begin{lstlisting}
	show iom<n> config
\end{lstlisting}

\begin{lstlisting}
	boot iom<n>
\end{lstlisting}

\begin{lstlisting}
	set scu nunits=<n>
\end{lstlisting}

\begin{lstlisting}
	show scu nunits
\end{lstlisting}

\begin{lstlisting}
	show scu<n> state
\end{lstlisting}

\begin{lstlisting}
	set scu<n> config=mode=[manual|program]
\end{lstlisting}

\begin{lstlisting}
	set scu<n> config=mask[a|b]=[off|<n>]
\end{lstlisting}

\begin{lstlisting}
	set scu<n> config=port<n>=[enable|disable|0|1]
\end{lstlisting}

\begin{lstlisting}
	set scu<n> config=lwrstore_size=[0|1|2|3|4|5|6|7|
	                                 32|64|128|256|512|1024|2048|4096|
	                                 32K|64|128K|256K|512K|1024K|2048K|4096K|
	                                 1M|2M|4M]
\end{lstlisting}

\begin{lstlisting}
	show scu<n> config
\end{lstlisting}

\paragraph{Operator console autoinput}

These commands are currently unimplemented.

\begin{lstlisting}
	set opcon autoinput
	show opcon autoinput
\end{lstlisting}

\begin{lstlisting}
	show sys config
\end{lstlisting}

\begin{lstlisting}
	set sys config=[connect_time|activate_time|
	                mt_read_time|mt_xfer_time|
	               iom_boot_time=[off|n]]
\end{lstlisting}

\begin{lstlisting}
	set tape nunits=<n>
\end{lstlisting}

\begin{lstlisting}
	show tape nunits
\end{lstlisting}

\begin{lstlisting}
	set tape<n> rewind
\end{lstlisting}

\begin{lstlisting}
	set tape<n> [no]watch
\end{lstlisting}

\begin{lstlisting}
	attach [-r] tape<n> <filename.tap>
\end{lstlisting}

\begin{lstlisting}
	dpsinit
\end{lstlisting}

\begin{lstlisting}
	dpsdump
\end{lstlisting}

\begin{lstlisting}
	segment
\end{lstlisting}

\begin{lstlisting}
	segments
\end{lstlisting}

The `cable' command provides the emulation equivalent of stringing physical cables from device to device. This is an important step as the DPS8-M was not a plug-and-play design; which physical ports on a device the cables connect to influence the system configuration. The semantics of the `cable' command is to string cables inward; from peripherals towards the CPU.
\begin{lstlisting}
	cable tape=<tape_unit_num>,<IOM_unit_number>,
		<channel_number>,<device_code>
\end{lstlisting}
	String a cable from a tape drive to an IOM. As the MPC devices are not implemented, the `device\_code' represents the assignment of devices that the MPC was use when multiplexing multiple devices into a single channel.

\begin{lstlisting}
	cable opcon=<IOM_unit_num>,<channel_number>,
		<unused>,<unused>
\end{lstlisting}

	String a cable from the Operator's Console to an IOM.

\begin{lstlisting}
	cable iom=<tIOM_unit_num>,<IOM_port_number>,
		<SCU_unit_number>,<SCU_port_number>
\end{lstlisting}

	String a cable from an IOM to an SCU.

\begin{lstlisting}
	cable scu=<SCU_unit_num>,<SCU_port_number>,
		<CPU_unit_number>,<CPU_port_number>
\end{lstlisting}

	String a cable from an SCU to a CPU.

\begin{lstlisting}
	dbgstart
\end{lstlisting}

\begin{lstlisting}
	displaymatrix
\end{lstlisting}


\section{Booting the Test \& Diagnostic tape}

The file `t4d\_b.2.ini' is will set up the base system and boot the 't4d\_b.2.tap' tape image.
`
\begin{lstlisting}
	./dps8 t4d_b.2.ini
\end{lstlisting}

\section{Booting the 20184 tape}

The file `20184.ini' is will set up the base system and boot the '20184.tap' tape image.
`
\begin{lstlisting}
	./dps8 20184.ini
\end{lstlisting}

\part{AL-39 errata}

\section{\texttt{FRD} instruction.}

In the description of the \texttt{FRD} instruction AL39 has these notes:

\begin{verbatim}
The frd instruction is executed as follows:
C(AQ) + (11...1)29,71 → C(AQ)
If C(AQ)0 = 0, then a carry is added at AQ71
If overflow occurs, C(AQ) is shifted one place to the right and C(E) is increased by 1.
If overflow does not occur, C(EAQ) is normalized.
If C(AQ) = 0, C(E) is set to -128 and the zero indicator is set ON.
\end{verbatim}

I believe this is wrong.


Referring to my implementation notes of \texttt{FRD} in dps8\_math.c...

\begin{verbatim}
//! If C(AQ) ≠ 0, the frd instruction performs a true round to a precision of 28 bits and a normalization on C(EAQ).
//! A true round is a rounding operation such that the sum of the result of applying the operation to two numbers of
//! equal magnitude but opposite sign is exactly zero.

//! The frd instruction is executed as follows:
//! C(AQ) + (11...1)29,71 → C(AQ)
//! If C(AQ)0 = 0, then a carry is added at AQ71
//! If overflow occurs, C(AQ) is shifted one place to the right and C(E) is increased by 1.
//! If overflow does not occur, C(EAQ) is normalized.
//! If C(AQ) = 0, C(E) is set to -128 and the zero indicator is set ON.

//! I believe AL39 is incorrect; bits 28-71 should be set to 0, not 29-71. DH02-01 & Bull RJ78 are correct.

//! test case 15.5
//!                 rE                     rA                                     rQ
//! 014174000000 00000110 000111110000000000000000000000000000 000000000000000000000000000000000000
//! +                                                  1111111 111111111111111111111111111111111111
//! =            00000110 000111110000000000000000000001111111 111111111111111111111111111111111111
//! If C(AQ)0 = 0, then a carry is added at AQ71
//! =            00000110 000111110000000000000000000010000000 000000000000000000000000000000000000
//! 0 → C(AQ)29,71
//!              00000110 000111110000000000000000000010000000 000000000000000000000000000000000000
//! after normalization .....
//! 010760000002 00000100 011111000000000000000000001000000000 000000000000000000000000000000000000
//! This is wrong

//! 0 → C(AQ)28,71
//!              00000110 000111110000000000000000000000000000 000000000000000000000000000000000000
//! after normalization .....
//! 010760000000 00000100 011111000000000000000000000000000000 000000000000000000000000000000000000
//! This is correct

//!
//! GE CPB1004F, DH02-01 (DPS8/88) & Bull DPS9000 RJ78 ... have this ...

//! The rounding operation is performed in the following way.
//! -  a) A constant (all 1s) is added to bits 29-71 of the mantissa.
//! -  b) If the number being rounded is positive, a carry is inserted into the least significant bit position of the adder.
//! -  c) If the number being rounded is negative, the carry is not inserted.
//! -  d) Bits 28-71 of C(AQ) are replaced by zeros.
//! If the mantissa overflows upon rounding, it is shifted right one place and a corresponding correction is made to the exponent.
//! If the mantissa does not overflow and is nonzero upon rounding, normalization is performed.

//! If the resultant mantissa is all zeros, the exponent is forced to -128 and the zero indicator is set.
//! If the exponent resulting from the operation is greater than +127, the exponent Overflow indicator is set.
//! If the exponent resulting from the operation is less than -128, the exponent Underflow indicator is set.
//! The definition of normalization is located under the description of the FNO instruction.

//! So, Either AL39 is wrong or the DPS8m did it wrong. (Which was fixed in later models.) I'll assume AL39 is wrong.

\end{verbatim}



\section{\texttt{MVT instruction.}}

20184 crashes in formatting first\_message; an index register is
slightly negative, and an \texttt{MLR} instruction is (correctly) treating it
as unsigned, and running off of the end of the segment, where
appendCycle correctly slaps its hand for exceeding the segment
boundary.

The \texttt{X} register gets set negative here:

\begin{verbatim}
ascii.no_trim:
        mvt     (pr,rl),(pr,rl),fill(040)     " we will do some useless filling
        desc9a  pr1|0,al
        desc9a  pr7|0,x4
        arg     ascii.bad_char_trans
        ttn     ascii.truncated

        a9bd    7|0,al
        als     18
        sta     ascii.tct_count "  so we can subtract
        sbx4    ascii.tct_count " cant be negative, since no truncation
        tmoz    return_to_caller        " but be safe
        tra     main_char_loop
\end{verbatim}

\texttt{X4} gets negative becuase \texttt{A} is $>$ \texttt{X4}; the \texttt{MVT} 
instruction correctly detects this
and sets the truncate bit. The code tests the TRO bit to prevent the
underflow.

Why, O Why, is the code using TTN and not TTRN? Why?

Somebody is lying.


In the description of the indicator register (c.f. AL39 Fig. 3-7) the tally runout indicator has this note. 

\begin{quote}
This indicator is set OFF at initialization of any tallying operation, that is, any repeat instruction or any indirect then 
tally address modification. It is then set ON for any of the following conditions: ...
(4) If an EIS string scanning instruction reaches the end of the string without finding a match condition.
\end{quote}

Apparently MVT also follows this pattern -- although AL-39, DH02-01 and Bull RJ78 REV02 make absolutely no mention of this behavior. 
This is either a hack, bug or an undocumented feature. \texttt{MVT} instruction in dps8\_eis.c has been modified to set the TALLY bit as well as the TRUNC bituon overflow


\section{\texttt{EPP} instruction.}

The code in bootload\_formline has the line:

\begin{verbatim}
	epp1    0,x6*                   " pr1 -> word of chars
\end{verbatim}

which relies on the epp1 instruction setting the AR1.CHAR register to zero. Given the relationship between the AR and PR register sets, this is not an unreasonable behavior. AL-39 does not mention the CHAR registers in the EPPn instruction documentation. However, AL-39 does say (pg 317):

\begin{quote}
" The terms "pointer register" and "address register" both apply to the same physical hardware. The distinction arises from the manner in which the register is used and in the interpretation of the register contents."
\end{quote}

\sout{The emulator sets the corresponding CHAR register to zero for EPPn instructions.}
The emulator uses a union of bitfields to map PR.BITNO on the AR.BITNO and AR.CHAR bits, so that the "same phyiscal hardware" behavior is matched.

\section{\textbf{tss} instruction}

Page 169, the \textbf{tss} instruction:

\begin{quote}
SUMMARY: \texttt{C(TPR.CA) + (BAR base) $\rightarrow$ C(PPR.IC)}
\end{quote}

The \textbf{tss} instruction should not add the \texttt{BAR} base to the \texttt{CA}; that is done during \texttt{CA} formation in the instruction fetch cycle. The line should read:

\begin{quote}
SUMMARY: \texttt{C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\end{quote}

\section{\textbf{tsp\textit{n}} instruction}

AL-39, Page 340, Figure 8-1 "Complete Appending Unit Operation Flowchart", step L, shows that if the opcode
is \textbf{tsp\emph{n}} then set up the \texttt{PR\emph{n}} register.

Page 168-169 \textbf{tsp\textit{n}} instruction shows the same \texttt{PR\emph{n}} register setup, but the value in \texttt{PPR.PSR} will have been changed by the Append Unit.

\section{Left shifting and the carry bit}

AL-39, pg. 27, Indicator Register, says this about the carry bit:

\begin{verbatim}
Carry   This indicator is set ON for....

        (1) If a bit propagates leftward out of bit 0 ... for any binary or shifting instruction.
\end{verbatim}

Page 107, "als":

\begin{verbatim}
Carry    If C(A)0 changes during the shift, then ON; otherwise OFF
\end{verbatim}

Page 108, "lls":

\begin{verbatim}
Carry    If C(AQ)0 changes during the shift, then ON; otherwise OFF
\end{verbatim}

Page 109, "qls":

\begin{verbatim}
Carry    If C(Q)0 changes during the shift, then ON; otherwise OFF
\end{verbatim}

But, CPB-1004F, GE-635 Pgm Ref says:

Page 78, "als"

\begin{verbatim}
Carry    If C(Q)0 ever changes during the shift, then ON; otherwise OFF
\end{verbatim}

The wording is the same for "qls" and "lls".

DH02-01 DPS8 Asm, pg 243, "ALS" says:

\begin{verbatim}
Carry    If C(Q)0 changes during the shift, then ON; otherwise OFF. When the Carry indicator is ON, the algebriac range of A had been exceeded.
\end{verbatim}

(LLS and QLS have similar wording.)

The phrase about algebraic range supports the interpretation of checking the carry at each step; it the sign bit changes at any step of the shift, then information has been lost; right shifting the result will not recreate the original data.

RJ78 has the same wording as DH02.

\section{Minor typo in \texttt{div}}

AL-39, page 124:

\begin{verbatim}
SUMMARY: C(Q) / (Y) integer quotient  C(Q)..
\end{verbatim}

should read:

\begin{verbatim}
SUMMARY: C(Q) / C(Y) integer quotient  C(Q)..
\end{verbatim}

\section{Minor typo in \texttt{s9bd}}

AL-39, page 230:

\begin{verbatim}
MODIFICATIONS:       None except au, qu, al, qu, xn
\end{verbatim}

should read:

\begin{verbatim}
MODIFICATIONS:       None except au, qu, al, ql, xn
\end{verbatim}

\end{document}
